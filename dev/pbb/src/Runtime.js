window['Runtime'] = (function Runtime(__can, __path){
	var __scope = this;
	// CService object
	// -----------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 * 
	 * Permission is hereby granted to any person obtaining a legal copy 
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for 
	 * debugging, optimizing, or customizing applications created with 
	 * Clickteam Multimedia Fusion 2. 
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */

	var CServices = {};

	CServices.extend = function (top, bot)
	{
		var topC = Object.create(top.prototype || top);
		if(bot !== undefined && (bot = bot.prototype || bot))
			for(var prop in bot)
				if(bot.hasOwnProperty(prop))
					topC[prop] = bot[prop];

		return topC;
	};

	CServices.HIWORD = function (ul)
	{
		return ul >> 16;
	}
	CServices.LOWORD = function (ul)
	{
		return ul & 0x0000FFFF;
	}
	CServices.MAKELONG = function (lo, hi)
	{
		return (hi << 16) | (lo & 0xFFFF);
	}
	CServices.getRValueFlash = function (rgb)
	{
		return (rgb >>> 16) & 0xFF;
	}
	CServices.getGValueFlash = function (rgb)
	{
		return (rgb >>> 8) & 0xFF;
	}
	CServices.getBValueFlash = function (rgb)
	{
		return rgb & 0xFF;
	}
	CServices.RGBFlash = function (r, g, b)
	{
		return (r & 0xFF) << 16 | (g & 0xFF) << 8 | (b & 0xFF);
	}
	CServices.swapRGB = function (rgb)
	{
		var r = (rgb >>> 16) & 0xFF;
		var g = (rgb >>> 8) & 0xFF;
		var b = rgb & 0xFF;
		return (b & 0xFF) << 16 | (g & 0xFF) << 8 | (r & 0xFF);
	}
	CServices.clamp = function (val, a, b)
	{
		return Math.min(Math.max(val, a), b);
	}
	CServices.getColorString = function (rgb)
	{
		var r = ((rgb >>> 16) & 0xFF).toString(16);
		var g = ((rgb >>> 8) & 0xFF).toString(16);
		var b = (rgb & 0xFF).toString(16);
		while (r.length < 2)
			r = '0' + r;
		while (g.length < 2)
			g = '0' + g;
		while (b.length < 2)
			b = '0' + b;

		return '#' + r + g + b;
	}
	CServices.floatToInt = function (value)
	{
		if (value < 0)
			return Math.ceil(value);
		else
			return Math.floor(value);
	}
	CServices.approximateInt = function (value)
	{
		return Math.round(value);
	}
	CServices.isInt = function (value)
	{
		return Math.ceil(value) == value;
	}
	CServices.createEllipse = function (ctx, x, y, w, h)
	{
		var kappa = .5522848;
		ox = (w / 2) * kappa, // control point offset horizontal
			oy = (h / 2) * kappa, // control point offset vertical
			xe = x + w,           // x-end
			ye = y + h,           // y-end
			xm = x + w / 2,       // x-middle
			ym = y + h / 2;       // y-middle

		ctx.beginPath();
		ctx.moveTo(x, ym);
		ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
		ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
		ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
		ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
		ctx.closePath();
	}
	CServices.drawRect = function (context, rc)
	{
		context.beginPath();
		context.moveTo(rc.left, rc.top);
		context.lineTo(rc.right, rc.top);
		context.lineTo(rc.right, rc.bottom);
		context.lineTo(rc.left, rc.bottom);
		context.lineTo(rc.left, rc.top);
		context.closePath();
		context.stroke();
	}
	CServices.drawLine = function (context, x1, y1, x2, y2)
	{
		context.beginPath();
		context.moveTo(x1, y1);
		context.lineTo(x2, y2);
		context.closePath();
		context.stroke();
	}
	CServices.formatDiscName = function (number, extension)
	{
		var s = number.toString();
		while (s.length < 4)
			s = '0' + s;
		s += '.' + extension;
		return s;
	}
	CServices.compareStringsIgnoreCase = function (string1, string2)
	{
		if (string1 == string2) return true;
		string1 = string1.toLowerCase();
		string2 = string2.toLowerCase();
		return (string1 == string2);
	}
	CServices.parseName = function (name)
	{
		var pos = name.lastIndexOf("\\");
		if (pos > 0)
		{
			name = name.substring(pos + 1);
		}
		return name;
	}
	CServices.MAX_HEIGHTS = 40;
	CServices.aHeightNormalToLF =
		[
			0, // 0
			1, // 1
			2, // 2
			3, // 3
			5, // 4
			7, // 5
			8, // 6
			9, // 7
			11, // 8
			12, // 9
			13, // 10
			15, // 11
			16, // 12
			17, // 13
			19, // 14
			20, // 15
			21, // 16
			23, // 17
			24, // 18
			25, // 19
			27, // 20
			28, // 21
			29, // 22
			31, // 23
			32, // 24
			33, // 25
			35, // 26
			36, // 27
			37, // 28
			39, // 29
			40, // 30
			41, // 31
			43, // 32
			44, // 33
			45, // 34
			47, // 35
			48, // 36
			49, // 37
			51, // 38
			52		// 39
		];

	CServices.heightNormalToLF = function (height)
	{
	    if (height < CServices.MAX_HEIGHTS)
	    {
	        return CServices.aHeightNormalToLF[height];
	    }
	    return Math.round((height * 96) / 72);
	}

	CServices.DT_LEFT = 0x0000;
	CServices.DT_TOP = 0x0000;
	CServices.DT_CENTER = 0x0001;
	CServices.DT_RIGHT = 0x0002;
	CServices.DT_BOTTOM = 0x0008;
	CServices.DT_VCENTER = 0x0004;
	CServices.DT_SINGLELINE = 0x0020;
	CServices.DT_CALCRECT = 0x0400;
	CServices.DT_VALIGN = 0x0800;
	CServices.drawText = function (context, s, flags, rc, font, displayArray)
	{
		if (s.length == 0)
		{
			if ((flags & 0x0400) != 0)
			{
				rc.right = rc.left;
				rc.bottom = rc.top;
			}
			return 0;
		}

		if (!font.isGraphic)
			context.font = font.getFont();
		//CServices.fontHeight = font.getHeight();

		var maxHeight = 0;
		var char10 = String.fromCharCode(10);
		var char13 = String.fromCharCode(13);

	    // Is there a "new line" character?
		var index = s.indexOf(char10);
		if (index >= 0)
		{
	        // Yes, draw lines one by one
			var rc2 = new CRect();
			rc2.copyRect(rc);
			var sub;
			var h;
			var prevIndex = 0;
			var maxWidth = 0;
			var index2, nextIndex;

			do
			{
				index2 = -1;
				if (prevIndex < s.length)
				{
					index2 = s.indexOf(char13, prevIndex);
				}
				nextIndex = Math.max(index, index2);
				if (index2 == index - 1)
				{
					index--;
				}
				sub = s.substring(prevIndex, index);
				h = CServices.drawIt(context, sub, flags, rc2, displayArray, font);
				maxWidth = Math.max(maxWidth, rc2.right - rc2.left);
				maxHeight += h;
				rc2.top += h;
				rc2.bottom = rc.bottom;
				rc2.right = rc.right;
				prevIndex = nextIndex + 1;
				index = -1;
				if (prevIndex < s.length) {
				    index = s.indexOf(char10, prevIndex);
				}
				else {
	                // Draw an empty line if the text ends with CR/LF characters
				    h = CServices.drawIt(context, "", flags, rc2, displayArray, font);
				    maxWidth = Math.max(maxWidth, rc2.right - rc2.left);
				    maxHeight += h;
				    rc2.top += h;
				    rc2.bottom = rc.bottom;
				    rc2.right = rc.right;
				}
			} while (index >= 0);
			if (prevIndex < s.length)
			{
				sub = s.substring(prevIndex);
				h = CServices.drawIt(context, sub, flags, rc2, displayArray, font);
				maxWidth = Math.max(maxWidth, rc2.right - rc2.left);
				maxHeight += h;
			}
			if ((flags & CServices.DT_CALCRECT) != 0)
			{
				rc.right = rc.left + maxWidth;
				rc.bottom = rc2.bottom;
				return maxHeight;
			}
			return maxHeight;
		}

	    // No "new line" character, draw a single line
		maxHeight = CServices.drawIt(context, s, (flags | CServices.DT_VALIGN), rc, displayArray, font);
		return maxHeight;
	}
	CServices.xPos = null;
	//CServices.fontHeight = 0;
	CServices.drawIt = function (context, s, flags, rc, displayArray, font)
	{
		if (s.length == 0)
		{
			s = " ";
		}

		var hLine;
		var spaceWidth;
		hLine = font.getHeight();
		if (font.isGraphic)
			spaceWidth = font.measureText(" ");
		else
			spaceWidth = context.measureText(" ").width;

		var rectWidth = rc.right - rc.left;
		var startSpace = 0;
		var currentSpace = 0;
		var previousSpace;
		var firstSpace = 0;
		var x;
		var width = 0;
		var height = 0;
		var currentXPos;
		if (CServices.xPos == null)
		{
			CServices.xPos = new Array(100);
		}
		var sx;
		var ss;
		var bQuit = false;
		var bContinue = false;

		var y = rc.top;
		var hCalcul = hLine;
		if ((hCalcul & 1) != 0)
		{
			hCalcul++;
		}
		/*    if ((flags & CServices.DT_VALIGN) != 0)
		 {
		 if ((flags & CServices.DT_VCENTER) != 0)
		 {
		 y = rc.top + (rc.bottom - rc.top) / 2 - hCalcul / 2;
		 }
		 else if ((flags & CServices.DT_BOTTOM) != 0)
		 {
		 y = rc.bottom - hLine;
		 }
		 }
		 */
		var yTop = y;
		do
		{
			firstSpace = startSpace;
			currentXPos = 0;
			x = 0;
			height += hLine;
			do
			{
				CServices.xPos[currentXPos] = x;
				currentXPos += 1;
				previousSpace = currentSpace;
				currentSpace = -1;
				if (firstSpace < s.length)
					currentSpace = s.indexOf(" ", firstSpace);
				if (currentSpace == -1)
					currentSpace = s.length;
				if (currentSpace < firstSpace)
				{
					x -= spaceWidth;
					break;
				}
				ss = s.substring(firstSpace, currentSpace);
				if (font.isGraphic)
					sx = font.measureText(ss);
				else
					sx = context.measureText(ss).width;
				if (x + sx > rectWidth)
				{
					currentXPos--;
					if (currentXPos > 0)
					{
						sx -= spaceWidth;
						x -= spaceWidth;
						currentSpace = previousSpace;
						break;
					}
					var c;
					for (c = firstSpace; c < currentSpace; c++)
					{
						if (font.isGraphic)
							sx = font.measureText(s.substring(c, c + 1));
						else
							sx = context.measureText(s.substring(c, c + 1)).width;
						if (x + sx >= rectWidth)
						{
							c--;
							if (c > 0)
							{
								width = Math.max(x, width);
								if ((flags & CServices.DT_CALCRECT) == 0)
								{
									if ((flags & CServices.DT_CENTER) != 0)
									{
										x = rc.left + (rc.right - rc.left) / 2 - x / 2;
									}
									else if ((flags & CServices.DT_RIGHT) != 0)
									{
										x = rc.right - x;
									}
									else
									{
										x = rc.left;
									}
									ss = s.substring(firstSpace, c);
									displayArray.push(new CDisplayText(x, y, ss));
								}
								currentSpace = c - 1;
								bQuit = true;
								bContinue = true;
								break;
							}
							currentSpace = -1;
							if (c < s.length)
							{
								currentSpace = s.indexOf(" ", c);
							}
							else
							{
								currentSpace = -1;
							}
							bQuit = true;
							if (currentSpace >= 0)
							{
								bContinue = true;
							}
							break;
						}
						x += sx;
					}
				}
				if (bQuit)
				{
					break;
				}
				x += sx;
				if (x + spaceWidth > rectWidth)
				{
					break;
				}
				x += spaceWidth;
				firstSpace = currentSpace + 1;
			} while (true);
			if (bContinue == false)
			{
				if (bQuit)
				{
					break;
				}
				width = Math.max(x, width);
				var n;
				if ((flags & CServices.DT_CALCRECT) == 0)
				{
					if ((flags & CServices.DT_CENTER) != 0)
						x = rc.left + (rc.right - rc.left) / 2 - x / 2;
					else if ((flags & CServices.DT_RIGHT) != 0)
						x = rc.right - x;
					else
						x = rc.left;
					firstSpace = startSpace;
					for (n = 0; n < currentXPos; n++)
					{
						currentSpace = -1;
						if (firstSpace < s.length)
							currentSpace = s.indexOf(" ", firstSpace);
						if (currentSpace == -1)
							currentSpace = s.length;
						if (currentSpace < firstSpace)
							break;
						ss = s.substring(firstSpace, currentSpace);
						displayArray.push(new CDisplayText(x + CServices.xPos[n], y, ss));
						firstSpace = currentSpace + 1;
					}
				}
			}
			bQuit = false;
			bContinue = false;
			y += hLine;
			startSpace = currentSpace + 1;
		} while (startSpace < s.length);

		rc.right = rc.left + width;
		rc.bottom = yTop + height;
		return height;
	}

	CServices.displayText = function (context, x, y, displayArray, font, color, effect, effectParam)
	{
		var n, element;
		if (!font.isGraphic)
		{
			context.font = font.getFont();
			//CServices.fontHeight = font.getHeight();
			context.fillStyle = CServices.getColorString(color);
			context.textAlign = "left";
			context.textBaseline = "top";
			for (n = 0; n < displayArray.length; n++)
			{
				element = displayArray[n];
				context.fillText(element.text, x + element.x, y + element.y);
			}
		}
		else
		{
			for (n = 0; n < displayArray.length; n++)
			{
				element = displayArray[n];
				font.fillText(context, element.text, x + element.x, y + element.y);
			}
		}
	}

	CServices.intToString = function (value, displayFlags)
	{
		var s = value.toString();
		if ((displayFlags & CCounter.CPTDISPFLAG_INTNDIGITS) != 0)
		{
			var nDigits = displayFlags & CCounter.CPTDISPFLAG_INTNDIGITS;
			if (s.length > nDigits)
			{
				s = s.substring(s.length - nDigits);
			}
			else
			{
				while (s.length < nDigits)
				{
					s = "0" + s;
				}
			}
		}
		return s;
	}

	CServices.doubleToString = function (value, displayFlags)
	{
		var s;
		if ((displayFlags & CCounter.CPTDISPFLAG_FLOAT_FORMAT) == 0)
		{
			s = value.toString();
		}
		else
		{
			var bRemoveTrailingZeros = false;
			var nDigits = Math.floor(((displayFlags & CCounter.CPTDISPFLAG_FLOATNDIGITS) >> CCounter.CPTDISPFLAG_FLOATNDIGITS_SHIFT) + 1);
			var nDecimals = -1;
			if ((displayFlags & CCounter.CPTDISPFLAG_FLOAT_USENDECIMALS) != 0)
				nDecimals = ((displayFlags & CCounter.CPTDISPFLAG_FLOATNDECIMALS) >> CCounter.CPTDISPFLAG_FLOATNDECIMALS_SHIFT);
			else if (value != 0.0 && value > -1.0 && value < 1.0)
			{
				nDecimals = nDigits;
				bRemoveTrailingZeros = true;
			}
			if (nDecimals < 0)
			{
				s = value.toPrecision(nDigits);
			}
			else
			{
				s = value.toFixed(nDecimals);
			}
			var l, n;
			var ss;
			if ((displayFlags & CCounter.CPTDISPFLAG_FLOAT_PADD) != 0)
			{
				l = 0;
				for (n = 0; n < s.length; n++)
				{
					ss = s.charAt(n);
					if (ss != "." && ss != "+" && ss != "-" && ss != "e" && ss != "E")
						l++;
				}
			}
			var bFlag = false;
			if (s.charAt(0) == "-")
			{
				bFlag = true;
				s = s.substr(1);
			}
			while (l < nDigits)
			{
				s = "0" + s;
				l++;
			}
			if (bFlag)
			{
				s = "-" + s;
			}
		}
		return s;
	}

	CServices.subtractFilename = function (destination, source)
	{
		var tempDest = destination;
		var tempSource = source;
		var pos = tempSource.indexOf("\\");
		while (pos >= 0)
		{
			if (tempDest.substring(0, pos) == tempSource.substring(0, pos))
			{
				tempSource = tempSource.substring(pos + 1);
				tempDest = tempDest.substring(pos + 1);
			}
			pos = tempSource.indexOf("\\", pos + 1);
		}
		return tempDest;
	}

	// CDisplayText object
	// --------------------------------------------------------------
	function CDisplayText(xx, yy, s)
	{
		this.x = xx;
		this.y = yy;
		this.text = s;
	}


	// CFile Object 
	// -----------------------------------------------------------------


	// For IE9
	var bUseAjax = false;
	var bUseBlob = false;
	var bUseBinaryString = false;

	var req = window['XMLHttpRequest'] ? new XMLHttpRequest() : null;

	if (!req || !req.overrideMimeType)
	{
		bUseAjax = true;
		var script = document.createElement('script');
		script.type = "text/vbscript";
		script.innerHTML = 'Function BinFileReaderImpl_IE_VBAjaxLoader(fileName)\n\
	                Dim xhr\n\
	                Set xhr = CreateObject("Microsoft.XMLHTTP")\n\
	                xhr.Open "GET", fileName, False\n\
	                xhr.setRequestHeader "Accept-Charset", "x-user-defined"\n\
	                xhr.send\n\
	                Dim byteArray()\n\
	                if xhr.Status = 200 Then\n\
	                    Dim byteString\n\
	                    Dim i\n\
	                    byteString=xhr.responseBody\n\
	                    ReDim byteArray(LenB(byteString))\n\
	                    For i = 1 To LenB(byteString)\n\
	                        byteArray(i-1) = AscB(MidB(byteString, i, 1))\n\
	                    Next\n\
	                End If\n\
	                BinFileReaderImpl_IE_VBAjaxLoader=byteArray\n\
	            End Function';

		document.head.appendChild(script);
	}
	else
	{
		try
		{
			bUseBlob = typeof new XMLHttpRequest()["responseType"] === 'string';
			if (navigator.userAgent.toLowerCase().indexOf('safari') >= 0)
				bUseBlob = false;
		}
		catch (e)
		{
		}
	}
	if (bUseBlob)
	{
		var reader = new FileReader();
		try
		{
			if (reader["readAsBinaryString"])
				bUseBinaryString = true;
		}
		catch (e)
		{
		}
		reader = null;
	}
	req = null;

	function CFile()
	{
		this.ccfBytes = "";
		this.pointer = 0;
		this.offset = 0;
		this.bUnicode = false;
	}

	CFile.prototype =
	{

		readUnsignedByte: function ()
		{
			return this.ccfBytes.charCodeAt(this.pointer++) & 0xFF;
		},
		getChecksum:      function ()
		{
			var n;
			var count = 0;
			for (n = 0; n < this.end; n++)
				count += (this.ccfBytes.charCodeAt(n) & 0xFF) ^ 0xAA;
			return count;
		},
		getFile:          function (fileName, callback, size)
		{
			this.callback = callback;
	        
			if (!bUseAjax)
			{
				var request = new XMLHttpRequest();
				request["open"]('GET', fileName, true);
				var that = this;

				if (bUseBlob)
				{
					request["responseType"] = "blob";
					request["onload"] = function ()
					{
						if (request["readyState"] == 4)
						{
							if (request["status"] == 200)
							{
								var reader = new FileReader();
								reader["onloadend"] = function ()
								{
									if (bUseBinaryString)
										that.ccfBytes += reader["result"];
									else
									{
										var array = new Uint8Array(reader["result"]);
										var n;
										for (n = 0; n < array.length; n++)
											that.ccfBytes += String.fromCharCode(array[n]);
									}
									that.end = that.ccfBytes.length;
									that.callback();
								}
								if (bUseBinaryString)
									reader.readAsBinaryString(request["response"]);
								else
									reader.readAsArrayBuffer(request["response"]);
							}
						}
					}
					request["send"](null);
				}
				else
				{
					request["overrideMimeType"]('text/plain; charset=x-user-defined');
					request["onload"] = function ()
					{
						if (request["readyState"] == 4)
						{
							if (request["status"] == 200)
							{
								that.ccfBytes += request["responseText"];
								that.end = that.ccfBytes.length;
								that.callback();
							}
						}
					}
					request.send(null);
				}
			}
			else
			{
				try
				{
					var array = BinFileReaderImpl_IE_VBAjaxLoader(fileName)['toArray']()
					var n;
					var length = array.length;
					if (length > size)
						length = size;
					for (n = 0; n < length; n++)
						this.ccfBytes += String.fromCharCode(array[n]);
					this.end = this.ccfBytes.length;
					this.callback();
				}
				catch (error)
				{
				}
			}
		},
		openFileASync:    function (fileName, parent)
		{
			this.parent = parent;
			var request = new XMLHttpRequest();
			request.open('GET', fileName, true);
			request.overrideMimeType('text/plain; charset=x-user-defined');
			var that = this;
			request.onload = function ()
			{
				if (request.readyState == 4)
				{
					if (request.status == 200)
					{
						that.ccfBytes = request.responseText;
						that.end = that.ccfBytes.length;
						that.pointer = 0;
						that.offset = 0;
						that.bUnicode = false;
						that.parent.dataReceived(true);
						return;
					}
				}
			}
			request.send(null);
		},
		getBytes:         function ()
		{
			return this.ccfBytes;
		},
		setBinary:        function (binary)
		{
			this.ccfBytes = binary;
			this.end = binary.length;
			var that = this;
			this.readUnsignedByte = function ()
			{
				return that.ccfBytes.charCodeAt(that.pointer++) & 0xFF;
			}
		},
		createFromFile:   function (offset, length)
		{
			var file = new CFile();
			file.ccfBytes = this.ccfBytes;
			file.offset = offset;
			file.pointer = offset;
			file.end = offset + length;
			file.bUnicode = this.bUnicode;
			return file;
		},

		getLength: function ()
		{
			return this.end - this.offset;
		},

		setUnicode: function (unicode)
		{
			this.bUnicode = unicode;
		},
		detectUnicode: function()
		{
			var b1 = this.readUnsignedByte();
			var b2 = this.readUnsignedByte();
			var b3 = this.readUnsignedByte();
			if (b1 == 0xFF && b2 == 0xFE)
			{
				this.bUnicode = true;               // UTF16
				this.pointer--;
			}
			else if (b1 == 0xEF && b2 == 0xBB && b3 == 0xBF)
			{
				this.bUnicode = false;              // UTF8
			}
			else
			{
				this.bUnicode = false;              // ASCII
				this.pointer -= 3;
			}
		},
		skipBytes: function (skip)
		{
			this.pointer += skip;
		},

		adjustTo8: function ()
		{
			if ((this.pointer & 0x07) != 0)
			{
				this.pointer += 8 - (this.pointer & 0x07);
			}
		},

		isEOF: function ()
		{
			return this.pointer >= this.end;
		},

		readInString: function (len)
		{
			var n, s = "";
			for (n = 0; n < len; n++)
				s += String.fromCharCode(this.readUnsignedByte());
			return s;
		},

		readAByte: function ()
		{
			return this.readUnsignedByte();
		},

		readAShort: function ()
		{
			var b1, b2;
			b1 = this.readUnsignedByte();
			b2 = this.readUnsignedByte();
			return b2 * 256 + b1;
		},

		readShort: function ()
		{
			var b1, b2;
			b1 = this.readUnsignedByte();
			b2 = this.readUnsignedByte();
			var value = b2 * 256 + b1;
			if (value < 32768)
				return value;
			else
				return value - 65536;
		},

		readAChar: function ()
		{
			var b1, b2;
			b1 = this.readUnsignedByte();
			b2 = this.readUnsignedByte();
			return (b2 * 256 + b1);
		},

		readACharArray: function (size)
		{
			var c = new Array();
			var b1, b2;
			var n;
			for (n = 0; n < size; n++)
			{
				b1 = this.readUnsignedByte();
				b2 = this.readUnsignedByte();
				c[n] = (b2 * 256 + b1);
			}
			return c;
		},

		readAInt: function ()
		{
			var b1, b2, b3, b4;
			b1 = this.readUnsignedByte();
			b2 = this.readUnsignedByte();
			b3 = this.readUnsignedByte();
			b4 = this.readUnsignedByte();
			var value = b4 * 0x01000000 + b3 * 0x00010000 + b2 * 0x00000100 + b1;
			if (value <= 0x7FFFFFFF)
				return value;
			else
				return value - 0x100000000;

		},

		readAColor: function ()
		{
			var b1, b2, b3;
			var c;

			b1 = this.readUnsignedByte();
			b2 = this.readUnsignedByte();
			b3 = this.readUnsignedByte();
			this.readUnsignedByte();

			c = b1 * 0x00010000 + b2 * 0x00000100 + b3;
			return c;
		},

		readAFloat: function ()
		{
			var b1, b2, b3, b4;

			b1 = this.readUnsignedByte();
			b2 = this.readUnsignedByte();
			b3 = this.readUnsignedByte();
			b4 = this.readUnsignedByte();
			var total = b4 * 0x01000000 + b3 * 0x00010000 + b2 * 0x00000100 + b1;
			if (total > 0x80000000)
			{
				total -= 0x100000000;
			}
			return total / 65536.0;
		},

		readADouble: function ()
		{
			var b1, b2, b3, b4, b5, b6, b7, b8;

			b1 = this.readUnsignedByte();
			b2 = this.readUnsignedByte();
			b3 = this.readUnsignedByte();
			b4 = this.readUnsignedByte();
			b5 = this.readUnsignedByte();
			b6 = this.readUnsignedByte();
			b7 = this.readUnsignedByte();
			b8 = this.readUnsignedByte();

			var total = b8 * 0x0100000000000000 + b7 * 0x0001000000000000 + b6 * 0x0000010000000000 + b5 * 0x0000000100000000 + b4 * 0x01000000 + b3 * 0x00010000 + b2 * 0x00000100 + b1;
			if (total > 0x8000000000000000)
			{
				total -= 0xFFFFFFFFFFFFFFFF;
			}
			return total / 0x100000000;
		},

		readAString:    function (length)
		{
			var string = "";
			if (!this.bUnicode)
			{
				if (arguments.length < 1)
				{
					if (this.isEOF())
						return string;

					var begin = this.pointer;
					var b = this.readUnsignedByte();
					while (b && !this.isEOF())
						b = this.readUnsignedByte();

					var stringLength = this.pointer - begin - 1;
					this.pointer = begin;

					string = this.readAString(stringLength);
					this.readUnsignedByte();

					return string;
				}
				else
				{
					var c;
					var begin = this.pointer;
					for (var i = 0; i < length; ++i)
					{
						c = this.readUnsignedByte();
						if (c == 0)
							break;
						string += String.fromCharCode(c);
					}
					this.pointer = begin + length;
					return string;
				}
			}
			else
			{
				if (arguments.length < 1)
				{
					if (this.isEOF())
						return string;

					var begin = this.pointer;

					var b = this.readAChar();
					while (b && !this.isEOF())
						b = this.readAChar();

					var stringLength = (this.pointer - begin - 2) / 2;
					this.pointer = begin;

					string = this.readAString(stringLength);
					this.readUnsignedByte();
					this.readUnsignedByte();

					return string;
				}
				else
				{
					string = '';
					var begin = this.pointer;
					var c;
					for (var i = 0; i < length; i++)
					{
						c = this.readAChar();
						if (c == 0)
							break;
						string += String.fromCharCode(c);
					}
					this.pointer = begin + length * 2;
					return string;
				}
			}
		},
		readAStringEOL: function ()
		{
			var debut = this.pointer;
			var b;
			var ret = "";
			var end;
			var delta;
			var bb;

			if (this.bUnicode == false)
			{
				if (this.isEOF())
					return;

				b = this.readUnsignedByte();
				while (b != 10 && b != 13 && !this.isEOF())
					b = this.readUnsignedByte();

				end = this.pointer;
				this.pointer = debut;
				delta = 1;
				if (b != 10 && b != 13)
					delta = 0;

				if (end > debut + delta)
				{
					ret = this.readAString(end - debut - delta);
				}
				if (b == 10 || b == 13)
				{
					this.readUnsignedByte();
					bb = this.readAByte();
					if (b == 10 && bb != 13)
					{
						this.pointer--;
					}
					if (b == 13 && bb != 10)
					{
						this.pointer--;
					}
				}
				return ret;
			}
			else
			{
				if (this.isEOF())
					return;

				b = this.readAChar();
				while (b != 10 && b != 13 && !this.isEOF())
					b = this.readAChar();

				end = this.pointer;
				this.pointer = debut;
				delta = 2;
				if (b != 10 && b != 13)
					delta = 0;
				if (end > debut + delta)
					ret = this.readAString((end - debut - delta) / 2);

				if (b == 10 || b == 13)
				{
					this.pointer += 2;
					bb = this.readAChar();
					if (b == 10 && bb != 13)
						this.pointer -= 2;
					if (b == 13 && bb != 10)
						this.pointer -= 2;
				}
				return ret;
			}
		},

		skipAString: function ()
		{
			var b;
			if (this.bUnicode == false)
			{
				do
				{
					b = this.readUnsignedByte();
				} while (b != 0 && !this.EOF());
			}
			else
			{
				do
				{
					b = this.readAChar();
				} while (b != 0 && !this.EOF());
			}
		},

		getFilePointer: function ()
		{
			return this.pointer;
		},

		seek: function (pos)
		{
			if (pos >= this.end)
			{
				pos = this.end;
			}
			this.pointer = pos;
		},

		skipBack: function (n)
		{
			var pos = this.pointer;
			pos -= n;
			if (pos < 0)
				pos = 0;
			this.pointer = pos;
		},

		readBytesAsArray: function (a)
		{
			var n;
			var size = a.length;
			for (n = 0; n < size; n++)
				a[n] = this.readUnsignedByte();
		},

		readBuffer: function (size)
		{
			var buffer = new Array();
			var i;

			for (i = 0; i < size; i++)
				buffer[i] = this.readUnsignedByte();

			return buffer;
		},

		readLogFont: function ()
		{
			var lf = new CFontInfo();
			lf.readLogFont(this);
			return lf;
		},

		readLogFont16: function ()
		{
			var lf = new CFontInfo();
			lf.readLogFont16(this);
			return lf;
		}
	}


	// CArrayList Object 
	// -----------------------------------------------------------------
	function CArrayList()
	{
		this.array = new Array();
	}
	CArrayList.prototype =
	{
		add:          function (o)
		{
			this.array.push(o);
		},
		isEmpty:      function ()
		{
			return (this.array.length == 0);
		},
		insert:       function (index, o)
		{
			this.array.splice(index, 0, o);
		},
		get:          function (index)
		{
			if (index < this.array.length)
			{
				return this.array[index];
			}
			return null;
		},
		put:          function (index, o)
		{
			this.array[index] = o;
		},
		set:          function (index, o)
		{
			if (index < this.array.length)
			{
				this.array[index] = o;
			}
		},
		removeIndex:  function (index)
		{
			if (index < this.array.length)
			{
				this.array.splice(index, 1);
			}
		},
		indexOf:      function (o)
		{
			return this.array.indexOf(o);
		},
		contains:     function (o)
		{
			return this.array.indexOf(o) >= 0;
		},
		removeObject: function (o)
		{
			var n = this.array.indexOf(o);
			if (n >= 0)
				this.array.splice(n, 1);
		},
		size:         function ()
		{
			return this.array.length;
		},
		clear:        function ()
		{
			this.array.length = 0;
		},
		sort: function (callback)
		{
		    Array.prototype.sort.call(this.array, callback);
		}
	}

	// CRect object
	// -------------------------------------------------------------
	function CRect(l, t, r, b)
	{
		if (l)
			this.left = l
		else
			this.left = 0;

		if (t)
			this.top = t
		else
			this.top = 0;

		if (r)
			this.right = r;
		else
			this.right = 0;

		if (b)
			this.bottom = b;
		else
			this.bottom = 0;
	}
	CRect.prototype =
	{
		load: function (file)
		{
			this.left = file.readAInt();
			this.top = file.readAInt();
			this.right = file.readAInt();
			this.bottom = file.readAInt();
		},

		copyRect: function (srce)
		{
			this.left = srce.left;
			this.right = srce.right;
			this.top = srce.top;
			this.bottom = srce.bottom;
		},

		ptInRect: function (x, y)
		{
			if (x >= this.left && x < this.right && y >= this.top && y < this.bottom)
				return true;
			return false;
		},

		intersectRect: function (rc)
		{
			if ((this.left >= rc.left && this.left < rc.right) || (this.right >= rc.left && this.right < rc.right) || (rc.left >= this.left && rc.left < this.right) || (rc.right >= this.left && rc.right < this.right))
			{
				if ((this.top >= rc.top && this.top < rc.bottom) || (this.bottom >= rc.top && this.bottom < rc.bottom) || (rc.top >= this.top && rc.top < this.bottom) || (rc.bottom >= this.top && rc.bottom < this.bottom))
				{
					return true;
				}
			}
			return false;
		}
	}

	// CPoint object
	// ------------------------------------------------------------
	function CPoint()
	{
		this.x = 0;
		this.y = 0;
	}

	// CZone object
	// ------------------------------------------------------------
	function CZone()
	{
		this.x1 = 0;
		this.y1 = 0;
		this.x2 = 0;
		this.y2 = 0;
	}


	// CFontthis object
	// ------------------------------------------------------------
	function CFontInfo()
	{
		this.lfHeight = 12;
		this.lfWeight = 400;
		this.lfItalic = 0;
		this.lfFaceName = "Arial";
		this.isGraphic = false;
	}
	CFontInfo.prototype =
	{
		copy:    function (f)
		{
			this.lfHeight = f.lfHeight;
			this.lfWeight = f.lfWeight;
			this.lfItalic = f.lfItalic;
			this.lfFaceName = f.lfFaceName;
		},
		getFont: function ()
		{
			var result;
			if (this.lfItalic)
				result = "italic ";
			else
				result = "normal "

			var weight = Math.floor(this.lfWeight / 100) * 100;
			weight = Math.max(weight, 100);
			weight = Math.min(weight, 900);
			result += weight + " ";

			var height = this.lfHeight; // CServices.heightNormalToLF(this.lfHeight);
			result += height + "px ";
			result += this.lfFaceName;

			return result;
		},

		getHeight: function () {
		    return this.lfHeight + Math.ceil(this.lfHeight / 8);
		},

		init: function ()
		{
			this.lfFaceName = "Arial";
			this.lfHeight = 13;
			this.lfWeight = 400;
			this.lfItalic = 0;
		},
		readLogFont:   function (file)
		{
			this.lfHeight = file.readAInt();
			if (this.lfHeight < 0)
				this.lfHeight = -this.lfHeight;
			file.skipBytes(12);
			this.lfWeight = file.readAInt();
			this.lfItalic = file.readAByte();
			this.lfUnderline = file.readAByte();
			this.lfStrikeOut = file.readAByte();
			file.skipBytes(5);
			this.lfFaceName = file.readAString(32);
		},
		readLogFont16: function (file)
		{
			this.lfHeight = file.readShort();
			if (this.lfHeight < 0)
				this.lfHeight = -this.lfHeight;
			file.skipBytes(6);
			this.lfWeight = file.readAShort();
			this.lfItalic = file.readAByte();
			this.lfUnderline = file.readAByte();
			this.lfStrikeOut = file.readAByte();
			file.skipBytes(5);
			var oldUnicode = file.bUnicode;
			file.bUnicode = false;
			this.lfFaceName = file.readAString(32);
			file.bUnicode = oldUnicode;
		}
	}


	// CIni object
	// ------------------------------------------------------------
	CIni.separator = "{@24}";
	CIni.INIFLAG_UTF8 = 0x0001;
	CIni.INIFLAG_UTF16 = 0x0002;
	function CIni(a, flags)
	{
		this.app = a;
		this.flags = flags;
		this.strings = new CArrayList();
		this.currentFileName = null;
	}
	CIni.prototype =
	{
		saveIni:     function ()
		{
			if (this.strings != null && this.currentFileName != null)
			{
				var value = "";
				var n;
				for (n = 0; n < this.strings.size(); n++)
					value += this.strings.get(n) + CIni.separator;
				localStorage.setItem(this.currentFileName, value);
			}
		},
		loadIni:     function (fileName)
		{
			var reload = true;
			if (this.currentFileName != null)
			{
				if (CServices.compareStringsIgnoreCase(fileName, this.currentFileName))
				{
					reload = false;
				}
			}
			if (reload)
			{
				this.saveIni();

				this.currentFileName = fileName;
				this.strings = new CArrayList();

				var value = localStorage.getItem(this.currentFileName);
				if (value)
				{
					var begin = 0;
					var end = value.indexOf(CIni.separator, 0);
					while (end >= 0)
					{
						this.strings.add(value.substring(begin, end));
						begin = end + CIni.separator.length;
						end = value.indexOf(CIni.separator, begin);
					}
					;
				}
				else
				{
					/*		     	var cFile=new CFile();
					 cFile.openFile(this.currentFileName);
					 if (cFile.getLength()==0)
					 {
					 cFile=null;
					 }
					 */
					var cFile = null;
					if (cFile == null)
					{
						var eFile = this.app.getEmbeddedFile(this.currentFileName);
						if (eFile != null)
						{
							cFile = eFile.open();
						}
					}
					if (cFile)
					{
					    var utf8 = false;
					    cFile.detectUnicode();
						if (typeof this.flags != 'undefined')
						{
						    if (this.flags & CIni.INIFLAG_UTF8) {
						        this.bUnicode = false;
						        utf8 = true;
						    }
						    if (this.flags & CIni.INIFLAG_UTF16)
								this.bUnicode = true;
						}
						while (cFile.isEOF() == false)
						{
							var currentLine = cFile.readAStringEOL();
							if (utf8)
							    currentLine = this.decodeUtf8(currentLine);
							if (currentLine.substring(0, 1) == "<")
							{
								this.strings.clear();
								break;
							}
							if (currentLine == null)
							{
								break;
							}
							this.strings.add(currentLine);
						}
					}
				}
			}
		},
	    /**
	     * http://www.webtoolkit.info/javascript-utf8.html
	     */
		decodeUtf8: function (utftext) {
		    var string = "";
		    var i = 0;
		    var c = 0, c1 = 0, c2 = 0, c3 = 0;

		    while (i < utftext.length) {

		        c = utftext.charCodeAt(i);

		        if (c < 128) {
		            string += String.fromCharCode(c);
		            i++;
		        }
		        else if ((c > 191) && (c < 224)) {
		            c2 = utftext.charCodeAt(i + 1);
		            string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
		            i += 2;
		        }
		        else {
		            c2 = utftext.charCodeAt(i + 1);
		            c3 = utftext.charCodeAt(i + 2);
		            string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
		            i += 3;
		        }

		    }

		    return string;
		},
		findSection: function (sectionName)
		{
			var l;
			var s, s2;
			for (l = 0; l < this.strings.size(); l++)
			{
				s = this.strings.get(l);
				if (s.charAt(0) == "[")
				{
					var last = s.lastIndexOf("]");
					if (last >= 1)
					{
						s2 = s.substring(1, last);
						if (CServices.compareStringsIgnoreCase(sectionName, s2))
						{
							return l;
						}
					}
				}
			}
			return -1;
		},

		findKey: function (l, keyName)
		{
			var s, s2;
			var last;
			for (; l < this.strings.size(); l++)
			{
				s = this.strings.get(l);
				if (s.charAt(0) == "[")
				{
					return -1;
				}
				last = s.indexOf('=');
				if (last >= 0)
				{
					var start = 0;
					while (start < last && s.charCodeAt(start) == 32)
					{
						start++;
					}
					while (last > start && s.charCodeAt(last - 1) == 32)
					{
						last--;
					}
					if (last > start)
					{
						s2 = s.substring(0, last);
						if (CServices.compareStringsIgnoreCase(s2, keyName))
						{
							return l;
						}
					}
				}
			}
			return -1;
		},

		getPrivateProfileString: function (sectionName, keyName, defaultString, fileName)
		{
			this.loadIni(fileName);

			var l = this.findSection(sectionName);
			if (l >= 0)
			{
				l = this.findKey(l + 1, keyName);
				if (l >= 0)
				{
					var s = this.strings.get(l);
					var last = s.indexOf("=");
					return s.substring(last + 1);
				}
			}
			return defaultString;
		},

		writePrivateProfileString: function (sectionName, keyName, name, fileName)
		{
			this.loadIni(fileName);

			var s;
			var section = this.findSection(sectionName);
			if (section < 0)
			{
				s = "[" + sectionName + "]";
				this.strings.add(s);
				s = keyName + "=" + name;
				this.strings.add(s);
				//            this.saveIni();
				return;
			}

			var key = this.findKey(section + 1, keyName);
			if (key >= 0)
			{
				s = keyName + "=" + name;
				this.strings.set(key, s);
				//            this.saveIni();
				return;
			}

			for (key = section + 1; key < this.strings.size(); key++)
			{
				s = this.strings.get(key);
				if (s.charAt(0) == '[')
				{
					s = keyName + "=" + name;
					this.strings.insert(key, s);
					//	            this.saveIni();
					return;
				}
			}
			s = keyName + "=" + name;
			this.strings.add(s);
			//        this.saveIni();
		},

		deleteItem: function (group, item, iniName)
		{
			this.loadIni(iniName);

			var s = this.findSection(group);
			if (s >= 0)
			{
				var k = this.findKey(s + 1, item);
				if (k >= 0)
				{
					this.strings.removeIndex(k);
				}
				this.saveIni();
			}
		},

		deleteGroup: function (group, iniName)
		{
			this.loadIni(iniName);

			var s = this.findSection(group);
			if (s >= 0)
			{
				this.strings.removeIndex(s);
				while (true)
				{
					//s++;
					if (s >= this.strings.size())
					{
						break;
					}
					if (this.strings.get(s).charAt(0) == '[')
					{
						break;
					}
					this.strings.removeIndex(s);
				}
				this.saveIni();
			}
		}
	}

	// CTextSurface
	// -----------------------------------------------------------------
	function CTextSurface(a, w, h)
	{
		this.app = a;
		this.width = w;
		this.height = h;
		this.canvas = document.createElement("canvas");
		this.canvas.width = w;
		this.canvas.height = h;
		this.canvasContext = this.canvas.getContext("2d");
	}
	CTextSurface.prototype =
	{
		measureText:    function (text, font)
		{
			font = this.app.getGraphicFont(font);
			if (font.isGraphic)
				return font.measureText(text);
			this.canvasContext.font = font.getFont();
			return this.canvasContext.measureText(text).width;
		},
		setText:        function (text, dtflags, rectangle, font, color)
		{
			/* TODO : fix rect comparison */

			if (text == this.lastText && dtflags == this.lastFlags
				&& rectangle == this.lastRect && font == this.lastFont
				&& color == this.lastColor)
			{
				return this.lastHt;
			}

			var context = this.canvasContext;
			context.clearRect(0, 0, this.width, this.height);

			if (!rectangle)
				rectangle = new CRect(0, 0, this.width, this.height);
			var displayArray = new Array(0);
			font = this.app.getGraphicFont(font);
			var ht = CServices.drawText(context, text, dtflags, rectangle, font, displayArray);
			if (ht != 0)
			{
				var deltaY = 0;
				if ((dtflags & CServices.DT_BOTTOM) != 0)
					deltaY = this.height - ht;
				else if ((dtflags & CServices.DT_VCENTER) != 0)
					deltaY = this.height / 2 - ht / 2;
				CServices.displayText(context, 0, deltaY, displayArray, font, color, 0, 0);
			}
			this.lastText = text;
			this.lastFlags = dtflags;
			this.lastRect = rectangle;
			this.lastFont = font;
			this.lastColor = color;
			this.lastHt = ht;

			return ht;
		},
		manualClear:    function (color)
		{
			if (!color)
			{
				this.canvasContext.clearRect(0, 0, this.width, this.height);
				return;
			}

			this.canvasContext.fillStyle = CServices.getColorString(color);
			this.canvasContext.fillRect(0, 0, this.width, this.height);
		},
		manualDrawText: function (s, flags, rect, color, font, relief, color2)
		{
			var context = this.canvasContext;

			var displayArray = new Array(0);
			if (!rect)
				rect = new CRect(0, 0, this.width, this.height);
			font = this.app.getGraphicFont(font);
			var ht = CServices.drawText(this.canvasContext, s, flags, rect, font, displayArray);
			if (ht != 0)
			{
				var deltaY = 0;
				if ((flags & CServices.DT_BOTTOM) != 0)
					deltaY = this.height - ht;
				else if ((flags & CServices.DT_VCENTER) != 0)
					deltaY = this.height / 2 - ht / 2;
				switch (relief)
				{
					case 1:
						CServices.displayText(this.canvasContext, 1, deltaY + 1, displayArray, font, color2, 0, 0);
						CServices.displayText(this.canvasContext, 0, deltaY, displayArray, font, color, 0, 0);
						break;
					case 2:
						CServices.displayText(this.canvasContext, 1, deltaY, displayArray, font, color2, 0, 0);
						CServices.displayText(this.canvasContext, 1, deltaY + 2, displayArray, font, color2, 0, 0);
						CServices.displayText(this.canvasContext, 0, deltaY + 1, displayArray, font, color2, 0, 0);
						CServices.displayText(this.canvasContext, 2, deltaY + 1, displayArray, font, color2, 0, 0);
						CServices.displayText(this.canvasContext, 1, deltaY + 1, displayArray, font, color, 0, 0);
						break;
					case 0:
						CServices.displayText(this.canvasContext, 0, deltaY, displayArray, font, color, 0, 0);
						break;
				}
			}
		},
		resize:         function (w, h)
		{
			if (w != this.width || h != this.height)
			{
				this.width = w;
				this.height = h;
				this.canvas.width = w;
				this.canvas.height = h;
			}
		},
		draw:           function (context, x, y, inkEffect, inkEffectParam)
		{
			context.renderSimpleImage(this.canvas, x, y, this.width, this.height, inkEffect, inkEffectParam);
		}
	}

	// Browser detection
	// ----------------------------------------------------------------------
	BrowserDetect.dataBrowser =
		[
			{
				string:    navigator.userAgent,
				subString: "Chrome",
				identity:  "Chrome"
			},
			{    string:       navigator.userAgent,
				subString:     "OmniWeb",
				versionSearch: "OmniWeb/",
				identity:      "OmniWeb"
			},
			{
				string:        navigator.vendor,
				subString:     "Apple",
				identity:      "Safari",
				versionSearch: "Version"
			},
			{
				prop:          window.opera,
				identity:      "Opera",
				versionSearch: "Version"
			},
			{
				string:    navigator.vendor,
				subString: "iCab",
				identity:  "iCab"
			},
			{
				string:    navigator.vendor,
				subString: "KDE",
				identity:  "Konqueror"
			},
			{
				string:    navigator.userAgent,
				subString: "Firefox",
				identity:  "Firefox"
			},
			{
				string:    navigator.vendor,
				subString: "Camino",
				identity:  "Camino"
			},
			{		// for newer Netscapes (6+)
				string:    navigator.userAgent,
				subString: "Netscape",
				identity:  "Netscape"
			},
			{
				string:        navigator.userAgent,
				subString:     "MSIE",
				identity:      "Explorer",
				versionSearch: "MSIE"
			},
			{
				string:        navigator.userAgent,
				subString:     "Gecko",
				identity:      "Mozilla",
				versionSearch: "rv"
			},
			{ 		// for older Netscapes (4-)
				string:        navigator.userAgent,
				subString:     "Mozilla",
				identity:      "Netscape",
				versionSearch: "Mozilla"
			}
		];
	BrowserDetect.dataOS =
		[
			{
				string:    navigator.platform,
				subString: "Win",
				identity:  "Windows"
			},
			{
				string:    navigator.platform,
				subString: "Mac",
				identity:  "MacOS"
			},
			{
				string:    navigator.userAgent,
				subString: "iPhone",
				identity:  "iOS"
			},
			{
				string:    navigator.userAgent,
				subString: "iPod",
				identity:  "iOS"
			},
			{
				string:    navigator.userAgent,
				subString: "iPad",
				identity:  "iOS"
			},
			{
				string:    navigator.userAgent,
				subString: "Android",
				identity:  "Android"
			},
			{
				string:    navigator.platform,
				subString: "Windows Phone",
				identity:  "Windows Phone"
			},
			{
				string:    navigator.platform,
				subString: "Linux",
				identity:  "Linux"
			}
		];
	function BrowserDetect()
	{
	    // New detection, taken from http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser

	    // Opera 8.0+
	    this.isOpera = (!!window['opr'] && !!opr.addons) || !!window['opera'] || navigator.userAgent.indexOf(' OPR/') >= 0;

	    // Firefox 1.0+
	    this.isFirefox = typeof InstallTrigger !== 'undefined';

	    // Safari 3.0+ "[object HTMLElementConstructor]" 
	    this.isSafari = Object.prototype.toString.call(window['HTMLElement']).indexOf('Constructor') > 0 || (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window['safari'] || safari['pushNotification']);

	    // Internet Explorer 6-11
	    this.isIE = /*@cc_on!@*/false || !!document.documentMode;

	    // Edge 20+
	    this.isEdge = !this.isIE && !!window['StyleMedia'];
	    
	    // Chrome 1+
	    this.isChrome = !!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime);

		// Edge (based on chromium) detection
		this.isEdgeChromium = this.isChrome && (navigator.userAgent.indexOf("Edg") != -1);
		
	    if (this.isEdgeChromium)
		    this.browser = "Edge";
		else if (this.isChrome)
	        this.browser = "Chrome";
	    else if (this.isEdge)
	        this.browser = "Edge";
	    else if (this.isIE)
	        this.browser = "Explorer";
	    else if (this.isFirefox)
	        this.browser = "Firefox";
	    else if (this.isOpera)
	        this.browser = "Opera";
	    else if (this.isSafari)
	        this.browser = "Safari";

	    // Old version
	    else
	        this.browser = this.searchString(BrowserDetect.dataBrowser) || "Unknown browser";

	    this.version = this.searchVersion(navigator.userAgent)
			|| this.searchVersion(navigator.appVersion)
			|| "Unknown version";
		this.OS = this.searchString(BrowserDetect.dataOS) || "Unknown OS";
	}
	BrowserDetect.prototype =
	{
		searchString:  function (data)
		{
			for (var i = 0; i < data.length; i++)
			{
				var dataString = data[i].string;
				var dataProp = data[i].prop;
				this.versionSearchString = data[i].versionSearch || data[i].identity;
				if (dataString)
				{
					if (dataString.indexOf(data[i].subString) != -1)
						return data[i].identity;
				}
				else if (dataProp)
					return data[i].identity;
			}
		},
		searchVersion: function (dataString)
		{
			var index = dataString.indexOf(this.versionSearchString);
			if (index == -1) return;
			return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));
		}
	};

	// REPLACE COLOR
	// -----------------------------------------------------
	function CActReplaceColor()
	{
		this.mode = null;
		this.dwMax = null;
		this.pImages = null;
		this.pRh = null;
	}

	function CReplaceColor()
	{
		this.mode = 0;
		this.app = null;
		this.pImages = null;
	}
	CReplaceColor.prototype =
	{
		replaceColor: function (rhPtr, pHo, newColor, oldColor)
		{
			this.app = rhPtr.rhApp;

			// Changement des couleurs
			// ----------------------------------------------------------------------------
			var oi = pHo.hoOi;
			var poi = rhPtr.rhApp.OIList.getOIFromHandle(oi);
			if (poi == null)
				return;

			// Get image max
			this.dwMax = -1;
			this.mode = 0;
			poi.enumElements(this, null);

			// Rechercher le premier
			var pHoFirst = pHo;
			while ((pHoFirst.hoNumPrev & 0x80000000) == 0)
				pHoFirst = rhPtr.rhObjectList[pHoFirst.hoNumPrev & 0x7FFFFFFF];

			// Parcourir la liste
			do
			{
				if (pHoFirst.roc.rcImage != -1 && pHoFirst.roc.rcImage > this.dwMax)
					this.dwMax = pHoFirst.roc.rcImage;
				if (pHoFirst.roc.rcOldImage != -1 && pHoFirst.roc.rcOldImage > this.dwMax)
					this.dwMax = pHoFirst.roc.rcOldImage;

				// Le dernier?
				if ((pHoFirst.hoNumNext & 0x80000000) != 0)
					break;

				// Next OI
				pHoFirst = rhPtr.rhObjectList[pHoFirst.hoNumNext];

			} while (true);

			// Allocate memory
			this.pImages = new Array(this.dwMax + 1);
			var n;
			for (n = 0; n < this.dwMax + 1; n++)
			{
				this.pImages[n] = -1;
			}

			// List all images
			this.mode = 1;
			poi.enumElements(this, null);

			// Replace color in all images and create new images
			var i;
			var newImg;
			for (i = 0; i <= this.dwMax; i++)
			{
				if (this.pImages[i] == -1)
					continue;

				var sourceImg = rhPtr.rhApp.imageBank.getImageFromHandle(i);
				var destImg = CServices.performReplacement(rhPtr.rhApp, sourceImg, oldColor, newColor);
				if (destImg != null)
				{
					// Create new image in the bank
					this.pImages[i] = rhPtr.rhApp.imageBank.addImage(destImg);
				}
			}

			// Remplacer images dans les objets de m�me OI
			pHoFirst = pHo;
			while ((pHoFirst.hoNumPrev & 0x80000000) == 0)
				pHoFirst = rhPtr.rhObjectList[pHoFirst.hoNumPrev & 0x7FFFFFFF];

			// Parcourir la liste
			do
			{
				if (pHoFirst.roc.rcImage != -1 && this.pImages[pHoFirst.roc.rcImage] != -1)
				{
					pHoFirst.roc.rcImage = this.pImages[pHoFirst.roc.rcImage];
				}
				if (pHoFirst.roc.rcOldImage != -1 && this.pImages[pHoFirst.roc.rcOldImage] != -1)
				{
					pHoFirst.roc.rcOldImage = this.pImages[pHoFirst.roc.rcOldImage];
				}

				// Le dernier?
				if ((pHoFirst.hoNumNext & 0x80000000) != 0)
					break;
				// Next OI
				pHoFirst = rhPtr.rhObjectList[pHoFirst.hoNumNext];

			} while (true);

			this.mode = 2;
			poi.enumElements(this, null);

			// Replace old images by new ones
			this.mode = 3;
			poi.enumElements(this, null);

			// Mark OI to reload
			poi.oiLoadFlags |= COI.OILF_TORELOAD;
		},
		enumerate:    function (num)
		{
			switch (this.mode)
			{
				case 0:
					if (num > this.dwMax)
						this.dwMax = num;
					return -1;
				case 1:
					this.pImages[num] = 1;
					return -1;
				case 2:
					this.app.imageBank.delImage(num);
					return -1;
				case 3:
					var image = this.app.imageBank.getImageFromHandle(this.pImages[num]);
					image.useCount++;
					return this.pImages[num];
			}
			return -1;
		}
	}
	CServices.performReplacement = function (app, image, sourceColor, destColor)
	{
		var canvas = document.createElement("canvas");
		canvas.width = image.width;
		canvas.height = image.height;
		var context = canvas.getContext("2d");
		if (image.mosaic == 0)
		{
			context.drawImage(image.img, 0, 0);
		}
		else
		{
			context.drawImage(app.imageBank.mosaics[image.mosaic],
				image.mosaicX, image.mosaicY,
				image.width, image.height, 0, 0,
				image.width, image.height);
		}
		var imageData = context.getImageData(0, 0, image.width, image.height);
		var newR = (destColor >> 16) & 0xFF;
		var newG = (destColor >> 8) & 0xFF;
		var newB = destColor & 0xFF;
		var oldR = (sourceColor >> 16) & 0xFF;
		var oldG = (sourceColor >> 8) & 0xFF;
		var oldB = sourceColor & 0xFF;
		var index, x, y;
		for (y = 0; y < image.height; y++)
		{
			for (x = 0; x < image.width; x++)
			{
				index = (y * image.width + x) * 4;
				if (imageData.data[index] == oldR && imageData.data[index + 1] == oldG && imageData.data[index + 2] == oldB)
				{
					imageData.data[index] = newR;
					imageData.data[index + 1] = newG;
					imageData.data[index + 2] = newB;
				}
			}
		}
		context.putImageData(imageData, 0, 0);
		var newImage = new CImage();
		newImage.app = app;
		newImage.width = image.width;
		newImage.height = image.height;
		newImage.xSpot = image.xSpot;
		newImage.ySpot = image.ySpot;
		newImage.xAP = image.xAP;
		newImage.yAP = image.yAP;
		newImage.useCount = 0;
		newImage.img = canvas;
		newImage.maskNormal = image.maskNormal;
		newImage.maskPlatform = image.maskPlatform;
		newImage.maskRotation = image.maskRotation;

		return newImage;
	}

	// Graphic font
	// ---------------------------------------------------------
	CGraphicFont.FONTFLAG_ITALIC = 0x0001;
	CGraphicFont.FONTFLAG_UNDERLINE = 0x0002;
	CGraphicFont.FONTFLAG_BOLD = 0x0004;
	CGraphicFont.FLAG_PRIORITY = 0x0008;
	function CGraphicFont()
	{
		this.characters = null;
		this.width = 0;
		this.height = 0;
		this.image = null;
		this.color = 0;
		this.flags = 0;
		this.fontName = null;
		this.fontHeight = 0;
		this.fontFlags = 0;
		this.interline = 0;
		this.interchar = 0;
		this.nChars = 0;
		this.charWidths = null;
		this.isGraphic = true;
	}

	CGraphicFont.prototype =
	{
		compareFont: function (font)
		{
			if (this.fontName != font.lfFaceName)
				return false;
			if (this.fontHeight != font.lfHeight)
				return false;
			var b1 = (this.fontFlags & CGraphicFont.FONTFLAG_ITALIC) != 0;
			var b2 = (font.lfItalic) != 0;
			if (b1 != b2)
				return false;
			b1 = (this.fontFlags & CGraphicFont.FONTFLAG_BOLD) != 0;
			b2 = (font.lfWeight) > 400;
			if (b1 != b2)
				return false;
			return true;
		},

		getHeight: function () {
		    return this.height + this.interline;
		},

		measureText: function (s)
		{
			var w = 0;
			var l = s.length;
			var n, index;
			for (n = 0; n < l; n++)
			{
				index = this.characters.indexOf(s.charAt(n));
				if (index >= 0)
				{
					w += this.charWidths[index] + this.interchar;
				}
				else
				{
					w += this.width;
				}
			}
			return w;
		},

		measureChar: function (c)
		{
			var w;
			var index = characters.indexOf(String.fromCharCode(c));
			if (index >= 0)
				w = this.charWidths[index] + this.interchar;
			else
				w = this.width;
			return w;
		},

		fillText: function (context, s, x, y)
		{
			var l = s.length;
			var n, xs, ys, index, col, line, c;

			var image = this.image;

			if ((this.flags & CGraphicFont.FLAG_PRIORITY) == 0)
			{
				for (n = 0; n < l; n++)
				{
					index = this.characters.indexOf(s.charAt(n));
					if (index >= 0)
					{
						line = Math.floor(index / this.nChars);
						col = index - (line * this.nChars);
						ys = line * (this.height + 1);
						xs = col * (this.width + 1);

						if (image.mosaic == 0)
						{
						    context.drawImage(image.img, xs, ys, this.width, this.height, Math.round(x), Math.round(y), this.width, this.height);
						}
						else
						{
							context.drawImage(image.app.imageBank.mosaics[image.mosaic],
								xs + image.mosaicX, ys + image.mosaicY, this.width, this.height,
								Math.round(x), Math.round(y), this.width, this.height);
						}
						x += this.charWidths[index] + this.interchar;
					}
					else
					{
						context.fillStyle = CServices.getColorString(this.color);
						context.fillRect(x, y, this.width, this.height);
						x += this.width;
					}
				}
			}
			else
			{
				x += this.measureText(s);
				for (n = l - 1; n >= 0; n--)
				{
					index = this.characters.indexOf(s.charAt(n));
					if (index >= 0)
					{
						x -= (this.charWidths[index] + this.interchar);
						line = index / this.nChars;
						col = index - (line * this.nChars);
						ys = line * (this.height + 1);
						xs = col * (this.width + 1);
						if (image.mosaic == 0)
						{
						    context.drawImage(image.img, xs, ys, this.width, this.height, Math.round(x), Math.round(y), this.width, this.height);
						}
						else
						{
							context.drawImage(image.app.imageBank.mosaics[image.mosaic],
								xs + image.mosaicX, ys + image.mosaicY, this.width, this.height,
								Math.round(x), Math.round(y), this.width, this.height);
						}
					}
					else
					{
						x -= this.width;
						context.fillStyle = CServices.getColorString(this.color);
						context.fillRect(x, y, this.width, this.height);
					}
				}
			}
		}
	}

	// OBJECT SELECTION CLASS
	// ------------------------------------------------------------------------------
	function ObjectSelection(runApp)
	{
		this.rhPtr = runApp;
		this.run = this.rhPtr.run;
		this.eventProgram = this.run.rhEvtProg;
		this.ObjectList = this.run.rhObjectList;				//get a pointer to the mmf object list
		this.OiList = this.run.rhOiList;						//get a pointer to the mmf object info list
		this.QualToOiList = this.eventProgram.qualToOiList;	//get a pointer to the mmf qualifier to Oi list
	}
	ObjectSelection.prototype =
	{
		//Selects *all* objects of the given object-type
		selectAll:                 function (OiList)
		{
			var pObjectInfo = this.OiList[OiList];
			pObjectInfo.oilNumOfSelected = pObjectInfo.oilNObjects;
			pObjectInfo.oilListSelected = pObjectInfo.oilObject;
			pObjectInfo.oilEventCount = this.eventProgram.rh2EventCount;

			var i = pObjectInfo.oilObject;
			while ((i & 0x80000000) == 0)
			{
				var pObject = this.ObjectList[i];
				pObject.hoNextSelected = pObject.hoNumNext;
				i = pObject.hoNumNext;
			}
		},

		//Resets all objects of the given object-type
		selectNone:                function (OiList)
		{
			var pObjectInfo = this.OiList[OiList];
			if (pObjectInfo == null)
				return;
			pObjectInfo.oilNumOfSelected = 0;
			pObjectInfo.oilListSelected = -1;
			pObjectInfo.oilEventCount = this.eventProgram.rh2EventCount;
		},

		//Resets the SOL and inserts only one given object
		selectOneObject:           function (object)
		{
			var pObjectInfo = object.hoOiList;
			pObjectInfo.oilNumOfSelected = 1;
			pObjectInfo.oilEventCount = this.eventProgram.rh2EventCount;
			pObjectInfo.oilListSelected = object.hoNumber;
			this.ObjectList[object.hoNumber].hoNextSelected = -1;
		},

		//Resets the SOL and inserts the given list of objects
		selectObjects:             function (OiList, objects)
		{
			var pObjectInfo = this.OiList[OiList];

			if (pObjectInfo == null)
				return;

			pObjectInfo.oilNumOfSelected = objects.length;
			pObjectInfo.oilEventCount = eventProgram.rh2EventCount;

			if (objects.length == 0)
				return;

			var i = 0;
			var prevNumber = objects[i].hoNumber;
			pObjectInfo.oilListSelected = prevNumber;
			while (i < objects.length)
			{
				currentNumber = objects[i++].hoNumber;
				this.ObjectList[prevNumber].hoNextSelected = currentNumber;
				prevNumber = currentNumber;
			}
			this.ObjectList[prevNumber].hoNextSelected = -1;
		},

		//Run a custom filter on the SOL (via function callback)
		filterObjects:             function (rdPtr, OiList, negate, filter)
		{
			if ((OiList & 0x8000) != 0)
			{
				return ((this.filterQualifierObjects(rdPtr, OiList & 0x7FFF, negate, filter) ? 1 : 0) ^ (negate ? 1 : 0)) != 0;
			}
			return ((this.filterNonQualifierObjects(rdPtr, OiList, negate, filter) ? 1 : 0) ^ (negate ? 1 : 0)) != 0;
		},

		//Filter qualifier objects
		filterQualifierObjects:    function (rdPtr, OiList, negate, filter)
		{
			var CurrentQualToOi = this.QualToOiList[OiList];

			var hasSelected = false;
			var i = 0;

			while (i < CurrentQualToOi.qoiList.length)
			{
				var CurrentOi = CurrentQualToOi.qoiList[i + 1];
				hasSelected = (((hasSelected ? 1 : 0) |
					(this.filterNonQualifierObjects(rdPtr, CurrentOi, negate, filter) ? 1 : 0))) != 0;

				i += 2;
			}
			return hasSelected;
		},

		//Filter normal objects
		filterNonQualifierObjects: function (rdPtr, OiList, negate, filter)
		{
			var pObjectInfo = this.OiList[OiList];
			if (pObjectInfo == null)
				return false;
			var hasSelected = false;
			if (pObjectInfo.oilEventCount != this.eventProgram.rh2EventCount)
			{
				this.selectAll(OiList);	//The SOL is invalid, must reset.
			}

			//If SOL is empty
			if (pObjectInfo.oilNumOfSelected <= 0)
			{
				return false;
			}

			var firstSelected = -1;
			var count = 0;
			var current = pObjectInfo.oilListSelected;
			var previous = null;

			while ((current & 0x80000000) == 0)
			{
				var pObject = this.ObjectList[current];
				var filterResult = filter(rdPtr, pObject);
				var useObject = ((filterResult ? 1 : 0) ^ (negate ? 1 : 0)) != 0;
				hasSelected = ((hasSelected ? 1 : 0) | (useObject ? 1 : 0)) != 0;

				if (useObject)
				{
					if (firstSelected == -1)
					{
						firstSelected = current;
					}

					if (previous != null)
					{
						previous.hoNextSelected = current;
					}

					previous = pObject;
					count++;
				}
				current = pObject.hoNextSelected;
			}
			if (previous != null)
			{
				previous.hoNextSelected = -1;
			}

			pObjectInfo.oilListSelected = firstSelected;
			pObjectInfo.oilNumOfSelected = count;

			return hasSelected;
		},

		//Return the number of selected objects for the given object-type
		getNumberOfSelected:       function (OiList)
		{
			if ((OiList & 0x8000) != 0)
			{
				OiList &= 0x7FFF;	//Mask out the qualifier part
				var numberSelected = 0;

				var CurrentQualToOi = this.QualToOiList[OiList];

				var i = 0;
				while (i < CurrentQualToOi.qoiList.length)
				{
					var CurrentOi = this.OiList[CurrentQualToOi.qoiList[i + 1]];
					numberSelected += CurrentOi.oilNumOfSelected;
					i += 2;
				}
				return numberSelected;
			}
			else
			{
				var pObjectInfo = this.OiList[OiList];
				return pObjectInfo.oilNumOfSelected;
			}
		},

		objectIsOfType: function (obj, OiList)
		{
			if ((OiList & 0x8000) != 0)
			{
				OiList &= 0x7FFF;	//Mask out the qualifier part
				var CurrentQualToOi = this.QualToOiList[OiList];

				var i = 0;
				while (i < CurrentQualToOi.qoiList.length)
				{
					var CurrentOi = this.OiList[CurrentQualToOi.qoiList[i + 1]];
					if (CurrentOi.oilOi == obj.hoOi)
						return true;
					i += 2;
				}
				return false;
			}
			return (obj.hoOi == this.OiList[OiList].oilOi);
		},

		//Returns the object-info structure from a given object-type
		GetOILFromOI:   function (Oi)
		{
			for (i = 0; i < this.run.rhMaxOI; ++i)
			{
				var oil = this.OiList[i];
				if (oil.oilOi == Oi)
					return oil;
			}
			return null;
		}
	}


	// function decode_b64(d,b,c,u,r,q,x){b="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(r=q=x='';c=d.charAt(x++);~c&&(u=q%4?u*64+c:c,q++%4)?r+=String.fromCharCode(255&u>>(-2*q&6)):0)c=b.indexOf(c);return r}
	// function encode_b64(a,b,c,d,e,f){b="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";c="=";for(d=f='';e&=3,a.charAt(d++)||(b='=',e);f+=b.charAt(63&c>>++e*2))c=c<<8|a.charCodeAt(d-=!e);return f}


	//----------------------------------------------------------------------------------
	//
	// CTokenizer
	//
	//----------------------------------------------------------------------------------
	function CTokenizer(text, delimiter) {
	    this.tokens = new CArrayList();

	    var oldPos = 0;
	    var pos = text.indexOf(delimiter);

	    // Special case: if delimiter = \n, then remove \r from end of tokens
	    if (delimiter.length == 1 && delimiter.charCodeAt(0) == 10) {
	        while (pos >= 0) {
	            if (pos > oldPos) {
	                var str = text.substring(oldPos, pos);
	                if (str.length > 0 && str.charCodeAt(str.length - 1) == 13)
	                    str = str.substr(0, str.length - 1);
	                this.tokens.add(str);
	            }
	            oldPos = pos + delimiter.length;
	            pos = text.indexOf(delimiter, oldPos);
	        }

	        if (text.length > oldPos) {
	            var str = text.substring(oldPos, text.length);
	            if (str.length > 0 && str.charCodeAt(str.length - 1) == 13)
	                str = str.substr(0, str.length - 1);
	            this.tokens.add(str);
	        }
	    }
	    else {
	        while (pos >= 0) {
	            if (pos > oldPos) {
	                this.tokens.add(text.substring(oldPos, pos));
	            }
	            oldPos = pos + delimiter.length;
	            pos = text.indexOf(delimiter, oldPos);
	        }

	        if (text.length > oldPos) {
	            this.tokens.add(text.substring(oldPos, text.length));
	        }
	    }

	    this.numToken = 0;
	}
	CTokenizer.prototype =
	{
	    countTokens: function () {
	        return this.tokens.size();
	    },
	    nextToken: function () {
	        if (this.numToken < this.tokens.size()) {
	            var s = this.tokens.get(this.numToken++);
	            if (s == null) {
	                return "";
	            }
	            return s;
	        }
	        return "";
	    }
	}

	// CAct object
	// ----------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 * 
	 * Permission is hereby granted to any person obtaining a legal copy 
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for 
	 * debugging, optimizing, or customizing applications created with 
	 * Clickteam Multimedia Fusion 2. 
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CAct.ACTFLAGS_REPEAT = 0x0001;
	CAct.ACT_EXTSETFRICTION = (68 << 8);
	CAct.ACT_EXTSETELASTICITY = (69 << 8);
	CAct.ACT_EXTAPPLYIMPULSE = (70 << 8);
	CAct.ACT_EXTAPPLYANGULARIMPULSE = (71 << 8);
	CAct.ACT_EXTAPPLYFORCE = (72 << 8);
	CAct.ACT_EXTAPPLYTORQUE = (73 << 8);
	CAct.ACT_EXTSETLINEARVELOCITY = (74 << 8);
	CAct.ACT_EXTSETANGULARVELOCITY = (75 << 8);
	CAct.ACT_EXTFOREACH = (76 << 8);
	CAct.ACT_EXTFOREACH2 = (77 << 8);
	CAct.ACT_EXTSTOPFORCE = (78 << 8);
	CAct.ACT_EXTSTOPTORQUE = (79 << 8);
	CAct.ACT_EXTSETDENSITY = (80 << 8);
	CAct.ACT_EXTSETGRAVITYSCALE = (81 << 8);
	CAct.ACT_STARTLOOP = ((14 << 16) | 0xFFFF);
	CAct.create = function (app)
	{
	    var bSetVarGConst = false;
	    var bAddVarGConst = false;
	    var bSubVarGConst = false;
	    var bExtSetVar = false;
	    var bExtAddVar = false;
	    var bExtSubVar = false;
	    var bExtSetFlag = false;
	    var bExtClrFlag = false;
	    var bExtChgFlag = false;
	    var bExtra = false;

	    var debut = app.file.getFilePointer();

		var size = app.file.readAShort()
		var act = null;
		var c = app.file.readAInt();
		switch (c)
		{
			case ((0 << 16) | 0xFFFF):
				act = new ACT_SKIP();
				break;
			case ((1 << 16) | 0xFFFF):		// ACT_SKIPMONITOR			
				act = new ACT_SKIP();
				break;
			case ((3 << 16) | 0xFFFF):
				act = new ACT_SETVARG();
				break;
			case ((4 << 16) | 0xFFFF):
				act = new ACT_SUBVARG();
				break;
			case ((5 << 16) | 0xFFFF):
				act = new ACT_ADDVARG();
				break;
			case ((6 << 16) | 0xFFFF):
				act = new ACT_GRPACTIVATE();
				break;
			case ((7 << 16) | 0xFFFF):
				act = new ACT_GRPDEACTIVATE();
				break;
			case ((14 << 16) | 0xFFFF):
				act = new ACT_STARTLOOP();
				break;
			case ((15 << 16) | 0xFFFF):
				act = new ACT_STOPLOOP();
				break;
			case ((16 << 16) | 0xFFFF):
				act = new ACT_SETLOOPINDEX();
				break;
			case ((17 << 16) | 0xFFFF):
				act = new ACT_RANDOMIZE();
				break;
			case ((19 << 16) | 0xFFFF):
				act = new ACT_SETGLOBALSTRING();
				break;
			case ((23 << 16) | 0xFFFF):
				act = new ACT_SKIP();
				break;
			case ((24 << 16) | 0xFFFF):
				act = new ACT_SKIP();
				break;
		    case ((27 << 16) | 0xFFFF):
		        act = new ACT_SETVARGCONST();
		        bSetVarGConst = true;
		        break;
		    case ((28 << 16) | 0xFFFF):
		        act = new ACT_SETVARG();
		        break;
		    case ((29 << 16) | 0xFFFF):
		        act = new ACT_SETVARGCONST();
		        bSetVarGConst = true;
		        break;
		    case ((30 << 16) | 0xFFFF):
		        act = new ACT_SETVARG();
		        break;
		    case ((31 << 16) | 0xFFFF):
		        act = new ACT_ADDVARGCONST();
		        bAddVarGConst = true;
		        break;
		    case ((32 << 16) | 0xFFFF):
		        act = new ACT_ADDVARG();
		        break;
		    case ((33 << 16) | 0xFFFF):
		        act = new ACT_ADDVARGCONST();
		        bAddVarGConst = true;
		        break;
		    case ((34 << 16) | 0xFFFF):
		        act = new ACT_ADDVARG();
		        break;
		    case ((35 << 16) | 0xFFFF):
		        act = new ACT_SUBVARGCONST();
		        bSubVarGConst = true;
		        break;
		    case ((36 << 16) | 0xFFFF):
		        act = new ACT_SUBVARG();
		        break;
		    case ((37 << 16) | 0xFFFF):
		        act = new ACT_SUBVARGCONST();
		        bSubVarGConst = true;
		        break;
		    case ((38 << 16) | 0xFFFF):
		        act = new ACT_SUBVARG();
		        break;
		    case ((43 << 16) | 0xFFFF):
		        act = new ACT_EXECUTECHILDEVENTS;
		        break;
		    case ((44 << 16) | 0xFFFF):
		        act = new ACT_SKIP;
		        break;
		    case ((0 << 16) | 0xFFFE):
				act = new ACT_PLAYSAMPLE();
				break;
			case ((1 << 16) | 0xFFFE):
				act = new ACT_STOPSAMPLE();
				break;
			case ((4 << 16) | 0xFFFE):
				act = new ACT_PLAYLOOPSAMPLE();
				break;
			case ((6 << 16) | 0xFFFE):
				act = new ACT_STOPSPESAMPLE();
				break;
			case ((7 << 16) | 0xFFFE):
				act = new ACT_PAUSESAMPLE();
				break;
			case ((8 << 16) | 0xFFFE):
				act = new ACT_RESUMESAMPLE();
				break;
			case ((11 << 16) | 0xFFFE):
				act = new ACT_PLAYCHANNEL();
				break;
			case ((12 << 16) | 0xFFFE):
				act = new ACT_PLAYLOOPCHANNEL();
				break;
			case ((13 << 16) | 0xFFFE):
				act = new ACT_PAUSECHANNEL();
				break;
			case ((14 << 16) | 0xFFFE):
				act = new ACT_RESUMECHANNEL();
				break;
			case ((15 << 16) | 0xFFFE):
				act = new ACT_STOPCHANNEL();
				break;
			case ((16 << 16) | 0xFFFE):
				act = new ACT_SETCHANNELPOS();
				break;
			case ((17 << 16) | 0xFFFE):
				act = new ACT_SETCHANNELVOL();
				break;
			case ((18 << 16) | 0xFFFE):				// SETCHANNELPAN
				act = new ACT_SKIP();
				break;
			case ((19 << 16) | 0xFFFE):
				act = new ACT_SETSAMPLEPOS();
				break;
			case ((20 << 16) | 0xFFFE):
				act = new ACT_SETSAMPLEMAINVOL();
				break;
			case ((21 << 16) | 0xFFFE):
				act = new ACT_SETSAMPLEVOL();
				break;
			case ((22 << 16) | 0xFFFE):
				act = new ACT_SKIP();
				break;
			case ((23 << 16) | 0xFFFE):
				act = new ACT_SKIP();
				break;
			case ((24 << 16) | 0xFFFE):
				act = new ACT_PAUSEALLCHANNELS();
				break;
			case ((25 << 16) | 0xFFFE):
				act = new ACT_RESUMEALLCHANNELS();
				break;
			case ((30 << 16) | 0xFFFE):
				act = new ACT_LOCKCHANNEL();
				break;
			case ((31 << 16) | 0xFFFE):
				act = new ACT_UNLOCKCHANNEL();
				break;
			case ((32 << 16) | 0xFFFE):
				act = new ACT_SETCHANNELFREQ();
				break;
			case ((33 << 16) | 0xFFFE):
				act = new ACT_SETSAMPLEFREQ();
				break;
	        case ((36 << 16) | 0xFFFE):
	            act = new ACT_PLAYSAMPLE2();
	            break;
			case ((0 << 16) | 0xFFFD):
				act = new ACT_NEXTLEVEL();
				break;
			case ((1 << 16) | 0xFFFD):
				act = new ACT_PREVLEVEL();
				break;
			case ((2 << 16) | 0xFFFD):
				act = new ACT_GOLEVEL();
				break;
			case ((3 << 16) | 0xFFFD):
				act = new ACT_PAUSEKEY();
				break;
			case ((4 << 16) | 0xFFFD):
				act = new ACT_ENDGAME();
				break;
			case ((5 << 16) | 0xFFFD):
				act = new ACT_RESTARTGAME();
				break;
			case ((6 << 16) | 0xFFFD):
				act = new ACT_RESTARTLEVEL();
				break;
			case ((7 << 16) | 0xFFFD):
				act = new ACT_CDISPLAY();
				break;
			case ((8 << 16) | 0xFFFD):
				act = new ACT_CDISPLAYX();
				break;
			case ((9 << 16) | 0xFFFD):
				act = new ACT_CDISPLAYY();
				break;
			case ((14 << 16) | 0xFFFD):
				act = new ACT_FULLSCREENMODE();
				break;
			case ((15 << 16) | 0xFFFD):
				act = new ACT_WINDOWEDMODE();
				break;
			case ((16 << 16) | 0xFFFD):
				act = new ACT_SETFRAMERATE();
				break;
			case ((17 << 16) | 0xFFFD):
				act = new ACT_PAUSEKEY();
				break;
			case ((18 << 16) | 0xFFFD):
				act = new ACT_PAUSEANYKEY();
				break;
			case ((19 << 16) | 0xFFFD):
				act = new ACT_SETVSYNCON();
				break;
			case ((20 << 16) | 0xFFFD):
				act = new ACT_SETVSYNCOFF();
				break;
			case ((21 << 16) | 0xFFFD):
				act = new ACT_SETVIRTUALWIDTH();
				break;
			case ((22 << 16) | 0xFFFD):
				act = new ACT_SETVIRTUALHEIGHT();
				break;
			case ((23 << 16) | 0xFFFD):
				act = new ACT_SETFRAMEBDKCOLOR();
				break;
			case ((24 << 16) | 0xFFFD):
				act = new ACT_DELCREATEDBKDAT();
				break;
			case ((25 << 16) | 0xFFFD):
				act = new ACT_DELALLCREATEDBKD();
				break;
			case ((26 << 16) | 0xFFFD):
				act = new ACT_SETFRAMEWIDTH();
				break;
			case ((27 << 16) | 0xFFFD):
				act = new ACT_SETFRAMEHEIGHT();
				break;
			case ((31 << 16) | 0xFFFD):
				act = new ACT_PLAYDEMO();
				break;
			case ((32 << 16) | 0xFFFD): 		// ACT_SETFRAMEEFFECT				
				act = new ACT_SKIP();
				break;
			case ((33 << 16) | 0xFFFD):
				act = new ACT_SKIP();
				break;
			case ((34 << 16) | 0xFFFD):
				act = new ACT_SKIP();
				break;
			case ((35 << 16) | 0xFFFD):			// ACT_SETFRAMEALPHACOEF			
				act = new ACT_SKIP();
				break;
			case ((36 << 16) | 0xFFFD): 		// ACT_SETFRAMERGBCOEF				
				act = new ACT_SKIP();
				break;
		    case ((37 << 16) | 0xFFFD): 		// ACT_SETSTRETCHRESAMPLING
		        act = new ACT_SETSTRETCHRESAMPLING();
		        break;
		    case ((0 << 16) | 0xFFFC):
				act = new ACT_SETTIMER();
				break;
			case ((1 << 16) | 0xFFFC):
				act = new ACT_EVENTAFTER();
				break;
			case ((2 << 16) | 0xFFFC):
				act = new ACT_NEVENTSAFTER();
				break;
			case ((0 << 16) | 0xFFFA):
				act = new ACT_HIDECURSOR();
				break;
			case ((1 << 16) | 0xFFFA):
				act = new ACT_SHOWCURSOR();
				break;
			case ((0 << 16) | 0xFFF9):
				act = new ACT_SETSCORE();
				break;
			case ((1 << 16) | 0xFFF9):
				act = new ACT_SETLIVES();
				break;
			case ((2 << 16) | 0xFFF9):
				act = new ACT_NOINPUT();
				break;
			case ((3 << 16) | 0xFFF9):
				act = new ACT_RESTINPUT();
				break;
			case ((4 << 16) | 0xFFF9):
				act = new ACT_ADDSCORE();
				break;
			case ((5 << 16) | 0xFFF9):
				act = new ACT_ADDLIVES();
				break;
			case ((6 << 16) | 0xFFF9):
				act = new ACT_SUBSCORE();
				break;
			case ((7 << 16) | 0xFFF9):
				act = new ACT_SUBLIVES();
				break;
			case ((8 << 16) | 0xFFF9):
				act = new ACT_SETINPUT();
				break;
			case ((9 << 16) | 0xFFF9):
				act = new ACT_SETINPUTKEY();
				break;
			case ((10 << 16) | 0xFFF9):
				act = new ACT_SETPLAYERNAME();
				break;
			case ((0 << 16) | 0xFFFB):
				act = new ACT_CREATE();
				break;
			case ((1 << 16) | 0xFFFB):
				act = new ACT_CREATEBYNAME();
				break;
			case (((80 + 0) << 16) | 3):
				act = new ACT_STRDESTROY();
				break;
			case (( (80 + 1) << 16) | 3):
				act = new ACT_STRDISPLAY();
				break;
			case (( (80 + 2) << 16) | 3):
				act = new ACT_STRDISPLAYDURING();
				break;
			case (( (80 + 3) << 16) | 3):
				act = new ACT_STRSETCOLOUR();
				break;
			case (( (80 + 4) << 16) | 3):
				act = new ACT_STRSET();
				break;
			case (( (80 + 5) << 16) | 3):
				act = new ACT_STRPREV();
				break;
			case (( (80 + 6) << 16) | 3):
				act = new ACT_STRNEXT();
				break;
			case (( (80 + 7) << 16) | 3):
				act = new ACT_STRDISPLAYSTRING();
				break;
			case (( (80 + 8) << 16) | 3):
				act = new ACT_STRSETSTRING();
				break;
			case (((80 + 0) << 16) | 2):
				act = new ACT_SPRPASTE();
				break;
			case (((80 + 1) << 16) | 2):
				act = new ACT_SPRFRONT();
				break;
			case (((80 + 2) << 16) | 2):
				act = new ACT_SPRBACK();
				break;
			case (((80 + 3) << 16) | 2):
				act = new ACT_SPRADDBKD();
				break;
			case (((80 + 4) << 16) | 2):
				act = new ACT_SPRREPLACECOLOR();
				break;
			case (((80 + 5) << 16) | 2):
				act = new ACT_SPRSETSCALE();
				break;
			case (((80 + 6) << 16) | 2):
				act = new ACT_SPRSETSCALEX();
				break;
			case (((80 + 7) << 16) | 2):
				act = new ACT_SPRSETSCALEY();
				break;
			case (((80 + 8) << 16) | 2):
				act = new ACT_SPRSETANGLE();
				break;
			case (( (80 + 0) << 16) | 7):
				act = new ACT_CSETVALUE();
				break;
			case (( (80 + 1) << 16) | 7):
				act = new ACT_CADDVALUE();
				break;
			case (( (80 + 2) << 16) | 7):
				act = new ACT_CSUBVALUE();
				break;
			case (( (80 + 3) << 16) | 7):
				act = new ACT_CSETMIN();
				break;
			case (( (80 + 4) << 16) | 7):
				act = new ACT_CSETMAX();
				break;
			case (( (80 + 5) << 16) | 7):
				act = new ACT_CSETCOLOR1();
				break;
			case (( (80 + 6) << 16) | 7):
				act = new ACT_CSETCOLOR2();
				break;
			case (( (80 + 0) << 16) | 4):
				act = new ACT_QASK();
				break;
			case (((80 + 0) << 16) | 9):
				act = new ACT_CCARESTARTAPP();
				break;
			case (((80 + 1) << 16) | 9):
				act = new ACT_CCARESTARTFRAME();
				break;
			case (((80 + 2) << 16) | 9):
				act = new ACT_CCANEXTFRAME();
				break;
			case (((80 + 3) << 16) | 9):
				act = new ACT_CCAPREVIOUSFRAME();
				break;
			case (((80 + 4) << 16) | 9):
				act = new ACT_CCAENDAPP();
				break;
			case (((80 + 6) << 16) | 9):
				act = new ACT_CCAJUMPFRAME();
				break;
			case (((80 + 7) << 16) | 9):
				act = new ACT_CCASETGLOBALVALUE();
				break;
			case (((80 + 8) << 16) | 9):
				act = new ACT_CCASHOW();
				break;
			case (((80 + 9) << 16) | 9):
				act = new ACT_CCAHIDE();
				break;
			case (((80 + 10) << 16) | 9):
				act = new ACT_CCASETGLOBALSTRING();
				break;
			case (((80 + 11) << 16) | 9):
				act = new ACT_CCAPAUSEAPP();
				break;
			case (((80 + 12) << 16) | 9):
				act = new ACT_CCARESUMEAPP();
				break;
			case (((80 + 13) << 16) | 9):
				act = new ACT_CCASETWIDTH();
				break;
			case (((80 + 14) << 16) | 9):
				act = new ACT_CCASETHEIGHT();
				break;

			    // Actions pour les objets extensions 
			default:
			{
				switch (c & 0xFFFF0000)
				{
				    case 0:
				        act = new ACT_EXTEXTRA();
				        bExtra = true;
				        break;
				    case (1 << 16):
						act = new ACT_EXTSETPOS();
						break;
					case (2 << 16):
						act = new ACT_EXTSETX();
						break;
					case (3 << 16):
						act = new ACT_EXTSETY();
						break;
					case (4 << 16):
						act = new ACT_EXTSTOP();
						break;
					case (5 << 16):
						act = new ACT_EXTSTART();
						break;
					case (6 << 16):
						act = new ACT_EXTSPEED();
						break;
					case (7 << 16):
						act = new ACT_EXTMAXSPEED();
						break;
					case (8 << 16):
						act = new ACT_EXTWRAP();
						break;
					case (9 << 16):
						act = new ACT_EXTBOUNCE();
						break;
					case (10 << 16):
						act = new ACT_EXTREVERSE();
						break;
					case (11 << 16):
						act = new ACT_EXTNEXTMOVE();
						break;
					case (12 << 16):
						act = new ACT_EXTPREVMOVE();
						break;
					case (13 << 16):
						act = new ACT_EXTSELMOVE();
						break;
					case (14 << 16):
						act = new ACT_EXTLOOKAT();
						break;
					case (15 << 16):
						act = new ACT_EXTSTOPANIM();
						break;
					case (16 << 16):
						act = new ACT_EXTSTARTANIM();
						break;
					case (17 << 16):
						act = new ACT_EXTFORCEANIM();
						break;
					case (18 << 16):
						act = new ACT_EXTFORCEDIR();
						break;
					case (19 << 16):
						act = new ACT_EXTFORCESPEED();
						break;
					case (20 << 16):
						act = new ACT_EXTRESTANIM();
						break;
					case (21 << 16):
						act = new ACT_EXTRESTDIR();
						break;
					case (22 << 16):
						act = new ACT_EXTRESTSPEED();
						break;
					case (23 << 16):
						act = new ACT_EXTSETDIR();
						break;
					case (24 << 16):
						act = new ACT_EXTDESTROY();
						break;
					case (25 << 16):
						act = new ACT_EXTSHUFFLE();
						break;
					case (26 << 16):
						act = new ACT_EXTHIDE();
						break;
					case (27 << 16):
						act = new ACT_EXTSHOW();
						break;
					case (28 << 16):
						act = new ACT_EXTDISPLAYDURING();
						break;
					case (29 << 16):
						act = new ACT_EXTSHOOT();
						break;
					case (30 << 16):
						act = new ACT_EXTSHOOTTOWARD();
						break;
					case (31 << 16):
						act = new ACT_EXTSETVAR();
						bExtSetVar = true;
						break;
					case (32 << 16):
						act = new ACT_EXTADDVAR();
						bExtAddVar = true;
						break;
					case (33 << 16):
						act = new ACT_EXTSUBVAR();
						bExtSubVar = true;
						break;
					case (34 << 16):
						act = new ACT_EXTDISPATCHVAR();
						break;
					case (35 << 16):
						act = new ACT_EXTSETFLAG();
						bExtSetFlag = true;
						break;
					case (36 << 16):
						act = new ACT_EXTCLRFLAG();
						bExtClrFlag = true;
						break;
					case (37 << 16):
						act = new ACT_EXTCHGFLAG();
						bExtChgFlag = true;
						break;
					case (38 << 16):
						act = new ACT_EXTINKEFFECT();
						break;
					case (39 << 16):
						act = new ACT_EXTSETSEMITRANSPARENCY();
						break;
					case (40 << 16):
						act = new ACT_EXTFORCEFRAME();
						break;
					case (41 << 16):
						act = new ACT_EXTRESTFRAME();
						break;
					case (42 << 16):
						act = new ACT_EXTSETACCELERATION();
						break;
					case (43 << 16):
						act = new ACT_EXTSETDECELERATION();
						break;
					case (44 << 16):
						act = new ACT_EXTSETROTATINGSPEED();
						break;
					case (45 << 16):
						act = new ACT_EXTSETDIRECTIONS();
						break;
					case (46 << 16):
						act = new ACT_EXTBRANCHNODE();
						break;
					case (47 << 16):
						act = new ACT_EXTSETGRAVITY();
						break;
					case (48 << 16):
						act = new ACT_EXTGOTONODE();
						break;
					case (49 << 16):
						act = new ACT_EXTSETVARSTRING();
						break;
					case (50 << 16):
						act = new ACT_EXTSETFONTNAME();
						break;
					case (51 << 16):
						act = new ACT_EXTSETFONTSIZE();
						break;
					case (52 << 16):
						act = new ACT_EXTSETBOLD();
						break;
					case (53 << 16):
						act = new ACT_EXTSETITALIC();
						break;
					case (54 << 16):
						act = new ACT_EXTSETUNDERLINE();
						break;
					case (55 << 16):
						act = new ACT_SKIP();
						break;
					case (56 << 16):
						act = new ACT_EXTSETTEXTCOLOR();
						break;
					case (57 << 16):
						act = new ACT_EXTSPRFRONT();
						break;
					case (58 << 16):
						act = new ACT_EXTSPRBACK();
						break;
					case (59 << 16):
						act = new ACT_EXTMOVEBEFORE();
						break;
					case (60 << 16):
						act = new ACT_EXTMOVEAFTER();
						break;
					case (61 << 16):
						act = new ACT_EXTMOVETOLAYER();
						break;
					case (62 << 16):				//  ACT_EXTADDTODEBUGGER		
						act = new ACT_SKIP();
						break;
					case (63 << 16):
						act = new ACT_EXTSETEFFECT();
						break;
					case (64 << 16):  //  ACT_EXTSETEFFECTPARAM
						act = new ACT_SKIP();
						break;
					case (65 << 16):
						act = new ACT_EXTSETALPHACOEF();
						break;
					case (66 << 16):
						act = new ACT_EXTSETRGBCOEF();
						break;
					case (67 << 16):  // ACT_EXTSETEFFECTPARAMTEXTURE
						act = new ACT_SKIP();
						break;
					case (68 << 16):
						act = new ACT_EXTSETFRICTION();
						break;
					case (69 << 16):
						act = new ACT_EXTSETELASTICITY();
						break;
					case (70 << 16):
						act = new ACT_EXTAPPLYIMPULSE();
						break;
					case (71 << 16):
						act = new ACT_EXTAPPLYANGULARIMPULSE();
						break;
					case (72 << 16):
						act = new ACT_EXTAPPLYFORCE();
						break;
					case (73 << 16):
						act = new ACT_EXTAPPLYTORQUE();
						break;
					case (74 << 16):
						act = new ACT_EXTSETLINEARVELOCITY();
						break;
					case (75 << 16):
						act = new ACT_EXTSETANGULARVELOCITY();
						break;
					case (76 << 16):
						act = new ACT_EXTFOREACH();
						break;
					case (77 << 16):
						act = new ACT_EXTFOREACH2();
						break;
					case (78 << 16):
						act = new ACT_EXTSTOPFORCE();
						break;
					case (79 << 16):
						act = new ACT_EXTSTOPTORQUE();
						break;
				    default:
						act = new CActExtension();
						break;
				}
			}
		}

		if (act != null)
		{
			act.evtCode = c;
			act.evtOi = app.file.readShort();
			act.evtOiList = app.file.readShort();
			act.evtFlags = app.file.readAByte();
			act.evtFlags2 = app.file.readAByte();
			act.evtNParams = app.file.readAByte();
			act.evtDefType = app.file.readAByte();

	        // Extra common action? read subaction number and skip parameter
			var subaction = 0;
			if (bExtra) {
			    act.evtNParams--;
			    var paramstart = app.file.getFilePointer();
			    var paramsize = app.file.readAShort();
			    var paramcode = app.file.readAShort();      // PARAM_SUBACTION
			    subaction = app.file.readAShort();
			    app.file.seek(paramstart + paramsize);
			}

			if (act.evtNParams > 0)
			{
				act.evtParams = new Array(act.evtNParams);
				var n;
				for (n = 0; n < act.evtNParams; n++)
				{
					act.evtParams[n] = CParam.create(app);
				}
			}

			if (subaction != 0) {
			    var newAct = null;
			    switch (subaction) {
	            // Set flag by expression
			        case 1:
			            newAct = new ACT_EXTSETFLAGBYEXP;
			            break;
			    }
			    if (newAct != null) {
			        newAct.evtCode = act.evtCode;
			        newAct.evtOi = act.evtOi;
			        newAct.evtOiList = act.evtOiList;
			        newAct.evtFlags = act.evtFlags;
			        newAct.evtFlags2 = act.evtFlags2;
			        newAct.evtNParams = act.evtNParams;
			        newAct.evtDefType = act.evtDefType;
			        newAct.evtParams = act.evtParams;

			        act = newAct;
			    }
			}

			// Optimization of operations on global values for constant values
			if (bSetVarGConst || bAddVarGConst || bSubVarGConst)
	        {
		        var pParam = act.evtParams[0];
		        act.num = pParam.value;

		        var pExp1 = act.evtParams[1];
		        act.value = pExp1.tokens[0].value;
			}

		    // Optimization of operations on alterable values for constant values
			if (bExtSetVar || bExtAddVar || bExtSubVar) {
			    var newAct = null;
			    var pParam = act.evtParams[0];
			    if (pParam.code != 53) {
			        // Value number = constant
			        var num = pParam.value;

			        // Parameter = simple constant?
			        var pExp1 = act.evtParams[1];
			        if (num >= 0 && pExp1.tokens.length == 2 && (pExp1.tokens[1].code <= 0 || pExp1.tokens[1].code >= 0x00140000)) {
			            // INT
			            if (pExp1.tokens[0].code == ((0 << 16) | 65535) || pExp1.tokens[0].code == ((23 << 16) | 65535)) {
			                if (bExtSetVar) {
			                    newAct = new ACT_EXTSETVARCONST();
			                    newAct.num = num;
			                    newAct.value = pExp1.tokens[0].value;
			                }
			                else if (bExtAddVar) {
			                    newAct = new ACT_EXTADDVARCONST();
			                    newAct.num = num;
			                    newAct.value = pExp1.tokens[0].value;
			                }
			                else if (bExtSubVar) {
			                    newAct = new ACT_EXTSUBVARCONST();
			                    newAct.num = num;
			                    newAct.value = pExp1.tokens[0].value;
			                }
			            }
			        }
			        if (newAct != null) {
			            newAct.evtCode = act.evtCode;
			            newAct.evtOi = act.evtOi;
			            newAct.evtOiList = act.evtOiList;
			            newAct.evtFlags = act.evtFlags;
			            newAct.evtFlags2 = act.evtFlags2;
			            newAct.evtNParams = act.evtNParams;
			            newAct.evtDefType = act.evtDefType;
			            newAct.evtParams = act.evtParams;

			            act = newAct;
			        }
			    }
			}

		    // Optimization of operations on alterable flags for constant flag numbers
			if (bExtSetFlag || bExtClrFlag || bExtChgFlag) {
			    var newAct = null;

			    // Flag number = simple constant?
			    var pExp = act.evtParams[0];
			    if (pExp.tokens.length == 2 && (pExp.tokens[1].code <= 0 || pExp.tokens[1].code >= 0x00140000) && pExp.tokens[0].code == ((0 << 16) | 65535)) {
			        if (bExtSetFlag) {
			            newAct = new ACT_EXTSETFLAGCONST();
			            newAct.mask = (1 << pExp.tokens[0].value);
			        }
			        else if (bExtClrFlag) {
			            newAct = new ACT_EXTCLRFLAGCONST();
			            newAct.mask = (1 << pExp.tokens[0].value);
			        }
			        else if (bExtChgFlag) {
			            newAct = new ACT_EXTCHGFLAGCONST();
			            newAct.mask = (1 << pExp.tokens[0].value);
			        }
			    }
			    if (newAct != null) {
			        newAct.evtCode = act.evtCode;
			        newAct.evtOi = act.evtOi;
			        newAct.evtOiList = act.evtOiList;
			        newAct.evtFlags = act.evtFlags;
			        newAct.evtFlags2 = act.evtFlags2;
			        newAct.evtNParams = act.evtNParams;
			        newAct.evtDefType = act.evtDefType;
			        newAct.evtParams = act.evtParams;

			        act = newAct;
			    }
			}
	    }
		app.file.seek(debut + size);
		return act;
	}
	function CAct()
	{
	}

	CLoop.FLFLAG_STOP = 0x0001;
	function CLoop()
	{
		this.flags = 0;
		this.name = null;
		this.index = 0;
	}

	function ACT_SKIP()
	{
	}
	ACT_SKIP.prototype =
	{
		execute: function (rhPtr)
		{
		}
	}
	// CUT

	// System object
	// ------------------------------------------------------------------
	function ACT_ADDVARG()
	{
	}
	ACT_ADDVARG.prototype =
	{
		execute: function (rhPtr)
		{
			var num;
			if (this.evtParams[0].code == 52)
				num = (rhPtr.get_EventExpressionInt(this.evtParams[0]) - 1);
			else
				num = this.evtParams[0].value;
			var value = rhPtr.get_EventExpressionAny(this.evtParams[1]);
			rhPtr.rhApp.addGlobalValueAt(num, value);
		}
	}
	// -- CUT

	function ACT_ADDVARGCONST()
	{
	}
	ACT_ADDVARGCONST.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhApp.addGlobalValueAt(this.num, this.value);
		}
	}
	// CUT

	function ACT_GRPACTIVATE()
	{
	}
	ACT_GRPACTIVATE.prototype =
	{
		execute:     function (rhPtr)
		{
			var p = this.evtParams[0];
			var evg = p.pointer;
			var evgPtr = rhPtr.rhEvtProg.events[evg];
			var evtPtr = evgPtr.evgEvents[0];

			var grpPtr = evtPtr.evtParams[0];
			var bFlag = (grpPtr.grpFlags & PARAM_GROUP.GRPFLAGS_GROUPINACTIVE) != 0;
			grpPtr.grpFlags &= ~PARAM_GROUP.GRPFLAGS_GROUPINACTIVE;

			if (bFlag)
				this.grpActivate(rhPtr, evg);
		},
		grpActivate: function (rhPtr, evg)
		{
			var evgPtr = rhPtr.rhEvtProg.events[evg];
			var evtPtr = evgPtr.evgEvents[0];
			var grpPtr = evtPtr.evtParams[0];
			var cpt;
			var bQuit = false;

			if ((grpPtr.grpFlags & PARAM_GROUP.GRPFLAGS_PARENTINACTIVE) == 0)
			{
				evgPtr.evgFlags &= ~CEventGroup.EVGFLAGS_INACTIVE;

				for (evg++, bQuit = false, cpt = 1; ;)
				{
					evgPtr = rhPtr.rhEvtProg.events[evg];
					evtPtr = evgPtr.evgEvents[0];
					switch (evtPtr.evtCode)
					{
						case ((-10 << 16) | 65535):
							grpPtr = evtPtr.evtParams[0];
							if (cpt == 1)
								grpPtr.grpFlags &= ~PARAM_GROUP.GRPFLAGS_PARENTINACTIVE;
							if ((grpPtr.grpFlags & PARAM_GROUP.GRPFLAGS_GROUPINACTIVE) == 0)
							{
								evg = this.grpActivate(rhPtr, evg);
								continue;
							}
							else
								cpt++;
							break;
						case ((-11 << 16) | 65535):
							cpt--;
							if (cpt == 0)
							{
								evgPtr.evgFlags &= ~CEventGroup.EVGFLAGS_INACTIVE;
								bQuit = true;
								evg++;
							}
							break;
						case ((-23 << 16) | 65535):
							if (cpt == 1)
							{
								evgPtr.evgFlags &= ~CEventGroup.EVGFLAGS_INACTIVE;
								evgPtr.evgFlags &= ~CEventGroup.EVGFLAGS_ONCE;
							}
							break;
					    case ((-42 << 16) | 65535):
					        evgPtr.evgFlags |= CEventGroup.EVGFLAGS_INACTIVE;
					        break;
					    default:
							if (cpt == 1)
								evgPtr.evgFlags &= ~CEventGroup.EVGFLAGS_INACTIVE;
							break;
					}
					if (bQuit)
						break;
					evg++;
				}
			}
			else
			{
				for (evg++, bQuit = false, cpt = 1; ; evg++)
				{
					evgPtr = rhPtr.rhEvtProg.events[evg];
					evtPtr = evgPtr.evgEvents[0];
					switch (evtPtr.evtCode)
					{
						case ((-10 << 16) | 65535):
							cpt++;
							break;
						case ((-11 << 16) | 65535):
							cpt--;
							if (cpt == 0)
							{
								bQuit = true;
								evg++;
							}
							break;
					    case ((-42 << 16) | 65535):
					        evgPtr.evgFlags |= CEventGroup.EVGFLAGS_INACTIVE;
					        break;
					}
					if (bQuit)
						break;
				}
			}
			return evg;
		}
	}
	// CUT

	function ACT_GRPDEACTIVATE()
	{
	}
	ACT_GRPDEACTIVATE.prototype =
	{
		execute:       function (rhPtr)
		{
			var p = this.evtParams[0];
			var evg = p.pointer;
			var evgPtr = rhPtr.rhEvtProg.events[evg];
			var evtPtr = evgPtr.evgEvents[0];

			var grpPtr = evtPtr.evtParams[0];
			var bFlag = (grpPtr.grpFlags & PARAM_GROUP.GRPFLAGS_GROUPINACTIVE) == 0;
			grpPtr.grpFlags |= PARAM_GROUP.GRPFLAGS_GROUPINACTIVE;

			if (bFlag == true && (grpPtr.grpFlags & PARAM_GROUP.GRPFLAGS_PARENTINACTIVE) == 0)
				this.grpDeactivate(rhPtr, evg);
		},
		grpDeactivate: function (rhPtr, evg)
		{
			var evgPtr = rhPtr.rhEvtProg.events[evg];
			var evtPtr = evgPtr.evgEvents[0];
			var grpPtr = evtPtr.evtParams[0];

			evgPtr.evgFlags |= CEventGroup.EVGFLAGS_INACTIVE;

			var cpt;
			var bQuit, bFlag;

			for (evg++, bQuit = false, cpt = 1; ;)
			{
				evgPtr = rhPtr.rhEvtProg.events[evg];
				evtPtr = evgPtr.evgEvents[0];
				switch (evtPtr.evtCode)
				{
					case ((-10 << 16) | 65535):
						grpPtr = evtPtr.evtParams[0];
						bFlag = (grpPtr.grpFlags & PARAM_GROUP.GRPFLAGS_PARENTINACTIVE) == 0;
						if (cpt == 1)
							grpPtr.grpFlags |= PARAM_GROUP.GRPFLAGS_PARENTINACTIVE;
						if (bFlag != false && (grpPtr.grpFlags & PARAM_GROUP.GRPFLAGS_GROUPINACTIVE) == 0)
						{
							evg = this.grpDeactivate(rhPtr, evg);
							continue;
						}
						else
							cpt++;
						break;
					case ((-11 << 16) | 65535):
						cpt--;
						if (cpt == 0)
						{
							evgPtr.evgFlags |= CEventGroup.EVGFLAGS_INACTIVE;
							bQuit = true;
							evg++;
						}
						break;
					default:
						if (cpt == 1)
							evgPtr.evgFlags |= CEventGroup.EVGFLAGS_INACTIVE;
						break;
				}
				if (bQuit)
					break;

				evg++;
			}
			return evg;
		}
	}
	// CUT

	function ACT_RANDOMIZE()
	{
	}
	ACT_RANDOMIZE.prototype =
	{
		execute: function (rhPtr)
		{
			var seed = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			rhPtr.rh3Graine = seed;
		}
	}
	// CUT

	function ACT_SETGLOBALSTRING()
	{
	}
	ACT_SETGLOBALSTRING.prototype =
	{
		execute: function (rhPtr)
		{
			var num;
			if (this.evtParams[0].code == 59)
				num = (rhPtr.get_EventExpressionInt(this.evtParams[0]) - 1);
			else
				num = this.evtParams[0].value;

			var string = rhPtr.get_EventExpressionString(this.evtParams[1]);
			rhPtr.rhApp.setGlobalStringAt(num, string);
		}
	}
	// CUT

	function ACT_SETLOOPINDEX()
	{
	}
	ACT_SETLOOPINDEX.prototype =
	{
		execute: function (rhPtr)
		{
			var expression = this.evtParams[0];
			if (expression.tokens[0].code == CExp.EXP_LONG && expression.tokens[1].code == 0)
			{
				var number = rhPtr.get_EventExpressionInt(this.evtParams[1]);
				var pLoop = rhPtr.rh4FastLoops.get(expression.tokens[0].value);
				pLoop.index = number;
			}
			else
			{
				var name = rhPtr.get_EventExpressionString(this.evtParams[0]);
				if (name.length == 0)
					return;
				var number = rhPtr.get_EventExpressionInt(this.evtParams[1]);

				var pLoop;
				var n;
				for (n = 0; n < rhPtr.rh4FastLoops.size(); n++)
				{
					pLoop = rhPtr.rh4FastLoops.get(n);
					if (CServices.compareStringsIgnoreCase(pLoop.name, name))
					{
						pLoop.index = number;
						return;
					}
				}
			}
		}
	}
	// CUT

	function ACT_SETVARG()
	{
	}
	ACT_SETVARG.prototype =
	{
		execute: function (rhPtr)
		{
			var num;
			if (this.evtParams[0].code == 52)
				num = (rhPtr.get_EventExpressionInt(this.evtParams[0]) - 1);
			else
				num = this.evtParams[0].value;

			var value = rhPtr.get_EventExpressionAny(this.evtParams[1]);
			rhPtr.rhApp.setGlobalValueAt(num, value);
		}
	}
	// -- CUT

	function ACT_SETVARGCONST()
	{
	}
	ACT_SETVARGCONST.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhApp.setGlobalValueAt(this.num, this.value);
		}
	}
	// CUT

	function ACT_STOPLOOP()
	{
	}
	ACT_STOPLOOP.prototype =
	{
		execute: function (rhPtr)
		{
			var expression = this.evtParams[0];
			if (expression.tokens[0].code == CExp.EXP_LONG && expression.tokens[1].code == 0)
			{
				var pLoop = rhPtr.rh4FastLoops.get(expression.tokens[0].value);
				pLoop.flags |= CLoop.FLFLAG_STOP;
			}
			else
			{
				var name = rhPtr.get_EventExpressionString(this.evtParams[0]);
				if (name.length == 0)
					return;

				var pLoop;
				var n;
				for (n = 0; n < rhPtr.rh4FastLoops.size(); n++)
				{
					pLoop = rhPtr.rh4FastLoops.get(n);
					if (CServices.compareStringsIgnoreCase(pLoop.name, name))
						pLoop.flags |= CLoop.FLFLAG_STOP;
				}
			}
		}
	}
	// CUT

	function ACT_SUBVARG()
	{
	}
	ACT_SUBVARG.prototype =
	{
		execute: function (rhPtr)
		{
			var num;
			if (this.evtParams[0].code == 52)
				num = (rhPtr.get_EventExpressionInt(this.evtParams[0]) - 1);
			else
				num = this.evtParams[0].value;

			var value = rhPtr.get_EventExpressionAny(this.evtParams[1]);
			rhPtr.rhApp.addGlobalValueAt(num, -value);
		}
	}
	// -- CUT

	function ACT_SUBVARGCONST()
	{
	}
	ACT_SUBVARGCONST.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhApp.addGlobalValueAt(this.num, -this.value);
		}
	}
	// CUT

	function ACT_STARTLOOP()
	{
	}
	ACT_STARTLOOP.prototype =
	{
		execute: function (rhPtr)
	    {
	        var gotNameExp = false;
			var name;
			var number;

			// Accelerated handling
			if (rhPtr.rhEvtProg.complexOnLoop == false && rhPtr.rh4PosOnLoop != null)
	        {
	            var loopNumber = this.evtParams[0].fastFastLoop;
	            if (loopNumber == 0)
	            {
	                name = rhPtr.get_EventExpressionString(this.evtParams[0]);
	                gotNameExp = true;
	                if (name.length != 0)
	                {
	                    var nOnLoop;
	                    for (nOnLoop = 0; nOnLoop < rhPtr.rh4PosOnLoop.length; nOnLoop++)
	                    {
	                        if (CServices.compareStringsIgnoreCase(name, rhPtr.rh4PosOnLoop[nOnLoop].name))
	                            { loopNumber = nOnLoop + 1; break; }
	                    }
	                }
	            }

	            if (loopNumber != 0)
	            {
	                var infoLoop = rhPtr.rh4PosOnLoop[loopNumber - 1];
				    if (infoLoop.m_bOR == false)
				    {
					    //name = infoLoop.name;
					    number = Math.floor(rhPtr.get_EventExpressionInt(this.evtParams[1]));

					    var pLoop = rhPtr.rh4FastLoops.get(infoLoop.fastLoopIndex);
					    pLoop.flags &= ~CLoop.FLFLAG_STOP;

					    var bInfinite = false;
					    if (number < 0)
					    {
						    bInfinite = true;
						    number = 10;
					    }
					    var save = rhPtr.rh4CurrentFastLoop;
					    var actionLoop = rhPtr.rhEvtProg.rh2ActionLoop;
					    var actionLoopCount = rhPtr.rhEvtProg.rh2ActionLoopCount;
					    var eventGroup = rhPtr.rhEvtProg.rhEventGroup;
					    for (pLoop.index = 0; pLoop.index < number; pLoop.index++)
					    {
						    rhPtr.rh4CurrentFastLoop = pLoop.name;
						    rhPtr.rhEvtProg.rh2ActionOn = false;
						    rhPtr.rhEvtProg.computeEventFastLoopList(infoLoop.pointers);
						    if ((pLoop.flags & CLoop.FLFLAG_STOP) != 0)
							    break;
						    if (bInfinite)
							    number = pLoop.index + 10;
					    }
					    rhPtr.rhEvtProg.rh2ActionLoopCount = actionLoopCount;
					    rhPtr.rhEvtProg.rh2ActionLoop = actionLoop;
					    rhPtr.rh4CurrentFastLoop = save;
					    rhPtr.rhEvtProg.rh2ActionOn = true;

	    //				rhPtr.rh4FastLoops.removeIndex(index);
					    return;
	                }
	            }
			}

			// Normal handling
	        if ( !gotNameExp )
	            name = rhPtr.get_EventExpressionString(this.evtParams[0]);
			if (name.length == 0)
				return;
			number = Math.floor(rhPtr.get_EventExpressionInt(this.evtParams[1]));

			var index = rhPtr.addFastLoop(name);
			var pLoop = rhPtr.rh4FastLoops.get(index);
			pLoop = rhPtr.rh4FastLoops.get(index);
			pLoop.flags &= ~CLoop.FLFLAG_STOP;

			var bInfinite = false;
			if (number < 0)
			{
				bInfinite = true;
				number = 10;
			}
			var save = rhPtr.rh4CurrentFastLoop;
			var actionLoop = rhPtr.rhEvtProg.rh2ActionLoop;
			var actionLoopCount = rhPtr.rhEvtProg.rh2ActionLoopCount;
			var eventGroup = rhPtr.rhEvtProg.rhEventGroup;
			for (pLoop.index = 0; pLoop.index < number; pLoop.index++)
			{
				rhPtr.rh4CurrentFastLoop = pLoop.name;
				rhPtr.rhEvtProg.rh2ActionOn = false;
				rhPtr.rhEvtProg.handle_GlobalEvents(((-16 << 16) | 65535));
				if ((pLoop.flags & CLoop.FLFLAG_STOP) != 0)
					break;
				if (bInfinite)
					number = pLoop.index + 10;
			}
			//			rhPtr.rhEvtProg.rhEventGroup=eventGroup;
			rhPtr.rhEvtProg.rh2ActionLoopCount = actionLoopCount;
			rhPtr.rhEvtProg.rh2ActionLoop = actionLoop;
			rhPtr.rh4CurrentFastLoop = save;
			rhPtr.rhEvtProg.rh2ActionOn = true;

			//rhPtr.rh4FastLoops.removeIndex(index);
		}
	}
	// CUT

	function ACT_EXECUTECHILDEVENTS() {
	}
	ACT_EXECUTECHILDEVENTS.prototype =
	{
	    execute: function (rhPtr) {
	        rhPtr.rhEvtProg.childEventParam = this.evtParams[0];
	    }
	}
	// CUT


	// Keyboard object
	// ------------------------------------------------------------------
	function ACT_HIDECURSOR()
	{
	}
	ACT_HIDECURSOR.prototype =
	{
		execute: function (rhPtr)
		{
			if (rhPtr.rhMouseUsed == 0)
				rhPtr.hideMouse();
		}
	}
	// CUT

	function ACT_SHOWCURSOR()
	{
	}
	ACT_SHOWCURSOR.prototype =
	{
		execute: function (rhPtr)
		{
			if (rhPtr.rhMouseUsed == 0)
				rhPtr.showMouse();
		}
	}
	// CUT

	// Speaker object
	// ------------------------------------------------------------------
	function ACT_LOCKCHANNEL()
	{
	}
	ACT_LOCKCHANNEL.prototype =
	{
		execute: function (rhPtr)
		{
			var channel = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			rhPtr.rhApp.soundPlayer.lockChannel(channel - 1);
		}
	}
	// CUT

	function ACT_PAUSEALLCHANNELS()
	{
	}
	ACT_PAUSEALLCHANNELS.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhApp.soundPlayer.pause();
		}
	}
	// CUT

	function ACT_PAUSECHANNEL()
	{
	}
	ACT_PAUSECHANNEL.prototype =
	{
		execute: function (rhPtr)
		{
			var channel = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			rhPtr.rhApp.soundPlayer.pauseChannel(channel - 1);
		}
	}
	// CUT

	function ACT_PAUSESAMPLE()
	{
	}
	ACT_PAUSESAMPLE.prototype =
	{
		execute: function (rhPtr)
		{
			var p = this.evtParams[0];
			var nSound = -1;
		    // PARAM_EXPSTRING?
			if (p.code == 45) {
			    var name = rhPtr.get_EventExpressionString(p);
			    nSound = rhPtr.rhApp.soundBank.getSoundHandleFromName(name);
			}
			else {
			    nSound = p.sndHandle;
			}
			if (nSound >= 0)
			    rhPtr.rhApp.soundPlayer.pauseSample(nSound);
		}
	}
	// CUT

	function ACT_PLAYCHANNEL()
	{
	}
	ACT_PLAYCHANNEL.prototype =
	{
		execute: function (rhPtr)
		{
			var p = this.evtParams[0];
			var channel = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			var bPrio = false;
			var nSound = -1;
		    // PARAM_EXPSTRING?
			if (p.code == 45) {
			    var name = rhPtr.get_EventExpressionString(p);
			    nSound = rhPtr.rhApp.soundBank.getSoundHandleFromName(name);
			}
			else {
			    bPrio = (p.sndFlags & PARAM_SAMPLE.PSOUNDFLAG_UNINTERRUPTABLE) != 0;
			    nSound = p.sndHandle;
			}
			if (nSound >= 0)
			    rhPtr.rhApp.soundPlayer.play(nSound, 1, channel - 1, bPrio, -1, 0);
		}
	}
	// CUT

	function ACT_PLAYLOOPCHANNEL()
	{
	}
	ACT_PLAYLOOPCHANNEL.prototype =
	{
		execute: function (rhPtr)
		{
			var p = this.evtParams[0];
			var bPrio = false;
			var nSound = -1;
		    // PARAM_EXPSTRING?
			if (p.code == 45) {
			    var name = rhPtr.get_EventExpressionString(p);
			    nSound = rhPtr.rhApp.soundBank.getSoundHandleFromName(name);
			}
			else {
			    bPrio = (p.sndFlags & PARAM_SAMPLE.PSOUNDFLAG_UNINTERRUPTABLE) != 0;
			    nSound = p.sndHandle;
			}
			var channel = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			var nLoops = rhPtr.get_EventExpressionInt(this.evtParams[2]);
			if (nSound >= 0)
	            rhPtr.rhApp.soundPlayer.play(nSound, nLoops, channel - 1, bPrio, -1, 0);
		}
	}
	// CUT

	function ACT_PLAYLOOPSAMPLE()
	{
	}
	ACT_PLAYLOOPSAMPLE.prototype =
	{
		execute: function (rhPtr)
		{
			var p = this.evtParams[0];
			var nLoops = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			var bPrio = false;
			var nSound = -1;
		    // PARAM_EXPSTRING?
			if (p.code == 45) {
			    var name = rhPtr.get_EventExpressionString(p);
			    nSound = rhPtr.rhApp.soundBank.getSoundHandleFromName(name);
			}
			else {
			    bPrio = (p.sndFlags & PARAM_SAMPLE.PSOUNDFLAG_UNINTERRUPTABLE) != 0;
			    nSound = p.sndHandle;
			}
			if (nSound >= 0)
	            rhPtr.rhApp.soundPlayer.play(nSound, nLoops, -1, bPrio, -1, 0);
		}
	}
	// CUT

	function ACT_PLAYSAMPLE()
	{
	}
	ACT_PLAYSAMPLE.prototype =
	{
		execute: function (rhPtr)
		{
		    var p = this.evtParams[0];
		    var bPrio = false;
		    var nSound = -1;
		    // PARAM_EXPSTRING?
		    if (p.code == 45) {
		        var name = rhPtr.get_EventExpressionString(p);
		        nSound = rhPtr.rhApp.soundBank.getSoundHandleFromName(name);
		    }
		    else {
		        bPrio = (p.sndFlags & PARAM_SAMPLE.PSOUNDFLAG_UNINTERRUPTABLE) != 0;
		        nSound = p.sndHandle;
		    }
	        if (nSound >= 0)
	            rhPtr.rhApp.soundPlayer.play(nSound, 1, -1, bPrio, -1, 0);
		}
	}
	// CUT

	function ACT_PLAYSAMPLE2() {
	}
	ACT_PLAYSAMPLE2.prototype =
	    {
	        execute: function (rhPtr) {
	            var p = this.evtParams[0];
	            var bPrio = false;
	            var nSound = -1;
	            // PARAM_EXPSTRING?
	            if (p.code == 45) {
	                var name = rhPtr.get_EventExpressionString(p);
	                nSound = rhPtr.rhApp.soundBank.getSoundHandleFromName(name);
	            }
	            else {
	                bPrio = (p.sndFlags & PARAM_SAMPLE.PSOUNDFLAG_UNINTERRUPTABLE) != 0;
	                nSound = p.sndHandle;
	            }
	            if (nSound >= 0) {

	                // Get all params
	                var channel = rhPtr.get_EventExpressionInt(this.evtParams[1]);
	                var nLoops = rhPtr.get_EventExpressionInt(this.evtParams[2]);
	                var nVolume = rhPtr.get_EventExpressionInt(this.evtParams[3]);
	                //var pan = rhPtr.get_EventExpressionInt(this.evtParams[4]);  // not modifiable in this runtime
	                var freq = rhPtr.get_EventExpressionInt(this.evtParams[5]);
	                rhPtr.rhApp.soundPlayer.play(nSound, nLoops, channel - 1, bPrio, nVolume, freq);
	            }
	        }
	    }
	// CUT

	function ACT_RESUMEALLCHANNELS()
	{
	}
	ACT_RESUMEALLCHANNELS.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhApp.soundPlayer.resume();
		}
	}
	// CUT

	function ACT_RESUMECHANNEL()
	{
	}
	ACT_RESUMECHANNEL.prototype =
	{
		execute: function (rhPtr)
		{
			var channel = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			rhPtr.rhApp.soundPlayer.resumeChannel(channel - 1);
		}
	}
	// CUT

	function ACT_RESUMESAMPLE()
	{
	}
	ACT_RESUMESAMPLE.prototype =
	{
		execute: function (rhPtr)
		{
			var p = this.evtParams[0];
			var nSound = -1;
		    // PARAM_EXPSTRING?
			if (p.code == 45) {
			    var name = rhPtr.get_EventExpressionString(p);
			    nSound = rhPtr.rhApp.soundBank.getSoundHandleFromName(name);
			}
			else {
			    nSound = p.sndHandle;
			}
			if (nSound >= 0)
			    rhPtr.rhApp.soundPlayer.resumeSample(nSound);
		}
	}
	// CUT

	function ACT_SETCHANNELPOS()
	{
	}
	ACT_SETCHANNELPOS.prototype =
	{
		execute: function (rhPtr)
		{
			var channel = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			var position = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			if (position >= 0)
				rhPtr.rhApp.soundPlayer.setPositionChannel(channel - 1, position);
		}
	}
	// CUT

	function ACT_SETCHANNELFREQ()
	{
	}
	ACT_SETCHANNELFREQ.prototype =
	{
		execute: function (rhPtr)
		{
			var channel = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			var freq = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			if (freq >= 0)
				rhPtr.rhApp.soundPlayer.setFrequencyChannel(channel - 1, freq);
		}
	}
	// CUT

	function ACT_SETCHANNELVOL()
	{
	}
	ACT_SETCHANNELVOL.prototype =
	{
		execute: function (rhPtr)
		{
			var channel = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			var volume = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			if (volume >= 0 && volume <= 100)
				rhPtr.rhApp.soundPlayer.setVolumeChannel(channel - 1, volume);
		}
	}
	// CUT

	function ACT_SETSAMPLEMAINVOL()
	{
	}
	ACT_SETSAMPLEMAINVOL.prototype =
	{
		execute: function (rhPtr)
		{
			var volume = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			if (volume >= 0 && volume <= 100)
				rhPtr.rhApp.soundPlayer.setMainVolume(volume);
		}
	}
	// CUT

	function ACT_SETSAMPLEPOS()
	{
	}
	ACT_SETSAMPLEPOS.prototype =
	{
		execute: function (rhPtr)
		{
			var p = this.evtParams[0];
			var nSound = -1;
		    // PARAM_EXPSTRING?
			if (p.code == 45) {
			    var name = rhPtr.get_EventExpressionString(p);
			    nSound = rhPtr.rhApp.soundBank.getSoundHandleFromName(name);
			}
			else {
			    nSound = p.sndHandle;
			}
		    var position = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			if (nSound >= 0 && position >= 0)
				rhPtr.rhApp.soundPlayer.setPositionSample(nSound, position);
		}
	}
	// CUT

	function ACT_SETSAMPLEFREQ()
	{
	}
	ACT_SETSAMPLEFREQ.prototype =
	{
		execute: function (rhPtr)
		{
		    var p = this.evtParams[0];
		    var nSound = -1;
		    // PARAM_EXPSTRING?
		    if (p.code == 45) {
		        var name = rhPtr.get_EventExpressionString(p);
		        nSound = rhPtr.rhApp.soundBank.getSoundHandleFromName(name);
		    }
		    else {
		        nSound = p.sndHandle;
		    }
		    var freq = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			if (nSound >= 0 && freq >= 0)
				rhPtr.rhApp.soundPlayer.setFrequencySample(nSound, freq);
		}
	}
	// CUT

	function ACT_SETSAMPLEVOL()
	{
	}
	ACT_SETSAMPLEVOL.prototype =
	{
		execute: function (rhPtr)
		{
		    var p = this.evtParams[0];
		    var nSound = -1;
		    // PARAM_EXPSTRING?
		    if (p.code == 45) {
		        var name = rhPtr.get_EventExpressionString(p);
		        nSound = rhPtr.rhApp.soundBank.getSoundHandleFromName(name);
		    }
		    else {
		        nSound = p.sndHandle;
		    }
		    var volume = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			if (nSound >= 0 && volume >= 0 && volume <= 100)
				rhPtr.rhApp.soundPlayer.setVolumeSample(nSound, volume);
		}
	}
	// CUT

	function ACT_STOPCHANNEL()
	{
	}
	ACT_STOPCHANNEL.prototype =
	{
		execute: function (rhPtr)
		{
			var channel = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			rhPtr.rhApp.soundPlayer.stopChannel(channel - 1);
		}
	}
	// CUT

	function ACT_STOPSAMPLE()
	{
	}
	ACT_STOPSAMPLE.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhApp.soundPlayer.stopAllSounds();
		}
	}
	// CUT

	function ACT_STOPSPESAMPLE()
	{
	}
	ACT_STOPSPESAMPLE.prototype =
	{
		execute: function (rhPtr)
		{
			var p = this.evtParams[0];
			var nSound = -1;
		    // PARAM_EXPSTRING?
			if (p.code == 45) {
			    var name = rhPtr.get_EventExpressionString(p);
			    nSound = rhPtr.rhApp.soundBank.getSoundHandleFromName(name);
			}
			else {
			    nSound = p.sndHandle;
			}
			if ( nSound >= 0 )
			    rhPtr.rhApp.soundPlayer.stopSample(nSound);
		}
	}
	// CUT

	function ACT_UNLOCKCHANNEL()
	{
	}
	ACT_UNLOCKCHANNEL.prototype =
	{
		execute: function (rhPtr)
		{
			var channel = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			rhPtr.rhApp.soundPlayer.unlockChannel(channel - 1);
		}
	}
	// CUT

	// String object
	// ------------------------------------------------------------------
	function ACT_STRDESTROY()
	{
	}
	ACT_STRDESTROY.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo != null)
			{
				if ((pHo.rsHidden & CRun.COF_FIRSTTEXT) != 0)
				{
					pHo.ros.obHide();
					pHo.ros.rsFlags &= ~CRSpr.RSFLAG_VISIBLE;
					pHo.hoFlags |= CObject.HOF_NOCOLLISION;
				}
				else
				{
					pHo.hoFlags |= CObject.HOF_DESTROYED;
					rhPtr.destroy_Add(pHo.hoNumber);
				}
			}
		}
	}
	// CUT

	function ACT_STRDISPLAY()
	{
	}
	ACT_STRDISPLAY.prototype =
	{
		execute: function (rhPtr)
		{
			var p = this.evtParams[1];
			rhPtr.txtDoDisplay(this, p.value);
		}
	}
	// CUT

	function ACT_STRDISPLAYDURING()
	{
	}
	ACT_STRDISPLAYDURING.prototype =
	{
		execute: function (rhPtr)
		{
			var p = this.evtParams[1];
			var num = rhPtr.txtDoDisplay(this, p.value);
			if (num >= 0)
			{
				var p2 = this.evtParams[2];
				var hoPtr = rhPtr.rhObjectList[num];
				if (p2.code == 2)        // PARAM_TIME
				{
					hoPtr.ros.rsFlash = p2.timer;
					hoPtr.ros.rsFlashCpt = p2.timer;
				}
				else
				{
					hoPtr.ros.rsFlash = rhPtr.get_EventExpressionInt(p2);
					hoPtr.ros.rsFlashCpt = hoPtr.ros.rsFlash;
				}
			}
		}
	}
	// CUT

	function ACT_STRDISPLAYSTRING()
	{
	}
	ACT_STRDISPLAYSTRING.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo != null)
			{
				pHo.txtChange(-1);
			}
		}
	}
	// CUT

	function ACT_STRNEXT()
	{
	}
	ACT_STRNEXT.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo != null)
			{
				var num = pHo.rsMini + 1;
				pHo.txtChange(num);
			}
		}
	}
	// CUT

	function ACT_STRPREV()
	{
	}
	ACT_STRPREV.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo != null)
			{
				var num = pHo.rsMini - 1;
				if (num < 0)
					num = 0;
				pHo.txtChange(num);
			}
		}
	}
	// CUT

	function ACT_STRSET()
	{
	}
	ACT_STRSET.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo != null)
			{
				var text;
				if (this.evtParams[0].code == 31)
					text = this.evtParams[0].value;
				else
					text = rhPtr.get_EventExpressionInt(this.evtParams[0]) - 1;
				pHo.txtChange(text)
			}
		}
	}
	// CUT

	function ACT_STRSETCOLOUR()
	{
	}
	ACT_STRSETCOLOUR.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo != null)
			{
				var color;
				if (this.evtParams[0].code == 24)
					color = this.evtParams[0].color;
				else
				{
					color = rhPtr.get_EventExpressionInt(this.evtParams[0]);
					color = CServices.swapRGB(color);
				}
				CRun.setObjectTextColor(pHo, color);
			}
		}
	}
	// CUT

	function ACT_STRSETSTRING()
	{
	}
	ACT_STRSETSTRING.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo != null)
			{
				var text = rhPtr.get_EventExpressionString(this.evtParams[0]);
				if (pHo.rsTextBuffer == null || (pHo.rsTextBuffer != null && text != pHo.rsTextBuffer))
				{
					pHo.txtSetString(text);
					pHo.txtChange(-1);
				}
			}
		}
	}
	// CUT

	// Counter object
	// ------------------------------------------------------------------
	function ACT_CADDVALUE()
	{
	}
	ACT_CADDVALUE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			var pValue = rhPtr.get_EventExpressionAny(this.evtParams[0]);
			pHo.cpt_Add(pValue);
		}
	}
	// CUT

	function ACT_CSETCOLOR1()
	{
	}
	ACT_CSETCOLOR1.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var color;
			if (this.evtParams[0].code == CParam.PARAM_EXPRESSIONNUM)
			{
				color = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				color = CServices.swapRGB(color);
			}
			else
				color = this.evtParams[0].color;

			pHo.cpt_SetColor1(color);
		}
	}
	// CUT

	function ACT_CSETCOLOR2()
	{
	}
	ACT_CSETCOLOR2.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var color;
			if (this.evtParams[0].code == CParam.PARAM_EXPRESSIONNUM)
			{
				color = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				color = CServices.swapRGB(color);
			}
			else
				color = this.evtParams[0].color;

			pHo.cpt_SetColor2(color);
		}
	}
	// CUT

	function ACT_CSETMAX()
	{
	}
	ACT_CSETMAX.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var pValue = rhPtr.get_EventExpressionAny(this.evtParams[0]);
			pHo.cpt_SetMax(pValue);
		}
	}
	// CUT

	function ACT_CSETMIN()
	{
	}
	ACT_CSETMIN.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var pValue = rhPtr.get_EventExpressionAny(this.evtParams[0]);
			pHo.cpt_SetMin(pValue);
		}
	}
	// CUT

	function ACT_CSETVALUE()
	{
	}
	ACT_CSETVALUE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var pValue = rhPtr.get_EventExpressionAny(this.evtParams[0]);
			pHo.cpt_ToFloat(pValue);
			pHo.cpt_Change(pValue);
		}
	}
	// CUT

	function ACT_CSUBVALUE()
	{
	}
	ACT_CSUBVALUE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var pValue = rhPtr.get_EventExpressionAny(this.evtParams[0]);
			pHo.cpt_Sub(pValue);
		}
	}
	// CUT

	// Sub-application object
	// ------------------------------------------------------------------
	function ACT_CCAENDAPP()
	{
	}
	ACT_CCAENDAPP.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			pHo.endApp();
		}
	}
	// CUT

	function ACT_CCAHIDE()
	{
	}
	ACT_CCAHIDE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			pHo.hide();
		}
	}
	// CUT

	function ACT_CCAJUMPFRAME()
	{
	}
	ACT_CCAJUMPFRAME.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var frame = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			pHo.jumpFrame(frame);
		}
	}
	// CUT

	function ACT_CCANEXTFRAME()
	{
	}
	ACT_CCANEXTFRAME.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			pHo.nextFrame();
		}
	}
	// CUT

	function ACT_CCAPAUSEAPP()
	{
	}
	ACT_CCAPAUSEAPP.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			pHo.pause();
		}
	}
	// CUT

	function ACT_CCAPREVIOUSFRAME()
	{
	}
	ACT_CCAPREVIOUSFRAME.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			pHo.previousFrame();
		}
	}
	// CUT

	function ACT_CCARESTARTAPP()
	{
	}
	ACT_CCARESTARTAPP.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			pHo.restartApp();
		}
	}
	// CUT

	function ACT_CCARESTARTFRAME()
	{
	}
	ACT_CCARESTARTFRAME.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			pHo.restartFrame();
		}
	}
	// CUT

	function ACT_CCARESUMEAPP()
	{
	}
	ACT_CCARESUMEAPP.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			pHo.resume();
		}
	}
	// CUT

	function ACT_CCASETWIDTH()
	{
	}
	ACT_CCASETWIDTH.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			var width = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			pHo.setWidth(width);
		}
	}
	// CUT

	function ACT_CCASETHEIGHT()
	{
	}
	ACT_CCASETHEIGHT.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			var height = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			pHo.setHeight(height);
		}
	}
	// CUT

	function ACT_CCASETGLOBALSTRING()
	{
	}
	ACT_CCASETGLOBALSTRING.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var number = rhPtr.get_EventExpressionInt(this.evtParams[0]) - 1;
			var s = rhPtr.get_EventExpressionString(this.evtParams[1]);

			pHo.setGlobalString(number, s);
		}
	}
	// CUT

	function ACT_CCASETGLOBALVALUE()
	{
	}
	ACT_CCASETGLOBALVALUE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var number = rhPtr.get_EventExpressionInt(this.evtParams[0]) - 1;
			var value = rhPtr.get_EventExpressionAny(this.evtParams[1]);

			pHo.setGlobalValue(number, value);
		}
	}
	// CUT

	function ACT_CCASHOW()
	{
	}
	ACT_CCASHOW.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			pHo.show();
		}
	}
	// CUT


	// Player object
	// ------------------------------------------------------------------
	function ACT_ADDLIVES()
	{
	}
	ACT_ADDLIVES.prototype =
	{
		execute: function (rhPtr)
		{
			var value = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			var joueur = this.evtOi;
			value = rhPtr.rhApp.getLives()[joueur] + value;
			rhPtr.actPla_FinishLives(joueur, value);
		}
	}
	// CUT

	function ACT_NOINPUT()
	{
	}
	ACT_NOINPUT.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rh2InputMask[this.evtOi] = 0;
		}
	}
	// CUT

	function ACT_RESTINPUT()
	{
	}
	ACT_RESTINPUT.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rh2InputMask[this.evtOi] = 0xFF;
		}
	}
	// CUT

	function ACT_SETINPUT()
	{
	}
	ACT_SETINPUT.prototype =
	{
		execute: function (rhPtr)
		{
			var input = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			if (input > CRunApp.CTRLTYPE_KEYBOARD)
				return;
			if (input == CRunApp.CTRLTYPE_MOUSE)
				input = CRunApp.CTRLTYPE_KEYBOARD;
			var joueur = this.evtOi;
			if (joueur >= 4)
				return;
			rhPtr.rhApp.getCtrlType()[joueur] = input;

		}
	}
	// CUT

	function ACT_SETINPUTKEY()
	{
	}
	ACT_SETINPUTKEY.prototype =
	{
		execute: function (rhPtr)
		{
			var touche = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			if (touche >= 8)
				return;
			var joueur = this.evtOi;
			if (joueur >= 4)
				return;
			var key = this.evtParams[1].key;
			rhPtr.rhApp.pcCtrlKeys[joueur * CRunApp.MAX_KEY + touche] = key;
		}
	}
	// CUT

	function ACT_SETLIVES()
	{
	}
	ACT_SETLIVES.prototype =
	{
		execute: function (rhPtr)
		{
			var value = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			var joueur = this.evtOi;
			rhPtr.actPla_FinishLives(joueur, value);
		}
	}
	// CUT

	function ACT_SETPLAYERNAME()
	{
	}
	ACT_SETPLAYERNAME.prototype =
	{
		execute: function (rhPtr)
		{
			var joueur = this.evtOi;
			if (joueur >= CRunApp.MAX_PLAYER)
				return;
			var pString = rhPtr.get_EventExpressionString(this.evtParams[0]);
			rhPtr.rhApp.playerNames[joueur] = pString;
		}
	}
	// CUT

	function ACT_SETSCORE()
	{
	}
	ACT_SETSCORE.prototype =
	{
		execute: function (rhPtr)
		{
			var value = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			var joueur = this.evtOi;
			var scores = rhPtr.rhApp.getScores();
			scores[joueur] = value;

			rhPtr.update_PlayerObjects(joueur, COI.OBJ_SCORE, scores[joueur]);
		}
	}

	function ACT_SUBLIVES()
	{
	}
	ACT_SUBLIVES.prototype =
	{
		execute: function (rhPtr)
		{
			var value = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			var joueur = this.evtOi;
			value = rhPtr.rhApp.getLives()[joueur] - value;
			rhPtr.actPla_FinishLives(joueur, value);
		}
	}
	// CUT

	function ACT_SUBSCORE()
	{
	}
	ACT_SUBSCORE.prototype =
	{
		execute: function (rhPtr)
		{
			var value = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			var joueur = this.evtOi;
			var scores = rhPtr.rhApp.getScores();
			scores[joueur] -= value;
			if (scores[joueur] < 0)
			    scores[joueur] = 0;
			rhPtr.update_PlayerObjects(joueur, COI.OBJ_SCORE, scores[joueur]);
		}
	}
	// CUT

	function ACT_ADDSCORE()
	{
	}
	ACT_ADDSCORE.prototype =
	{
		execute: function (rhPtr)
		{
			var value = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			var joueur = this.evtOi;
			var scores = rhPtr.rhApp.getScores();
			scores[joueur] += value;
			rhPtr.update_PlayerObjects(joueur, COI.OBJ_SCORE, scores[joueur]);
		}
	}
	// CUT


	// Timer object
	// -------------------------------------------------------------------
	function ACT_EVENTAFTER()
	{
	}
	ACT_EVENTAFTER.prototype =
	{
		execute: function (rhPtr)
		{
			var timer;
			if (this.evtParams[0].code == 22)
				timer = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			else
				timer = this.evtParams[0].timer;
			var pName = rhPtr.get_EventExpressionString(this.evtParams[1]);

			var pLoop = rhPtr.rh4TimerEvents;
			var pPrevious = null;
			while (pLoop != null)
			{
				pPrevious = pLoop;
				pLoop = pLoop.next;
			}
			var pEvent = new TimerEvents();
			if (pPrevious == null)
				rhPtr.rh4TimerEvents = pEvent;
			else
				pPrevious.next = pEvent;
			pEvent.type = TimerEvents.TIMEREVENTTYPE_ONESHOT;
			pEvent.timer = rhPtr.rhTimer + timer;
			pEvent.name = pName;
			pEvent.next = null;
		}
	}
	// CUT

	function ACT_NEVENTSAFTER()
	{
	}
	ACT_NEVENTSAFTER.prototype =
	{
		execute: function (rhPtr)
		{
			var timer;
			if (this.evtParams[0].code == 22)
				timer = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			else
				timer = this.evtParams[0].timer;
			var loops = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			var timerNext;
			if (this.evtParams[2].code == 22)
				timerNext = rhPtr.get_EventExpressionInt(this.evtParams[2]);
			else
				timerNext = this.evtParams[2].timer;
			var pName = rhPtr.get_EventExpressionString(this.evtParams[3]);

			var pLoop = rhPtr.rh4TimerEvents;
			var pPrevious = null;
			while (pLoop != null)
			{
				pPrevious = pLoop;
				pLoop = pLoop.next;
			}
			var pEvent = new TimerEvents();
			if (pPrevious == null)
				rhPtr.rh4TimerEvents = pEvent;
			else
				pPrevious.next = pEvent;
			pEvent.type = TimerEvents.TIMEREVENTTYPE_REPEAT;
			pEvent.timer = rhPtr.rhTimer + timer;
			pEvent.timerNext = timerNext;
			pEvent.timerPosition = 0;
			pEvent.loops = loops;
			pEvent.index = 0;
			pEvent.next = null;
			pEvent.name = pName;
		}
	}
	// CUT

	function ACT_SETTIMER()
	{
	}
	ACT_SETTIMER.prototype =
	{
		execute: function (rhPtr)
		{
			var newTime;
			if (this.evtParams[0].code == 22)
				newTime = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			else
				newTime = this.evtParams[0].timer;

			var time = rhPtr.rhApp.timer;
			rhPtr.rhTimer = newTime;
			rhPtr.rhTimerOld = time - rhPtr.rhTimer;

			rhPtr.rhEvtProg.restartTimerEvents();
		}
	}
	// CUT

	// Storyboard object
	// -------------------------------------------------------------------
	function ACT_CDISPLAY()
	{
	}
	ACT_CDISPLAY.prototype =
	{
		execute: function (rhPtr)
		{
			var position = this.evtParams[0];
			var pInfo = new CPositionInfo();
			position.read_Position(rhPtr, 0, pInfo);
			rhPtr.setDisplay(pInfo.x, pInfo.y, pInfo.layer, 3);
		}
	}
	// CUT

	function ACT_CDISPLAYX()
	{
	}
	ACT_CDISPLAYX.prototype =
	{
		execute: function (rhPtr)
		{
			var x = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			rhPtr.setDisplay(x, 0, -1, 1);
		}
	}
	// CUT

	function ACT_CDISPLAYY()
	{
	}
	ACT_CDISPLAYY.prototype =
	{
		execute: function (rhPtr)
		{
			var y = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			rhPtr.setDisplay(0, y, -1, 2);
		}
	}
	// CUT

	function ACT_SETFRAMEBDKCOLOR()
	{
	}
	ACT_SETFRAMEBDKCOLOR.prototype =
	{
		execute: function (rhPtr)
		{
			var color;
			if (this.evtParams[0].code == 24)		// PARAM_COLOUR
				color = this.evtParams[0].color;
			else
			{
				color = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				color = CServices.swapRGB(color);
			}
			rhPtr.rhFrame.leBackground = color;
			rhPtr.rhApp.frameColor = color;
		}
	}
	// CUT

	function ACT_CDISPLAYY()
	{
	}
	ACT_CDISPLAYY.prototype =
	{
		execute: function (rhPtr)
		{
			var y = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			rhPtr.setDisplay(0, y, -1, 2);
		}
	}
	// CUT

	function ACT_DELALLCREATEDBKD()
	{
	}
	ACT_DELALLCREATEDBKD.prototype =
	{
		execute: function (rhPtr)
		{
			var layer = rhPtr.get_EventExpressionInt(this.evtParams[0]) - 1;
			rhPtr.deleteAllBackdrop2(layer);
		}
	}
	// CUT

	function ACT_DELCREATEDBKDAT()
	{
	}
	ACT_DELCREATEDBKDAT.prototype =
	{
		execute: function (rhPtr)
		{
			var layer = rhPtr.get_EventExpressionInt(this.evtParams[0]) - 1;
			var x = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			var y = rhPtr.get_EventExpressionInt(this.evtParams[2]);
			var bFineDetection = rhPtr.get_EventExpressionInt(this.evtParams[3]) != 0;

			rhPtr.deleteBackdropAt(layer, x, y, bFineDetection);
		}
	}
	// CUT

	function ACT_ENDGAME()
	{
	}
	ACT_ENDGAME.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhApp.subAppStopped = true;			

			if (rhPtr.rhApp.isSubApp && !rhPtr.rhApp.isPreloaderSubApp) {
		        rhPtr.rhQuit = CRun.LOOPEXIT_ENDGAME;
			}
		}
	}
	// CUT

	function ACT_GOLEVEL()
	{
	}
	ACT_GOLEVEL.prototype =
	{
		execute: function (rhPtr)
		{
			var level;
			if (this.evtParams[0].code == 26)
			{
				level = this.evtParams[0].value;
				if (rhPtr.rhApp.HCellToNCell(level) == -1)
					return;
			}
			else
			{
				level = rhPtr.get_EventExpressionInt(this.evtParams[0]) - 1;
				if (level < 0 || level >= 4096)
					return;
				if (rhPtr.rhApp.bShiftFrameNumber)
					level++;
				level |= 0x8000;
			}
			rhPtr.rhQuit = CRun.LOOPEXIT_GOTOLEVEL;
			rhPtr.rhQuitParam = level;
			rhPtr.rhApp.subAppStopped = true;
		}
	}
	// CUT

	function ACT_NEXTLEVEL()
	{
	}
	ACT_NEXTLEVEL.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhQuit = CRun.LOOPEXIT_NEXTLEVEL;
			rhPtr.rhApp.subAppStopped = true;
		}
	}
	// CUT

	function ACT_PAUSEKEY()
	{
	}
	ACT_PAUSEKEY.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rh4PauseKey = this.evtParams[0].key;
			rhPtr.rhQuit = CRun.LOOPEXIT_PAUSEGAME;
		}
	}
	// CUT

	function ACT_SETFRAMERATE()
	{
	}
	ACT_SETFRAMERATE.prototype =
	{
		execute: function (rhPtr)
		{
			var rate = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			rhPtr.rhApp.gaFrameRate = rate;
		}
	}

	function ACT_SETVSYNCON()
	{
	}
	ACT_SETVSYNCON.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhApp.gaNewFlags |= CRunApp.GANF_VSYNC;
		}
	}
	// CUT

	function ACT_SETVSYNCOFF()
	{
	}
	ACT_SETVSYNCOFF.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhApp.gaNewFlags &= ~CRunApp.GANF_VSYNC;
		}
	}
	// CUT

	function ACT_FULLSCREENMODE()
	{
	}
	ACT_FULLSCREENMODE.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhApp.enterFullScreen();
		}
	}
	// CUT

	function ACT_WINDOWEDMODE()
	{
	}
	ACT_WINDOWEDMODE.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhApp.exitFullScreen();
		}
	}
	// CUT

	function ACT_PAUSEANYKEY()
	{
	}
	ACT_PAUSEANYKEY.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rh4PauseKey = -1;
			rhPtr.rhQuit = CRun.LOOPEXIT_PAUSEGAME;
		}
	}
	// CUT

	function ACT_PLAYDEMO()
	{
	}
	ACT_PLAYDEMO.prototype =
	{
		execute: function (rhPtr)
		{
			// TODO		
			/*		var pFilename:String;
			 if ( evtParams[0].code==63 )	    // PARAM_FILENAME2
			 pFilename=(PARAM_STRING(evtParams[0])).string;
			 else
			 pFilename=rhPtr.get_EventExpressionString(evtParams[0]);

			 if (rhPtr.rh4Demo==null)
			 {
			 rhPtr.rh4Demo=new CDemoRecord(rhPtr, pFilename);
			 rhPtr.rh4Demo.startPlaying();
			 }
			 */
		}
	}
	// CUT

	function ACT_SETSTRETCHRESAMPLING() {
	}
	ACT_SETSTRETCHRESAMPLING.prototype =
	{
	    execute: function (rhPtr) {
	        var value = rhPtr.get_EventExpressionInt(this.evtParams[0]);
	        rhPtr.rhApp.dwOptions &= ~CRunApp.AH2OPT_RESAMPLESTRETCH;
	        if (value)
	            rhPtr.rhApp.dwOptions |= CRunApp.AH2OPT_RESAMPLESTRETCH;
	    }
	}
	// CUT

	function ACT_PREVLEVEL()
	{
	}
	ACT_PREVLEVEL.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhApp.subAppStopped = true;
			rhPtr.rhQuit = CRun.LOOPEXIT_PREVLEVEL;
		}
	}
	// CUT

	function ACT_SETFRAMEHEIGHT()
	{
	}
	ACT_SETFRAMEHEIGHT.prototype =
	{
		execute: function (rhPtr)
		{
			var newHeight = rhPtr.get_EventExpressionInt(this.evtParams[0]);

			var nOldHeight = rhPtr.rhFrame.leHeight;
			rhPtr.rhFrame.leHeight = newHeight;

			if (nOldHeight == rhPtr.rhFrame.leVirtualRect.bottom)
				rhPtr.rhFrame.leVirtualRect.bottom = rhPtr.rhLevelSy = newHeight;

			var n;
			for (n = 0; n < rhPtr.rhFrame.nLayers; n++)
				rhPtr.rhFrame.layers[n].resetLevelBackground();
			rhPtr.drawLevel();
		}
	}
	// CUT

	function ACT_SETFRAMEWIDTH()
	{
	}
	ACT_SETFRAMEWIDTH.prototype =
	{
		execute: function (rhPtr)
		{
			var newWidth = rhPtr.get_EventExpressionInt(this.evtParams[0]);

			var nOldWidth = rhPtr.rhFrame.leWidth;
			rhPtr.rhFrame.leWidth = newWidth;

			if (nOldWidth == rhPtr.rhFrame.leVirtualRect.right)
				rhPtr.rhFrame.leVirtualRect.right = rhPtr.rhLevelSx = newWidth;

			var n;
			for (n = 0; n < rhPtr.rhFrame.nLayers; n++)
				rhPtr.rhFrame.layers[n].resetLevelBackground();
			rhPtr.drawLevel();
		}
	}
	// CUT

	function ACT_SETVIRTUALHEIGHT()
	{
	}
	ACT_SETVIRTUALHEIGHT.prototype =
	{
		execute: function (rhPtr)
		{
			var newHeight = rhPtr.get_EventExpressionInt(this.evtParams[0]);

			if (newHeight < rhPtr.rhFrame.leHeight)
				newHeight = rhPtr.rhFrame.leHeight;
			if (newHeight > 0x7FFFF000)
				newHeight = 0x7FFFF000;

			if (rhPtr.rhFrame.leVirtualRect.bottom != newHeight)
				rhPtr.rhFrame.leVirtualRect.bottom = rhPtr.rhLevelSy = newHeight;
		}
	}
	// CUT

	function ACT_SETVIRTUALWIDTH()
	{
	}
	ACT_SETVIRTUALWIDTH.prototype =
	{
		execute: function (rhPtr)
		{
			var newWidth = rhPtr.get_EventExpressionInt(this.evtParams[0]);

			if (newWidth < rhPtr.rhFrame.leWidth)
				newWidth = rhPtr.rhFrame.leWidth;
			if (newWidth > 0x7FFFF000)
				newWidth = 0x7FFFF000;

			if (rhPtr.rhFrame.leVirtualRect.right != newWidth)
				rhPtr.rhFrame.leVirtualRect.right = rhPtr.rhLevelSx = newWidth;
		}
	}
	// CUT

	// Active object
	// ---------------------------------------------------------------------
	function ACT_SPRFRONT()
	{
	}
	ACT_SPRFRONT.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			var index = pHo.getChildMaxIndex();
			pHo.setChildIndex(index - 1);
		}
	}
	// CUT

	function ACT_SPRPASTE()
	{
	}
	ACT_SPRPASTE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.roa != null)
				pHo.roa.animIn(0);
			rhPtr.activeToBackdrop(pHo, this.evtParams[0].value);
		}
	}
	// CUT

	function ACT_SPRSETANGLE()
	{
	}
	ACT_SPRSETANGLE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var nAngle = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			nAngle %= 360;
			if (nAngle < 0)
			    nAngle += 360;

			// If physical movement
			var pMBase = rhPtr.GetMBase(pHo);
			if (pMBase)
			{
				pMBase.setAngle(nAngle);
				return;
			}

			var bAntiA = false;
			if (rhPtr.get_EventExpressionInt(this.evtParams[1]) != 0)
				bAntiA = true;

			var bOldAntiA = false;
			if ((pHo.ros.rsFlags & CRSpr.RSFLAG_ROTATE_ANTIA) != 0)
				bOldAntiA = true;
			if (pHo.roc.rcAngle != nAngle || bOldAntiA != bAntiA)
			{
				pHo.roc.rcAngle = nAngle;
				pHo.ros.rsFlags &= ~CRSpr.RSFLAG_ROTATE_ANTIA;
				if (bAntiA)
					pHo.ros.rsFlags |= CRSpr.RSFLAG_ROTATE_ANTIA;
				pHo.roc.rcChanged = true;

				var ifo = pHo.hoAdRunHeader.rhApp.imageBank.getImageInfoEx(pHo.roc.rcImage, pHo.roc.rcAngle, pHo.roc.rcScaleX, pHo.roc.rcScaleY);
				pHo.hoImgWidth = ifo.width;
				pHo.hoImgHeight = ifo.height;
				pHo.hoImgXSpot = ifo.xSpot;
				pHo.hoImgYSpot = ifo.ySpot;
			}
		}
	}
	// CUT

	function ACT_SPRREPLACECOLOR()
	{
		this.replace = null;
	}
	ACT_SPRREPLACECOLOR.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			pHo.roa.animIn(0);

			var oldColor;
			if (this.evtParams[0].code == 24)
				oldColor = this.evtParams[0].color;
			else
			{
				oldColor = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				oldColor = CServices.swapRGB(oldColor);
			}

			var newColor;
			if (this.evtParams[1].code == 24)	    // PARAM_COLOUR)
				newColor = this.evtParams[1].color;
			else
			{
				newColor = rhPtr.get_EventExpressionInt(this.evtParams[1]);
				newColor = CServices.swapRGB(newColor);
			}
			if (oldColor != newColor)
			{
				if (this.replace == null)
					this.replace = new CReplaceColor();
				this.replace.replaceColor(rhPtr, pHo, newColor, oldColor);
			}
		}
	}
	// CUT


	function ACT_SPRSETSCALE()
	{
	}
	ACT_SPRSETSCALE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var fScale = rhPtr.get_EventExpressionDouble(this.evtParams[0]);
			if (fScale < 0)
				fScale = 0;

			var bResample = false;
			if (rhPtr.get_EventExpressionInt(this.evtParams[1]) != 0)
				bResample = true;

			pHo.ros.rsFlags &= ~CRSpr.RSFLAG_ROTATE_ANTIA;
			if (bResample)
				pHo.ros.rsFlags |= CRSpr.RSFLAG_ROTATE_ANTIA;
			pHo.setScale(fScale, fScale);
		}
	}
	// CUT

	function ACT_SPRSETSCALEX()
	{
	}
	ACT_SPRSETSCALEX.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var fScale = rhPtr.get_EventExpressionDouble(this.evtParams[0]);
			if (fScale < 0)
				fScale = 0;

			var bResample = false;
			if (rhPtr.get_EventExpressionInt(this.evtParams[1]) != 0)
				bResample = true;
			pHo.ros.rsFlags &= ~CRSpr.RSFLAG_ROTATE_ANTIA;
			if (bResample)
				pHo.ros.rsFlags |= CRSpr.RSFLAG_ROTATE_ANTIA;

			pHo.setScale(fScale, pHo.roc.rcScaleY);
		}
	}
	// CUT

	function ACT_SPRSETSCALEY()
	{
	}
	ACT_SPRSETSCALEY.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var fScale = rhPtr.get_EventExpressionDouble(this.evtParams[0]);
			if (fScale < 0)
				fScale = 0;

			var bResample = false;
			if (rhPtr.get_EventExpressionInt(this.evtParams[1]) != 0)
				bResample = true;
			pHo.ros.rsFlags &= ~CRSpr.RSFLAG_ROTATE_ANTIA;
			if (bResample)
				pHo.ros.rsFlags |= CRSpr.RSFLAG_ROTATE_ANTIA;

			pHo.setScale(pHo.roc.rcScaleX, fScale);
		}
	}
	// CUT

	function ACT_SPRADDBKD()
	{
	}
	ACT_SPRADDBKD.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			// Un cran d'animation sans effet
			if (pHo.roa != null)
				pHo.roa.animIn(0);

			rhPtr.activeToBackdrop(pHo, this.evtParams[0].value);
		}
	}
	// CUT

	// Question object
	// ---------------------------------------------------------------------
	function ACT_QASK()
	{
	}
	ACT_QASK.prototype =
	{
		execute:   function (rhPtr)
		{
			if ((this.evtOiList & 0x8000) == 0)
			{
				this.qstCreate(rhPtr, this.evtOi);
				return;
			}

			if ((this.evtOiList & 0x7FFF) != 0x7FFF)
			{
				var qoil = rhPtr.rhEvtProg.qualToOiList[this.evtOiList & 0x7FFF];
				var qoi;
				for (qoi = 0; qoi < qoil.qoiList.length; qoi += 2)
					this.qstCreate(rhPtr, qoil.qoiList[qoi]);
			}
		},
		qstCreate: function (rhPtr, oi)
		{
			var c = this.evtParams[0];
			var info = new CPositionInfo();

			if (c.read_Position(rhPtr, 0x10, info))
			{
				rhPtr.f_CreateObject(c.cdpHFII, oi, info.x, info.y, info.dir, 0, rhPtr.rhFrame.nLayers - 1, -1);
			}
		}
	}
	// CUT

	function ACT_RESTARTGAME()
	{
	}
	ACT_RESTARTGAME.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhQuit = CRun.LOOPEXIT_NEWGAME;
		}
	}
	// CUT

	function ACT_RESTARTLEVEL()
	{
	}
	ACT_RESTARTLEVEL.prototype =
	{
		execute: function (rhPtr)
		{
			rhPtr.rhQuit = CRun.LOOPEXIT_RESTART;
		}
	}
	// CUT


	// Create object
	// ---------------------------------------------------------------------
	function ACT_CREATE()
	{
	}
	ACT_CREATE.prototype =
	{
		execute: function (rhPtr)
		{
			var pEvp = this.evtParams[0];
			var pInfo = new CPositionInfo();
			if (pEvp.read_Position(rhPtr, 0x11, pInfo))
			{
				if (pInfo.bRepeat)
				{
					this.evtFlags |= CAct.ACTFLAGS_REPEAT;
					rhPtr.rhEvtProg.rh2ActionLoop = true;
				}
				else
				{
					this.evtFlags &= ~CAct.ACTFLAGS_REPEAT;
				}
				var number = rhPtr.f_CreateObject(pEvp.cdpHFII, pEvp.cdpOi, pInfo.x, pInfo.y, pInfo.dir, 0, pInfo.layer, -1);
				if (number >= 0)
				{
					var pHo = rhPtr.rhObjectList[number];
					rhPtr.rhEvtProg.evt_AddCurrentObject(pHo);

				    // Build 283.2: add physics attractor
					if (pHo && pHo.hoType >= 32)
					    rhPtr.addPhysicsAttractor(pHo);

					var mBase = rhPtr.GetMBase(pHo);
					if (mBase)
						mBase.CreateBody();
					else
					{
						if (rhPtr.rhBox2DBase != null)
						{
							rhPtr.rh4Box2DBase.rAddNormalObject(pHo);
						}
					}
				}
			}
		}
	}
	// CUT

	function ACT_CREATEBYNAME()
	{
	}
	ACT_CREATEBYNAME.prototype =
	{
		execute: function (rhPtr)
		{
			var pName = rhPtr.get_EventExpressionString(this.evtParams[0]);
			var pInfo = new CPositionInfo();
			if (this.evtParams[1].read_Position(rhPtr, 0x11, pInfo))
			{
				if (pInfo.bRepeat)
				{
					this.evtFlags |= CAct.ACTFLAGS_REPEAT;
					rhPtr.rhEvtProg.rh2ActionLoop = true;
				}
				else
					this.evtFlags &= ~CAct.ACTFLAGS_REPEAT;

				var oiPtr;
				for (oiPtr = rhPtr.rhApp.OIList.getFirstOI(); oiPtr != null; oiPtr = rhPtr.rhApp.OIList.getNextOI())
				{
					if (oiPtr.oiType >= 2)
					{
						if (CServices.compareStringsIgnoreCase(oiPtr.oiName, pName))
							break;
					}
				}

				if (oiPtr != null) {
				    var number = rhPtr.f_CreateObject(-1, oiPtr.oiHandle, pInfo.x, pInfo.y, pInfo.dir, 0, pInfo.layer, -1);
				    if (number >= 0) {
				        var pHo = rhPtr.rhObjectList[number];
				        rhPtr.rhEvtProg.evt_AddCurrentObject(pHo);

				        // Build 283.2: add physics attractor
				        if (pHo && pHo.hoType >= 32)
				            rhPtr.addPhysicsAttractor(pHo);

				        var mBase = rhPtr.GetMBase(pHo);
				        if (mBase)
				            mBase.CreateBody();
				        else {
				            if (rhPtr.rhBox2DBase != null) {
				                rhPtr.rh4Box2DBase.rAddNormalObject(pHo);
				            }
				        }
				    }
				}
			}
		}
	}
	// CUT

	// Common object actions
	// -----------------------------------------------------------------
	function ACT_EXTFOREACH()
	{
	}
	ACT_EXTFOREACH.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			var pName = rhPtr.get_EventExpressionString(this.evtParams[0]);
			rhPtr.rhEvtProg.addForEach(pName, pHo, this.evtOiList);
			rhPtr.rhEvtProg.callEndForEach = true;
		}
	}
	// CUT

	function ACT_EXTFOREACH2()
	{
	}
	ACT_EXTFOREACH2.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			var pName = rhPtr.get_EventExpressionString(this.evtParams[1]);
			rhPtr.rhEvtProg.addForEach(pName, pHo, this.evtOiList);

			pHo = rhPtr.rhEvtProg.get_CurrentObjects(this.evtParams[0].oiList);
			if (pHo != null)
				rhPtr.rhEvtProg.addForEach(pName, pHo, this.evtParams[0].oiList);

			rhPtr.rhEvtProg.callEndForEach = true;
		}
	}
	// CUT

	function ACT_EXTBOUNCE()
	{
	}
	ACT_EXTBOUNCE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.rom != null && pHo.rom.rmMovement.bounce != null)
				pHo.rom.rmMovement.bounce();
		}
	}
	// CUT

	function ACT_EXTBRANCHNODE()
	{
	}
	ACT_EXTBRANCHNODE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var pName = rhPtr.get_EventExpressionString(this.evtParams[0]);

			if (pHo.roc.rcMovementType == CMoveDef.MVTYPE_TAPED)
			{
				pHo.rom.rmMovement.mtBranchNode(pName);
			}
		}
	}
	// CUT

	function ACT_EXTCHGFLAG()
	{
	}
	ACT_EXTCHGFLAG.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.rov != null)
			{
				var number = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				var mask = 1 << number;
				if ((pHo.rov.rvValueFlags & mask) != 0)
					pHo.rov.rvValueFlags &= ~mask;
				else
					pHo.rov.rvValueFlags |= mask;
			}
		}
	}
	// -- CUT

	function ACT_EXTCHGFLAGCONST()
	{
	}
	ACT_EXTCHGFLAGCONST.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.rov != null)
			{
				if ((pHo.rov.rvValueFlags & this.mask) != 0)
					pHo.rov.rvValueFlags &= ~this.mask;
				else
					pHo.rov.rvValueFlags |= this.mask;
			}
		}
	}
	// CUT

	function ACT_EXTCLRFLAG()
	{
	}
	ACT_EXTCLRFLAG.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.rov != null)
			{
				var number = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				pHo.rov.rvValueFlags &= ~(1 << number);
			}
		}
	}
	// -- CUT

	function ACT_EXTCLRFLAGCONST()
	{
	}
	ACT_EXTCLRFLAGCONST.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.rov != null)
			{
				pHo.rov.rvValueFlags &= ~this.mask;
			}
		}
	}
	// CUT

	function ACT_EXTDESTROY()
	{
	}
	ACT_EXTDESTROY.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.hoType == 3)
			{
				var pText = pHo;
				if ((pText.rsHidden & CRun.COF_FIRSTTEXT) != 0)
				{
					pHo.ros.obHide();
					pHo.ros.rsFlags &= ~CRSpr.RSFLAG_VISIBLE;
					pHo.hoFlags |= CObject.HOF_NOCOLLISION;
				}
				else
				{
					pHo.hoFlags |= CObject.HOF_DESTROYED;
					rhPtr.destroy_Add(pHo.hoNumber);
				}
				return;
			}
			if ((pHo.hoFlags & CObject.HOF_DESTROYED) == 0)
			{
				pHo.hoFlags |= CObject.HOF_DESTROYED;
				if ((pHo.hoOEFlags & CObjectCommon.OEFLAG_ANIMATIONS) != 0 || (pHo.hoOEFlags & CObjectCommon.OEFLAG_SPRITES) != 0)
				{
					rhPtr.init_Disappear(pHo);
				}
				else
				{
					pHo.hoCallRoutine = false;
					rhPtr.destroy_Add(pHo.hoNumber);
				}
			}
		}
	}
	// CUT

	function ACT_EXTDISPATCHVAR()
	{
	}
	ACT_EXTDISPATCHVAR.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var num;
			if (this.evtParams[0].code == 53)
				num = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			else
				num = this.evtParams[0].value;

			var pBuffer = this.evtParams[2];
			if (rhPtr.rhEvtProg.rh2ActionLoopCount == 0)
				pBuffer.value = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			else
				pBuffer.value++;
			if (num >= 0 && pHo.rov != null)
			{
				if (num >= pHo.rov.rvValues.length)
					pHo.rov.growValues(num + 10);
				pHo.rov.rvValues[num] = pBuffer.value;
			}
		}
	}
	// CUT

	function ACT_EXTDISPLAYDURING()
	{
	}
	ACT_EXTDISPLAYDURING.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.ros != null)
			{
				pHo.ros.obHide();
				pHo.ros.rsFlags &= ~CRSpr.RSFLAG_VISIBLE;

				if (this.evtParams[0].code == 2)        // PARAM_TIME
				{
					pHo.ros.rsFlash = this.evtParams[0].timer;
					pHo.ros.rsFlashCpt = this.evtParams[0].timer;
				}
				else
				{
					pHo.ros.rsFlash = rhPtr.get_EventExpressionInt(this.evtParams[0]);
					pHo.ros.rsFlashCpt = pHo.ros.rsFlash;
				}
			}
		}
	}
	// CUT

	function ACT_EXTFORCEANIM()
	{
	}
	ACT_EXTFORCEANIM.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var ani;
			if (this.evtParams[0].code == 10)
				ani = this.evtParams[0].value;
			else
				ani = rhPtr.get_EventExpressionInt(this.evtParams[0]);

			if (ani < 0)
			    ani = 0;
			pHo.roa.animation_Force(ani);
			pHo.roc.rcChanged = true;
		}
	}
	// CUT

	function ACT_EXTFORCEDIR()
	{
	}
	ACT_EXTFORCEDIR.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var ani;
			if (this.evtParams[0].code == 29)
				ani = rhPtr.get_Direction(this.evtParams[0].value);
			else
				ani = rhPtr.get_EventExpressionInt(this.evtParams[0]);

			pHo.roa.animDir_Force(ani);
			pHo.roc.rcChanged = true;
		}
	}
	// CUT

	function ACT_EXTFORCEFRAME()
	{
	}
	ACT_EXTFORCEFRAME.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var frame = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			pHo.roa.animFrame_Force(frame);
			pHo.roc.rcChanged = true;
		}
	}
	// CUT

	function ACT_EXTFORCESPEED()
	{
	}
	ACT_EXTFORCESPEED.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var speed;
			speed = rhPtr.get_EventExpressionInt(this.evtParams[0]);

			pHo.roa.animSpeed_Force(speed);
		}
	}
	// CUT

	function ACT_EXTGOTONODE()
	{
	}
	ACT_EXTGOTONODE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var pName = rhPtr.get_EventExpressionString(this.evtParams[0]);

			if (pHo.roc.rcMovementType == CMoveDef.MVTYPE_TAPED)
			{
				pHo.rom.rmMovement.mtGotoNode(pName);
			}
		}
	}
	// CUT

	function ACT_EXTHIDE()
	{
	}
	ACT_EXTHIDE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			CRun.objectHide(pHo);
		}
	}
	// CUT

	function ACT_EXTINKEFFECT()
	{
	}
	ACT_EXTINKEFFECT.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.ros != null)
			{
				var p = this.evtParams[0];
				var param1 = p.value1;
				var param2 = p.value2;
				if (param1 == CRSpr.BOP_BLEND)
					param2 = 0;
				pHo.ros.modifSpriteEffect(param1, param2);
			}
		}
	}
	// CUT

	function ACT_EXTLOOKAT()
	{
	}
	ACT_EXTLOOKAT.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var position = this.evtParams[0];
			var pInfo = new CPositionInfo();
			if (position.read_Position(rhPtr, 0, pInfo))
			{
				var x = pInfo.x;
				var y = pInfo.y;
				x -= pHo.hoX;
				y -= pHo.hoY;
				var pMovement = rhPtr.GetMBase(pHo);
				if (pMovement == null)
				{
					var dir = CRun.get_DirFromPente(x, y);
					dir &= 31;
					if (rhPtr.getDir(pHo) != dir)
					{
						pHo.roc.rcDir = dir;
						pHo.roc.rcChanged = true;
						pHo.rom.rmMovement.setDir(dir);
					}
				}
				else
				{
					var angle = Math.atan2(-y, x) * 180.0 / 3.141592653589;
					if (angle < 0)
						angle = 360 + angle;
					pMovement.setAngle(angle);
				}
			}
		}
	}
	// CUT

	function ACT_EXTMAXSPEED()
	{
	}
	ACT_EXTMAXSPEED.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var s = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			if (pHo.rom != null)
				pHo.rom.rmMovement.setMaxSpeed(s);
		}
	}
	// CUT

	function ACT_EXTMOVEAFTER()
	{
	}
	ACT_EXTMOVEAFTER.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.ros != null)
			{
				var pHo2 = rhPtr.rhEvtProg.get_ParamActionObjects(this.evtParams[0].oiList, this);
				if (pHo2 == null)
					return;
				var pos;
				var pos1 = pHo2.getChildIndex();
				var pos2 = pHo.getChildIndex();
				if (pos2 < pos1)
					pHo.setChildIndex(pos1 + 1);
			}
		}
	}
	// CUT

	function ACT_EXTMOVEBEFORE()
	{
	}
	ACT_EXTMOVEBEFORE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.ros != null)
			{
				var pHo2 = rhPtr.rhEvtProg.get_ParamActionObjects(this.evtParams[0].oiList, this);
				if (pHo2 == null)
					return;
				var pos1 = pHo2.getChildIndex();
				var pos2 = pHo.getChildIndex();
				if (pos1 < pos2)
					pHo.setChildIndex(pos1);
			}
		}
	}
	// CUT

	function ACT_EXTMOVETOLAYER()
	{
	}
	ACT_EXTMOVETOLAYER.prototype =
	{
		execute: function (rhPtr)
		{
			var hoPtr = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (hoPtr == null)
				return;

			if (hoPtr.ros != null)
			{
				var nLayer = rhPtr.get_EventExpressionInt(this.evtParams[0]);

				if (nLayer > 0 && nLayer <= rhPtr.rhFrame.nLayers && hoPtr.hoLayer != nLayer - 1)
				{
					nLayer -= 1;

					var pLayer = rhPtr.rhFrame.layers[nLayer];
					if (hoPtr.ros != null)
					{
						hoPtr.hoLayer = nLayer;
						hoPtr.ros.rsLayer = nLayer;
						hoPtr.delSprite();
						hoPtr.ros.createSprite(false);
					}
				}
			}
		}
	}
	// CUT

	function ACT_EXTNEXTMOVE()
	{
	}
	ACT_EXTNEXTMOVE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.rom != null)
				pHo.rom.nextMovement(pHo);
		}
	}
	// CUT

	function ACT_EXTPREVMOVE()
	{
	}
	ACT_EXTPREVMOVE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.rom != null)
				pHo.rom.previousMovement(pHo);
		}
	}
	// CUT

	function ACT_EXTRESTANIM()
	{
	}
	ACT_EXTRESTANIM.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			pHo.roa.animation_Restore();
			pHo.roc.rcChanged = true;
		}
	}
	// CUT

	function ACT_EXTRESTDIR()
	{
	}
	ACT_EXTRESTDIR.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			pHo.roa.animDir_Restore();
			pHo.roc.rcChanged = true;
		}
	}
	// CUT

	function ACT_EXTRESTFRAME()
	{
	}
	ACT_EXTRESTFRAME.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			pHo.roa.animFrame_Restore();
			pHo.roc.rcChanged = true;
		}
	}
	// CUT

	function ACT_EXTRESTSPEED()
	{
	}
	ACT_EXTRESTSPEED.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			pHo.roa.animSpeed_Restore();
		}
	}
	// CUT

	function ACT_EXTREVERSE()
	{
	}
	ACT_EXTREVERSE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.rom != null)
				pHo.rom.rmMovement.reverse();
		}
	}
	// CUT

	function ACT_EXTSELMOVE()
	{
	}
	ACT_EXTSELMOVE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var n;
			if (this.evtParams[0].code == 22)
				n = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			else
				n = this.evtParams[0].value;
			if (pHo.rom != null)
				pHo.rom.selectMovement(pHo, n);
		}
	}
	// CUT

	function ACT_EXTSETACCELERATION()
	{
	}
	ACT_EXTSETACCELERATION.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var acc = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			pHo.rom.rmMovement.setAcc(acc);
		}
	}
	// CUT

	function ACT_EXTSETALPHACOEF()
	{
	}
	ACT_EXTSETALPHACOEF.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.ros == null)
				return;

			var alpha = CServices.clamp(255 - rhPtr.get_EventExpressionInt(this.evtParams[0]), 0, 255);
			var wasSemi = ((pHo.ros.rsEffect & CRSpr.BOP_RGBAFILTER) == 0);
			pHo.ros.rsEffect = (pHo.ros.rsEffect & CRSpr.BOP_MASK) | CRSpr.BOP_RGBAFILTER;

			var rgbaCoeff = 0x00FFFFFF;

			if (!wasSemi)
				rgbaCoeff = pHo.ros.rsEffectParam;

			var alphaPart = alpha << 24;
			var rgbPart = (rgbaCoeff & 0x00FFFFFF);
			pHo.ros.rsEffectParam = alphaPart | rgbPart;

			pHo.ros.modifSpriteEffect(pHo.ros.rsEffect, pHo.ros.rsEffectParam);
		}
	}
	// CUT

	function ACT_EXTSETBOLD()
	{
	}
	ACT_EXTSETBOLD.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var bFlag = rhPtr.get_EventExpressionInt(this.evtParams[0]);

			var info = CRun.getObjectFont(pHo);
			if (bFlag != 0)
				info.lfWeight = 700;
			else
				info.lfWeight = 400;

			CRun.setObjectFont(pHo, info, null);
		}
	}
	// CUT

	function ACT_EXTSETDECELERATION()
	{
	}
	ACT_EXTSETDECELERATION.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var dec = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			pHo.rom.rmMovement.setDec(dec);
		}
	}
	// CUT

	function ACT_EXTSETDIR()
	{
	}
	ACT_EXTSETDIR.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var dir;
			if (this.evtParams[0].code == 29)
				dir = rhPtr.get_Direction(this.evtParams[0].value);
			else
				dir = rhPtr.get_EventExpressionInt(this.evtParams[0]);

			dir &= 31;
			if (rhPtr.getDir(pHo) != dir)
			{
				pHo.roc.rcDir = dir;
				pHo.roc.rcChanged = true;
				pHo.rom.rmMovement.setDir(dir);

				if (pHo.hoType == 2)
					pHo.roa.animIn(0);
			}
		}
	}
	// CUT

	function ACT_EXTSETDIRECTIONS()
	{
	}
	ACT_EXTSETDIRECTIONS.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var dirs = this.evtParams[0].value;
			pHo.rom.rmMovement.set8Dirs(dirs);
		}
	}
	// CUT

	function ACT_EXTSETEFFECT()
	{
	}
	ACT_EXTSETEFFECT.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var effectName = this.evtParams[0].string;
			var effect = CRSpr.BOP_COPY;
			if (effectName != null && effectName.length != 0)
			{
				if (effectName == "Add")
					effect = CRSpr.BOP_ADD;
				else if (effectName == "Invert")
					effect = CRSpr.BOP_INVERT;
				else if (effectName == "Sub")
					effect = CRSpr.BOP_SUB;
				else if (effectName == "Mono")
					effect = CRSpr.BOP_MONO;
				else if (effectName == "Blend")
					effect = CRSpr.BOP_BLEND;
				else if (effectName == "XOR")
					effect = CRSpr.BOP_XOR;
				else if (effectName == "OR")
					effect = CRSpr.BOP_OR;
				else if (effectName == "AND")
					effect = CRSpr.BOP_AND;
			}
			pHo.ros.modifSpriteEffect(effect, pHo.ros.rsEffectParam);
		}
	}
	// CUT

	function ACT_EXTSETEFFECTPARAM()
	{
	}
	ACT_EXTSETEFFECTPARAM.prototype =
	{
		execute: function (rhPtr)
		{

		}
	}
	// CUT

	function ACT_EXTSETFLAG()
	{
	}
	ACT_EXTSETFLAG.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.rov != null)
			{
				var number = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				pHo.rov.rvValueFlags |= (1 << number);
			}
		}
	}
	// -- CUT

	function ACT_EXTSETFLAGCONST()
	{
	}
	ACT_EXTSETFLAGCONST.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.rov != null)
			{
				pHo.rov.rvValueFlags |= this.mask;
			}
		}
	}
	// CUT

	function ACT_EXTEXTRA() {
	}
	ACT_EXTEXTRA.prototype =
	{
	    execute: function (rhPtr) {
	        var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
	        if (pHo == null)
	            return;
	        // Should be never called
	    }
	}

	function ACT_EXTSETFLAGBYEXP() {
	}
	ACT_EXTSETFLAGBYEXP.prototype =
	{
	    execute: function (rhPtr) {
	        var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
	        if (pHo == null)
	            return;
	        if (pHo.rov != null) {
	            var number = rhPtr.get_EventExpressionInt(this.evtParams[0]);       // flag number
	            var value = rhPtr.get_EventExpressionInt(this.evtParams[1]);        // value
	            pHo.rov.rvValueFlags &= ~(1 << number);
	            if ( value )
	                pHo.rov.rvValueFlags |= (1 << number);
	        }
	    }
	}
	// CUT

	function ACT_EXTSETFONTNAME()
	{
	}
	ACT_EXTSETFONTNAME.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var name = rhPtr.get_EventExpressionString(this.evtParams[0]);
			var info = CRun.getObjectFont(pHo);
			info.lfFaceName = name;
			CRun.setObjectFont(pHo, info, null);
		}
	}
	// CUT

	function ACT_EXTSETFONTSIZE()
	{
	}
	ACT_EXTSETFONTSIZE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var newSize = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			var bResize = rhPtr.get_EventExpressionInt(this.evtParams[1]);

			var lf = CRun.getObjectFont(pHo);

			var oldSize = lf.lfHeight;
			lf.lfHeight = CServices.heightNormalToLF(newSize);

			if (bResize == 0)
				CRun.setObjectFont(pHo, lf, null);
			else
			{
				if (newSize != oldSize)
				{
					var rc = new CRect();
					var coef = 1.0;
					if (oldSize != 0)
						coef = newSize / oldSize;
					rc.right = Math.floor(pHo.hoImgWidth * coef);
					rc.bottom = Math.floor(pHo.hoImgHeight * coef);
					rc.left = 0;
					rc.top = 0;
					CRun.setObjectFont(pHo, lf, rc);
				}
			}
		}
	}
	// CUT

	function ACT_EXTSETGRAVITY()
	{
	}
	ACT_EXTSETGRAVITY.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var grav = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			pHo.rom.rmMovement.setGravity(grav);
		}
	}
	// CUT

	function ACT_EXTSETITALIC()
	{
	}
	ACT_EXTSETITALIC.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var bFlag = rhPtr.get_EventExpressionInt(this.evtParams[0]);

			var info = CRun.getObjectFont(pHo);
			info.lfItalic = bFlag;
			CRun.setObjectFont(pHo, info, null);
		}
	}
	// CUT

	function ACT_EXTSETPOS()
	{
	}
	ACT_EXTSETPOS.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var position = this.evtParams[0];
			var pInfo = new CPositionInfo();
			if (position.read_Position(rhPtr, 1, pInfo))
			{
				CRun.setXPosition(pHo, pInfo.x);
				CRun.setYPosition(pHo, pInfo.y);
				if (pInfo.dir != -1)
				{
					var dir = pInfo.dir &= 31;
					if (rhPtr.getDir(pHo) != dir)
					{
						pHo.roc.rcDir = dir;
						pHo.roc.rcChanged = true;
						pHo.rom.rmMovement.setDir(dir);

						if (pHo.hoType == 2)
							pHo.roa.animIn(0);
					}
				}
			}
		}
	}
	// CUT

	function ACT_EXTSETRGBCOEF()
	{
	}
	ACT_EXTSETRGBCOEF.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.ros == null)
				return;

			var argb = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			var wasSemi = ((pHo.ros.rsEffect & CRSpr.BOP_RGBAFILTER) == 0);
			pHo.ros.rsEffect = (pHo.ros.rsEffect & CRSpr.BOP_MASK) | CRSpr.BOP_RGBAFILTER;

			var rgbaCoeff = pHo.ros.rsEffectParam;
			var alphaPart;
			if (wasSemi)
			{
				if (pHo.ros.rsEffectParam == -1)
					alphaPart = 0xFF000000;
				else
					alphaPart = (255 - (pHo.ros.rsEffectParam * 2)) << 24;
			}
			else
				alphaPart = rgbaCoeff & 0xFF000000;

			var rgbPart = CServices.swapRGB(argb & 0x00FFFFFF);
			var filter = alphaPart | rgbPart;
			pHo.ros.rsEffectParam = filter;

			pHo.ros.modifSpriteEffect(pHo.ros.rsEffect, pHo.ros.rsEffectParam);
		}
	}
	// CUT

	function ACT_EXTSETROTATINGSPEED()
	{
	}
	ACT_EXTSETROTATINGSPEED.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var speed = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			pHo.rom.rmMovement.setRotSpeed(speed);
		}
	}
	// CUT

	function ACT_EXTSETSEMITRANSPARENCY()
	{
	}
	ACT_EXTSETSEMITRANSPARENCY.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.ros != null)
			{
				var val = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				if (val < 0) val = 0;
				if (val > 128) val = 128;

				pHo.roc.rcChanged = true;
				pHo.ros.setSemiTransparency(val);
			}
		}
	}
	// CUT

	function ACT_EXTSETTEXTCOLOR()
	{
	}
	ACT_EXTSETTEXTCOLOR.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var rgb;
			if (this.evtParams[0].code == 22)
			{
				rgb = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				rgb = CServices.swapRGB(rgb);
			}
			else
				rgb = this.evtParams[0].color;

			CRun.setObjectTextColor(pHo, rgb);
		}
	}
	// CUT

	function ACT_EXTSETUNDERLINE()
	{
	}
	ACT_EXTSETUNDERLINE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var bFlag = rhPtr.get_EventExpressionInt(this.evtParams[0]);

			var info = CRun.getObjectFont(pHo);
			info.lfUnderline = bFlag;
			CRun.setObjectFont(pHo, info, null);
		}
	}
	// CUT

	function ACT_EXTSETVAR()
	{
	}
	ACT_EXTSETVAR.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var num;
			if (this.evtParams[0].code == 53)
				num = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			else
				num = this.evtParams[0].value;

			if (num >= 0 && pHo.rov != null)
			{
				if (num >= pHo.rov.rvValues.length)
					pHo.rov.growValues(num + 10);
				var pValue2 = rhPtr.get_EventExpressionAny(this.evtParams[1]);
				pHo.rov.rvValues[num] = pValue2;
			}
		}
	}
	// -- CUT

	function ACT_EXTSETVARCONST()
	{
	}
	ACT_EXTSETVARCONST.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (this.num >= 0 && pHo.rov != null)
			{
				if (this.num >= pHo.rov.rvValues.length)
					pHo.rov.growValues(this.num + 10);
				pHo.rov.rvValues[this.num] = this.value;
			}
		}
	}
	// CUT

	function ACT_EXTSETVARSTRING()
	{
	}
	ACT_EXTSETVARSTRING.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var num;
			if (this.evtParams[0].code == 62)
				num = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			else
				num = this.evtParams[0].value;

			if (num >= 0 && pHo.rov != null)
			{
				if (num >= pHo.rov.rvStrings.length)
					pHo.rov.growStrings(num + 10);
				pHo.rov.rvStrings[num] = rhPtr.get_EventExpressionString(this.evtParams[1]);
			}
		}
	}
	// CUT

	function ACT_EXTSETX()
	{
	}
	ACT_EXTSETX.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var x = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			CRun.setXPosition(pHo, Math.floor(x));
		}
	}
	// CUT

	function ACT_EXTSETY()
	{
	}
	ACT_EXTSETY.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var y = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			CRun.setYPosition(pHo, Math.floor(y));
		}
	}
	// CUT

	function ACT_EXTSHOOT()
	{
	}
	ACT_EXTSHOOT.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var pEvp = this.evtParams[0];
			var pInfo = new CPositionInfo();
			if (pEvp.read_Position(rhPtr, 0x11, pInfo))
			{
				pHo.shtCreate(pEvp, pInfo.x, pInfo.y, pInfo.dir);
			}
		}
	}
	// CUT

	function ACT_EXTSHOOTTOWARD()
	{
	}
	ACT_EXTSHOOTTOWARD.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null) return;

			var pInfo = new CPositionInfo();
			if (this.evtParams[0].read_Position(rhPtr, 0x11, pInfo))
			{
				var pInfoDest = new CPositionInfo();
				if (this.evtParams[1].read_Position(rhPtr, 0, pInfoDest))
				{
					var x2 = pInfoDest.x;
					var y2 = pInfoDest.y;
					var dir = CRun.get_DirFromPente(x2 - pInfo.x, y2 - pInfo.y);

					pHo.shtCreate(this.evtParams[0], pInfo.x, pInfo.y, dir);
				}
			}
		}
	}
	// CUT

	function ACT_EXTSHOW()
	{
	}
	ACT_EXTSHOW.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null) return;
			CRun.objectShow(pHo);
		}
	}
	// CUT

	function ACT_EXTSHUFFLE()
	{
	}
	ACT_EXTSHUFFLE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null) return;

			rhPtr.rhEvtProg.rh2ShuffleBuffer.add(pHo);
		}
	}
	// CUT

	function ACT_EXTSPEED()
	{
	}
	ACT_EXTSPEED.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var s = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			if (pHo.rom != null)
				pHo.rom.rmMovement.setSpeed(s);
		}
	}
	// CUT

	function ACT_EXTSPRBACK()
	{
	}
	ACT_EXTSPRBACK.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null) return;
			pHo.setChildIndex(0);
		}
	}
	// CUT

	function ACT_EXTSPRFRONT()
	{
	}
	ACT_EXTSPRFRONT.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null) return;
			var index = pHo.getChildMaxIndex();
			pHo.setChildIndex(index);
		}
	}
	// CUT

	function ACT_SPRBACK()
	{
	}
	ACT_SPRBACK.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null) return;
			pHo.setChildIndex(0);
		}
	}
	// CUT

	function ACT_SPRFRONT()
	{
	}
	ACT_SPRFRONT.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null) return;
			var index = pHo.getChildMaxIndex();
			pHo.setChildIndex(index);
		}
	}
	// CUT

	function ACT_EXTSTART()
	{
	}
	ACT_EXTSTART.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.rom != null)
				pHo.rom.rmMovement.start();
		}
	}
	// CUT

	function ACT_EXTSTARTANIM()
	{
	}
	ACT_EXTSTARTANIM.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			pHo.roa.raAnimStopped = false;
		}
	}
	// CUT

	function ACT_EXTSTOP()
	{
	}
	ACT_EXTSTOP.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.rom != null)
				pHo.rom.rmMovement.stop();
		}
	}
	// CUT

	function ACT_EXTSTOPANIM()
	{
	}
	ACT_EXTSTOPANIM.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;
			pHo.roa.raAnimStopped = true;
		}
	}
	// CUT

	function ACT_EXTADDVAR()
	{
	}
	ACT_EXTADDVAR.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null) return;

			var num;
			if (this.evtParams[0].code == 53)
				num = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			else
				num = this.evtParams[0].value;

			if (num >= 0 && pHo.rov != null)
			{
				if (num >= pHo.rov.rvValues.length)
					pHo.rov.growValues(num + 10);
				var pValue2 = rhPtr.get_EventExpressionAny(this.evtParams[1]);
				pHo.rov.rvValues[num] += pValue2;
			}
		}
	}
	// -- CUT

	function ACT_EXTADDVARCONST()
	{
	}
	ACT_EXTADDVARCONST.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null) return;

			if (this.num >= 0 && pHo.rov != null)
			{
				if (this.num >= pHo.rov.rvValues.length)
					pHo.rov.growValues(this.num + 10);
				pHo.rov.rvValues[this.num] += this.value;
			}
		}
	}
	// CUT

	function ACT_EXTSUBVAR()
	{
	}
	ACT_EXTSUBVAR.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null) return;

			var num;
			if (this.evtParams[0].code == 53)
				num = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			else
				num = this.evtParams[0].value;

			if (num >= 0 && pHo.rov != null)
			{
				if (num >= pHo.rov.rvValues.length)
					pHo.rov.growValues(num + 10);
				var pValue2 = rhPtr.get_EventExpressionAny(this.evtParams[1]);
				pHo.rov.rvValues[num] -= pValue2;
			}
		}
	}
	// -- CUT

	function ACT_EXTSUBVARCONST()
	{
	}
	ACT_EXTSUBVARCONST.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null) return;

			if (this.num >= 0 && pHo.rov != null)
			{
				if (this.num >= pHo.rov.rvValues.length)
					pHo.rov.growValues(this.num + 10);
				pHo.rov.rvValues[this.num] -= this.value;
			}
		}
	}
	// CUT

	function ACT_EXTWRAP()
	{
	}
	ACT_EXTWRAP.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (pHo.rom != null)
				pHo.rom.rmEventFlags |= CRMvt.EF_WRAP;
		}
	}
	// CUT

	// BOX2D MOVEMENTS
	//////////////////////////////////////////////////////////////////////////////////////

	function ACT_EXTSETFRICTION()
	{
	}
	ACT_EXTSETFRICTION.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (rhPtr.GetMBase(pHo) != null)
			{
				var friction = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				pHo.rom.rmMovement.callMovement(CAct.ACT_EXTSETFRICTION, friction);
			}
		}
	}
	// CUT

	function ACT_EXTSETELASTICITY()
	{
	}
	ACT_EXTSETELASTICITY.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (rhPtr.GetMBase(pHo) != null)
			{
				var elasticity = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				pHo.rom.rmMovement.callMovement(CAct.ACT_EXTSETELASTICITY, elasticity);
			}
		}
	}
	// CUT

	function ACT_EXTAPPLYANGULARIMPULSE()
	{
	}
	ACT_EXTAPPLYANGULARIMPULSE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (rhPtr.GetMBase(pHo) != null)
			{
				var torque = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				pHo.rom.rmMovement.callMovement(CAct.ACT_EXTAPPLYANGULARIMPULSE, torque);
			}
		}
	}
	// CUT

	function ACT_EXTAPPLYFORCE()
	{
	}
	ACT_EXTAPPLYFORCE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (rhPtr.GetMBase(pHo) != null)
			{
				var array = new Array();
				array[0] = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				array[1] = rhPtr.get_EventExpressionInt(this.evtParams[1]);
				pHo.rom.rmMovement.callMovement(CAct.ACT_EXTAPPLYFORCE, array);
			}
		}
	}
	// CUT

	function ACT_EXTAPPLYTORQUE()
	{
	}
	ACT_EXTAPPLYTORQUE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (rhPtr.GetMBase(pHo) != null)
			{
				var torque = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				pHo.rom.rmMovement.callMovement(CAct.ACT_EXTAPPLYTORQUE, torque);
			}
		}
	}
	// CUT

	function ACT_EXTSETLINEARVELOCITY()
	{
	}
	ACT_EXTSETLINEARVELOCITY.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (rhPtr.GetMBase(pHo) != null)
			{
				var array = new Array();
				array[0] = rhPtr.get_EventExpressionDouble(this.evtParams[0]);
				array[1] = rhPtr.get_EventExpressionDouble(this.evtParams[1]);
				pHo.rom.rmMovement.callMovement(CAct.ACT_EXTSETLINEARVELOCITY, array);
			}
		}
	}
	// CUT

	function ACT_EXTSETANGULARVELOCITY()
	{
	}
	ACT_EXTSETANGULARVELOCITY.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (rhPtr.GetMBase(pHo) != null)
			{
				var torque = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				pHo.rom.rmMovement.callMovement(CAct.ACT_EXTSETANGULARVELOCITY, torque);
			}
		}
	}
	// CUT

	function ACT_EXTAPPLYIMPULSE()
	{
	}
	ACT_EXTAPPLYIMPULSE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (rhPtr.GetMBase(pHo) != null)
			{
				var array = new Array();
				array[0] = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				array[1] = rhPtr.get_EventExpressionInt(this.evtParams[1]);
				pHo.rom.rmMovement.callMovement(CAct.ACT_EXTAPPLYIMPULSE, array);
			}
		}
	}
	// CUT

	function ACT_EXTSTOPFORCE()
	{
	}
	ACT_EXTSTOPFORCE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (rhPtr.GetMBase(pHo) != null)
			{
				pHo.rom.rmMovement.callMovement(CAct.ACT_EXTSTOPFORCE, 0);
			}
		}
	}
	// CUT

	function ACT_EXTSTOPTORQUE()
	{
	}
	ACT_EXTSTOPTORQUE.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			if (rhPtr.GetMBase(pHo) != null)
			{
				pHo.rom.rmMovement.callMovement(CAct.ACT_EXTSTOPTORQUE, 0);
			}
		}
	}
	// CUT

	// CCnd object
	// ----------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 * 
	 * Permission is hereby granted to any person obtaining a legal copy 
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for 
	 * debugging, optimizing, or customizing applications created with 
	 * Clickteam Multimedia Fusion 2. 
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CCnd.NUM_ONEVENT = 6;
	CCnd.CND_ONLOOP = ((-16 << 16) | 0xFFFF);
	CCnd.CND_OR = ((-24 << 16) | 65535);
	CCnd.CND_ORLOGICAL = ((-25 << 16) | 65535);
	function CCnd()
	{
	}
	CCnd.create = function (app)
	{
		var debut = app.file.getFilePointer();

		var size = app.file.readAShort();
		var cnd = null;
		var c = app.file.readAInt();
		switch (c)
		{
		    case ((-43 << 16) | 0xFFFF):
		        cnd = new CND_STARTCHILDEVENT();
		        break;
		    case ((-42 << 16) | 0xFFFF):
		        cnd = new CND_NEVER();
		        break;
	        case ((-40 << 16) | 0xFFFF):
		        cnd = new CND_RUNNINGAS();
		        break;
		    case ((-39 << 16) | 0xFFFF):
		        cnd = new CND_COMPAREGCONST_GT();
		        break;
		    case ((-38 << 16) | 0xFFFF):
		        cnd = new CND_COMPAREGCONST_GE();
		        break;
		    case ((-37 << 16) | 0xFFFF):
		        cnd = new CND_COMPAREGCONST_LT();
		        break;
		    case ((-36 << 16) | 0xFFFF):
		        cnd = new CND_COMPAREGCONST_LE();
		        break;
		    case ((-35 << 16) | 0xFFFF):
		        cnd = new CND_COMPAREGCONST_NE();
		        break;
		    case ((-34 << 16) | 0xFFFF):
		        cnd = new CND_COMPAREGCONST_EQ();
		        break;
		    case ((-33 << 16) | 0xFFFF):
		        cnd = new CND_COMPAREGCONST_GT();
		        break;
		    case ((-32 << 16) | 0xFFFF):
		        cnd = new CND_COMPAREGCONST_GE();
		        break;
		    case ((-31 << 16) | 0xFFFF):
		        cnd = new CND_COMPAREGCONST_LT();
		        break;
		    case ((-30 << 16) | 0xFFFF):
		        cnd = new CND_COMPAREGCONST_LE();
		        break;
		    case ((-29 << 16) | 0xFFFF):
		        cnd = new CND_COMPAREGCONST_NE();
		        break;
		    case ((-28 << 16) | 0xFFFF):
		        cnd = new CND_COMPAREGCONST_EQ();
		        break;
		    case ((-27 << 16) | 0xFFFF):    // ELSE IF
				cnd = new CND_NEVER();
				break;
			case ((-26 << 16) | 0xFFFF):
				cnd = new CND_CHANCE();
				break;
			case ((-25 << 16) | 0xFFFF):		// CND_ORLOGICAL
				cnd = new CND_NEVER();
				break;
			case ((-24 << 16) | 0xFFFF):		// CND_OR		
				cnd = new CND_NEVER();
				break;
			case ((-23 << 16) | 0xFFFF):
				cnd = new CND_GROUPSTART();
				break;
			case ((-20 << 16) | 0xFFFF):
				cnd = new CND_COMPAREGSTRING();
				break;
			case ((-16 << 16) | 0xFFFF):
				cnd = new CND_ONLOOP();
				break;
			case ((-12 << 16) | 0xFFFF):
				cnd = new CND_GROUPACTIVATED();
				break;
			case ((-11 << 16) | 0xFFFF):
				cnd = new CND_NEVER();
				break;
			case ((-10 << 16) | 0xFFFF):
				cnd = new CND_NEVER();
				break;
			case ((-9 << 16) | 0xFFFF):
				cnd = new CND_NEVER();
				break;
			case ((-8 << 16) | 0xFFFF):
				cnd = new CND_COMPAREG();
				break;
			case ((-7 << 16) | 0xFFFF):
				cnd = new CND_NOTALWAYS();
				break;
			case ((-6 << 16) | 0xFFFF):
				cnd = new CND_ONCE();
				break;
			case ((-5 << 16) | 0xFFFF):
				cnd = new CND_REPEAT();
				break;
			case ((-4 << 16) | 0xFFFF):
				cnd = new CND_NOMORE();
				break;
			case ((-3 << 16) | 0xFFFF):
				cnd = new CND_COMPARE();
				break;
			case ((-2 << 16) | 0xFFFF):
				cnd = new CND_NEVER();
				break;
			case ((-1 << 16) | 0xFFFF):
				cnd = new CND_ALWAYS();
				break;
			case ((-9 << 16) | 0xFFFE):
				cnd = new CND_SPCHANNELPAUSED();
				break;
			case ((-8 << 16) | 0xFFFE):
				cnd = new CND_NOSPCHANNELPLAYING();
				break;
			case ((-6 << 16) | 0xFFFE):
				cnd = new CND_SPSAMPAUSED();
				break;
			case ((-3 << 16) | 0xFFFE):
				cnd = new CND_NOSAMPLAYING;
				break;
			case ((-1 << 16) | 0xFFFE):
				cnd = new CND_NOSPSAMPLAYING();
				break;
			case ((-8 << 16) | 0xFFFD):
				cnd = new CND_ENDOFPAUSE();
				break;
			case ((-7 << 16) | 0xFFFD):
				cnd = new CND_ISVSYNCON();
				break;
			case ((-6 << 16) | 0xFFFD):
				cnd = new CND_ISLADDER();
				break;
			case ((-5 << 16) | 0xFFFD):
				cnd = new CND_ISOBSTACLE();
				break;
			case ((-4 << 16) | 0xFFFD):
				cnd = new CND_QUITAPPLICATION();
				break;
			case ((-3 << 16) | 0xFFFD):
				cnd = new CND_NEVER();
				break;
			case ((-2 << 16) | 0xFFFD):
				cnd = new CND_ALWAYS();
				break;
			case ((-1 << 16) | 0xFFFD):
				cnd = new CND_START();
				break;
			case ((-8 << 16) | 0xFFFC):
				cnd = new CND_EVERY2();
				break;
			case ((-7 << 16) | 0xFFFC):
				cnd = new CND_TIMEREQUALS();
				break;
			case ((-6 << 16) | 0xFFFC):
				cnd = new CND_ONEVENT();
				break;
			case ((-5 << 16) | 0xFFFC):
				cnd = new CND_TIMEOUT();
				break;
			case ((-4 << 16) | 0xFFFC):
				cnd = new CND_EVERY();
				break;
			case ((-3 << 16) | 0xFFFC):
				cnd = new CND_TIMER();
				break;
			case ((-2 << 16) | 0xFFFC):
				cnd = new CND_TIMERINF();
				break;
			case ((-1 << 16) | 0xFFFC):
				cnd = new CND_TIMERSUP();
				break;
			case ((-12 << 16) | 0xFFFA):
				cnd = new CND_ONMOUSEWHEELDOWN();
				break;
			case ((-11 << 16) | 0xFFFA):
				cnd = new CND_ONMOUSEWHEELUP();
				break;
			case ((-10 << 16) | 0xFFFA):
				cnd = new CND_MOUSEON();
				break;
			case ((-9 << 16) | 0xFFFA):
				cnd = new CND_ANYKEY();
				break;
			case ((-8 << 16) | 0xFFFA):
				cnd = new CND_MKEYDEPRESSED();
				break;
			case ((-7 << 16) | 0xFFFA):
				cnd = new CND_MCLICKONOBJECT();
				break;
			case ((-6 << 16) | 0xFFFA):
				cnd = new CND_MCLICKINZONE();
				break;
			case ((-5 << 16) | 0xFFFA):
				cnd = new CND_MCLICK();
				break;
			case ((-4 << 16) | 0xFFFA):
				cnd = new CND_MONOBJECT();
				break;
			case ((-3 << 16) | 0xFFFA):
				cnd = new CND_MINZONE();
				break;
			case ((-2 << 16) | 0xFFFA):
				cnd = new CND_KBKEYDEPRESSED();
				break;
			case ((-1 << 16) | 0xFFFA):
				cnd = new CND_KBPRESSKEY();
				break;
			case ((-6 << 16) | 0xFFF9):
				cnd = new CND_JOYPUSHED();
				break;
			case ((-5 << 16) | 0xFFF9):
				cnd = new CND_NOMORELIVE();
				break;
			case ((-4 << 16) | 0xFFF9):
				cnd = new CND_JOYPRESSED();
				break;
			case ((-3 << 16) | 0xFFF9):
				cnd = new CND_LIVE();
				break;
			case ((-2 << 16) | 0xFFF9):
				cnd = new CND_SCORE();
				break;
			case ((-1 << 16) | 0xFFF9):
				cnd = new CND_PLAYERPLAYING();
				break;
			case ((-23 << 16) | 0xFFFB):
				cnd = new CND_CHOOSEALLINLINE();
				break;
			case ((-22 << 16) | 0xFFFB):
				cnd = new CND_CHOOSEFLAGRESET();
				break;
			case ((-21 << 16) | 0xFFFB):
				cnd = new CND_CHOOSEFLAGSET();
				break;
			case ((-20 << 16) | 0xFFFB):
				cnd = new CND_CHOOSEVALUE();
				break;
			case ((-19 << 16) | 0xFFFB):
				cnd = new CND_PICKFROMID();
				break;
			case ((-18 << 16) | 0xFFFB):
				cnd = new CND_CHOOSEALLINZONE();
				break;
			case ((-17 << 16) | 0xFFFB):
				cnd = new CND_CHOOSEALL();
				break;
			case ((-16 << 16) | 0xFFFB):
				cnd = new CND_CHOOSEZONE();
				break;
			case ((-15 << 16) | 0xFFFB):
				cnd = new CND_NUMOFALLOBJECT();
				break;
			case ((-14 << 16) | 0xFFFB):
				cnd = new CND_NUMOFALLZONE();
				break;
			case ((-13 << 16) | 0xFFFB):
				cnd = new CND_NOMOREALLZONE();
				break;
			case ((-12 << 16) | 0xFFFB):
				cnd = new CND_CHOOSEFLAGRESET_OLD();
				break;
			case ((-11 << 16) | 0xFFFB):
				cnd = new CND_CHOOSEFLAGSET_OLD();
				break;
			case ((-8 << 16) | 0xFFFB):
				cnd = new CND_CHOOSEVALUE_OLD();
				break;
			case ((-7 << 16) | 0xFFFB):
				cnd = new CND_PICKFROMID_OLD();
				break;
			case ((-6 << 16) | 0xFFFB):
				cnd = new CND_CHOOSEALLINZONE_OLD();
				break;
			case ((-5 << 16) | 0xFFFB):
				cnd = new CND_CHOOSEALL_OLD();
				break;
			case ((-4 << 16) | 0xFFFB):
				cnd = new CND_CHOOSEZONE_OLD();
				break;
			case ((-3 << 16) | 0xFFFB):
				cnd = new CND_NUMOFALLOBJECT_OLD();
				break;
			case ((-2 << 16) | 0xFFFB):
				cnd = new CND_NUMOFALLZONE_OLD();
				break;
			case ((-1 << 16) | 0xFFFB):
				cnd = new CND_NOMOREALLZONE_OLD();
				break;
			case (((-80 - 1) << 16) | 7):
				cnd = new CND_CCOUNTER();
				break;
			case (((-80 - 3) << 16) | 4):
				cnd = new CND_QEQUAL();
				break;
			case (((-80 - 2) << 16) | 4):
				cnd = new CND_QFALSE();
				break;
			case (((-80 - 1) << 16) | 4):
				cnd = new CND_QEXACT();
				break;
			case (((-80 - 4) << 16) | (9 & 0x00FF)):
				cnd = new CND_CCAISPAUSED();
				break;
			case (((-80 - 3) << 16) | (9 & 0x00FF)):
				cnd = new CND_CCAISVISIBLE();
				break;
			case (((-80 - 2) << 16) | (9 & 0x00FF)):
				cnd = new CND_CCAAPPFINISHED();
				break;
			case (((-80 - 1) << 16) | (9 & 0x00FF)):
				cnd = new CND_CCAFRAMECHANGED();
				break;
			default:
				switch (c & 0xFFFF0000)
				{
				    case (-43 << 16):
				        cnd = new CND_EXTCMPVARCONST();
				        break;
				    case (-42 << 16):
				        cnd = new CND_EXTCMPVARCONST();
				        break;
				    case (-41 << 16):
						cnd = new CND_EXTONLOOP();
						break;
					case (-40 << 16):
						cnd = new CND_EXTISSTRIKEOUT();
						break;
					case (-39 << 16):
						cnd = new CND_EXTISUNDERLINE();
						break;
					case (-38 << 16):
						cnd = new CND_EXTISITALIC();
						break;
					case (-37 << 16):
						cnd = new CND_EXTISBOLD();
						break;
					case (-36 << 16):
						cnd = new CND_EXTCMPVARSTRING();
						break;
					case (-35 << 16):
						cnd = new CND_EXTPATHNODENAME();
						break;
					case (-34 << 16):
						cnd = new CND_EXTCHOOSE();
						break;
					case (-33 << 16):
						cnd = new CND_EXTNOMOREOBJECT();
						break;
					case (-32 << 16):
						cnd = new CND_EXTNUMOFOBJECT();
						break;
					case (-31 << 16):
						cnd = new CND_EXTNOMOREZONE();
						break;
					case (-30 << 16):
						cnd = new CND_EXTNUMBERZONE();
						break;
					case (-29 << 16):
						cnd = new CND_EXTSHOWN();
						break;
					case (-28 << 16):
						cnd = new CND_EXTHIDDEN();
						break;
					case (-27 << 16):
						cnd = new CND_EXTCMPVAR();
						break;
					case (-26 << 16):
						cnd = new CND_EXTCMPVARFIXED();
						break;
					case (-25 << 16):
						cnd = new CND_EXTFLAGSET();
						break;
					case (-24 << 16):
						cnd = new CND_EXTFLAGRESET();
						break;
					case (-23 << 16):
						cnd = new CND_EXTISCOLBACK();
						break;
					case (-22 << 16):
						cnd = new CND_EXTNEARBORDERS();
						break;
					case (-21 << 16):
						cnd = new CND_EXTENDPATH();
						break;
					case (-20 << 16):
						cnd = new CND_EXTPATHNODE();
						break;
					case (-19 << 16):
						cnd = new CND_EXTCMPACC();
						break;
					case (-18 << 16):
						cnd = new CND_EXTCMPDEC();
						break;
					case (-17 << 16):
						cnd = new CND_EXTCMPX();
						break;
					case (-16 << 16):
						cnd = new CND_EXTCMPY();
						break;
					case (-15 << 16):
						cnd = new CND_EXTCMPSPEED();
						break;
					case (-14 << 16):
						cnd = new CND_EXTCOLLISION();
						break;
					case (-13 << 16):
						cnd = new CND_EXTCOLBACK();
						break;
					case (-12 << 16):
						cnd = new CND_EXTOUTPLAYFIELD();
						break;
					case (-11 << 16):
						cnd = new CND_EXTINPLAYFIELD();
						break;
					case (-10 << 16):
						cnd = new CND_EXTISOUT();
						break;
					case (-9 << 16):
						cnd = new CND_EXTISIN();
						break;
					case (-8 << 16):
						cnd = new CND_EXTFACING();
						break;
					case (-7 << 16):
						cnd = new CND_EXTSTOPPED();
						break;
					case (-6 << 16):
						cnd = new CND_EXTBOUNCING();
						break;
					case (-5 << 16):
						cnd = new CND_EXTREVERSED();
						break;
					case (-4 << 16):
						cnd = new CND_EXTISCOLLIDING();
						break;
					case (-3 << 16):
						cnd = new CND_EXTANIMPLAYING();
						break;
					case (-2 << 16):
						cnd = new CND_EXTANIMENDOF();
						break;
					case (-1 << 16):
						cnd = new CND_EXTCMPFRAME();
						break;
					default:
						cnd = new CCndExtension();
						break;
				}
		}
		if (cnd != null)
		{
			cnd.evtCode = c;
			cnd.evtOi = app.file.readShort();
			cnd.evtOiList = app.file.readShort();
			cnd.evtFlags = app.file.readAByte();
			cnd.evtFlags2 = app.file.readAByte();
			cnd.evtNParams = app.file.readAByte();
			cnd.evtDefType = app.file.readAByte();
			cnd.evtIdentifier = app.file.readAShort();

			if (cnd.evtNParams > 0)
			{
				cnd.evtParams = new Array(cnd.evtNParams);
				var n;
				for (n = 0; n < cnd.evtNParams; n++)
				{
					cnd.evtParams[n] = CParam.create(app);
				}
			}
		}
		app.file.seek(debut + size);

		return cnd;
	}
	CCnd.negaTRUE = function (evtPtr)
	{
		if (evtPtr.evtFlags2 & CEvent.EVFLAG2_NOT)
			return false;
		return true;
	}
	CCnd.negaFALSE = function (evtPtr)
	{
		if (evtPtr.evtFlags2 & CEvent.EVFLAG2_NOT)
			return true;
		return false;
	}
	CCnd.negate = function (evtPtr, b)
	{
		if (evtPtr.evtFlags2 & CEvent.EVFLAG2_NOT)
			return !b;
		return b;
	}
	CCnd.compute_GlobalNoRepeat = function (rhPtr)
	{
		var evgPtr = rhPtr.rhEvtProg.rhEventGroup;
		var inhibit = evgPtr.evgInhibit;
		evgPtr.evgInhibit = rhPtr.rhLoopCount;
		var loopCount = rhPtr.rhLoopCount;
		if (loopCount == inhibit)
			return false;
		loopCount--;
		if (loopCount == inhibit)
			return false;
		return true;
	}
	CCnd.compute_NoRepeatCol = function (identifier, pHo)
	{
		var id;
		var n;

		var pArray = pHo.hoBaseNoRepeat;
		if (pArray == null)
		{
			pArray = new CArrayList();
			pHo.hoBaseNoRepeat = pArray;
		}
		else
		{
			for (n = 0; n < pArray.size(); n++)
			{
				if (pArray.get(n) == identifier)
					return false;
			}
		}
		pArray.add(identifier);

		pArray = pHo.hoPrevNoRepeat;
		if (pArray == null)
			return true;
		for (n = 0; n < pArray.size(); n++)
		{
			if (pArray.get(n) == identifier)
				return false;
		}
		return true;
	}
	CCnd.checkMark = function (rhPtr, mark)
	{
		if (mark == 0) return false;
		if (mark == rhPtr.rhLoopCount) return true;
		if (mark == rhPtr.rhLoopCount - 1) return true;
		return false;
	}
	function CND_NEVER()
	{
	}
	CND_NEVER.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return false;
		},
		eva2: function (rhPtr)
		{
			return false;
		}
	}
	function CND_ALWAYS()
	{
	}
	CND_ALWAYS.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return true;
		},
		eva2: function (rhPtr)
		{
			return true;
		}
	}
	function CCnd()
	{
	}
	CCnd.prototype =
	{
		compute_NoRepeat:  function (pHo)
		{
			return CCnd.compute_NoRepeatCol(this.evtIdentifier, pHo);
		},
		evaChooseValueOld: function (rhPtr, pRoutine)
		{
			var cpt = 0;

			var pHo = rhPtr.rhEvtProg.evt_FirstObjectFromType(COI.OBJ_SPR);
			while (pHo != null)
			{
				cpt++;
				var value = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				if (pRoutine.evaluate(pHo, value) == false)
				{
					cpt--;
					rhPtr.rhEvtProg.evt_DeleteCurrentObject();
				}
				pHo = rhPtr.rhEvtProg.evt_NextObjectFromType();
			}
			if (cpt != 0)
				return true;
			return false;
		},
		evaChooseValue:    function (rhPtr, pRoutine)
		{
			var cpt = 0;

			var pHo = rhPtr.rhEvtProg.evt_FirstObjectFromType(-1);
			while (pHo != null)
			{
				cpt++;
				var value = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				if (pRoutine.evaluate(pHo, value) == false)
				{
					cpt--;
					rhPtr.rhEvtProg.evt_DeleteCurrentObject();
				}
				pHo = rhPtr.rhEvtProg.evt_NextObjectFromType();
			}
			if (cpt != 0)
				return true;
			return false;
		},
		evaExpObject:      function (rhPtr, pRoutine)
		{
			var pHo = rhPtr.rhEvtProg.evt_FirstObject(this.evtOiList);
			var cpt = rhPtr.rhEvtProg.evtNSelectedObjects;
			var p = this.evtParams[0];
			var value;

			var token = p.tokens[0];
			if ( (token.code == CExp.EXP_LONG || token.code == CExp.EXP_DOUBLE) && p.tokens[1].code == 0 )
			{
				var value = token.value;
				while (pHo != null)
				{
					if (pRoutine.evaExpRoutine(pHo, value, p.comparaison) == false)
					{
						cpt--;
						rhPtr.rhEvtProg.evt_DeleteCurrentObject();
					}
					pHo = rhPtr.rhEvtProg.evt_NextObject();
				}
			}
			else
			{
				while (pHo != null)
				{
					value = rhPtr.get_EventExpressionInt(p);
					if (pRoutine.evaExpRoutine(pHo, value, p.comparaison) == false)
					{
						cpt--;
						rhPtr.rhEvtProg.evt_DeleteCurrentObject();
					}
					pHo = rhPtr.rhEvtProg.evt_NextObject();
				}
			}
			if (cpt != 0)
				return true;
			return false;
		},
		evaObject:         function (rhPtr, pRoutine)
		{
			var pHo = rhPtr.rhEvtProg.evt_FirstObject(this.evtOiList);
			var cpt = rhPtr.rhEvtProg.evtNSelectedObjects;
			while (pHo != null)
			{
				if (pRoutine.evaObjectRoutine(pHo) == false)
				{
					cpt--;
					rhPtr.rhEvtProg.evt_DeleteCurrentObject();
				}
				pHo = rhPtr.rhEvtProg.evt_NextObject();
			}
			if (cpt != 0)
				return true;
			return false;
		},
		compareCondition:  function (rhPtr, param, v)
		{
			var value2 = rhPtr.get_EventExpressionAny(this.evtParams[param]);
			var comp = this.evtParams[param].comparaison;
			return CRun.compareTo(v, value2, comp);
		},
		isColliding:       function (rhPtr)
		{
			if (rhPtr.rhEvtProg.rh4ConditionsFalse)
			{
				rhPtr.rhEvtProg.evt_FirstObject(this.evtOiList);
				rhPtr.rhEvtProg.evt_FirstObject(this.evtParams[0].oiList);
				return false;
			}

			var negate = false;
			if ((this.evtFlags2 & CEvent.EVFLAG2_NOT) != 0)
				negate = true;

			var pHo = rhPtr.rhEvtProg.evt_FirstObject(this.evtOiList);
			if (pHo == null)
				return CCnd.negaFALSE(this);
			var cpt = rhPtr.rhEvtProg.evtNSelectedObjects;

			var oi = this.evtParams[0].oi;
			var oi2List;
			if (oi >= 0)
			{
				rhPtr.isColArray[0] = oi;
				rhPtr.isColArray[1] = this.evtParams[0].oiList;
				oi2List = rhPtr.isColArray;
			}
			else
			{
				var qoil = rhPtr.rhEvtProg.qualToOiList[this.evtParams[0].oiList & 0x7FFF];
				oi2List = qoil.qoiList;
			}

			var bFlag = false;
			var list;
			var list2 = new CArrayList();
			var index, n;
			var pHo2;
			do
			{
				list = rhPtr.objectAllCol_IXY(pHo, pHo.roc.rcImage, pHo.roc.rcAngle, pHo.roc.rcScaleX, pHo.roc.rcScaleY, pHo.hoX, pHo.hoY, oi2List);
				if (list == null)
				{
					if (negate == false)
					{
						cpt--;
						rhPtr.rhEvtProg.evt_DeleteCurrentObject();
					}
				}
				else
				{
					bFlag = false;
					for (index = 0; index < list.size(); index++)
					{
						pHo2 = list.get(index);
						if ((pHo2.hoFlags & CObject.HOF_DESTROYED) == 0)
						{
							list2.add(pHo2);
							bFlag = true;
						}
					}

					if (negate == true)
					{
						if (bFlag == true)
						{
							cpt--;
							rhPtr.rhEvtProg.evt_DeleteCurrentObject();
						}
					}
					else
					{
						if (bFlag == false)
						{
							cpt--;
							rhPtr.rhEvtProg.evt_DeleteCurrentObject();
						}
					}
				}
				pHo = rhPtr.rhEvtProg.evt_NextObject();
			} while (pHo != null);

			if (cpt == 0)
				return false;

			pHo = rhPtr.rhEvtProg.evt_FirstObject(this.evtParams[0].oiList);
			if (pHo == null) return false;
			cpt = rhPtr.rhEvtProg.evtNSelectedObjects;
			if (negate == false)
			{
				do
				{
					for (index = 0; index < list2.size(); index++)
					{
						pHo2 = list2.get(index);
						if (pHo == pHo2)
						{
							break;
						}
					}
					if (index == list2.size())
					{
						cpt--;
						rhPtr.rhEvtProg.evt_DeleteCurrentObject();
					}
					pHo = rhPtr.rhEvtProg.evt_NextObject();
				} while (pHo != null);
				if (cpt != 0) return true;
				return false;
			}

			do
			{
				for (index = 0; index < list2.size(); index++)
				{
					pHo2 = list2.get(index);
					if (pHo == pHo2)
					{
						cpt--;
						rhPtr.rhEvtProg.evt_DeleteCurrentObject();
						break;
					}
				}
				pHo = rhPtr.rhEvtProg.evt_NextObject();
			} while (pHo != null);
			if (cpt != 0) return true;
			return false;
		}
	}
	// CUT

	// System conditions
	// ------------------------------------------------------------------

	function CND_CHANCE()
	{
	}
	CND_CHANCE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var param1 = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			var param2 = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			if (param1 >= param2)
			    return true;
			if (param2 >= 1 && param1 > 0 && param1 <= param2)
			{
				var rnd = rhPtr.random(param2);
				if (rnd <= param1)
				{
					return true;
				}
			}
			return false;
		}
	}
	// CUT

	function CND_COMPARE()
	{
	}
	CND_COMPARE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var value1 = rhPtr.get_EventExpressionAny(this.evtParams[0]);
			var value2 = rhPtr.get_EventExpressionAny(this.evtParams[1]);
			var comp = this.evtParams[1].comparaison;
			return CRun.compareTo(value1, value2, comp);
		}
	}
	// CUT

	function CND_COMPAREG()
	{
	}
	CND_COMPAREG.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var num;
			if (this.evtParams[0].code == 52)
				num = rhPtr.get_EventExpressionInt(this.evtParams[0]) - 1;
			else
				num = this.evtParams[0].value;

			var gValue = rhPtr.rhApp.getGlobalValueAt(num);
			var value = rhPtr.get_EventExpressionAny(this.evtParams[1]);
			var comp = this.evtParams[1].comparaison;
			return CRun.compareTo(gValue, value, comp);
		}
	}
	// -- CUT

	function CND_COMPAREGCONST_EQ() {
	}
	CND_COMPAREGCONST_EQ.prototype =
	{
	    eva1: function (rhPtr, hoPtr) {
	        return this.eva2(rhPtr);
	    },
	    eva2: function (rhPtr) {
	        var num = this.evtParams[0].value;
	        var gValue = rhPtr.rhApp.getGlobalValueAt(num);
	        var p = this.evtParams[1];
	        var value = p.tokens[0].value;
	        return gValue == value;
	    }
	}
	// -- CUT

	function CND_COMPAREGCONST_NE() {
	}
	CND_COMPAREGCONST_NE.prototype =
	{
	    eva1: function (rhPtr, hoPtr) {
	        return this.eva2(rhPtr);
	    },
	    eva2: function (rhPtr) {
	        var num = this.evtParams[0].value;
	        var gValue = rhPtr.rhApp.getGlobalValueAt(num);
	        var p = this.evtParams[1];
	        var value = p.tokens[0].value;
	        return gValue != value;
	    }
	}
	// -- CUT

	function CND_COMPAREGCONST_LE() {
	}
	CND_COMPAREGCONST_LE.prototype =
	{
	    eva1: function (rhPtr, hoPtr) {
	        return this.eva2(rhPtr);
	    },
	    eva2: function (rhPtr) {
	        var num = this.evtParams[0].value;
	        var gValue = rhPtr.rhApp.getGlobalValueAt(num);
	        var p = this.evtParams[1];
	        var value = p.tokens[0].value;
	        return gValue <= value;
	    }
	}
	// -- CUT

	function CND_COMPAREGCONST_LT() {
	}
	CND_COMPAREGCONST_LT.prototype =
	{
	    eva1: function (rhPtr, hoPtr) {
	        return this.eva2(rhPtr);
	    },
	    eva2: function (rhPtr) {
	        var num = this.evtParams[0].value;
	        var gValue = rhPtr.rhApp.getGlobalValueAt(num);
	        var p = this.evtParams[1];
	        var value = p.tokens[0].value;
	        return gValue < value;
	    }
	}
	// -- CUT

	function CND_COMPAREGCONST_GE() {
	}
	CND_COMPAREGCONST_GE.prototype =
	{
	    eva1: function (rhPtr, hoPtr) {
	        return this.eva2(rhPtr);
	    },
	    eva2: function (rhPtr) {
	        var num = this.evtParams[0].value;
	        var gValue = rhPtr.rhApp.getGlobalValueAt(num);
	        var p = this.evtParams[1];
	        var value = p.tokens[0].value;
	        return gValue >= value;
	    }
	}
	// -- CUT

	function CND_COMPAREGCONST_GT() {
	}
	CND_COMPAREGCONST_GT.prototype =
	{
	    eva1: function (rhPtr, hoPtr) {
	        return this.eva2(rhPtr);
	    },
	    eva2: function (rhPtr) {
	        var num = this.evtParams[0].value;
	        var gValue = rhPtr.rhApp.getGlobalValueAt(num);
	        var p = this.evtParams[1];
	        var value = p.tokens[0].value;
	        return gValue > value;
	    }
	}
	// CUT

	function CND_COMPAREGSTRING()
	{
	}
	CND_COMPAREGSTRING.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var num;
			if (this.evtParams[0].code == 59)
				num = rhPtr.get_EventExpressionInt(this.evtParams[0]) - 1;
			else
				num = this.evtParams[0].value;

			var gString = rhPtr.rhApp.getGlobalStringAt(num);
			var value = rhPtr.get_EventExpressionAny(this.evtParams[1]);
			var comp = this.evtParams[1].comparaison;
			return CRun.compareTo(gString, value, comp);
		}
	}
	// CUT

	function CND_GROUPACTIVATED()
	{
	}
	CND_GROUPACTIVATED.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var pEvg = rhPtr.rhEvtProg.events[this.evtParams[0].pointer];
			if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_INACTIVE) != 0)
				return CCnd.negaFALSE(this);
			return CCnd.negaTRUE(this);
		}
	}
	// CUT

	function CND_GROUPSTART()
	{
	}
	CND_GROUPSTART.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var pEvg = rhPtr.rhEvtProg.rhEventGroup;
			if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_ONCE) != 0)
	            return CCnd.negaFALSE(this);
			pEvg.evgFlags |= CEventGroup.EVGFLAGS_ONCE;
	        return CCnd.negaTRUE(this);
		}
	}
	// CUT

	function CND_NOMORE()
	{
	}
	CND_NOMORE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var pEvg = rhPtr.rhEvtProg.rhEventGroup;
	        if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_NOMORE) != 0) {
	            if (this.evtParams[0].code == CParam.PARAM_EXPRESSIONNUM)
	                pEvg.evgInhibit = rhPtr.get_EventExpressionInt(this.evtParams[0]) / 10;
	            return true;
	        }
			if ((pEvg.evgFlags & (CEventGroup.EVGFLAGS_REPEAT | CEventGroup.EVGFLAGS_NOTALWAYS)) != 0)
				return false;

			if (this.evtParams[0].code == CParam.PARAM_EXPRESSIONNUM)
				pEvg.evgInhibit = rhPtr.get_EventExpressionInt(this.evtParams[0]) / 10;
			else
				pEvg.evgInhibit = (this.evtParams[0].timer / 10);
			pEvg.evgInhibitCpt = 0;
			pEvg.evgFlags |= CEventGroup.EVGFLAGS_NOMORE;
			return true;
		}
	}
	// CUT

	function CND_NOTALWAYS()
	{
	}
	CND_NOTALWAYS.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var pEvg = rhPtr.rhEvtProg.rhEventGroup;
			if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_NOTALWAYS) != 0)
				return true;
			if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_NOMORE) != 0)
				return false;
			pEvg.evgInhibit = -2;
			pEvg.evgFlags |= CEventGroup.EVGFLAGS_NOTALWAYS;
			return true;
		}
	}
	// CUT

	function CND_ONCE()
	{
	}
	CND_ONCE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var pEvg = rhPtr.rhEvtProg.rhEventGroup;
			if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_ONCE) != 0)
				return false;
			pEvg.evgFlags |= CEventGroup.EVGFLAGS_ONCE;
			return true;
		}
	}
	// CUT

	function CND_ONLOOP()
	{
	}
	CND_ONLOOP.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			var pExp = this.evtParams[0];
			if (pExp.tokens.length == 2 && pExp.tokens[0].code == ((3 << 16) | 65535) && pExp.tokens[1].code == 0)
			{
				if (CServices.compareStringsIgnoreCase(rhPtr.rh4CurrentFastLoop, pExp.tokens[0].string))
				{
					return true;
				}
				return false;
			}

			var pName = rhPtr.get_EventExpressionString(pExp);
			if (CServices.compareStringsIgnoreCase(rhPtr.rh4CurrentFastLoop, pName) == false)
				return false;
			rhPtr.rhEvtProg.rh2ActionOn = false;
			return true;
		},
		eva2: function (rhPtr)
		{
			return false;
		}
	}
	// CUT

	function CND_REPEAT()
	{
	}
	CND_REPEAT.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var pEvg = rhPtr.rhEvtProg.rhEventGroup;
			if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_REPEAT) != 0)
				return true;
			if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_NOMORE) != 0)
				return false;

			pEvg.evgInhibitCpt = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			pEvg.evgFlags |= CEventGroup.EVGFLAGS_REPEAT;
			return true;
		}
	}
	// CUT


	// Create object conditions
	// -----------------------------------------------------------------
	function CND_CHOOSEALL()
	{
	}
	CND_CHOOSEALL.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			rhPtr.rhEvtProg.count_ObjectsFromType(0, -1);
			if (rhPtr.rhEvtProg.evtNSelectedObjects == 0)
				return false;
			var rnd = rhPtr.random(rhPtr.rhEvtProg.evtNSelectedObjects);
			var pHo = rhPtr.rhEvtProg.count_ObjectsFromType(0, rnd);
			rhPtr.rhEvtProg.evt_DeleteCurrent();
			rhPtr.rhEvtProg.evt_AddCurrentObject(pHo);
			return true;
		}
	}
	// CUT

	function CND_CHOOSEALL_OLD()
	{
	}
	CND_CHOOSEALL_OLD.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			rhPtr.rhEvtProg.count_ObjectsFromType(COI.OBJ_SPR, -1);
			if (rhPtr.rhEvtProg.evtNSelectedObjects == 0)
				return false;
			var rnd = rhPtr.random(rhPtr.rhEvtProg.evtNSelectedObjects);
			var pHo = rhPtr.rhEvtProg.count_ObjectsFromType(COI.OBJ_SPR, rnd);
			rhPtr.rhEvtProg.evt_DeleteCurrentType(COI.OBJ_SPR);
			rhPtr.rhEvtProg.evt_AddCurrentObject(pHo);
			return true;
		}
	}
	// CUT

	function CND_CHOOSEALLINLINE()
	{
	}
	CND_CHOOSEALLINLINE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var x1 = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			var y1 = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			var x2 = rhPtr.get_EventExpressionInt(this.evtParams[2]);
			var y2 = rhPtr.get_EventExpressionInt(this.evtParams[3]);

			if (rhPtr.rhEvtProg.select_LineOfSight(x1, y1, x2, y2) != 0)
				return true;
			return false;
		}
	}
	// CUT

	function CND_CHOOSEALLINZONE()
	{
	}
	CND_CHOOSEALLINZONE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			if (rhPtr.rhEvtProg.select_ZoneTypeObjects(this.evtParams[0], 0) != 0)
				return true;
			return false;
		}
	}
	// CUT

	function CND_CHOOSEALLINZONE_OLD()
	{
	}
	CND_CHOOSEALLINZONE_OLD.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			if (rhPtr.rhEvtProg.select_ZoneTypeObjects(this.evtParams[0], COI.OBJ_SPR) != 0)
				return true;
			return false;
		}
	}
	// CUT

	function CND_CHOOSEFLAGRESET()
	{
	}
	CND_CHOOSEFLAGRESET.prototype = CServices.extend(new CCnd(),
		{
			eva1:     function (rhPtr, hoPtr)
			{
				return this.eva2(rhPtr);
			},
			eva2:     function (rhPtr)
			{
				return this.evaChooseValue(rhPtr, this);
			},
			evaluate: function (pHo, value)
			{
				if (pHo.rov != null)
				{
					if ((pHo.rov.rvValueFlags & (1 << value)) == 0)
						return true;
				}
				return false;
			}
		});
	// CUT

	function CND_CHOOSEFLAGRESET_OLD()
	{
	}
	CND_CHOOSEFLAGRESET_OLD.prototype = CServices.extend(new CCnd(),
		{
			eva1:     function (rhPtr, hoPtr)
			{
				return this.eva2(rhPtr);
			},
			eva2:     function (rhPtr)
			{
				return this.evaChooseValueOld(rhPtr, this);
			},
			evaluate: function (pHo, value)
			{
				if (pHo.rov != null)
				{
					if ((pHo.rov.rvValueFlags & (1 << value)) == 0)
						return true;
				}
				return false;
			}
		});
	// CUT

	function CND_CHOOSEFLAGSET()
	{
	}
	CND_CHOOSEFLAGSET.prototype = CServices.extend(new CCnd(),
		{
			eva1:     function (rhPtr, hoPtr)
			{
				return this.eva2(rhPtr);
			},
			eva2:     function (rhPtr)
			{
				return this.evaChooseValue(rhPtr, this);
			},
			evaluate: function (pHo, value)
			{
				if (pHo.rov != null)
				{
					if ((pHo.rov.rvValueFlags & (1 << value)) != 0)
						return true;
				}
				return false;
			}
		});
	// CUT

	function CND_CHOOSEFLAGSET_OLD()
	{
	}
	CND_CHOOSEFLAGSET_OLD.prototype = CServices.extend(new CCnd(),
		{
			eva1:     function (rhPtr, hoPtr)
			{
				return this.eva2(rhPtr);
			},
			eva2:     function (rhPtr)
			{
				return this.evaChooseValueOld(rhPtr, this);
			},
			evaluate: function (pHo, value)
			{
				if (pHo.rov != null)
				{
					if ((pHo.rov.rvValueFlags & (1 << value)) != 0)
						return true;
				}
				return false;
			}
		});
	// CUT

	function CND_CHOOSEVALUE()
	{
	}
	CND_CHOOSEVALUE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var cpt = 0;

			var pHo = rhPtr.rhEvtProg.evt_FirstObjectFromType(-1);
			while (pHo != null)
			{
				cpt++;

				var number;
				if (this.evtParams[0].code == 53)
					number = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				else
					number = this.evtParams[0].value;
				var value2 = rhPtr.get_EventExpressionAny(this.evtParams[1]);

				if (pHo.rov != null)
				{
					var value = pHo.rov.getValue(number);
					var comp = this.evtParams[1].comparaison;
					if (CRun.compareTo(value, value2, comp) == false)
					{
						rhPtr.rhEvtProg.evt_DeleteCurrentObject();
						cpt--;
					}
				}
				pHo = rhPtr.rhEvtProg.evt_NextObjectFromType();
			}
			;
			if (cpt != 0)
				return true;
			return false;
		}
	}
	// CUT

	function CND_CHOOSEVALUE_OLD()
	{
	}
	CND_CHOOSEVALUE_OLD.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var cpt = 0;

			var pHo = rhPtr.rhEvtProg.evt_FirstObjectFromType(COI.OBJ_SPR);
			while (pHo != null)
			{
				cpt++;

				var number;
				if (evtParams[0].code == 53)
					number = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				else
					number = this.evtParams[0].value;
				var value2 = rhPtr.get_EventExpressionAny(this.evtParams[1]);

				if (pHo.rov != null)
				{
					var value = pHo.rov.getValue(number);
					var comp = this.evtParams[1].comparaison;
					if (CRun.compareTo(value, value2, comp) == false)
					{
						rhPtr.rhEvtProg.evt_DeleteCurrentObject();
						cpt--;
					}
				}
				pHo = rhPtr.rhEvtProg.evt_NextObjectFromType();
			}
			;
			if (cpt != 0)
				return true;
			return false;
		}
	}
	// CUT

	function CND_CHOOSEZONE()
	{
	}
	CND_CHOOSEZONE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var p = this.evtParams[0];
			rhPtr.rhEvtProg.count_ZoneTypeObjects(p, -1, 0);
			if (rhPtr.rhEvtProg.evtNSelectedObjects == 0)
				return false;

			var rnd = rhPtr.random(rhPtr.rhEvtProg.evtNSelectedObjects);
			var pHo = rhPtr.rhEvtProg.count_ZoneTypeObjects(p, rnd, 0);
			rhPtr.rhEvtProg.evt_DeleteCurrent();
			rhPtr.rhEvtProg.evt_AddCurrentObject(pHo);
			return true;
		}
	}
	// CUT

	function CND_CHOOSEZONE_OLD()
	{
	}
	CND_CHOOSEZONE_OLD.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var p = this.evtParams[0];
			rhPtr.rhEvtProg.count_ZoneTypeObjects(p, -1, COI.OBJ_SPR);
			if (rhPtr.rhEvtProg.evtNSelectedObjects == 0)
				return false;

			var rnd = rhPtr.random(rhPtr.rhEvtProg.evtNSelectedObjects);
			var pHo = rhPtr.rhEvtProg.count_ZoneTypeObjects(p, rnd, COI.OBJ_SPR);
			rhPtr.rhEvtProg.evt_DeleteCurrent();
			rhPtr.rhEvtProg.evt_AddCurrentObject(pHo);
			return true;
		}
	}
	// CUT

	function CND_NOMOREALLZONE()
	{
	}
	CND_NOMOREALLZONE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			rhPtr.rhEvtProg.count_ZoneTypeObjects(this.evtParams[0], -1, 0);
			if (rhPtr.rhEvtProg.evtNSelectedObjects != 0)
				return false;
			return true;
		}
	}
	// CUT

	function CND_NOMOREALLZONE_OLD()
	{
	}
	CND_NOMOREALLZONE_OLD.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			rhPtr.rhEvtProg.count_ZoneTypeObjects(this.evtParams[0], -1, COI.OBJ_SPR);
			if (rhPtr.rhEvtProg.evtNSelectedObjects != 0)
				return false;
			return true;
		}
	}
	// CUT

	function CND_NUMOFALLOBJECT()
	{
	}
	CND_NUMOFALLOBJECT.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var value2 = rhPtr.get_EventExpressionAny(this.evtParams[0]);
			var comp = this.evtParams[0].comparaison;
			return CRun.compareTo(rhPtr.rhNObjects, value2, comp);
		}
	}
	// CUT

	function CND_NUMOFALLOBJECT_OLD()
	{
	}
	CND_NUMOFALLOBJECT_OLD.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			rhPtr.rhEvtProg.count_ObjectsFromType(COI.OBJ_SPR, -1);
			var value2 = rhPtr.get_EventExpressionAny(this.evtParams[0]);
			var comp = this.evtParams[0].comparaison;
			return CRun.compareTo(rhPtr.rhEvtProg.evtNSelectedObjects, value2, comp);
		}
	}
	// CUT

	function CND_NUMOFALLZONE()
	{
	}
	CND_NUMOFALLZONE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			rhPtr.rhEvtProg.count_ZoneTypeObjects(this.evtParams[0], -1, 0);
			var value2 = rhPtr.get_EventExpressionAny(this.evtParams[1]);
			var comp = this.evtParams[1].comparaison;
			return CRun.compareTo(rhPtr.rhEvtProg.evtNSelectedObjects, value2, comp);
		}
	}
	// CUT

	function CND_NUMOFALLZONE_OLD()
	{
	}
	CND_NUMOFALLZONE_OLD.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			rhPtr.rhEvtProg.count_ZoneTypeObjects(this.evtParams[0], -1, COI.OBJ_SPR);

			var value2 = rhPtr.get_EventExpressionAny(this.evtParams[1]);
			var comp = this.evtParams[1].comparaison;
			return CRun.compareTo(rhPtr.rhEvtProg.evtNSelectedObjects, value2, comp);
		}
	}
	// CUT

	function CND_PICKFROMID()
	{
	}
	CND_PICKFROMID.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var value = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			return rhPtr.rhEvtProg.pickFromId(value);
		}
	}
	// CUT

	function CND_PICKFROMID_OLD()
	{
	}
	CND_PICKFROMID_OLD.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var value = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			return rhPtr.rhEvtProg.pickFromId(value);
		}
	}
	// CUT

	function CND_EXTCHOOSE()
	{
	}
	CND_EXTCHOOSE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			rhPtr.rhEvtProg.count_ObjectsFromOiList(this.evtOiList, -1);
			if (rhPtr.rhEvtProg.evtNSelectedObjects == 0)
				return false;
			var rnd = rhPtr.random(rhPtr.rhEvtProg.evtNSelectedObjects);
			var pHo = rhPtr.rhEvtProg.count_ObjectsFromOiList(this.evtOiList, rnd);
			if ( this.evtNParams > 0 )
			{
			    var p = this.evtParams[0];
			    if (p.code == 68) {       // PARAM_MULTIPLEVAR)
			        if (p.evaluate(pHo) == false) {
			            return false;
			        }
			    }
			}
			rhPtr.rhEvtProg.evt_ForceOneObject(this.evtOiList, pHo);
			return true;
		}
	}
	// CUT

	function CND_EXTONLOOP()
	{
	}
	CND_EXTONLOOP.prototype =
	{
		eva1: function (rhPtr, pHo)
		{
			var pName = rhPtr.get_EventExpressionString(this.evtParams[0]);
			if (rhPtr.rh4CurrentForEach != null)
			{
				if (CServices.compareStringsIgnoreCase(rhPtr.rh4CurrentForEach.name, pName))
				{
				    if (this.evtNParams > 1) {
				        var p = this.evtParams[1];  // PARAM_MULTIPLEVAR
			            if (p.evaluate(pHo) == false) {
			                return false;
			            }
				    }
				    rhPtr.rhEvtProg.evt_ForceOneObject(this.evtOiList, pHo);
					return true;
				}
			}
			if (rhPtr.rh4CurrentForEach2 != null)
			{
				if (CServices.compareStringsIgnoreCase(rhPtr.rh4CurrentForEach2.name, pName))
				{
				    if (this.evtNParams > 1) {
				        var p = this.evtParams[1];  // PARAM_MULTIPLEVAR
				        if (p.evaluate(pHo) == false) {
				            return false;
				        }
				    }
				    rhPtr.rhEvtProg.evt_ForceOneObject(this.evtOiList, pHo);
					return true;
				}
			}
			return false;
		},
		eva2: function (rhPtr)
		{
			var pHo2 = null;
			var pName = rhPtr.get_EventExpressionString(this.evtParams[0]);
			var pForEach = rhPtr.rh4CurrentForEach;
			if (pForEach != null)
			{
				if (CServices.compareStringsIgnoreCase(pForEach.name, pName))
				{
				    if (pForEach.oi == this.evtOiList)
					{
						var index = pForEach.index % pForEach.number;
						pHo2 = pForEach.objects[index];
					}
				}
			}
			pForEach = rhPtr.rh4CurrentForEach2;
			if (pForEach != null)
			{
				if (CServices.compareStringsIgnoreCase(pForEach.name, pName))
				{
				    if (pForEach.oi == this.evtOiList)
					{
						var index = pForEach.index % pForEach.number;
						pHo2 = pForEach.objects[index];
					}
				}
			}
			if (pHo2 != null)
			{
			    if (this.evtNParams > 1) {
			        var p = this.evtParams[1];  // PARAM_MULTIPLEVAR
			        if (p.evaluate(pHo2) == false) {
			            return false;
			        }
			    }
			    rhPtr.rhEvtProg.evt_ForceOneObject(this.evtOiList, pHo2);
				return true;
			}
			return false;
		}
	}
	// CUT


	// Storyboard object
	// ---------------------------------------------------------------------
	function CND_ENDOFPAUSE()
	{
	}
	CND_ENDOFPAUSE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return true;
		},
		eva2: function (rhPtr)
		{
			if (rhPtr.rh4EndOfPause != rhPtr.rhLoopCount - 1)
				return false;
			return true;
		}
	}
	// CUT


	function CND_ISVSYNCON()
	{
	}
	CND_ISVSYNCON.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return (rhPtr.rhApp.gaNewFlags & CRunApp.GANF_VSYNC) != 0 && window.requestAnimationFrame;
			;
		},
		eva2: function (rhPtr)
		{
			return (rhPtr.rhApp.gaNewFlags & CRunApp.GANF_VSYNC) != 0 && window.requestAnimationFrame;
			;
		}
	}
	// CUT

	function CND_ISLADDER()
	{
	}
	CND_ISLADDER.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var x = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			var y = rhPtr.get_EventExpressionInt(this.evtParams[1]);

			if (rhPtr.y_GetLadderAt(-1, x, y) != null)
				return CCnd.negaTRUE(this);
			return CCnd.negaFALSE(this);
		}
	}
	// CUT

	function CND_ISOBSTACLE()
	{
	}
	CND_ISOBSTACLE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var x = rhPtr.get_EventExpressionInt(this.evtParams[0]) - rhPtr.rhWindowX;
			var y = rhPtr.get_EventExpressionInt(this.evtParams[1]) - rhPtr.rhWindowY;

			if (rhPtr.colMask_Test_XY(x, y, -1, CRunFrame.CM_TEST_OBSTACLE))
				return CCnd.negaTRUE(this);
			return CCnd.negaFALSE(this);
		}
	}
	// CUT

	function CND_QUITAPPLICATION()
	{
	}
	CND_QUITAPPLICATION.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return true;
		},
		eva2: function (rhPtr)
		{
			return false;
		}
	}
	// CUT

	function CND_START()
	{
	}
	CND_START.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			if (rhPtr.rhLoopCount > 2)
				return false;
			return true;
		},
		eva2: function (rhPtr)
		{
			if (rhPtr.rhLoopCount > 2)
				return false;
			return true;
		}
	}
	// CUT


	// Timer object
	// -----------------------------------------------------------------------
	function CND_ONEVENT()
	{
	}
	CND_ONEVENT.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var pName = rhPtr.get_EventExpressionString(this.evtParams[0]);
			return CServices.compareStringsIgnoreCase(pName, rhPtr.rhEvtProg.rhCurParam0);
		}
	}
	// CUT
	function CND_EVERY()
	{
	}
	CND_EVERY.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var p = this.evtParams[0];
			p.compteur -= rhPtr.rhTimerDelta;
			if (p.compteur > 0)
				return false;
			p.compteur += p.delay;
			return true;
		}
	}
	// CUT

	function CND_TIMEOUT()
	{
	}
	CND_TIMEOUT.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var time;
			if (this.evtParams[0].code == 22)
				time = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			else
				time = this.evtParams[0].timer;

			if (rhPtr.rh4TimeOut > time)
				return true;
			return false;
		}
	}
	// CUT

	function CND_TIMER()
	{
	}
	CND_TIMER.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			if ((this.evtFlags & CEvent.EVFLAGS_DONE) != 0)
				return  false;

			var time = this.evtParams[0].timer;
			if (rhPtr.rhTimer < time)
				return false;
			this.evtFlags |= CEvent.EVFLAGS_DONE;
			return true;
		},
		eva2: function (rhPtr)
		{
			return false;
		}
	}
	// CUT

	function CND_TIMERINF()
	{
	}
	CND_TIMERINF.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var time;
			if (this.evtParams[0].code == 22)
				time = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			else
				time = this.evtParams[0].timer;

			if (rhPtr.rhTimer > time)
				return false;

			return true;
		}
	}
	// CUT

	function CND_EVERY2()
	{
	}
	CND_EVERY2.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var param2 = this.evtParams[1];
			var time;

			if (param2.value2 == 0)
			{
				if (this.evtParams[0].code == 22)
					time = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				else
					time = this.evtParams[0].timer;
				param2.value = time;
				param2.value2 = -1;
			}
			else
			{
				param2.value -= rhPtr.rhTimerDelta;
				if (param2.value <= 0)
				{
					if (this.evtParams[0].code == 22)
						time = rhPtr.get_EventExpressionInt(this.evtParams[0]);
					else
						time = this.evtParams[0].timer;
					param2.value += time;
					return true;
				}
			}
			return false;
		}
	}
	// CUT

	function CND_TIMEREQUALS()
	{
	}
	CND_TIMEREQUALS.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var time;
			if (this.evtParams[0].code == 22)
				time = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			else
				time = this.evtParams[0].timer;

			var param2 = this.evtParams[1];
			if (rhPtr.rhTimer >= time)
			{
				if (param2.value == rhPtr.rhLoopCount)
				{
					param2.value = rhPtr.rhLoopCount + 1;
					return false;
				}
				param2.value = rhPtr.rhLoopCount + 1;
				return true;
			}
			return false;
		}
	}
	// CUT

	function CND_TIMERSUP()
	{
	}
	CND_TIMERSUP.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var time;
			if (this.evtParams[0].code == 22)
				time = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			else
				time = this.evtParams[0].timer;

			if (rhPtr.rhTimer > time)
				return true;

			return false;
		}
	}
	// CUT


	// Player object
	// --------------------------------------------------------------------
	function CND_JOYPRESSED()
	{
	}
	CND_JOYPRESSED.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			var joueur = this.evtOi;
			if (joueur != rhPtr.rhEvtProg.rhCurOi)
				return false;

			var j = rhPtr.rhEvtProg.rhCurParam0;
			j &= this.evtParams[0].value;
			if (j != this.evtParams[0].value)
				return false;
			return true;
		},
		eva2: function (rhPtr)
		{
			var joueur = this.evtOi;
			var b = (rhPtr.rh2NewPlayer[joueur] & rhPtr.rhPlayer[joueur]);

			var s = b;
			s &= this.evtParams[0].value;
			if (this.evtParams[0].value != s)
				return false;
			return true;
		}
	}
	// CUT

	function CND_JOYPUSHED()
	{
	}
	CND_JOYPUSHED.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var s = rhPtr.rhPlayer[this.evtOi];
			s &= this.evtParams[0].value;
			if (s != this.evtParams[0].value)
				return CCnd.negaFALSE(this);
			return CCnd.negaTRUE(this);
		}
	}
	// CUT

	function CND_LIVE()
	{
	}
	CND_LIVE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var value2 = rhPtr.get_EventExpressionAny(this.evtParams[0]);
			var comp = this.evtParams[0].comparaison;
			return CRun.compareTo(rhPtr.rhApp.getLives()[this.evtOi], value2, comp);
		}
	}
	// CUT

	function CND_NOMORELIVE()
	{
	}
	CND_NOMORELIVE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			if (rhPtr.rhApp.getLives()[this.evtOi] != 0)
				return false;
			return true;
		}
	}
	// CUT

	// TODO dans tous les runtimes
	function CND_PLAYERPLAYING()
	{
	}
	CND_PLAYERPLAYING.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return false;
		},
		eva2: function (rhPtr)
		{
			return false;
		}
	}
	// CUT

	function CND_SCORE()
	{
	}
	CND_SCORE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var scores = rhPtr.rhApp.getScores();
			var value2 = rhPtr.get_EventExpressionAny(this.evtParams[0]);
			var comp = this.evtParams[0].comparaison;
			return CRun.compareTo(scores[this.evtOi], value2, comp);
		}
	}
	// CUT


	// Keyboard object
	// -------------------------------------------------------------------
	function CND_KBKEYDEPRESSED()
	{
	}
	CND_KBKEYDEPRESSED.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			return CCnd.negate(this, rhPtr.rhApp.keyBuffer[this.evtParams[0].key]);
		}
	}
	// CUT

	function CND_KBPRESSKEY()
	{
	}
	CND_KBPRESSKEY.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			if (rhPtr.rhApp.keyBuffer[this.evtParams[0].key] == false)
				return CCnd.negaFALSE(this);
			if (CCnd.compute_GlobalNoRepeat(rhPtr))
				return CCnd.negaTRUE(this);
			else
				return CCnd.negaFALSE(this);
		}
	}

	// CUT
	function CND_MCLICK()
	{
	}
	CND_MCLICK.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			var key = rhPtr.rhEvtProg.rhCurParam0;
			if (this.evtParams[0].value != key)
				return false;
			return true;
		},
		eva2: function (rhPtr)
		{
			if (this.evtParams[0].value == rhPtr.rhEvtProg.rh2CurrentClick)
				return true;
			return false;
		}
	}
	// CUT

	function CND_MCLICKINZONE()
	{
	}
	CND_MCLICKINZONE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			var key = rhPtr.rhEvtProg.rhCurParam0;
			if (this.evtParams[0].value == key)
			{
				var p = this.evtParams[1];
				if (rhPtr.rh2MouseX >= p.x1 && rhPtr.rh2MouseX < p.x2 && rhPtr.rh2MouseY >= p.y1 && rhPtr.rh2MouseY < p.y2)
				{
					return true;
				}
			}
			return false;
		},
		eva2: function (rhPtr)
		{
			if (this.evtParams[0].value == rhPtr.rhEvtProg.rh2CurrentClick)
			{
				var p = this.evtParams[1];
				if (rhPtr.rh2MouseX >= p.x1 && rhPtr.rh2MouseX < p.x2 && rhPtr.rh2MouseY >= p.y1 && rhPtr.rh2MouseY < p.y2)
				{
					return true;
				}
			}
			return false;
		}
	}
	// CUT

	function CND_MCLICKONOBJECT()
	{
	}
	CND_MCLICKONOBJECT.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			var p = this.evtParams[0];
			if (rhPtr.rhEvtProg.rhCurParam0 != p.value)
				return false;

			var oi = rhPtr.rhEvtProg.rhCurParam1;
			var po = this.evtParams[1];
			if (oi == po.oi)
			{
				rhPtr.rhEvtProg.evt_AddCurrentObject(rhPtr.rhEvtProg.rh4_2ndObject);
				return true;
			}

			var oil = po.oiList;
			if ((oil & 0x8000) == 0)
				return false;
			var qoil = rhPtr.rhEvtProg.qualToOiList[oil & 0x7FFF];
			var qoi;
			for (qoi = 0; qoi < qoil.qoiList.length; qoi += 2)
			{
				if (qoil.qoiList[qoi] == oi)
				{
					rhPtr.rhEvtProg.evt_AddCurrentQualifier(oil);
					rhPtr.rhEvtProg.evt_AddCurrentObject(rhPtr.rhEvtProg.rh4_2ndObject);
					return true;
				}
			}
			return false;
		},
		eva2: function (rhPtr)
		{
			var p = this.evtParams[0];
			if (rhPtr.rhEvtProg.rh2CurrentClick != p.value)
				return false;

			var po = this.evtParams[1];
			return rhPtr.getMouseOnObjectsEDX(po.oiList, false);
		}
	}
	// CUT

	function CND_MINZONE()
	{
	}
	CND_MINZONE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var p = this.evtParams[0];
			if (rhPtr.rh2MouseX >= p.x1 && rhPtr.rh2MouseX < p.x2 && rhPtr.rh2MouseY >= p.y1 && rhPtr.rh2MouseY < p.y2)
				return CCnd.negaTRUE(this);
			return CCnd.negaFALSE(this);
		}
	}
	// CUT

	function CND_MKEYDEPRESSED()
	{
	}
	CND_MKEYDEPRESSED.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var code = 0;
			switch (this.evtParams[0].key)
			{
				case 1:
					code = CRunApp.VK_LBUTTON;
					break;
				case 2:
					code = CRunApp.VK_RBUTTON;
					break;
				case 4:
					code = CRunApp.VK_MBUTTON;
					break;
			}
			if (rhPtr.rhApp.keyBuffer[code] == false)
				return CCnd.negaFALSE(this);
			return CCnd.negaTRUE(this);
		}
	}
	// CUT

	function CND_MONOBJECT()
	{
	}
	CND_MONOBJECT.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var flag = (this.evtFlags2 & CEvent.EVFLAG2_NOT) != 0;
			return rhPtr.getMouseOnObjectsEDX(this.evtParams[0].oiList, flag);
		}
	}
	// CUT

	function CND_MOUSEON()
	{
	}
	CND_MOUSEON.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			if (rhPtr.isMouseOn())
			{
				return CCnd.negaTRUE(this);
			}
			return CCnd.negaFALSE(this);
		}
	}
	// CUT

	function CND_ONMOUSEWHEELDOWN()
	{
	}
	CND_ONMOUSEWHEELDOWN.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return true;
		},
		eva2: function (rhPtr)
		{
			if (rhPtr.rhWheelCount == rhPtr.rh4EventCount)
			{
				return true;
			}
			return false;
		}
	}
	// CUT

	function CND_ONMOUSEWHEELUP()
	{
	}
	CND_ONMOUSEWHEELUP.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return true;
		},
		eva2: function (rhPtr)
		{
			if (rhPtr.rhWheelCount == rhPtr.rh4EventCount)
			{
				return true;
			}
			return false;
		}
	}
	// CUT

	function CND_ANYKEY()
	{
	}
	CND_ANYKEY.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return true;
		},
		eva2: function (rhPtr)
		{
			return false;
		}
	}
	// CUT

	// Speaker object
	// -----------------------------------------------------------------------
	function CND_NOSAMPLAYING()
	{
	}
	CND_NOSAMPLAYING.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			if (!rhPtr.rhApp.soundPlayer.isSoundPlaying())
			{
				return CCnd.negaTRUE(this);
			}
			return CCnd.negaFALSE(this);
		}
	}
	// CUT

	function CND_NOSPCHANNELPLAYING()
	{
	}
	CND_NOSPCHANNELPLAYING.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var channel = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			if (!rhPtr.rhApp.soundPlayer.isChannelPlaying(channel - 1))
			{
				return CCnd.negaTRUE(this);
			}
			return CCnd.negaFALSE(this);
		}
	}
	// CUT

	function CND_NOSPSAMPLAYING()
	{
	}
	CND_NOSPSAMPLAYING.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
		    var p = this.evtParams[0];
		    var bPlaying = false;
		    var nSound = -1;
		    // PARAM_EXPSTRING?
		    if (p.code == 45) {
		        var name = rhPtr.get_EventExpressionString(p);
		        nSound = rhPtr.rhApp.soundBank.getSoundHandleFromName(name);
		    }
		    else {
		        nSound = p.sndHandle;
		    }
		    if ( nSound >= 0 )
		        bPlaying = rhPtr.rhApp.soundPlayer.isSamplePlaying(nSound);
		    if (!bPlaying)
			{
				return CCnd.negaTRUE(this);
			}
			return CCnd.negaFALSE(this);
		}
	}
	// CUT

	function CND_SPCHANNELPAUSED()
	{
	}
	CND_SPCHANNELPAUSED.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var channel = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			if (rhPtr.rhApp.soundPlayer.isChannelPaused(channel - 1))
			{
				return CCnd.negaTRUE(this);
			}
			return CCnd.negaFALSE(this);
		}
	}
	// CUT

	function CND_SPSAMPAUSED()
	{
	}
	CND_SPSAMPAUSED.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var p = this.evtParams[0];
			var bPaused = false;
			var nSound = -1;
		    // PARAM_EXPSTRING?
			if (p.code == 45) {
			    var name = rhPtr.get_EventExpressionString(p);
			    nSound = rhPtr.rhApp.soundBank.getSoundHandleFromName(name);
			}
			else {
			    nSound = p.sndHandle;
			}
			if (nSound >= 0)
			    bPaused = rhPtr.rhApp.soundPlayer.isSamplePaused(nSound);
			if (bPaused)
			{
				return CCnd.negaTRUE(this);
			}
			return CCnd.negaFALSE(this);
		}
	}
	// CUT


	// Question and Answer object
	// --------------------------------------------------------------
	function CND_QEQUAL()
	{
	}
	CND_QEQUAL.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			var num = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			if (rhPtr.rhEvtProg.rhCurParam0 == num)
				return true;
			return false;
		},
		eva2: function (rhPtr)
		{
			return false;
		}
	}
	// CUT

	function CND_QEXACT()
	{
	}
	CND_QEXACT.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return true;
		},
		eva2: function (rhPtr)
		{
			return false;
		}
	}
	// CUT

	function CND_QFALSE()
	{
	}
	CND_QFALSE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return true;
		},
		eva2: function (rhPtr)
		{
			return false;
		}
	}
	// CUT

	// Sub-Application object
	// ------------------------------------------------------------
	function CND_CCAAPPFINISHED()
	{
	}
	CND_CCAAPPFINISHED.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				return CCnd.negate(this, hoPtr.appFinished());
			}
		});
	// CUT

	function CND_CCAFRAMECHANGED()
	{
	}
	CND_CCAFRAMECHANGED.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				return CCnd.negate(this, hoPtr.frameChanged());
			}
		});
	// CUT

	function CND_CCAISPAUSED()
	{
	}
	CND_CCAISPAUSED.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				return CCnd.negate(this, hoPtr.isPaused());
			}
		});
	// CUT

	function CND_CCAISVISIBLE()
	{
	}
	CND_CCAISVISIBLE.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				return CCnd.negate(this, hoPtr.isVisible());
			}
		});
	// CUT

	// Counter object
	// -------------------------------------------------------------
	function CND_CCOUNTER()
	{
	}
	CND_CCOUNTER.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.evt_FirstObject(this.evtOiList);
			var cpt = rhPtr.rhEvtProg.evtNSelectedObjects;
			var value1, value2;
			while (pHo != null)
			{
				value1 = pHo.cpt_GetValue();
				value2 = rhPtr.get_EventExpressionAny(this.evtParams[0]);
				if (CRun.compareTo(value1, value2, this.evtParams[0].comparaison) == false)
				{
					cpt--;
					rhPtr.rhEvtProg.evt_DeleteCurrentObject();
				}
				pHo = rhPtr.rhEvtProg.evt_NextObject();
			}
			;
			return (cpt != 0);
		}
	}
	// CUT

	// Active and extension objects
	// ----------------------------------------------------------------
	function CND_EXTHIDDEN()
	{
	}
	CND_EXTHIDDEN.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				if ((hoPtr.ros.rsFlags & CRSpr.RSFLAG_HIDDEN) != 0)
					return true;
				return false;
			}
		});
	// CUT

	function CND_EXTANIMENDOF()
	{
	}
	CND_EXTANIMENDOF.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				var ani;
				if (this.evtParams[0].code == 10)
					ani = this.evtParams[0].value;
				else
					ani = rhPtr.get_EventExpressionInt(this.evtParams[0]);

				if (ani != rhPtr.rhEvtProg.rhCurParam0)
					return false;
				rhPtr.rhEvtProg.evt_AddCurrentObject(hoPtr);
				return true;
			},
			eva2:             function (rhPtr)
			{
				if (this.evtParams[0].code == 10)
					return this.evaObject(rhPtr, this);
				return this.evaExpObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				var anim = this.evtParams[0].value;
				if (anim != hoPtr.roa.raAnimOn)
					return false;
				if (hoPtr.roa.raAnimNumberOfFrame == 0)
					return true;
				return false;
			},
			evaExpRoutine:    function (hoPtr, value, comp)
			{
				if (value != hoPtr.roa.raAnimOn)
					return false;
				if (hoPtr.roa.raAnimNumberOfFrame == 0)
					return true;
				return false;
			}
		});
	// CUT

	function CND_EXTANIMPLAYING()
	{
	}
	CND_EXTANIMPLAYING.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.eva2(rhPtr);
			},
			eva2:             function (rhPtr)
			{
				if (this.evtParams[0].code == 10)
					return this.evaObject(rhPtr, this);
				return this.evaExpObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				var anim = this.evtParams[0].value;
				if (anim != hoPtr.roa.raAnimOn)
					return CCnd.negaFALSE(this);
				if (hoPtr.roa.raAnimNumberOfFrame != 0)
					return CCnd.negaTRUE(this);
				return CCnd.negaFALSE(this);
			},
			evaExpRoutine:    function (hoPtr, value, comp)
			{
				if (value != hoPtr.roa.raAnimOn)
					return CCnd.negaFALSE(this);
				if (hoPtr.roa.raAnimNumberOfFrame != 0)
					return CCnd.negaTRUE(this);
				return CCnd.negaFALSE(this);
			}
		});
	// CUT

	function CND_EXTBOUNCING()
	{
	}
	CND_EXTBOUNCING.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				return CCnd.negate(this, hoPtr.rom.rmBouncing);
			}
		});
	// CUT

	function CND_EXTCMPACC()
	{
	}
	CND_EXTCMPACC.prototype = CServices.extend(new CCnd(),
		{
			eva1:          function (rhPtr, hoPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			eva2:          function (rhPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			evaExpRoutine: function (hoPtr, value, comp)
			{
				return CRun.compareTer(hoPtr.rom.rmMovement.rmAcc, value, comp);
			}
		});
	// CUT

	function CND_EXTCMPDEC()
	{
	}
	CND_EXTCMPDEC.prototype = CServices.extend(new CCnd(),
		{
			eva1:          function (rhPtr, hoPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			eva2:          function (rhPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			evaExpRoutine: function (hoPtr, value, comp)
			{
				return CRun.compareTer(hoPtr.rom.rmMovement.rmDec, value, comp);
			}
		});
	// CUT

	function CND_EXTCMPFRAME()
	{
	}
	CND_EXTCMPFRAME.prototype = CServices.extend(new CCnd(),
		{
			eva1:          function (rhPtr, hoPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			eva2:          function (rhPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			evaExpRoutine: function (hoPtr, value, comp)
			{
				return CRun.compareTer(hoPtr.roa.raAnimFrame, value, comp);
			}
		});
	// CUT

	function CND_EXTCMPSPEED()
	{
	}
	CND_EXTCMPSPEED.prototype = CServices.extend(new CCnd(),
		{
			eva1:          function (rhPtr, hoPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			eva2:          function (rhPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			evaExpRoutine: function (hoPtr, value, comp)
			{
				return CRun.compareTer(hoPtr.roc.rcSpeed, value, comp);
			}
		});
	// CUT

	function CND_EXTCMPVAR()
	{
	}
	CND_EXTCMPVAR.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.evt_FirstObject(this.evtOiList);
			if (pHo == null) return false;

			var cpt = rhPtr.rhEvtProg.evtNSelectedObjects;
			var value1;
			var value2;
			var p = this.evtParams[1];
			do
			{
				var num;
				if (this.evtParams[0].code == 53)
					num = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				else
					num = this.evtParams[0].value;

				if (num >= 0 && pHo.rov != null)
				{
					if (num < pHo.rov.rvValues.length)
						value1 = pHo.rov.getValue(num);
					else
						value1 = 0;
					value2 = rhPtr.get_EventExpressionAny(p);

					if (CRun.compareTo(value1, value2, p.comparaison) == false)
					{
						cpt--;
						rhPtr.rhEvtProg.evt_DeleteCurrentObject();
					}
				}
				else
				{
					cpt--;
					rhPtr.rhEvtProg.evt_DeleteCurrentObject();
				}
				pHo = rhPtr.rhEvtProg.evt_NextObject();
			} while (pHo != null);
			return (cpt != 0);
		}
	}
	// -- CUT

	function CND_EXTCMPVARCONST() {
	}
	CND_EXTCMPVARCONST.prototype =
	{
	    eva1: function (rhPtr, hoPtr) {
	        return this.eva2(rhPtr);
	    },
	    eva2: function (rhPtr) {
	        var pHo = rhPtr.rhEvtProg.evt_FirstObject(this.evtOiList);
	        if (pHo == null) return false;

	        var cpt = rhPtr.rhEvtProg.evtNSelectedObjects;
	        var num = this.evtParams[0].value;
	        var p = this.evtParams[1];
	        var value1;
	        var value2 = p.tokens[0].value;
	        do {

	            if (num >= 0 && pHo.rov != null)
	            {
	                if (num < pHo.rov.rvValues.length)
	                    value1 = pHo.rov.getValue(num);
	                else
	                    value1 = 0;

	                if (CRun.compareTo(value1, value2, p.comparaison) == false) {
	                    cpt--;
	                    rhPtr.rhEvtProg.evt_DeleteCurrentObject();
	                }
	            }
	            else {
	                cpt--;
	                rhPtr.rhEvtProg.evt_DeleteCurrentObject();
	            }
	            pHo = rhPtr.rhEvtProg.evt_NextObject();
	        } while (pHo != null);
	        return (cpt != 0);
	    }
	}
	// CUT

	function CND_EXTCMPVARFIXED()
	{
	}
	CND_EXTCMPVARFIXED.prototype = CServices.extend(new CCnd(),
		{
			eva1:          function (rhPtr, hoPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			eva2:          function (rhPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			evaExpRoutine: function (hoPtr, value, comp)
			{
				var fixed = (hoPtr.hoCreationId << 16) | ( (hoPtr.hoNumber) & 0xFFFF );
				return CRun.compareTer(fixed, value, comp);
			}
		});
	// CUT

	function CND_EXTCMPVARSTRING()
	{
	}
	CND_EXTCMPVARSTRING.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.evt_FirstObject(this.evtOiList);
			if (pHo == null) return false;

			var cpt = rhPtr.rhEvtProg.evtNSelectedObjects;
			var value1;
			var value2;
			do
			{
				var num;
				if (this.evtParams[0].code == 62)
					num = rhPtr.get_EventExpressionInt(this.evtParams[0]);
				else
					num = this.evtParams[0].value;

				if (num >= 0 && pHo.rov != null && num < pHo.rov.rvStrings.length)
				{
					value1 = pHo.rov.getString(num);
					value2 = rhPtr.get_EventExpressionAny(this.evtParams[1]);

					if (CRun.compareTo(value1, value2, this.evtParams[1].comparaison) == false)
					{
						cpt--;
						rhPtr.rhEvtProg.evt_DeleteCurrentObject();
					}
				}
				else
				{
					cpt--;
					rhPtr.rhEvtProg.evt_DeleteCurrentObject();
				}
				pHo = rhPtr.rhEvtProg.evt_NextObject();
			} while (pHo != null);
			return (cpt != 0);
		}
	}
	// CUT

	function CND_EXTCMPX()
	{
	}
	CND_EXTCMPX.prototype = CServices.extend(new CCnd(),
		{
			eva1:          function (rhPtr, hoPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			eva2:          function (rhPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			evaExpRoutine: function (hoPtr, value, comp)
			{
				return CRun.compareTer(hoPtr.hoX, value, comp);
			}
		});
	// CUT

	function CND_EXTCMPY()
	{
	}
	CND_EXTCMPY.prototype = CServices.extend(new CCnd(),
		{
			eva1:          function (rhPtr, hoPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			eva2:          function (rhPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			evaExpRoutine: function (hoPtr, value, comp)
			{
				return CRun.compareTer(hoPtr.hoY, value, comp);
			}
		});
	// CUT

	function CND_EXTCOLBACK()
	{
	}
	CND_EXTCOLBACK.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				if (this.compute_NoRepeat(hoPtr))
				{
					rhPtr.rhEvtProg.evt_AddCurrentObject(hoPtr);
					return true;
				}

				var pEvg = rhPtr.rhEvtProg.rhEventGroup;
				if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_STOPINGROUP) == 0)
					return false;
				rhPtr.rhEvtProg.rh3DoStop = true;
				return true;
			},
			eva2:             function (rhPtr)
			{
				return CCnd.negate(this, this.evaObject(rhPtr, this));
			},
			evaObjectRoutine: function (hoPtr)
			{
				return hoPtr.hoAdRunHeader.colMask_TestObject_IXY(hoPtr, hoPtr.roc.rcImage, hoPtr.roc.rcAngle, hoPtr.roc.rcScaleX, hoPtr.roc.rcScaleY, hoPtr.hoX, hoPtr.hoY, 0, CColMask.CM_TEST_PLATFORM);
			}
		});
	// CUT

	function CND_EXTCOLLISION()
	{
	}
	CND_EXTCOLLISION.prototype = CServices.extend(new CCnd(),
		{
			eva1:       function (rhPtr, pHo)
			{
				var pHo1 = rhPtr.rhObjectList[rhPtr.rhEvtProg.rh1stObjectNumber];
				if (pHo1 == null)
				{
					var toto = 2;
				}
				var oiEvent = this.evtOi;
				var p = this.evtParams[0];
				var oiParam = p.oi;

				while (true)
				{
					if (oiEvent == pHo.hoOi)
					{
						if (oiParam == pHo1.hoOi)
							break;
						if (oiParam >= 0)
							return false;
						if (this.colGetList(rhPtr, p.oiList, pHo1.hoOi))
							break;
						return false;
					}
					if (oiParam == pHo.hoOi)
					{
						if (oiEvent == pHo1.hoOi)
							break;
						if (oiEvent >= 0)
							return false;
						if (this.colGetList(rhPtr, this.evtOiList, pHo1.hoOi))
							break;
						return false;
					}
					if (oiEvent < 0)
					{
						if (oiParam < 0)
						{
							if (this.colGetList(rhPtr, this.evtOiList, pHo.hoOi))
							{
								if (this.colGetList(rhPtr, p.oiList, pHo1.hoOi))
									break;
								if (this.colGetList(rhPtr, p.oiList, pHo.hoOi) == false)
									return false;
								if (this.colGetList(rhPtr, this.evtOiList, pHo1.hoOi))
									break;
								return false;
							}
							else
							{
								if (this.colGetList(rhPtr, this.evtOiList, pHo1.hoOi))
									break;
								return false;
							}
						}
						else
						{
							if (oiParam == pHo1.hoOi)
								break;
							return false;
						}
					}
					if (oiParam >= 0)
						return false;
					if (oiEvent != pHo1.hoOi)
						return false;
					break;
				}

				var id = ( (pHo1.hoCreationId) << 16) | ((this.evtIdentifier) & 0x0000FFFF);
				if (CCnd.compute_NoRepeatCol(id, pHo) == false)
				{
					if ((rhPtr.rhEvtProg.rhEventGroup.evgFlags & CEventGroup.EVGFLAGS_STOPINGROUP) == 0)
						return false;
					rhPtr.rhEvtProg.rh3DoStop = true;
				}
				id = ( (pHo.hoCreationId) << 16) | ((this.evtIdentifier) & 0x0000FFFF);
				if (CCnd.compute_NoRepeatCol(id, pHo1) == false)
				{
					if ((rhPtr.rhEvtProg.rhEventGroup.evgFlags & CEventGroup.EVGFLAGS_STOPINGROUP) == 0)
						return false;
					rhPtr.rhEvtProg.rh3DoStop = true;
				}

				if (oiEvent < 0)
				    rhPtr.rhEvtProg.evt_DeleteCurrentQualifier(this.evtOiList);
				if (oiParam < 0)
				    rhPtr.rhEvtProg.evt_DeleteCurrentQualifier(p.oiList);
				rhPtr.rhEvtProg.evt_AddCurrentObject(pHo);
				rhPtr.rhEvtProg.evt_AddCurrentObject(pHo1);

				if (pHo1.rom.rmMovement.rmCollisionCount == rhPtr.rh3CollisionCount)
					pHo.rom.rmMovement.rmCollisionCount = rhPtr.rh3CollisionCount;
				else if (pHo.rom.rmMovement.rmCollisionCount == rhPtr.rh3CollisionCount)
					pHo1.rom.rmMovement.rmCollisionCount = rhPtr.rh3CollisionCount;

				return true;
			},
			eva2:       function (rhPtr)
			{
				return this.isColliding(rhPtr);
			},
			colGetList: function (rhPtr, oiList, lookFor)
			{
				if (oiList == -1)
					return false;
				var qoil = rhPtr.rhEvtProg.qualToOiList[oiList & 0x7FFF];
				var index;
				for (index = 0; index < qoil.qoiList.length; index += 2)
				{
					if (qoil.qoiList[index] == lookFor)
						return true;
				}
				return false;
			}
		});
	// CUT

	function CND_EXTENDPATH()
	{
	}
	CND_EXTENDPATH.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return true;
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				if (hoPtr.roc.rcMovementType != CMoveDef.MVTYPE_TAPED)
					return false;
				return CCnd.checkMark(hoPtr.hoAdRunHeader, hoPtr.hoMark2);
			}
		});
	// CUT

	function CND_EXTFACING()
	{
	}
	CND_EXTFACING.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.eva2(rhPtr);
			},
			eva2:             function (rhPtr)
			{
				if (this.evtParams[0].code == 29)
					return this.evaObject(rhPtr, this);
				return this.evaExpObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				var mask = this.evtParams[0].value;
				var dir;
				for (dir = 0; dir < 32; dir++)
				{
					if (((1 << dir) & mask) != 0)
					{
						if (hoPtr.hoAdRunHeader.getDir(hoPtr) == dir)
						{
							return CCnd.negaTRUE(this);
						}
					}
				}
				return CCnd.negaFALSE(this);
			},
			evaExpRoutine:    function (hoPtr, value, comp)
			{
				value &= 31;
				return CCnd.negate(this, hoPtr.roc.rcDir == value);
			}
		});
	// CUT

	function CND_EXTFLAGRESET()
	{
	}
	CND_EXTFLAGRESET.prototype = CServices.extend(new CCnd(),
		{
			eva1:          function (rhPtr, hoPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			eva2:          function (rhPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			evaExpRoutine: function (hoPtr, value, comp)
			{
				value &= 31;
				if (hoPtr.rov != null)
				{
					if ((hoPtr.rov.rvValueFlags & (1 << value)) != 0) return false;
				}
				return true;
			}
		});
	// CUT

	function CND_EXTFLAGSET()
	{
	}
	CND_EXTFLAGSET.prototype = CServices.extend(new CCnd(),
		{
			eva1:          function (rhPtr, hoPtr)
			{
			    return this.eva2(rhPtr);
			},
			eva2:          function (rhPtr)
			{
			    var p = this.evtParams[0];
			    if (p.code != 68)       // PARAM_MULTIPLEVAR)
			        return this.evaExpObject(rhPtr, this);

			    // Parameter = mask and value of multiple flags
			    var pHo = rhPtr.rhEvtProg.evt_FirstObject(this.evtOiList);
			    var cpt = rhPtr.rhEvtProg.evtNSelectedObjects;
			    while (pHo != null) {
			        if (p.evaluateNoGlobal(pHo) == false) {
			            cpt--;
			            rhPtr.rhEvtProg.evt_DeleteCurrentObject();
			        }
			        pHo = rhPtr.rhEvtProg.evt_NextObject();
			    }
			    if (cpt != 0)
			        return true;
			    return false;
			},
			evaExpRoutine: function (hoPtr, value, comp)
			{
				value &= 31;
				if (hoPtr.rov != null)
				{
					if ((hoPtr.rov.rvValueFlags & (1 << value)) != 0)
					{
						return true;
					}
				}
				return false;
			}
		});
	// CUT

	function CND_EXTINPLAYFIELD()
	{
	}
	CND_EXTINPLAYFIELD.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				var evpPtr = this.evtParams[0];
				if ((evpPtr.value & (rhPtr.rhEvtProg.rhCurParam0)) == 0)
					return false;

				if (this.compute_NoRepeat(hoPtr))
				{
					rhPtr.rhEvtProg.evt_AddCurrentObject(hoPtr);
					return true;
				}

				var pEvg = rhPtr.rhEvtProg.rhEventGroup;
				if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_STOPINGROUP) == 0)
					return false;
				rhPtr.rhEvtProg.rh3DoStop = true;
				return true;
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				return CCnd.negate(this, (hoPtr.rom.rmEventFlags & CRMvt.EF_GOESOUTPLAYFIELD) != 0);
			}
		});
	// CUT

	function CND_EXTISBOLD()
	{
	}
	CND_EXTISBOLD.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				var info = CRun.getObjectFont(hoPtr);
				if (info.lfWeight >= 400)
					return true;
				return false;
			}
		});
	// CUT

	function CND_EXTISCOLBACK()
	{
	}
	CND_EXTISCOLBACK.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				if (hoPtr.hoAdRunHeader.colMask_TestObject_IXY(hoPtr, hoPtr.roc.rcImage, hoPtr.roc.rcAngle, hoPtr.roc.rcScaleX, hoPtr.roc.rcScaleY, hoPtr.hoX, hoPtr.hoY, 0, CColMask.CM_TEST_OBSTACLE))
					return CCnd.negaTRUE(this);
				if (hoPtr.hoAdRunHeader.colMask_TestObject_IXY(hoPtr, hoPtr.roc.rcImage, hoPtr.roc.rcAngle, hoPtr.roc.rcScaleX, hoPtr.roc.rcScaleY, hoPtr.hoX, hoPtr.hoY, 0, CColMask.CM_TEST_PLATFORM))
					return CCnd.negaTRUE(this);
				return CCnd.negaFALSE(this);
			}
		});
	// CUT

	function CND_EXTISCOLLIDING()
	{
	}
	CND_EXTISCOLLIDING.prototype = CServices.extend(new CCnd(),
		{
			eva1: function (rhPtr, hoPtr)
			{
				return this.isColliding(rhPtr);
			},
			eva2: function (rhPtr)
			{
				return this.isColliding(rhPtr);
			}
		});
	// CUT

	function CND_EXTISIN()
	{
	}
	CND_EXTISIN.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (pHo)
			{
				var x1 = pHo.hoX - pHo.hoImgXSpot;
				var x2 = x1 + pHo.hoImgWidth;
				var y1 = pHo.hoY - pHo.hoImgYSpot;
				var y2 = y1 + pHo.hoImgHeight;
				if (pHo.hoAdRunHeader.quadran_In(x1, y1, x2, y2) != 0)
					return CCnd.negaFALSE(this);
				return CCnd.negaTRUE(this);
			}
		});
	// CUT

	function CND_EXTISITALIC()
	{
	}
	CND_EXTISITALIC.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				var info = CRun.getObjectFont(hoPtr);
				if (info.lfItalic != 0)
					return true;
				return false;
			}
		});
	// CUT

	function CND_EXTISOUT()
	{
	}
	CND_EXTISOUT.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (pHo)
			{
				var x1 = pHo.hoX - pHo.hoImgXSpot;
				var x2 = x1 + pHo.hoImgWidth;
				var y1 = pHo.hoY - pHo.hoImgYSpot;
				var y2 = y1 + pHo.hoImgHeight;
				if (pHo.hoAdRunHeader.quadran_In(x1, y1, x2, y2) != 0)
					return CCnd.negaTRUE(this);
				return CCnd.negaFALSE(this);
			}
		});
	// CUT

	function CND_EXTISSTRIKEOUT()
	{
	}
	CND_EXTISSTRIKEOUT.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				var info = CRun.getObjectFont(hoPtr);
				if (info.lfStrikeOut != 0)
					return true;
				return false;
			}
		});
	// CUT

	function CND_EXTISUNDERLINE()
	{
	}
	CND_EXTISUNDERLINE.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
			    var info = CRun.getObjectFont(hoPtr);
				if (info.lfUnderline != 0)
					return true;
				return false;
			}
		});
	// CUT

	function CND_EXTNEARBORDERS()
	{
	}
	CND_EXTNEARBORDERS.prototype = CServices.extend(new CCnd(),
		{
			eva1:          function (rhPtr, hoPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			eva2:          function (rhPtr)
			{
				return this.evaExpObject(rhPtr, this);
			},
			evaExpRoutine: function (hoPtr, bord, comp)
			{
				var xw = hoPtr.hoAdRunHeader.rhWindowX + bord;
				var x = hoPtr.hoX - hoPtr.hoImgXSpot;
				if (x <= xw) return CCnd.negaTRUE(this);

				xw = hoPtr.hoAdRunHeader.rhWindowX + hoPtr.hoAdRunHeader.rh3WindowSx - bord;
				x += hoPtr.hoImgWidth;
				if (x >= xw) return CCnd.negaTRUE(this);

				var yw = hoPtr.hoAdRunHeader.rhWindowY + bord;
				var y = hoPtr.hoY - hoPtr.hoImgYSpot;
				if (y <= yw) return CCnd.negaTRUE(this);

				yw = hoPtr.hoAdRunHeader.rhWindowY + hoPtr.hoAdRunHeader.rh3WindowSy - bord;
				y += hoPtr.hoImgHeight;
				if (y >= yw) return CCnd.negaTRUE(this);

				return CCnd.negaFALSE(this);
			}
		});
	// CUT

	function CND_EXTNOMOREOBJECT()
	{
	}
	CND_EXTNOMOREOBJECT.prototype =
	{
		eva1:            function (rhPtr, hoPtr)
		{
			if (hoPtr == null)
				return this.eva2(rhPtr);
			if (this.evtOi >= 0)
			{
				if (hoPtr.hoOi != this.evtOi)
					return false;
				return true;
			}
			return this.evaNoMoreObject(rhPtr, 1);
		},
		eva2:            function (rhPtr)
		{
			return this.evaNoMoreObject(rhPtr, 0);
		},
		evaNoMoreObject: function (rhPtr, sub)
		{
			var oil = this.evtOiList;

			var poil;
			if ((oil & 0x8000) == 0)
			{
				poil = rhPtr.rhOiList[oil];
				if (poil.oilNObjects == 0)
					return true;
				return false;
			}

			if ((oil & 0x7FFF) == 0x7FFF)
				return false;
			var pqoi = rhPtr.rhEvtProg.qualToOiList[oil & 0x7FFF];
			var count = 0;
			var qoi;
			for (qoi = 0; qoi < pqoi.qoiList.length; qoi += 2)
			{
				poil = rhPtr.rhOiList[pqoi.qoiList[qoi + 1]];
				count += poil.oilNObjects;
			}
			count -= sub;
			if (count == 0)
				return true;
			return false;
		}
	}
	// CUT

	function CND_EXTNOMOREZONE()
	{
	}
	CND_EXTNOMOREZONE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var count = rhPtr.rhEvtProg.count_ZoneOneObject(this.evtOiList, this.evtParams[0]);
			return count == 0;
		}
	}
	// CUT

	function CND_EXTNUMBERZONE()
	{
	}
	CND_EXTNUMBERZONE.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var count = rhPtr.rhEvtProg.count_ZoneOneObject(this.evtOiList, this.evtParams[0]);
			var number = rhPtr.get_EventExpressionInt(this.evtParams[1]);
			return CRun.compareTer(count, number, this.evtParams[1].comparaison);
		}
	}
	// CUT

	function CND_EXTNUMOFOBJECT()
	{
	}
	CND_EXTNUMOFOBJECT.prototype =
	{
		eva1: function (rhPtr, hoPtr)
		{
			return this.eva2(rhPtr);
		},
		eva2: function (rhPtr)
		{
			var count = 0;
			var poil;
			var oil = this.evtOiList;
			if ((oil & 0x8000) == 0)
			{
				poil = rhPtr.rhOiList[oil];
				count = poil.oilNObjects;
			}
			else
			{
				if ((oil & 0x7FFF) != 0x7FFF)
				{
					var pqoi = rhPtr.rhEvtProg.qualToOiList[oil & 0x7FFF];
					var qoi;
					for (qoi = 0; qoi < pqoi.qoiList.length; qoi += 2)
					{
						poil = rhPtr.rhOiList[pqoi.qoiList[qoi + 1]];
						count += poil.oilNObjects;
					}
				}
			}
			var value = rhPtr.get_EventExpressionInt(this.evtParams[0]);
			return CRun.compareTer(count, value, this.evtParams[0].comparaison);
		}
	}
	// CUT

	function CND_EXTOUTPLAYFIELD()
	{
	}
	CND_EXTOUTPLAYFIELD.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				var evpPtr = this.evtParams[0];
				if ((evpPtr.value & (rhPtr.rhEvtProg.rhCurParam0)) == 0)
					return false;
				//        if (rhPtr.rhEvtProg.curParam1 == 0x12345678)
				//            return true;

				if (this.compute_NoRepeat(hoPtr))
				{
					rhPtr.rhEvtProg.evt_AddCurrentObject(hoPtr);
					return true;
				}

				var pEvg = rhPtr.rhEvtProg.rhEventGroup;
				if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_STOPINGROUP) == 0)
					return false;
				rhPtr.rhEvtProg.rh3DoStop = true;
				return true;
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				return CCnd.negate(this, (hoPtr.rom.rmEventFlags & CRMvt.EF_GOESOUTPLAYFIELD) != 0);
			}
		});
	// CUT

	function CND_EXTPATHNODE()
	{
	}
	CND_EXTPATHNODE.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return true;
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				if (hoPtr.roc.rcMovementType != CMoveDef.MVTYPE_TAPED)
					return false;
				return CCnd.checkMark(hoPtr.hoAdRunHeader, hoPtr.hoMark1);
			}
		});
	// CUT

	function CND_EXTPATHNODENAME()
	{
	}
	CND_EXTPATHNODENAME.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				var pName = rhPtr.get_EventExpressionString(this.evtParams[0]);
				if (hoPtr.hoMT_NodeName != null)
				{
					if (hoPtr.hoMT_NodeName == pName)
					{
						return true;
					}
				}
				return false;
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				if (hoPtr.roc.rcMovementType != CMoveDef.MVTYPE_TAPED)
					return false;
				if (CCnd.checkMark(hoPtr.hoAdRunHeader, hoPtr.hoMark1))
				{
					var pName = hoPtr.hoAdRunHeader.get_EventExpressionString(this.evtParams[0]);
					if (hoPtr.hoMT_NodeName != null)
					{
						if (hoPtr.hoMT_NodeName == pName)
						{
							return true;
						}
					}
				}
				return false;
			}
		});
	// CUT

	function CND_EXTREVERSED()
	{
	}
	CND_EXTREVERSED.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				return CCnd.negate(this, hoPtr.rom.rmReverse == 0);
			}
		});
	// CUT

	function CND_EXTSHOWN()
	{
	}
	CND_EXTSHOWN.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				return CCnd.negate(this, (hoPtr.ros.rsFlags & CRSpr.RSFLAG_HIDDEN) == 0);
			}
		});
	// CUT

	function CND_EXTSTOPPED()
	{
	}
	CND_EXTSTOPPED.prototype = CServices.extend(new CCnd(),
		{
			eva1:             function (rhPtr, hoPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			eva2:             function (rhPtr)
			{
				return this.evaObject(rhPtr, this);
			},
			evaObjectRoutine: function (hoPtr)
			{
				return CCnd.negate(this, hoPtr.roc.rcSpeed == 0);
			}
		});
	// CUT

	function CND_RUNNINGAS() {
	}
	CND_RUNNINGAS.prototype =
	{
	    eva1: function (rhPtr, hoPtr) {
	        return this.eva2(rhPtr);
	    },
	    eva2: function (rhPtr) {
	        var number;
	        if (this.evtParams[0].code == 67)   // PARAM_RUNTIME
	            number = this.evtParams[0].value;
	        else
	            number = rhPtr.get_EventExpressionInt(this.evtParams[0]);
	        if (number == 5)		// RUNTIME_HTML5
	            return CCnd.negaTRUE(this);
	        return CCnd.negaFALSE(this);
	    }
	}
	// CUT

	function CND_STARTCHILDEVENT() {
	}
	CND_STARTCHILDEVENT.prototype =
	{
	    eva1: function (rhPtr, hoPtr) {
	        return this.eva2(rhPtr);
	    },
	    eva2: function (rhPtr) {
	        var childEventParam = this.evtParams[0];    // PARAM_CHILDEVENT

	        // Restore object selection
	        if (childEventParam.ois.length != 0 && rhPtr.rhEvtProg.childEventSelectionStack.length != 0)
	        {
	            var selectedObjects = rhPtr.rhEvtProg.childEventSelectionStack[rhPtr.rhEvtProg.childEventSelectionStack.length - 1];
	            rhPtr.rhEvtProg.evt_RestoreSelectedObjects(childEventParam.ois, selectedObjects);
	        }
	        return CCnd.negaTRUE(this);
	    }
	}
	// CUT









































	// CExp object
	// -------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 * 
	 * Permission is hereby granted to any person obtaining a legal copy 
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for 
	 * debugging, optimizing, or customizing applications created with 
	 * Clickteam Multimedia Fusion 2. 
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CExp.EXP_EXTGETFRICTION = (35 << 8);
	CExp.EXP_EXTGETRESTITUTION = (36 << 8);
	CExp.EXP_EXTGETDENSITY = (37 << 8);
	CExp.EXP_EXTGETVELOCITY = (38 << 8);
	CExp.EXP_EXTGETANGLE = (39 << 8);
	CExp.EXP_EXTGETMASS = (42 << 8);
	CExp.EXP_EXTGETANGULARVELOCITY = (43 << 8);
	CExp.EXP_STRING = ((3 << 16) | 0xFFFF);
	CExp.EXP_LONG = ((0 << 16) | 0xFFFF);
	CExp.EXP_DOUBLE = ((23 << 16) | 0xFFFF);

	CExp.create = function (file)
	{
		var debut = file.getFilePointer();
		var exp = null;
		var c = file.readAInt();
		switch (c)
		{
			case 0x00000000:
				exp = new EXP_ZERO();
				break;
			case 0x00020000:
				exp = new EXP_PLUS();
				break;
			case 0x00040000:
				exp = new EXP_MINUS();
				break;
			case 0x00060000:
				exp = new EXP_MULT();
				break;
			case 0x00080000:
				exp = new EXP_DIV();
				break;
			case 0x000A0000:
				exp = new EXP_MOD();
				break;
			case 0x000C0000:
				exp = new EXP_POW();
				break;
			case 0x000E0000:
				exp = new EXP_AND();
				break;
			case 0x00100000:
				exp = new EXP_OR();
				break;
			case 0x00120000:
				exp = new EXP_XOR();
				break;
			case ((0 << 16) | 0xFFFF):
				exp = new EXP_LONG();
				break;
			case ((1 << 16) | 0xFFFF):
				exp = new EXP_RANDOM();
				break;
			case ((2 << 16) | 0xFFFF):
				exp = new EXP_VARGLO();
				break;
			case ((3 << 16) | 0xFFFF):
				exp = new EXP_STRING();
				break;
			case ((4 << 16) | 0xFFFF):
				exp = new EXP_STR();
				break;
			case ((5 << 16) | 0xFFFF):
				exp = new EXP_VAL();
				break;
			case ((6 << 16) | 0xFFFF):
			case ((7 << 16) | 0xFFFF):
			case ((8 << 16) | 0xFFFF):
			case ((9 << 16) | 0xFFFF):
				exp = new EXP_EMPTY();
				break;
			case ((10 << 16) | 0xFFFF):
				exp = new EXP_SIN();
				break;
			case ((11 << 16) | 0xFFFF):
				exp = new EXP_COS();
				break;
			case ((12 << 16) | 0xFFFF):
				exp = new EXP_TAN();
				break;
			case ((13 << 16) | 0xFFFF):
				exp = new EXP_SQR();
				break;
			case ((14 << 16) | 0xFFFF):
				exp = new EXP_LOG();
				break;
			case ((15 << 16) | 0xFFFF):
				exp = new EXP_LN();
				break;
			case ((16 << 16) | 0xFFFF):
				exp = new EXP_HEX();
				break;
			case ((17 << 16) | 0xFFFF):
				exp = new EXP_BIN();
				break;
			case ((18 << 16) | 0xFFFF):
				exp = new EXP_EXP();
				break;
			case ((19 << 16) | 0xFFFF):
				exp = new EXP_LEFT();
				break;
			case ((20 << 16) | 0xFFFF):
				exp = new EXP_RIGHT();
				break;
			case ((21 << 16) | 0xFFFF):
				exp = new EXP_MID();
				break;
			case ((22 << 16) | 0xFFFF):
				exp = new EXP_LEN();
				break;
			case ((23 << 16) | 0xFFFF):
				exp = new EXP_DOUBLE();
				break;
			case ((24 << 16) | 0xFFFF):
				exp = new EXP_VARGLONAMED();
				break;
			case ((28 << 16) | 0xFFFF):
				exp = new EXP_INT();
				break;
			case ((29 << 16) | 0xFFFF):
				exp = new EXP_ABS();
				break;
			case ((30 << 16) | 0xFFFF):
				exp = new EXP_CEIL();
				break;
			case ((31 << 16) | 0xFFFF):
				exp = new EXP_FLOOR();
				break;
			case ((32 << 16) | 0xFFFF):
				exp = new EXP_ACOS();
				break;
			case ((33 << 16) | 0xFFFF):
				exp = new EXP_ASIN();
				break;
			case ((34 << 16) | 0xFFFF):
				exp = new EXP_ATAN();
				break;
			case ((35 << 16) | 0xFFFF):
				exp = new EXP_NOT();
				break;
			case ((40 << 16) | 0xFFFF):
				exp = new EXP_MIN();
				break;
			case ((41 << 16) | 0xFFFF):
				exp = new EXP_MAX();
				break;
			case ((42 << 16) | 0xFFFF):
				exp = new EXP_GETRGB();
				break;
			case ((43 << 16) | 0xFFFF):
				exp = new EXP_GETRED();
				break;
			case ((44 << 16) | 0xFFFF):
				exp = new EXP_GETGREEN();
				break;
			case ((45 << 16) | 0xFFFF):
				exp = new EXP_GETBLUE();
				break;
			case ((46 << 16) | 0xFFFF):
				exp = new EXP_LOOPINDEX();
				break;
			case ((47 << 16) | 0xFFFF):
				exp = new EXP_NEWLINE();
				break;
			case ((48 << 16) | 0xFFFF):
				exp = new EXP_ROUND();
				break;
			case ((49 << 16) | 0xFFFF):
				exp = new EXP_STRINGGLO();
				break;
			case ((50 << 16) | 0xFFFF):
				exp = new EXP_STRINGGLONAMED();
				break;
			case ((51 << 16) | 0xFFFF):
				exp = new EXP_LOWER();
				break;
			case ((52 << 16) | 0xFFFF):
				exp = new EXP_UPPER();
				break;
			case ((53 << 16) | 0xFFFF):
				exp = new EXP_FIND();
				break;
			case ((54 << 16) | 0xFFFF):
				exp = new EXP_REVERSEFIND();
				break;
			case ((58 << 16) | 0xFFFF):
				exp = new EXP_FLOATTOSTRING();
				break;
			case ((59 << 16) | 0xFFFF):
				exp = new EXP_ATAN2();
				break;
			case ((60 << 16) | 0xFFFF):
				exp = new EXP_ZERO();
				break;
			case ((61 << 16) | 0xFFFF):
				exp = new EXP_EMPTY();
				break;
			case ((62 << 16) | 0xFFFF):
				exp = new EXP_DISTANCE();
				break;
			case ((63 << 16) | 0xFFFF):
				exp = new EXP_ANGLE();
				break;
			case ((64 << 16) | 0xFFFF):
				exp = new EXP_RANGE();
				break;
			case ((65 << 16) | 0xFFFF):
				exp = new EXP_RANDOMRANGE();
				break;
		    case ((67 << 16) | 0xFFFF):
		        exp = new EXP_RUNTIMENAME();
		        break;
		    case ((-1 << 16) | 0xFFFF):
				exp = new EXP_PARENTH1();
				break;
			case ((-2 << 16) | 0xFFFF):
				exp = new EXP_PARENTH2();
				break;
			case ((-3 << 16) | 0xFFFF):
				exp = new EXP_VIRGULE();
				break;
			case ((0 << 16) | 0xFFFE):
				exp = new EXP_GETSAMPLEMAINVOL();
				break;
			case ((1 << 16) | 0xFFFE):
				exp = new EXP_GETSAMPLEVOL();
				break;
			case ((2 << 16) | 0xFFFE):
				exp = new EXP_GETCHANNELVOL();
				break;
			case ((3 << 16) | 0xFFFE):
				exp = new EXP_ZERO();
				break;
			case ((4 << 16) | 0xFFFE):
				exp = new EXP_GETSAMPLEPAN();
				break;
			case ((5 << 16) | 0xFFFE):
				exp = new EXP_GETCHANNELPAN();
				break;
			case ((6 << 16) | 0xFFFE):
				exp = new EXP_GETSAMPLEPOS();
				break;
			case ((7 << 16) | 0xFFFE):
				exp = new EXP_GETCHANNELPOS();
				break;
			case ((8 << 16) | 0xFFFE):
				exp = new EXP_GETSAMPLEDUR();
				break;
			case ((9 << 16) | 0xFFFE):
				exp = new EXP_GETCHANNELDUR();
				break;
			case ((10 << 16) | 0xFFFE):
				exp = new EXP_GETSAMPLEFREQ();
				break;
			case ((11 << 16) | 0xFFFE):
				exp = new EXP_GETCHANNELFREQ();
				break;
	        case ((12 << 16) | 0xFFFE):
	            exp = new EXP_GETCHANNELSNDNAME();
	            break;
			case ((0 << 16) | 0xFFFD):
				exp = new EXP_GAMLEVEL();
				break;
			case ((1 << 16) | 0xFFFD):
				exp = new EXP_GAMNPLAYER();
				break;
			case ((2 << 16) | 0xFFFD):
				exp = new EXP_PLAYXLEFT();
				break;
			case ((3 << 16) | 0xFFFD):
				exp = new EXP_PLAYXRIGHT();
				break;
			case ((4 << 16) | 0xFFFD):
				exp = new EXP_PLAYYTOP();
				break;
			case ((5 << 16) | 0xFFFD):
				exp = new EXP_PLAYYBOTTOM();
				break;
			case ((6 << 16) | 0xFFFD):
				exp = new EXP_PLAYWIDTH();
				break;
			case ((7 << 16) | 0xFFFD):
				exp = new EXP_PLAYHEIGHT();
				break;
			case ((8 << 16) | 0xFFFD):
				exp = new EXP_GAMLEVELNEW();
				break;
			case ((9 << 16) | 0xFFFD):
				exp = new EXP_GETCOLLISIONMASK();
				break;
			case ((10 << 16) | 0xFFFD):
				exp = new EXP_FRAMERATE();
				break;
			case ((11 << 16) | 0xFFFD):
				exp = new EXP_GETVIRTUALWIDTH();
				break;
			case ((12 << 16) | 0xFFFD):
				exp = new EXP_GETVIRTUALHEIGHT();
				break;
			case ((13 << 16) | 0xFFFD):
				exp = new EXP_GETFRAMEBKDCOLOR();
				break;
			case ((14 << 16) | 0xFFFD):
				exp = new EXP_ZERO();
				break;
			case ((15 << 16) | 0xFFFD):
				exp = new EXP_ZERO();
				break;
			case ((16 << 16) | 0xFFFD):
				exp = new EXP_FRAMEALPHACOEF();
				break;
			case ((17 << 16) | 0xFFFD):
				exp = new EXP_FRAMERGBCOEF();
				break;
			case ((18 << 16) | 0xFFFD):
				exp = new EXP_ZERO();
				break;
			case ((0 << 16) | 0xFFFC):
				exp = new EXP_TIMVALUE();
				break;
			case ((1 << 16) | 0xFFFC):
				exp = new EXP_TIMCENT();
				break;
			case ((2 << 16) | 0xFFFC):
				exp = new EXP_TIMSECONDS();
				break;
			case ((3 << 16) | 0xFFFC):
				exp = new EXP_TIMHOURS();
				break;
			case ((4 << 16) | 0xFFFC):
				exp = new EXP_TIMMINITS();
				break;
			case ((5 << 16) | 0xFFFC):
				exp = new EXP_EVENTAFTER();
				break;
			case ((0 << 16) | 0xFFFA):
				exp = new EXP_XMOUSE();
				break;
			case ((1 << 16) | 0xFFFA):
				exp = new EXP_YMOUSE();
				break;
			case ((2 << 16) | 0xFFFA):
				exp = new EXP_MOUSEWHEELDELTA();
				break;
			case ((0 << 16) | 0xFFF9):
				exp = new EXP_PLASCORE();
				break;
			case ((1 << 16) | 0xFFF9):
				exp = new EXP_PLALIVES();
				break;
			case ((2 << 16) | 0xFFF9):
				exp = new EXP_GETINPUT();
				break;
			case ((3 << 16) | 0xFFF9):
				exp = new EXP_GETINPUTKEY();
				break;
			case ((4 << 16) | 0xFFF9):
				exp = new EXP_GETPLAYERNAME();
				break;
			case ((0 << 16) | 0xFFFB):
				exp = new EXP_CRENUMBERALL();
				break;
			case (( (80 + 0) << 16) | 3):
				exp = new EXP_STRNUMBER();
				break;
			case (( (80 + 1) << 16) | 3):
				exp = new EXP_STRGETCURRENT();
				break;
			case (( (80 + 2) << 16) | 3):
				exp = new EXP_STRGETNUMBER();
				break;
			case (( (80 + 3) << 16) | 3):
				exp = new EXP_STRGETNUMERIC();
				break;
			case (( (80 + 4) << 16) | 3):
				exp = new EXP_STRGETNPARA();
				break;
			case ((80 + 0) << 16 | 2):
				exp = new EXP_GETRGBAT();
				break;
			case ((80 + 1) << 16 | 2):
				exp = new EXP_GETSCALEX();
				break;
			case ((80 + 2) << 16 | 2):
				exp = new EXP_GETSCALEY();
				break;
			case ((80 + 3) << 16 | 2):
				exp = new EXP_GETANGLE();
				break;
			case (( (80 + 0) << 16) | 7):
				exp = new EXP_CVALUE();
				break;
			case (( (80 + 1) << 16) | 7):
				exp = new EXP_CGETMIN();
				break;
			case (( (80 + 2) << 16) | 7):
				exp = new EXP_CGETMAX();
				break;
			case (( (80 + 3) << 16) | 7):
				exp = new EXP_CGETCOLOR1();
				break;
			case (( (80 + 4) << 16) | 7):
				exp = new EXP_CGETCOLOR2();
				break;
			case (((80 + 0) << 16) | 9):
				exp = new EXP_CCAGETFRAMENUMBER();
				break;
			case (((80 + 1) << 16) | 9):
				exp = new EXP_CCAGETGLOBALVALUE();
				break;
			case (((80 + 2) << 16) | 9):
				exp = new EXP_CCAGETGLOBALSTRING();
				break;
			default:
				switch (c & 0xFFFF0000)
				{
					case ( 1 << 16):
						exp = new EXP_EXTYSPR();
						break;
					case ( 2 << 16):
						exp = new EXP_EXTISPR();
						break;
					case ( 3 << 16):
						exp = new EXP_EXTSPEED();
						break;
					case ( 4 << 16):
						exp = new EXP_EXTACC();
						break;
					case ( 5 << 16):
						exp = new EXP_EXTDEC();
						break;
					case ( 6 << 16):
						exp = new EXP_EXTDIR();
						break;
					case ( 7 << 16):
						exp = new EXP_EXTXLEFT();
						break;
					case ( 8 << 16):
						exp = new EXP_EXTXRIGHT();
						break;
					case ( 9 << 16):
						exp = new EXP_EXTYTOP();
						break;
					case (10 << 16):
						exp = new EXP_EXTYBOTTOM();
						break;
					case (11 << 16):
						exp = new EXP_EXTXSPR();
						break;
					case (12 << 16):
						exp = new EXP_EXTIDENTIFIER();
						break;
					case (13 << 16):
						exp = new EXP_EXTFLAG();
						break;
					case (14 << 16):
						exp = new EXP_EXTNANI();
						break;
					case (15 << 16):
						exp = new EXP_EXTNOBJECTS();
						break;
					case (16 << 16):
						exp = new EXP_EXTVAR();
						break;
					case (17 << 16):
						exp = new EXP_EXTGETSEMITRANSPARENCY();
						break;
					case (18 << 16):
						exp = new EXP_EXTNMOVE();
						break;
					case (19 << 16):
						exp = new EXP_EXTVARSTRING();
						break;
					case (20 << 16):
						exp = new EXP_EXTGETFONTNAME();
						break;
					case (21 << 16):
						exp = new EXP_EXTGETFONTSIZE();
						break;
					case (22 << 16):
						exp = new EXP_EXTGETFONTCOLOR();
						break;
					case (23 << 16):
						exp = new EXP_EXTGETLAYER();
						break;
					case (24 << 16):
						exp = new EXP_EXTGETGRAVITY();
						break;
					case (25 << 16):
						exp = new EXP_EXTXAP();
						break;
					case (26 << 16):
						exp = new EXP_EXTYAP();
						break;
					case (27 << 16):
						exp = new EXP_EXTALPHACOEF();
						break;
					case (28 << 16):
						exp = new EXP_EXTRGBCOEF();
						break;
					case (29 << 16):
						exp = new EXP_ZERO();
						break;
					case (30 << 16):
						exp = new EXP_EXTVARBYINDEX();
						break;
					case (31 << 16):
						exp = new EXP_EXTVARSTRINGBYINDEX();
						break;

					case (32 << 16):
						exp = new EXP_EXTDISTANCE();
						break;
					case (33 << 16):
						exp = new EXP_EXTANGLE();
						break;
					case (34 << 16):
						exp = new EXP_EXTLOOPINDEX();
						break;

					case (35 << 16):
						exp = new EXP_EXTGETFRICTION();
						break;
					case (36 << 16):
						exp = new EXP_EXTGETRESTITUTION();
						break;
					case (37 << 16):
						exp = new EXP_EXTGETDENSITY();
						break;
					case (38 << 16):
						exp = new EXP_EXTGETVELOCITY();
						break;
					case (39 << 16):
						exp = new EXP_EXTGETANGLE();
						break;
					case (40 << 16):
						exp = new EXP_EXTWIDTH();
						break;
					case (41 << 16):
						exp = new EXP_EXTHEIGHT();
						break;
				    case (42 << 16):
				        exp = new EXP_EXTGETMASS();
				        break;
				    case (43 << 16):
				        exp = new EXP_EXTGETANGULARVELOCITY();
				        break;
				    case (44 << 16):
				        exp = new EXP_EXTGETNAME();
				        break;

					default:
						exp = new CExpExtension();
						break;
				}
		}
		if (exp != null)
		{
			exp.code = c;

			if (c != 0x00000000)
			{
				var size = file.readAShort();

				var type;
				switch (c)
				{
					case ((3 << 16) | 0xFFFF):
						exp.string = file.readAString();
						break;
					case ((0 << 16) | 0xFFFF):
						exp.value = file.readAInt();
						break;
					case ((23 << 16) | 0xFFFF):
						exp.value = file.readADouble();
						break;
					case ((24 << 16) | 0xFFFF):
						file.skipBytes(4);
						exp.number = file.readAShort();
						break;
					case ((50 << 16) | 0xFFFF):
						file.skipBytes(4);
						exp.number = file.readAShort();
						break;
					default:
						type = c & 0xFFFF;
						if ((type & 0x8000) != 0)
							type = type - 65536;
						if (type >= 2 || type == COI.OBJ_PLAYER)
						{
							exp.oi = file.readShort();
							exp.oiList = file.readShort();
							switch (c & 0xFFFF0000)
							{
								case (16 << 16):		// EXP_EXTVAR
									exp.number = file.readAShort();
									break;
								case (19 << 16):		// EXP_EXTVARSTRING			
									exp.number = file.readAShort();
									break;
								default:
									break;
							}
						}
				}
				file.seek(debut + size);
			}
		}
		return exp;
	}
	function CExp()
	{
	}

	function EXP_EMPTY()
	{
	}
	EXP_EMPTY.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = "";
		}
	}

	function EXP_ZERO()
	{
	}
	EXP_ZERO.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
		}
	}

	function EXP_LONG()
	{
	}
	EXP_LONG.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = this.value;

		}
	}

	function EXP_DOUBLE()
	{
	}
	EXP_DOUBLE.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = this.value;
			rhPtr.flagFloat = true;
		}
	}
	function EXP_EXTVAR()
	{
	}
	EXP_EXTVAR.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var value;
			if (pHo.rov != null)
				value = pHo.rov.getValue(this.number);
			else
				value = 0;
			if (!CServices.isInt(value))
				rhPtr.flagFloat = true;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = value;
		}
	}
	function EXP_EXTVARSTRING()
	{
	}
	EXP_EXTVARSTRING.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = "";
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rov.getString(this.number);
		}
	}

	function EXP_STRINGGLONAMED()
	{
	}
	EXP_STRINGGLONAMED.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.getGlobalStringAt(this.number);
		}
	}

	function EXP_VARGLONAMED()
	{
	}
	EXP_VARGLONAMED.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.getGlobalValueAt(this.number);
		}
	}

	function EXP_STRING()
	{
	}
	EXP_STRING.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = this.string;
		}
	}

	function EXP_EXTVARBYINDEX()
	{
	}
	EXP_EXTVARBYINDEX.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			rhPtr.rh4CurToken++;
			var number = rhPtr.get_ExpressionInt();
			if (pHo != null && pHo.rov != null)
			{
				if (number >= 0 && number < pHo.rov.rvValues.length)
				{
					var value = pHo.rov.getValue(number);
					if (!CServices.isInt(value))
						rhPtr.flagFloat = true;

					rhPtr.rh4Results[rhPtr.rh4PosPile] = value;
					return;
				}
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
		}
	}

	function EXP_EXTVARSTRINGBYINDEX()
	{
	}
	EXP_EXTVARSTRINGBYINDEX.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			rhPtr.rh4CurToken++;
			var number = rhPtr.get_ExpressionInt();
			if (pHo != null && pHo.rov != null)
			{
			    if (number >= 0 && number < pHo.rov.rvStrings.length)
				{
					rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rov.getString(number);
					return;
				}
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = "";
		}
	}

	// CUT


	// System object
	// ---------------------------------------------------------------
	function EXP_DISTANCE()
	{
	}
	EXP_DISTANCE.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var x1 = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var y1 = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var x2 = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var y2 = rhPtr.getExpression();
			var deltaX = x2 - x1;
			var deltaY = y2 - y1;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = CServices.approximateInt(Math.sqrt(deltaX * deltaX + deltaY * deltaY));
		}
	}
	// CUT

	function EXP_ANGLE()
	{
	}
	EXP_ANGLE.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var x1 = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var y1 = rhPtr.getExpression();
			var angle = Math.atan2(-y1, x1) * 180.0 / 3.141592653589;
			if (angle < 0)
				angle = 360 + angle;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = CServices.approximateInt(angle);
		}
	}
	// CUT

	function EXP_RANGE()
	{
	}
	EXP_RANGE.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var minimum = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var maximum = rhPtr.getExpression();

			value = Math.max(value, minimum);
			value = Math.min(value, maximum);
			rhPtr.rh4Results[rhPtr.rh4PosPile] = value;
		}
	}
	// CUT

	function EXP_RANDOMRANGE()
	{
	}
	EXP_RANDOMRANGE.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var minimum = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var maximum = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = minimum + rhPtr.random(maximum - minimum + 1);
		}
	}
	// CUT

	function EXP_RUNTIMENAME()
	{
	}
	EXP_RUNTIMENAME.prototype =
	{
	    evaluate: function (rhPtr) {
	        rhPtr.rh4Results[rhPtr.rh4PosPile] = "Html5";
	    }
	}
	// CUT

	function EXP_ABS()
	{
	}
	EXP_ABS.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.abs(value);
		}
	}
	// CUT

	function EXP_ABS()
	{
	}
	EXP_ABS.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.abs(value);
		}
	}
	// CUT

	function EXP_ACOS()
	{
	}
	EXP_ACOS.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.acos(value) * 57.295779513082320876798154814105;
			rhPtr.flagFloat = true;
		}
	}
	// CUT

	function EXP_AND()
	{
	}
	EXP_AND.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] &= rhPtr.rh4Results[rhPtr.rh4PosPile + 1];
		}
	}
	// CUT

	function EXP_ASIN()
	{
	}
	EXP_ASIN.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.asin(value) * 57.295779513082320876798154814105;
			rhPtr.flagFloat = true;
		}
	}
	// CUT

	function EXP_ATAN()
	{
	}
	EXP_ATAN.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.atan(value) * 57.295779513082320876798154814105;
			rhPtr.flagFloat = true;
		}
	}
	// CUT

	function EXP_ATAN2()
	{
	}
	EXP_ATAN2.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value1 = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var value2 = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.atan2(value1, value2) * 57.295779513082320876798154814105;
			rhPtr.flagFloat = true;
		}
	}
	// CUT

	function EXP_CEIL()
	{
	}
	EXP_CEIL.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.ceil(value);
		}
	}
	// CUT

	function EXP_BIN()
	{
	}
	EXP_BIN.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var a = rhPtr.get_ExpressionInt();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = "0b" + a.toString(2);
		}
	}
	// CUT

	function EXP_COS()
	{
	}
	EXP_COS.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.cos(value / 57.295779513082320876798154814105);
			rhPtr.flagFloat = true;
		}
	}
	// CUT

	function EXP_DIV()
	{
	}
	EXP_DIV.prototype =
	{
		evaluate: function (rhPtr)
		{
			var value1 = rhPtr.rh4Results[rhPtr.rh4PosPile];
			var value2 = rhPtr.rh4Results[rhPtr.rh4PosPile + 1];
			//		if (Math.floor(value1)==value1 &&  (value2)==value2)
			if (value2 != 0)
			{
				if (rhPtr.flagFloat == false)
					rhPtr.rh4Results[rhPtr.rh4PosPile] = CServices.floatToInt(value1 / value2);
				else
					rhPtr.rh4Results[rhPtr.rh4PosPile] /= rhPtr.rh4Results[rhPtr.rh4PosPile + 1];
			}
			else
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
		}
	}
	// CUT

	function EXP_EXP()
	{
	}
	EXP_EXP.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.exp(value);
			rhPtr.flagFloat = true;
		}
	}
	// CUT

	function EXP_FIND()
	{
	}
	EXP_FIND.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var pMainString = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var pSubString = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var firstChar = rhPtr.get_ExpressionInt();

			if (firstChar >= pMainString.length)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = -1;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pMainString.indexOf(pSubString, firstChar);
		}
	}
	// CUT

	function EXP_FLOATTOSTRING()
	{
	}
	EXP_FLOATTOSTRING.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();

			rhPtr.rh4CurToken++;
			var nDigits = rhPtr.get_ExpressionInt();
			if (nDigits < 1)
				nDigits = 1;

			rhPtr.rh4CurToken++;
			var nDecimals = rhPtr.get_ExpressionInt();

			var temp = value.toString();
			var result = new String();

			var point = temp.indexOf(".");

			var cpt;
			if (point >= 0)
			{
				for (cpt = point + 1; cpt < temp.length; cpt++)
				{
					if (temp.charAt(cpt) != "0")
					{
						break;
					}
				}
				if (cpt == temp.length)
					point = -1;
			}

			var pos = 0;
			if (point >= 0)
			{
				if (value < 0.0)
				{
					result += "-";
					pos++;
				}

				while (pos < point)
				{
					result += temp.charAt(pos);
					pos++;
				}

				if (nDecimals > 0)
				{
					result += ".";
					pos++;

					for (cpt = 0; cpt < nDecimals && cpt + pos < temp.length; cpt++)
						result += temp.charAt(pos + cpt);
				}
				else if (nDecimals < 0)
				{
					result += ".";
					pos++;
					while (pos < temp.length)
					{
						result += temp.charAt(pos);
						pos++;
					}
				}
			}
			else
			{
				while (pos < temp.length && temp.charAt(pos) != ".")
				{
					result += temp.charAt(pos);
					pos++;
				}
				if (nDecimals > 0)
				{
					result += ".";
					for (cpt = 0; cpt < nDecimals; cpt++)
					{
						result += "0";
					}
				}
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = result;
		}
	}
	// CUT

	function EXP_FLOOR()
	{
	}
	EXP_FLOOR.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.floor(value);
		}
	}
	// CUT

	function EXP_GETBLUE()
	{
	}
	EXP_GETBLUE.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var rgb = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = (rgb >>> 16) & 255;
		}
	}
	// CUT

	function EXP_GETGREEN()
	{
	}
	EXP_GETGREEN.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var rgb = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = (rgb >>> 8) & 255;
		}
	}
	// CUT

	function EXP_GETRED()
	{
	}
	EXP_GETRED.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var rgb = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rgb & 255;
		}
	}
	// CUT

	function EXP_GETRGB()
	{
	}
	EXP_GETRGB.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var r = rhPtr.get_ExpressionInt();
			rhPtr.rh4CurToken++;
			var g = rhPtr.get_ExpressionInt();
			rhPtr.rh4CurToken++;
			var b = rhPtr.get_ExpressionInt();
			var rgb = ((b & 255) << 16) + ((g & 255) << 8) + (r & 255);
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rgb;
		}
	}
	// CUT

	function EXP_HEX()
	{
	}
	EXP_HEX.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var a = rhPtr.get_ExpressionInt();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = "0x" + a.toString(16);
		}
	}
	// CUT

	function EXP_INT()
	{
	}
	EXP_INT.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = CServices.floatToInt(value);

		}
	}
	// CUT

	function EXP_LEFT()
	{
	}
	EXP_LEFT.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var string = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var pos = rhPtr.get_ExpressionInt();
			if (pos < 0)
				pos = 0;
			if (pos > string.length)
				pos = string.length;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = string.substring(0, pos);

		}
	}
	// CUT

	function EXP_LEN()
	{
	}
	EXP_LEN.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var pString = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pString.length;
		}
	}
	// CUT

	function EXP_LN()
	{
	}
	EXP_LN.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.log(value);
			rhPtr.flagFloat = true;
		}
	}
	// CUT

	function EXP_LOG()
	{
	}
	EXP_LOG.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.log(value) / Math.log(10);
			rhPtr.flagFloat = true;
		}
	}
	// CUT

	function EXP_LOOPINDEX()
	{
	}
	EXP_LOOPINDEX.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var token = rhPtr.rh4Tokens[rhPtr.rh4CurToken];
			var pLoop;

			// Simple expression?
			if ( rhPtr.rh4Tokens[rhPtr.rh4CurToken+1].code<=0 || rhPtr.rh4Tokens[rhPtr.rh4CurToken+1].code>=0x00140000 )
			{
				// Index?
				if ( token.code == CExp.EXP_LONG )
				{
					pLoop = rhPtr.rh4FastLoops.get(token.value);
					rhPtr.rh4CurToken++;
					rhPtr.rh4Results[rhPtr.rh4PosPile] = pLoop.index;
					return;
				}

				// Name = simple string?
				if ( token.code == CExp.EXP_STRING )
				{
					var curToken = rhPtr.rh4CurToken;
					var pName = token.string;	// rhPtr.getExpression();
					rhPtr.rh4CurToken++;

					var n;
					for (n = 0; n < rhPtr.rh4FastLoops.size(); n++)
					{
						pLoop = rhPtr.rh4FastLoops.get(n);
						if (CServices.compareStringsIgnoreCase(pLoop.name, pName))
						{
							rhPtr.rh4Tokens[curToken] = new EXP_LONG();
							rhPtr.rh4Tokens[curToken].code = CExp.EXP_LONG;
							rhPtr.rh4Tokens[curToken].value = n;

							rhPtr.rh4Results[rhPtr.rh4PosPile] = pLoop.index;
							return;
						}
					}
					rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
					return;
				}
			}

			var pName = rhPtr.getExpression();

			var n;
			for (n = 0; n < rhPtr.rh4FastLoops.size(); n++)
			{
				pLoop = rhPtr.rh4FastLoops.get(n);
				if (CServices.compareStringsIgnoreCase(pLoop.name, pName))
				{
					rhPtr.rh4Results[rhPtr.rh4PosPile] = pLoop.index;
					return;
				}
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
		}
	}
	// CUT

	function EXP_LOWER()
	{
	}
	EXP_LOWER.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var pString = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pString.toLowerCase();

		}
	}
	// CUT

	function EXP_MAX()
	{
	}
	EXP_MAX.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var aValue = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var bValue = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.max(aValue, bValue);
		}
	}
	// CUT

	function EXP_MID()
	{
	}
	EXP_MID.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var string = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var start = rhPtr.get_ExpressionInt();
			rhPtr.rh4CurToken++;
			var len = rhPtr.get_ExpressionInt();

			if (start < 0)
				start = 0;
			if (start > string.length)
				start = string.length;
			if (len < 0)
				len = 0;
			if (start + len > string.length)
				len = string.length - start;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = string.substr(start, len);
		}
	}
	// CUT

	function EXP_MIN()
	{
	}
	EXP_MIN.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var aValue = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var bValue = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.min(aValue, bValue);
		}
	}
	// CUT

	function EXP_MINUS()
	{
	}
	EXP_MINUS.prototype =
	{
		evaluate: function (rhPtr)
		{
			if (rhPtr.bOperande)
			{
				rhPtr.rh4CurToken++;
				rhPtr.rh4Tokens[rhPtr.rh4CurToken].evaluate(rhPtr);
				rhPtr.rh4Results[rhPtr.rh4PosPile] = -rhPtr.rh4Results[rhPtr.rh4PosPile];
			}
			else
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] -= rhPtr.rh4Results[rhPtr.rh4PosPile + 1];
			}
		}
	}
	// CUT

	function EXP_MOD()
	{
	}
	EXP_MOD.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] %= rhPtr.rh4Results[rhPtr.rh4PosPile + 1];
		}
	}
	// CUT

	function EXP_MULT()
	{
	}
	EXP_MULT.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] *= rhPtr.rh4Results[rhPtr.rh4PosPile + 1];
		}
	}
	// CUT

	function EXP_NEWLINE()
	{
	}
	EXP_NEWLINE.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = "\n";
		}
	}
	// CUT

	function EXP_OR()
	{
	}
	EXP_OR.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] |= rhPtr.rh4Results[rhPtr.rh4PosPile + 1];
		}
	}
	// CUT

	function EXP_NOT()
	{
	}
	EXP_NOT.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.get_ExpressionInt();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = value ^ 0xFFFFFFFF;
		}
	}
	// CUT

	function EXP_PARENTH1()
	{
	}
	EXP_PARENTH1.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.getExpression();
		}
	}
	// CUT

	function EXP_PARENTH2()
	{
	}
	EXP_PARENTH2.prototype =
	{
		evaluate: function (rhPtr)
		{
		}
	}
	// CUT

	function EXP_PLUS()
	{
	}
	EXP_PLUS.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] += rhPtr.rh4Results[rhPtr.rh4PosPile + 1];
		}
	}
	// CUT

	function EXP_POW()
	{
	}
	EXP_POW.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.pow(rhPtr.rh4Results[rhPtr.rh4PosPile], rhPtr.rh4Results[rhPtr.rh4PosPile + 1]);
			rhPtr.flagFloat = true;
		}
	}
	// CUT

	function EXP_RANDOM()
	{
	}
	EXP_RANDOM.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var num = rhPtr.get_ExpressionInt();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.random(num);
		}
	}
	// CUT

	function EXP_REVERSEFIND()
	{
	}
	EXP_REVERSEFIND.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var pMainString = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var pSubString = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var firstChar = rhPtr.get_ExpressionInt();

			if (firstChar > pMainString.length)
			{
				firstChar = pMainString.length;
			}

			var oldPos;
			var pos = -1;
			while (true)
			{
				oldPos = pos;
				var pFound = pMainString.indexOf(pSubString, pos + 1);
				if (pFound == -1)
					break;
				pos = pFound;
				if (pos > firstChar)
					break;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = oldPos;
		}
	}
	// CUT

	function EXP_RIGHT()
	{
	}
	EXP_RIGHT.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var str = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var pos = rhPtr.get_ExpressionInt();

			if (pos < 0)
				pos = 0;
			if (pos > str.length)
				pos = str.length;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = str.substring(str.length - pos, str.length);
		}
	}
	// CUT

	function EXP_ROUND()
	{
	}
	EXP_ROUND.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.round(value);
		}
	}
	// CUT

	function EXP_SIN()
	{
	}
	EXP_SIN.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.sin(value / 57.295779513082320876798154814105);
			rhPtr.flagFloat = true;
		}
	}
	// CUT

	function EXP_SQR()
	{
	}
	EXP_SQR.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			if (value < 0)
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
			else
				rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.sqrt(value);
			rhPtr.flagFloat = true;
		}
	}
	// CUT

	function EXP_STR()
	{
	}
	EXP_STR.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var pValue = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pValue.toString();
		}
	}
	// CUT

	function EXP_STRINGGLO()
	{
	}
	EXP_STRINGGLO.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var num = (rhPtr.get_ExpressionInt() - 1);
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.getGlobalStringAt(num);
		}
	}
	// CUT

	function EXP_TAN()
	{
	}
	EXP_TAN.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.tan(value / 57.295779513082320876798154814105);
			rhPtr.flagFloat = true;
		}
	}
	// CUT

	function EXP_UPPER()
	{
	}
	EXP_UPPER.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var pString = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pString.toUpperCase();
		}
	}
	// CUT

	function EXP_VAL()
	{
	}
	EXP_VAL.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;

			var s = rhPtr.getExpression();

			var n = 0;
			while(n < s.length && s.charAt(n) == 32)
				n++;
			var result = 0;
			if (n < s.length)
			{
				s = s.substr(n);
				if (s.substr(0, 2) == '0b' || s.substr(n, 2) == '0B')
					result = parseInt(s.substr(n + 2), 2);
				else
				{
					var result1 = parseInt(s);
					result = parseFloat(s);
					if (!isNaN(result) && !isNaN(result1))
					{
						if (result == 0 && result1 != 0)
							result = result1;
						var iValue = CServices.floatToInt(result);
						if (iValue != result)
							rhPtr.flagFloat = true;
					}
					else
						result = 0;
				}
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = result;
		}
	}
	// CUT

	function EXP_VARGLO()
	{
	}
	EXP_VARGLO.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var num = (rhPtr.get_ExpressionInt() - 1);
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.getGlobalValueAt(num);
		}
	}
	// CUT

	function EXP_VIRGULE()
	{
	}
	EXP_VIRGULE.prototype =
	{
		evaluate: function (rhPtr)
		{
		}
	}
	// CUT

	function EXP_XOR()
	{
	}
	EXP_XOR.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] ^= rhPtr.rh4Results[rhPtr.rh4PosPile + 1];
		}
	}
	// CUT

	function EXP_VIRGULE()
	{
	}
	EXP_VIRGULE.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
		}
	}
	// CUT

	// Timer object
	// ------------------------------------------------------------------
	function EXP_EVENTAFTER()
	{
	}
	EXP_EVENTAFTER.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhEvtProg.rhCurParam1;
		}
	}
	// CUT

	function EXP_TIMCENT()
	{
	}
	EXP_TIMCENT.prototype =
	{
		evaluate: function (rhPtr)
		{
			var c = CServices.floatToInt(rhPtr.rhTimer / 10);
			rhPtr.rh4Results[rhPtr.rh4PosPile] = c % 100;
		}
	}
	// CUT

	function EXP_TIMHOURS()
	{
	}
	EXP_TIMHOURS.prototype =
	{
		evaluate: function (rhPtr)
		{
			var c = CServices.floatToInt(rhPtr.rhTimer / 3600000);
			rhPtr.rh4Results[rhPtr.rh4PosPile] = c;
		}
	}
	// CUT

	function EXP_TIMMINITS()
	{
	}
	EXP_TIMMINITS.prototype =
	{
		evaluate: function (rhPtr)
		{
			var c = CServices.floatToInt(rhPtr.rhTimer / 60000);
			rhPtr.rh4Results[rhPtr.rh4PosPile] = c % 60;
		}
	}
	// CUT

	function EXP_TIMSECONDS()
	{
	}
	EXP_TIMSECONDS.prototype =
	{
		evaluate: function (rhPtr)
		{
			var s = CServices.floatToInt(rhPtr.rhTimer / 1000);
			rhPtr.rh4Results[rhPtr.rh4PosPile] = s % 60;
		}
	}
	// CUT

	function EXP_TIMVALUE()
	{
	}
	EXP_TIMVALUE.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhTimer;

			// For benchmarks only
			//var date = new Date();
		    //rhPtr.rh4Results[rhPtr.rh4PosPile] = date.getTime() % 100000;
		}
	}
	// CUT

	// Storyboard object
	// ------------------------------------------------------------------
	function EXP_FRAMEALPHACOEF()
	{
	}
	EXP_FRAMEALPHACOEF.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
		}
	}
	// CUT

	function EXP_FRAMERGBCOEF()
	{
	}
	EXP_FRAMERGBCOEF.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = 0x00FFFFFF;
		}
	}
	// CUT

	function EXP_FRAMERATE()
	{
	}
	EXP_FRAMERATE.prototype =
	{
		evaluate: function (rhPtr)
		{
			var n;
			var total = 0;
			for (n = 0; n < CRun.MAX_FRAMERATE; n++)
				total += rhPtr.rh4FrameRateArray[n];
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.round((1000 * CRun.MAX_FRAMERATE) / total);
		}
	};


	// CUT

	function EXP_GAMLEVEL()
	{
	}
	EXP_GAMLEVEL.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.currentFrame;
		}
	}
	// CUT

	function EXP_GAMLEVELNEW()
	{
	}
	EXP_GAMLEVELNEW.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.currentFrame + 1;
		}
	}
	// CUT

	function EXP_GAMNPLAYER()
	{
	}
	EXP_GAMNPLAYER.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhNPlayers;
		}
	}
	// CUT

	function EXP_GETCOLLISIONMASK()
	{
	}
	EXP_GETCOLLISIONMASK.prototype =
	{
		evaluate: function (rhPtr)
		{
			var x, y;

			rhPtr.rh4CurToken++;
			x = rhPtr.get_ExpressionInt();
			rhPtr.rh4CurToken++;
			y = rhPtr.get_ExpressionInt();

			var result = 0;
			if (rhPtr.y_GetLadderAt(-1, x, y) != null)
				result = 2;
			else
			{
				if (rhPtr.colMask_Test_XY(x, y, -1, CRunFrame.CM_TEST_OBSTACLE))
					result = 1;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = result;
		}
	}
	// CUT

	function EXP_GETFRAMEBKDCOLOR()
	{
	}
	EXP_GETFRAMEBKDCOLOR.prototype =
	{
		evaluate: function (rhPtr)
		{
			var color = rhPtr.rhFrame.leBackground;
			if (rhPtr.rhApp.isPreloaderSubApp)
				color = rhPtr.rhApp.parentApp.frame.leBackground;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = CServices.swapRGB(color);
		}
	}
	// CUT

	function EXP_GETVIRTUALHEIGHT()
	{
	}
	EXP_GETVIRTUALHEIGHT.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhFrame.leVirtualRect.bottom;
		}
	}
	// CUT

	function EXP_GETVIRTUALWIDTH()
	{
	}
	EXP_GETVIRTUALWIDTH.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhFrame.leVirtualRect.right;
		}
	}
	// CUT

	function EXP_PLAYHEIGHT()
	{
	}
	EXP_PLAYHEIGHT.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhFrame.leHeight;
		}
	}
	// CUT

	function EXP_PLAYWIDTH()
	{
	}
	EXP_PLAYWIDTH.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhFrame.leWidth;
		}
	}
	// CUT

	function EXP_PLAYXLEFT()
	{
	}
	EXP_PLAYXLEFT.prototype =
	{
		evaluate: function (rhPtr)
		{
			var r = rhPtr.rhWindowX;
			if ((rhPtr.rh3Scrolling & CRun.RH3SCROLLING_SCROLL) != 0)
				r = rhPtr.rh3DisplayX;
			if (r < 0)
				r = 0;

			rhPtr.rh4Results[rhPtr.rh4PosPile] = r;
		}
	}
	// CUT

	function EXP_PLAYXRIGHT()
	{
	}
	EXP_PLAYXRIGHT.prototype =
	{
		evaluate: function (rhPtr)
		{
			var r = rhPtr.rhWindowX;
			if ((rhPtr.rh3Scrolling & CRun.RH3SCROLLING_SCROLL) != 0)
				r = rhPtr.rh3DisplayX;
			r += rhPtr.rh3WindowSx;
			if (r > rhPtr.rhLevelSx)
				r = rhPtr.rhLevelSx;

			rhPtr.rh4Results[rhPtr.rh4PosPile] = r;
		}
	}
	// CUT

	function EXP_PLAYYBOTTOM()
	{
	}
	EXP_PLAYYBOTTOM.prototype =
	{
		evaluate: function (rhPtr)
		{
			var r = rhPtr.rhWindowY;
			if ((rhPtr.rh3Scrolling & CRun.RH3SCROLLING_SCROLL) != 0)
				r = rhPtr.rh3DisplayY;
			r += rhPtr.rh3WindowSy;
			if (r > rhPtr.rhLevelSy)
				r = rhPtr.rhLevelSy;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = r;
		}
	}
	// CUT

	function EXP_PLAYYTOP()
	{
	}
	EXP_PLAYYTOP.prototype =
	{
		evaluate: function (rhPtr)
		{
			var r = rhPtr.rhWindowY;
			if ((rhPtr.rh3Scrolling & CRun.RH3SCROLLING_SCROLL) != 0)
				r = rhPtr.rh3DisplayY;
			if (r < 0)
				r = 0;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = r;
		}
	}
	// CUT

	// Create object
	// ------------------------------------------------------------------
	function EXP_CRENUMBERALL()
	{
	}
	EXP_CRENUMBERALL.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhNObjects;
		}
	}
	// CUT

	// Counter object
	// ------------------------------------------------------------------
	function EXP_CGETCOLOR1()
	{
	}
	EXP_CGETCOLOR1.prototype =
	{
		evaluate: function (rhPtr)
		{
			var hoPtr = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (hoPtr == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var rgb = hoPtr.cpt_GetColor1();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = CServices.swapRGB(rgb);
		}
	}
	// CUT

	function EXP_CGETCOLOR2()
	{
	}
	EXP_CGETCOLOR2.prototype =
	{
		evaluate: function (rhPtr)
		{
			var hoPtr = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (hoPtr == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var rgb = hoPtr.cpt_GetColor2();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = CServices.swapRGB(rgb);
		}
	}
	// CUT

	function EXP_CGETMAX()
	{
	}
	EXP_CGETMAX.prototype =
	{
		evaluate: function (rhPtr)
		{
			var hoPtr = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (hoPtr == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = hoPtr.cpt_GetMax();
		}
	}
	// CUT

	function EXP_CGETMIN()
	{
	}
	EXP_CGETMIN.prototype =
	{
		evaluate: function (rhPtr)
		{
			var hoPtr = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (hoPtr == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = hoPtr.cpt_GetMin();
		}
	}
	// CUT

	function EXP_CVALUE()
	{
	}
	EXP_CVALUE.prototype =
	{
		evaluate: function (rhPtr)
		{
			var hoPtr = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (hoPtr == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = hoPtr.cpt_GetValue();
			if (hoPtr.bFloat)
				rhPtr.flagFloat = true;
		}
	}
	// CUT

	// Sub application object
	// ------------------------------------------------------------------
	function EXP_CCAGETGLOBALSTRING()
	{
	}
	EXP_CCAGETGLOBALSTRING.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			rhPtr.rh4CurToken++;
			var num = rhPtr.get_ExpressionInt() - 1;
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = "";
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.getGlobalString(num);
		}
	}
	// CUT

	function EXP_CCAGETGLOBALVALUE()
	{
	}
	EXP_CCAGETGLOBALVALUE.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			rhPtr.rh4CurToken++;
			var num = rhPtr.get_ExpressionInt() - 1;
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.getGlobalValue(num);
		}
	}
	// CUT

	function EXP_CCAGETFRAMENUMBER()
	{
	}
	EXP_CCAGETFRAMENUMBER.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.getFrameNumber();
		}
	}
	// CUT

	// String object
	// ----------------------------------------------------------------------
	function EXP_STRGETCURRENT()
	{
	}
	EXP_STRGETCURRENT.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = "";
				return;
			}
			if (pHo.rsTextBuffer != null)
				rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rsTextBuffer;
			else
				rhPtr.rh4Results[rhPtr.rh4PosPile] = "";
		}
	}
	// CUT

	function EXP_STRGETNPARA()
	{
	}
	EXP_STRGETNPARA.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.getCurrentResult().forceInt(0);
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rsMaxi;
		}
	}
	// CUT

	function EXP_STRGETNUMBER()
	{
	}
	EXP_STRGETNUMBER.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			rhPtr.rh4CurToken++;
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = "";
				return;
			}
			var num = rhPtr.get_ExpressionInt();

			if (num < 0)
			{
				if (pHo.rsTextBuffer != null)
					rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rsTextBuffer;
				else
					rhPtr.rh4Results[rhPtr.rh4PosPile] = "";
				return;
			}

			if (num >= pHo.rsMaxi)
				num = pHo.rsMaxi - 1;
			var txt = pHo.hoCommon.ocObject;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = txt.otTexts[num].tsText;
		}
	}
	// CUT

	function EXP_STRGETNUMERIC()
	{
	}
	EXP_STRGETNUMERIC.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.getCurrentResult().forceInt(0);
				return;
			}
			if (pHo.rsTextBuffer != null)
				rhPtr.rh4Results[rhPtr.rh4PosPile] = parseFloat(pHo.rsTextBuffer);
			else
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
		}
	}
	// CUT

	function EXP_STRNUMBER()
	{
	}
	EXP_STRNUMBER.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rsMini + 1;
		}
	}
	// CUT

	// Common object expressions
	// -----------------------------------------------------------------------

	function EXP_EXTDISTANCE()
	{
	}
	EXP_EXTDISTANCE.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			rhPtr.rh4CurToken++;
			var x2 = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var y2 = rhPtr.getExpression();
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var deltaX = x2 - pHo.hoX;
			var deltaY = y2 - pHo.hoY;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = CServices.approximateInt(Math.sqrt(deltaX * deltaX + deltaY * deltaY));
		}
	}
	// CUT

	function EXP_EXTANGLE()
	{
	}
	EXP_EXTANGLE.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			rhPtr.rh4CurToken++;
			var x2 = rhPtr.getExpression();
			rhPtr.rh4CurToken++;
			var y2 = rhPtr.getExpression();
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var angle = Math.atan2(-(y2 - pHo.hoY), (x2 - pHo.hoX)) * 180.0 / 3.141592653589;
			if (angle < 0)
				angle = 360 + angle;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = CServices.approximateInt(angle);
		}
	}
	// CUT

	function EXP_EXTACC()
	{
	}
	EXP_EXTACC.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rom.rmMovement.getAcc();
		}
	}
	// CUT

	function EXP_EXTALPHACOEF()
	{
	}
	EXP_EXTALPHACOEF.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var effect = pHo.ros.rsEffect;
			var effectParam = pHo.ros.rsEffectParam;
			var alpha = 0;
			var rgbaCoeff = effectParam;

			switch (effect & CRSpr.BOP_MASK)
			{
				case CRSpr.BOP_EFFECTEX:
					alpha = 255 - ((effectParam >> 24) & 0xFF);
					break;
				case CRSpr.BOP_BLEND:
					alpha = 255 - ((effectParam == 128) ? 0 : (255 - effectParam * 2));
					break;
				default:
					if (effect & CRSpr.BOP_RGBAFILTER)
						alpha = 255 - ((effectParam >> 24) & 0xFF);
					break;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = alpha;
		}
	}
	// CUT

	function EXP_EXTDEC()
	{
	}
	EXP_EXTDEC.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rom.rmMovement.getDec();
		}
	}
	// CUT

	function EXP_EXTDIR()
	{
	}
	EXP_EXTDIR.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.getDir(pHo);
		}
	}
	// CUT

	function EXP_EXTFLAG()
	{
	}
	EXP_EXTFLAG.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			rhPtr.rh4CurToken++;
			var num = rhPtr.get_ExpressionInt();
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			num &= 31;
			if (pHo.rov != null)
			{
				var result = 0;
				if (((1 << num) & pHo.rov.rvValueFlags) != 0)
					result = 1;
				rhPtr.rh4Results[rhPtr.rh4PosPile] = result;
			}
			else
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
		}
	}
	// CUT

	function EXP_EXTGETFONTCOLOR()
	{
	}
	EXP_EXTGETFONTCOLOR.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var rgb = CRun.getObjectTextColor(pHo);
			rgb = CServices.swapRGB(rgb);
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rgb;
		}
	}
	// CUT

	function EXP_EXTGETFONTNAME()
	{
	}
	EXP_EXTGETFONTNAME.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = "";
				return;
			}
			var info = CRun.getObjectFont(pHo);
			rhPtr.rh4Results[rhPtr.rh4PosPile] = info.lfFaceName;
		}
	}
	// CUT

	function EXP_EXTGETFONTSIZE()
	{
	}
	EXP_EXTGETFONTSIZE.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var info = CRun.getObjectFont(pHo);
			rhPtr.rh4Results[rhPtr.rh4PosPile] = Math.round((info.lfHeight * 72) / 96);
		}
	}
	// CUT

	function EXP_EXTGETGRAVITY()
	{
	}
	EXP_EXTGETGRAVITY.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rom.rmMovement.getGravity();
		}
	}
	// CUT

	function EXP_EXTGETLAYER()
	{
	}
	EXP_EXTGETLAYER.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.hoLayer + 1;
		}
	}
	// CUT

	function EXP_EXTGETSEMITRANSPARENCY()
	{
	}
	EXP_EXTGETSEMITRANSPARENCY.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var t = 0;
			if (pHo.ros != null)
				t = pHo.ros.getSemiTransparency();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = t;
		}
	}
	// CUT

	function EXP_EXTIDENTIFIER()
	{
	}
	EXP_EXTIDENTIFIER.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var id = (pHo.hoCreationId << 16) | (pHo.hoNumber & 0xFFFF);
			rhPtr.rh4Results[rhPtr.rh4PosPile] = id;
		}
	}
	// CUT

	function EXP_EXTISPR()
	{
	}
	EXP_EXTISPR.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var i = 0;
			if (pHo.roa != null)
				i = pHo.roa.raAnimFrame;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = i;
		}
	}
	// CUT

	function EXP_EXTNANI()
	{
	}
	EXP_EXTNANI.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var i = 0;
			if (pHo.roa != null)
				i = pHo.roa.raAnimOn;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = i;
		}
	}
	// CUT

	function EXP_EXTNMOVE()
	{
	}
	EXP_EXTNMOVE.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var i = 0;
			if (pHo.roa != null)
				i = pHo.rom.rmMvtNum;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = i;
		}
	}
	// CUT

	function EXP_EXTNOBJECTS()
	{
	}
	EXP_EXTNOBJECTS.prototype =
	{
		evaluate: function (rhPtr)
		{
			var qoil = this.oiList;
			var poil;
			if ((qoil & 0x8000) == 0)
			{
				poil = rhPtr.rhOiList[qoil];
				rhPtr.rh4Results[rhPtr.rh4PosPile] = poil.oilNObjects;
			}
			else
			{
				var count = 0;
				if (qoil != -1)
				{
					var pqoi = rhPtr.rhEvtProg.qualToOiList[qoil & 0x7FFF];
					var qoi;
					for (qoi = 0; qoi < pqoi.qoiList.length; qoi += 2)
					{
						poil = rhPtr.rhOiList[pqoi.qoiList[qoi + 1]];
						count += poil.oilNObjects;
					}
				}
				rhPtr.rh4Results[rhPtr.rh4PosPile] = count;
			}
		}
	}
	// CUT

	function EXP_EXTRGBCOEF()
	{
	}
	EXP_EXTRGBCOEF.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var effect = pHo.ros.rsEffect;
			var effectParam = pHo.ros.rsEffectParam;
			var rgb = 0;
			var rgbaCoeff = effectParam;

			if ((effect & CRSpr.BOP_MASK) == CRSpr.BOP_EFFECTEX || (effect & CRSpr.BOP_RGBAFILTER) != 0)
				rgb = CServices.swapRGB((rgbaCoeff & 0x00FFFFFF));
			else
				rgb = 0x00FFFFFF;

			rhPtr.rh4Results[rhPtr.rh4PosPile] = rgb;
		}
	}
	// CUT

	function EXP_EXTSPEED()
	{
	}
	EXP_EXTSPEED.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var i = 0;
			if (pHo.roa != null)
				i = pHo.rom.rmMovement.getSpeed();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = i;
		}
	}
	// CUT

	function EXP_EXTXAP()
	{
	}
	EXP_EXTXAP.prototype =
	{
		evaluate: function (rhPtr)
		{
			var x = 0;
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo != null)
			{
				x = pHo.hoX;
				if (pHo.roa != null)
				{
					if (pHo.roc.rcImage >= 0)
					{
						var ifo;
						ifo = rhPtr.rhApp.imageBank.getImageInfoEx(pHo.roc.rcImage, pHo.roc.rcAngle, pHo.roc.rcScaleX, pHo.roc.rcScaleY);
						if (ifo != null)
						{
							rhPtr.rh4Results[rhPtr.rh4PosPile] = x + ifo.xAP - ifo.xSpot;
							return;
						}
					}
				}
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = x;
		}
	}
	// CUT

	function EXP_EXTXLEFT()
	{
	}
	EXP_EXTXLEFT.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.hoX - pHo.hoImgXSpot;
		}
	}
	// CUT

	function EXP_EXTXRIGHT()
	{
	}
	EXP_EXTXRIGHT.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.hoX - pHo.hoImgXSpot + pHo.hoImgWidth;
		}
	}
	// CUT

	function EXP_EXTXSPR()
	{
	}
	EXP_EXTXSPR.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.hoX;
		}
	}
	// CUT

	function EXP_EXTYAP()
	{
	}
	EXP_EXTYAP.prototype =
	{
		evaluate: function (rhPtr)
		{
			var y = 0;
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo != null)
			{
				y = pHo.hoY;
				if (pHo.roa != null)
				{
					if (pHo.roc.rcImage >= 0)
					{
						var ifo;
						ifo = rhPtr.rhApp.imageBank.getImageInfoEx(pHo.roc.rcImage, pHo.roc.rcAngle, pHo.roc.rcScaleX, pHo.roc.rcScaleY);
						if (ifo != null)
						{
							rhPtr.rh4Results[rhPtr.rh4PosPile] = y + ifo.yAP - ifo.ySpot;
							return;
						}
					}
				}
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = y;
		}
	}
	// CUT

	function EXP_EXTACC()
	{
	}
	EXP_EXTACC.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rom.rmMovement.getAcc();
		}
	}
	// CUT

	function EXP_EXTYBOTTOM()
	{
	}
	EXP_EXTYBOTTOM.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.hoY - pHo.hoImgYSpot + pHo.hoImgHeight;
		}
	}
	// CUT

	function EXP_EXTYSPR()
	{
	}
	EXP_EXTYSPR.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.hoY;
		}
	}
	// CUT

	function EXP_EXTYTOP()
	{
	}
	EXP_EXTYTOP.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.hoY - pHo.hoImgYSpot;
		}
	}
	// CUT

	// Active object
	// -----------------------------------------------------------------------
	function EXP_GETANGLE()
	{
	}
	EXP_GETANGLE.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var angle = pHo.roc.rcAngle;
			var pMovement = rhPtr.GetMBase(pHo);
			if (pMovement)
			{
				angle = pMovement.getAngle();
				if (angle == CRunMBase.ANGLE_MAGIC)
					angle = pHo.roc.rcAngle;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = angle;
		}
	}
	// CUT


	function EXP_GETRGBAT()
	{
	}
	EXP_GETRGBAT.prototype =
	{
		evaluate: function (rhPtr)
		{
			var hoPtr = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			rhPtr.rh4CurToken++;
			if (hoPtr == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var x = rhPtr.get_ExpressionInt();
			rhPtr.rh4CurToken++;
			var y = rhPtr.get_ExpressionInt();

			var rgb = 0;
			if (hoPtr.roc.rcImage != -1)
			{
			    var image = rhPtr.rhApp.imageBank.getImageFromHandle(hoPtr.roc.rcImage);
			    if (image != null) {
			        rgb = image.getPixel(x, y);
			        rgb = CServices.swapRGB(rgb);
			    }
			    else
			        rgb = 0;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rgb;
		}
	}
	// CUT

	function EXP_GETSCALEX()
	{
	}
	EXP_GETSCALEX.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.roc.rcScaleX;
			rhPtr.flagFloat = true;
		}
	}
	// CUT

	function EXP_GETSCALEY()
	{
	}
	EXP_GETSCALEY.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.roc.rcScaleY;
			rhPtr.flagFloat = true;
		}
	}
	// CUT

	// Speaker object
	// -----------------------------------------------------------------------
	function EXP_GETCHANNELDUR()
	{
	}
	EXP_GETCHANNELDUR.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.get_ExpressionInt();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.soundPlayer.getDurationChannel(value - 1);
		}
	}
	// CUT

	function EXP_GETCHANNELFREQ()
	{
	}
	EXP_GETCHANNELFREQ.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.get_ExpressionInt();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.soundPlayer.getFrequencyChannel(value - 1);
		}
	}
	// CUT

	function EXP_GETCHANNELSNDNAME() {
	}
	EXP_GETCHANNELSNDNAME.prototype =
	{
	    evaluate: function (rhPtr) {
	        rhPtr.rh4CurToken++;
	        var value = rhPtr.get_ExpressionInt();
	        rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.soundPlayer.getSndNameChannel(value - 1);
	    }
	}
	// CUT

	function EXP_GETCHANNELPOS()
	{
	}
	EXP_GETCHANNELPOS.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.get_ExpressionInt();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.soundPlayer.getPositionChannel(value - 1);
		}
	}
	// CUT


	function EXP_GETSAMPLEDUR()
	{
	}
	EXP_GETSAMPLEDUR.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var name = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.soundPlayer.getDurationSample(name);
		}
	}
	// CUT

	function EXP_GETSAMPLEFREQ()
	{
	}
	EXP_GETSAMPLEFREQ.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var name = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.soundPlayer.getFrequencySample(name);
		}
	}
	// CUT

	function EXP_GETSAMPLEMAINPAN()
	{
	}
	EXP_GETSAMPLEMAINPAN.prototype =
	{
		evaluate: function (rhPtr)
		{
			var p = rhPtr.rhApp.soundPlayer.getMainPan() * 100;
			if (p < 0)
				p -= 0.5;
			else
				p += 0.5;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = p;
		}
	}
	// CUT

	function EXP_GETSAMPLEMAINVOL()
	{
	}
	EXP_GETSAMPLEMAINVOL.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.soundPlayer.getMainVolume();
		}
	}
	// CUT

	function EXP_GETSAMPLEPOS()
	{
	}
	EXP_GETSAMPLEPOS.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var name = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.soundPlayer.getPositionSample(name);
		}
	}
	// CUT

	function EXP_GETCHANNELVOL()
	{
	}
	EXP_GETCHANNELVOL.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var value = rhPtr.get_ExpressionInt();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.soundPlayer.getVolumeChannel(value - 1);
		}
	}
	// CUT

	function EXP_GETSAMPLEVOL()
	{
	}
	EXP_GETSAMPLEVOL.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var name = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.soundPlayer.getVolumeSample(name);
		}
	}

	function EXP_GETSAMPLEPAN()
	{
	}
	EXP_GETSAMPLEPAN.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var name = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
		}
	}
	// CUT

	function EXP_GETCHANNELPAN()
	{
	}
	EXP_GETCHANNELPAN.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4CurToken++;
			var name = rhPtr.getExpression();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
		}
	}
	// CUT

	// Keyboard object
	// ---------------------------------------------------------
	function EXP_MOUSEWHEELDELTA()
	{
	}
	EXP_MOUSEWHEELDELTA.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.deltaWheel * 40;
		}
	}
	// CUT

	function EXP_XMOUSE()
	{
	}
	EXP_XMOUSE.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.getXMouse();
		}
	}
	// CUT

	function EXP_YMOUSE()
	{
	}
	EXP_YMOUSE.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.getYMouse();
		}
	}
	// CUT

	// Player object
	// ---------------------------------------------------------
	function EXP_GETINPUT()
	{
	}
	EXP_GETINPUT.prototype =
	{
		evaluate: function (rhPtr)
		{
			var joueur = this.oi;
			var r = CRunApp.CTRLTYPE_KEYBOARD;
			if (joueur < CRunApp.MAX_PLAYER)
				r = rhPtr.rhApp.getCtrlType()[joueur];
			if (r == CRunApp.CTRLTYPE_KEYBOARD)
				r = CRunApp.CTRLTYPE_MOUSE;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = r;
		}
	}
	// CUT

	function EXP_GETINPUTKEY()
	{
	}
	EXP_GETINPUTKEY.prototype =
	{
		evaluate: function (rhPtr)
		{
			var joueur = this.oi;

			rhPtr.rh4CurToken++;
			var kvCode = rhPtr.get_ExpressionInt();
			var s = "";
			if (key < CRunApp.MAX_KEY)
			{
				if (vkCode >= 96 && vkCode <= 105)
				{
					c = vkCode - 96;
					s = "Numpad" + c.toString();
				}
				else if (vkCode >= 112 && vkCode <= 126)
				{
					c = vkCode - 112;
					s = "F" + c.toString();
				}
				else if (vkCode >= 48 && vkCode <= 57)
				{
					c = vkCode - 48;
					s = c.toString();
				}
				else if (vkCode >= 65 && vkCode <= 90)
				{
					s = String.fromCharCode(vkCode);
				}
				else
				{
					s = "Control key";
					/*TODO		    var n;
					 for (n=0; n<NB_SPECIAL_KEYS; n++)
					 {
					 if (keys[n*2+1]==vkCode)
					 {
					 s=keyNames[n];
					 break;
					 }
					 }
					 */
				}
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = s;
		}
	}
	// CUT

	function EXP_GETPLAYERNAME()
	{
	}
	EXP_GETPLAYERNAME.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.playerNames[this.oi];
		}
	}
	// CUT

	function EXP_PLALIVES()
	{
	}
	EXP_PLALIVES.prototype =
	{
		evaluate: function (rhPtr)
		{
			rhPtr.rh4Results[rhPtr.rh4PosPile] = rhPtr.rhApp.getLives()[this.oi];
		}
	}
	// CUT

	function EXP_PLASCORE()
	{
	}
	EXP_PLASCORE.prototype =
	{
		evaluate: function (rhPtr)
		{
			var scores = rhPtr.rhApp.getScores();
			rhPtr.rh4Results[rhPtr.rh4PosPile] = scores[this.oi];
		}
	}
	// CUT

	function EXP_EXTLOOPINDEX()
	{
	}
	EXP_EXTLOOPINDEX.prototype =
	{
		evaluate: function (rhPtr)
		{
			var x = 0;
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo != null)
			{
				if (rhPtr.rh4CurrentForEach != null)
				    if (this.oiList == rhPtr.rh4CurrentForEach.oi)
						x = rhPtr.rh4CurrentForEach.index;

				if (rhPtr.rh4CurrentForEach2 != null)
				    if (this.oiList == rhPtr.rh4CurrentForEach2.oi)
						x = rhPtr.rh4CurrentForEach2.index;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = x;
		}
	}
	// CUT

	// BOX2D MOVEMENTS
	//////////////////////////////////////////////////////////////////////

	function EXP_EXTGETFRICTION()
	{
	}
	EXP_EXTGETFRICTION.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (rhPtr.GetMBase(pHo) == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rom.rmMovement.callMovement(CExp.EXP_EXTGETFRICTION, 0);
		}
	}
	// CUT

	function EXP_EXTGETRESTITUTION()
	{
	}
	EXP_EXTGETRESTITUTION.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (rhPtr.GetMBase(pHo) == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rom.rmMovement.callMovement(CExp.EXP_EXTGETRESTITUTION, 0);
		}
	}
	// CUT

	function EXP_EXTGETDENSITY()
	{
	}
	EXP_EXTGETDENSITY.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (rhPtr.GetMBase(pHo) == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rom.rmMovement.callMovement(CExp.EXP_EXTGETDENSITY, 0);
		}
	}
	// CUT

	function EXP_EXTGETVELOCITY()
	{
	}
	EXP_EXTGETVELOCITY.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (rhPtr.GetMBase(pHo) == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rom.rmMovement.callMovement(CExp.EXP_EXTGETVELOCITY, 0);
		}
	}
	// CUT

	function EXP_EXTGETANGLE()
	{
	}
	EXP_EXTGETANGLE.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (rhPtr.GetMBase(pHo) == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rom.rmMovement.callMovement(CExp.EXP_EXTGETANGLE, 0);
		}
	}
	// CUT

	function EXP_EXTGETRESTITUTION()
	{
	}
	EXP_EXTGETRESTITUTION.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (rhPtr.GetMBase(pHo) == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rom.rmMovement.callMovement(CExp.EXP_EXTGETRESTITUTION, 0);
		}
	}
	// CUT

	function EXP_EXTWIDTH()
	{
	}
	EXP_EXTWIDTH.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.hoImgWidth;
		}
	}
	// CUT

	function EXP_EXTHEIGHT()
	{
	}
	EXP_EXTHEIGHT.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.hoImgHeight;
		}
	}
	// CUT

	function EXP_EXTGETMASS() {
	}
	EXP_EXTGETMASS.prototype =
	{
	    evaluate: function (rhPtr) {
	        var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
	        if (rhPtr.GetMBase(pHo) == null) {
	            rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
	            return;
	        }
	        rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rom.rmMovement.callMovement(CExp.EXP_EXTGETMASS, 0);
	    }
	}
	// CUT

	function EXP_EXTGETANGULARVELOCITY() {
	}
	EXP_EXTGETANGULARVELOCITY.prototype =
	{
	    evaluate: function (rhPtr) {
	        var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
	        if (rhPtr.GetMBase(pHo) == null) {
	            rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
	            return;
	        }
	        rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.rom.rmMovement.callMovement(CExp.EXP_EXTGETANGULARVELOCITY, 0);
	    }
	}
	// CUT

	function EXP_EXTGETNAME() {
	}
	EXP_EXTGETNAME.prototype =
	{
	    evaluate: function (rhPtr) {
	        var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
	        if (pHo == null) {
	            rhPtr.rh4Results[rhPtr.rh4PosPile] = "";
	            return;
	        }
	        rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.hoOiList.oilName;
	    }
	}
	// CUT
	// CRunApp object
	// -----------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	__scope["FusionVersion"] = "Clickteam Fusion HTML5 Exporter Build 285.1";

	CRunApp.MAX_PLAYER = 4;
	CRunApp.RUNTIME_VERSION = 0x0302;
	CRunApp.MAX_KEY = 8;
	CRunApp.GA_NOHEADING = 0x0002;
	CRunApp.GA_STRETCHTOFIT = 0x0004;
	CRunApp.GA_SPEEDINDEPENDANT = 0x0008;
	CRunApp.GA_STRETCH = 0x0010;
	CRunApp.GA_MENUHIDDEN = 0x0080;
	CRunApp.GA_MENUBAR = 0x0100;
	CRunApp.GA_MAXIMISE = 0x0200;
	CRunApp.GA_MIX = 0x0400;
	CRunApp.GA_FULLSCREENATSTART = 0x0800;
	CRunApp.GANF_SAMPLESOVERFRAMES = 0x0001;
	CRunApp.GANF_RUNFRAME = 0x0004;
	CRunApp.GANF_SAMPLESEVENIFNOTFOCUS = 0x0008;
	CRunApp.GANF_NOTHICKFRAME = 0x0040;
	CRunApp.GANF_DONOTCENTERFRAME = 0x0080;
	CRunApp.GANF_DISABLE_CLOSE = 0x0200;
	CRunApp.GANF_HIDDENATSTART = 0x0400;
	CRunApp.GANF_VSYNC = 0x1000;
	CRunApp.GAOF_JAVASWING = 0x1000;
	CRunApp.GAOF_JAVAAPPLET = 0x2000;
	CRunApp.RUNTIME_CM = 1;
	CRunApp.SL_RESTART = 0;
	CRunApp.SL_STARTFRAME = 1;
	CRunApp.SL_FRAMEFADEINLOOP = 2;
	CRunApp.SL_FRAMELOOP = 3;
	CRunApp.SL_FRAMEFADEOUTLOOP = 4;
	CRunApp.SL_ENDFRAME = 5;
	CRunApp.SL_QUIT = 6;
	CRunApp.SL_WAITFORMOCHI = 7;
	CRunApp.MAX_VK = 203;
	CRunApp.VK_LEFT = 0x25;
	CRunApp.VK_RIGHT = 0x27;
	CRunApp.VK_UP = 0x26;
	CRunApp.VK_DOWN = 0x28;
	CRunApp.VK_LBUTTON = 200;
	CRunApp.VK_MBUTTON = 201;
	CRunApp.VK_RBUTTON = 202;
	CRunApp.VK_NUMPAD0 = 0x60;
	CRunApp.VK_NUMPAD1 = 0x61;
	CRunApp.VK_NUMPAD2 = 0x62;
	CRunApp.VK_NUMPAD3 = 0x63;
	CRunApp.VK_NUMPAD4 = 0x64;
	CRunApp.VK_NUMPAD5 = 0x65;
	CRunApp.VK_NUMPAD6 = 0x66;
	CRunApp.VK_NUMPAD7 = 0x67;
	CRunApp.VK_NUMPAD8 = 0x68;
	CRunApp.VK_NUMPAD9 = 0x69;
	CRunApp.VK_S = 0x53;
	CRunApp.VK_D = 0x44;
	CRunApp.VK_E = 0x45;
	CRunApp.VK_X = 0x58;
	CRunApp.VK_F12 = 0x7B;
	CRunApp.VK_SHIFT = 0x10;
	CRunApp.VK_CONTROL = 0x11;
	CRunApp.VK_MENU = 0x12;
	CRunApp.CTRLTYPE_MOUSE = 0;
	CRunApp.CTRLTYPE_JOY1 = 1;
	CRunApp.CTRLTYPE_JOY2 = 2;
	CRunApp.CTRLTYPE_JOY3 = 3;
	CRunApp.CTRLTYPE_JOY4 = 4;
	CRunApp.CTRLTYPE_KEYBOARD = 5;
	CRunApp.ARF_INGAMELOOP = 0x0004;
	CRunApp.BUILDFLAG_TEST = 0x0080;
	CRunApp.AH2OPT_KEEPSCREENRATIO = 0x0001;
	CRunApp.AH2OPT_RESAMPLESTRETCH = 0x0004;
	CRunApp.AH2OPT_WEBGL = 0x10000;
	CRunApp.AH2OPT_KEEPRESOURCESBETWEENFRAMES = 0x8000;
	CRunApp.AH2OPT_RUNEVENIFNOTFOCUS = 0x100000;
	CRunApp.AH2OPT_PRELOADERQUIT = 0x800000;
	CRunApp.AH2OPT_LOADDATAATSTART = 0x1000000;
	CRunApp.AH2OPT_LOADSOUNDSONTOUCH = 0x2000000;
	CRunApp.AH2OPT_DESTROYIFNOINACTIVATE = 0x4000000;
	CRunApp.MAX_TOUCHES = 10;
	CRunApp.FAKE_TOUCHIDENTIFIER = 0x2356A465;
	CRunApp.TOUCHID_EMPTY = 0x69865358;

	function loadApplication()
	{
		__scope.application.loadApplication();
	}
	function loadInfo()
	{
		__scope.application.loadInfo();
	}
	__scope['loadApplication'] = loadApplication;
	__scope['loadInfo'] = loadInfo;

	function CRunApp(cName, cfile, path, sub)
	{
		this.isSubApp = (sub === true);
		if(this.isSubApp)
		{
			this.canvas = cName.canvas;
			this.parent_element = cName.parent_element;
			this.cName = null;
		}
		else if(typeof cName === 'string')
		{
			this.canvas = document.getElementById(cName);
			this.parent_element = this.canvas.parentElement;
			this.cName = cName;
		}
		else if(cName instanceof HTMLElement)
		{
			this.canvas = document.createElement('canvas');
			this.parent_element = cName;
			this.cName = null;
		}

		var cont = this.container = cName.container || document.createElement('div');
		cont.appendChild(this.canvas);
		this.parent_element.appendChild(cont);

		cont.style.overflow = 'hidden';
		cont.style.position = 'relative';
		cont.style.transform = 'translateZ(0)';
		cont.style.margin = '0';
		cont.style.padding = '0';
		cont.style.display = 'block';
		cont.style.boxSizing = 'content-box';
		cont.className = "MMFDiv";

		this.frameOffsets = null;
		this.frameEffects = null;
		this.frameEffectParams = null;
		this.frameMaxIndex = 0;
		this.framePasswords = null;
		this.appName = null;
		this.nGlobalValuesInit = 0;
		this.globalValuesInitTypes = null;
		this.globalValuesInit = null;
		this.nGlobalStringsInit = 0;
		this.globalStringsInit = null;
		this.OIList = null;
		this.imageBank = null;
		this.fontBank = null;
		this.soundBank = null;
		this.soundPlayer = null;
		this.soundContext = null;
		this.soundContextType = 0;
		this.appRunningState = 0;
		this.lives = null;
		this.scores = null;
		this.playerNames = null;
		this.gValues = null;
		this.gStrings = null;
		this.startFrame = 0;
		this.nextFrame = 0;
		this.currentFrame = 0;
		this.frame = null;
		this.file = null;
		this.parentApp = null;
		this.parentOptions = 0;
		this.parentWidth = 0;
		this.parentHeight = 0;
		this.refTime = 0;
		this.run = null;
		this.preloader = null;
		this.loadPreloader = false;

		this.xOffset = 0;
		this.yOffset = 0;
		this.gaFlags = 0;
		this.gaNewFlags = 0;
		this.gaMode = 0;
		this.gaOtherFlags = 0;
		this.gaCxWin = 0;
		this.gaCyWin = 0;
		this.gaScoreInit = 0;
		this.gaLivesInit = 0;
		this.gaBorderColour = 0;
		this.gaNbFrames = 0;
		this.gaFrameRate = 0;
		this.pcCtrlType = null;
		this.pcCtrlKeys = null;
		this.frameHandleToIndex = null;
		this.frameMaxHandle = 0;
		this.cx = 0;
		this.cy = 0;
		this.mouseX = 0;
		this.mouseY = 0;
		this.bMouseIn = false;
		this.keyBuffer = null;

		this.cursorCount = 0;
		this.cursor = 'auto';
		this.sysEvents = null;
		this.quit = false;
		this.m_bLoading = false;
		this.extensionStorage = null;
		this.extLoader = null;
		this.embeddedFiles = null;
		this.bUnicode = false;
		this.xMouseOffset = 0;
		this.yMouseOffset = 0;
		this.deltaWheel = 0;
		this.effect = 0;
		this.effectParam = 0;
		this.alpha = 0;

		this.dwOptions = 0;
		this.dwBuildType = 0;
		this.dwBuildFlags = 0;
		this.wScreenRatioTolerance = 0;
		this.wScreenAngle = 0;

		this.file = cfile;
		this.resources = "";
		this.path = path;
		var pos = path.lastIndexOf("/");
		if (pos >= 0)
			this.resources = path.substring(0, pos + 1);

		this.frameColor = 0;
		this.appEditorFilename = null;

		this.run = null;
		this.timer = 0;
		this.imagesToLoad = 0;
		this.imagesLoaded = 0;
		this.bLoading = false;
		this.keyNew = false;
		this.subApps = new Array(0);
		this.preloaderType = -1;                        // HTML5PRELOADER_IMAGE (0) ou HTML5PRELOADER_FRAMENUM (1)
		this.preloaderCircleCenterX = 0;
		this.preloaderCircleCenterY = 0;
		this.preloaderCircleRadius = 0;
		this.preloaderCircleThickness = 0;
		this.preloaderCircleColor = 0;
		this.preloaderBackColor = 0;
		this.preloaderFrameNumber = 0;        // première frame = 0
		this.transition = null;
		this.transitionManager = null;
		this.transitionDisplay = null;
		this.transitionOldSurface = null;
		this.bStartFadeIn = false;
		// Browser detection
		this.browserDetect = new BrowserDetect();
		this.touchesID = null;
		this.touchesX = null;
		this.touchesY = null;
		this.mouseTouch = CRunApp.TOUCHID_EMPTY;
		this.nTouches = 0;

		this.joystick = null;
		this.joystickOn = 0;

		this.accelerometer = 0;
		this.accX = 0;
		this.accY = 0;
		this.accZ = 0;
		this.accGravX = 0;
		this.accGravY = 0;
		this.accGravZ = 0;
		this.scaleX = this.scaleY = 1;

		this.hasFocus = true;
		this.bStoppedFocus = false;
		this.iOS = false;
		this.firstFrameColor = 0;
		this.previousFrameGraphics = null;
		this.graphicFonts = null;

		this.infoVersion = -1;
		this.infoFile = null;
		this.infoCounter = 1000000000;
		this.infoPath = null;
		if (window.location.href.indexOf("192.") >= 0)
		{
			var pos = window.location.href.indexOf("21700/");
			if (pos >= 0)
			{
				this.infoPath = window.location.href.substring(0, pos + 6);
				this.infoVersion = -1;
				this.infoCounter = 25;
			}
		}
		this.bZoom = false;
		this.dataLoadingStep = 3;
		this.dataToLoad = new CArrayList();
		this.dataLoading = new CArrayList();
		this.mosaics = new Array();
		this.mosaicMaxHandle = 0;
		this.silentSound = null;
		this.m_touchMe = "Please touch the screen to start";
		this.oldFrameRate = -1000;
		this.fullScreen = false;
		this.versionCode = "***version***";
		this.versionCodePos = 0;
		this.versionCodeDisplay = 0;
		this.codePage = -1;


	}
	CRunApp.prototype =
	{
		loadInfo:        function ()
		{
			var version = this.infoFile.readAInt();
			if (this.infoVersion < 0)
				this.infoVersion = version;
			if (version != this.infoVersion)
			{
				this.infoFile.setUnicode(true);
				var name = this.infoFile.readAString();
				var path = this.infoPath + name;
				window.open(path, "_self");
			}
			this.infoCounter = 25;
		},
		load:            function ()
		{
			this.numberOfFiles = this.file.readAShort();
			this.currentFile = 1;
			this.loadingFile = new CFile();
			var size = this.file.readAInt();
			var filePath = this.path.substring(0, this.path.length - 1) + this.currentFile.toString();
			this.loadingFile.getFile(filePath, loadApplication, size);
		},
		loadApplication: function ()
		{
			this.currentFile++;
			if (this.currentFile > this.numberOfFiles)
			{
				var zip = new JSZip(this.loadingFile.getBytes(), "content");
				var unzipped = zip.file("Application.ccj").asBinary();
				this.loadingFile = null;
				this.file = new CFile();
				this.file.setBinary(unzipped);
				this.digest();
				this.startApplication();
				return;
			}
			var size = this.file.readAInt();
			var filePath = this.path.substring(0, this.path.length - 1) + this.currentFile.toString();
			this.loadingFile.getFile(filePath, loadApplication, size);
		},
		digest:          function ()
		{
			// Charge le mini-header
			this.file.seek(0);
			var b = this.file.readBuffer(4);
			this.bUnicode = false;
			if (b[0] == 80 && b[1] == 65 && b[2] == 77 && b[3] == 85)
			{
				this.bUnicode = true;
			}
			this.file.setUnicode(this.bUnicode);
			this.file.skipBytes(8);
			this.file.skipBytes(4);

			// Reserve les objets
			this.OIList = new COIList();
			this.imageBank = new CImageBank(this);
			this.fontBank = new CFontBank(this);
			this.soundBank = new CSoundBank(this);
			this.soundPlayer = new CSoundPlayer(this);

			// Lis les chunks
			var posEnd;
			var nbPass = 0, n;
			var chID = 0;
			var chFlags;
			var chSize;
			while (chID != 0x7F7F)
			{
				chID = this.file.readAShort();
				chFlags = this.file.readAShort();
				chSize = this.file.readAInt();

				if (chSize == 0)
				{
					continue;
				}
				posEnd = this.file.getFilePointer() + chSize;

				switch (chID)
				{
					// CHUNK_APPHEADER
					case 0x2223:
						this.loadAppHeader();
						// Buffer pour les offsets frame
						this.frameOffsets = new Array(this.gaNbFrames);
						this.frameEffects = new Array(this.gaNbFrames);
						this.frameEffectParams = new Array(this.gaNbFrames);
						// Pour les password
						this.framePasswords = new Array(this.gaNbFrames);
						for (n = 0; n < this.gaNbFrames; n++)
							this.framePasswords[n] = null;
						break;
					// CHUNK_APPHDR2
					case 0x2245:
						this.dwOptions = this.file.readAInt();
						this.dwBuildType = this.file.readAInt();
						this.dwBuildFlags = this.file.readAInt();
						this.wScreenRatioTolerance = this.file.readAShort();
						this.wScreenAngle = this.file.readAShort();
						break;
					// CHUNK_APPNAME
					case 0x2224:
						this.appName = this.file.readAString();
						break;
				    // CHUNK_APPCODEPAGE
				    case 0x2246:
				        this.codePage = this.file.readAInt();
				        break;
				   // Target file name
					case 0x222E:		// CHUNK_APPEDITORFILENAME:
						this.appEditorFilename = this.file.readAString();
						break;
					// Touch Screen message for iOS
					case 0x224E:        // CHUNK_HTML5_TOUCHME
						this.m_touchMe = this.file.readAString();
						break;
					// CHUNK_GLOBALVALUES
					case 0x2232:
						this.loadGlobalValues();
						break;
					// CHUNK_GLOBALSTRINGS
					case 0x2233:
						this.loadGlobalStrings();
						break;
					// CHUNK_FRAMEITEMS
					// CHUNK_FRAMEITEMS_2
					case 0x2229:
				    case 0x223F:
					    this.extLoader = new CExtLoader(this);
					    this.extLoader.createList(this.file);
					    this.OIList.preLoad(this.file);
						break;
					// CHUNK_FRAMEHANDLES
					case 0x222B:
						this.loadFrameHandles(chSize);
						break;
					// CHUNK_HTML5PRELOADER
					case 0x224A:
						this.preloaderType = this.file.readAInt();
						this.preloaderCircleCenterX = this.file.readAInt();
						this.preloaderCircleCenterY = this.file.readAInt();
						this.preloaderCircleRadius = this.file.readAInt();
						this.preloaderCircleThickness = this.file.readAInt();
						this.preloaderCircleColor = this.file.readAColor();
						this.preloaderBackColor = this.file.readAInt();
						if (this.preloaderBackColor != -1)
						{
							this.file.skipBack(4);
							this.preloaderBackColor = this.file.readAColor();
						}
						this.preloaderFrameNumber = this.file.readAInt();
						this.loadPreloader = true;
						break;
					// CHUNK_FRAME
					case 0x3333:
						// Repere les positions des frames dans le fichier
						this.frameOffsets[this.frameMaxIndex] = this.file.getFilePointer();
						var frID = 0;
						var frFlags;
						var frSize;
						while (frID != 0x7F7F)		// CHUNK_LAST
						{
							frID = this.file.readAShort();
							frFlags = this.file.readAShort();
							frSize = this.file.readAInt();

							if (frSize == 0)
							{
								continue;
							}
							var frPosEnd = this.file.getFilePointer() + frSize;

							switch (frID)
							{
								case 0x3334:
									if (this.frameMaxIndex == 0)
									{
										this.file.skipBytes(2 * 4);
										this.firstFrameColor = this.file.readAColor();
									}
									break;
								case 0x3336:
									this.framePasswords[this.frameMaxIndex] = this.file.readAString();
									break;
								case 0x3349:
									this.frameEffects[this.frameMaxIndex] = this.file.readAInt();
									this.frameEffectParams[this.frameMaxIndex] = this.file.readAInt();
									break;
								// CHUNK_MOSAICIMAGETABLE
								case 0x3348:
									var number = frSize / (3 * 2);
									var n;
									for (n = 0; n < number; n++)
									{
										var handle = this.file.readAShort();
										this.file.skipBytes(4);
										if (handle != 0)
										{
											this.mosaics[handle] = 1;
											this.mosaicMaxHandle = Math.max(this.mosaicMaxHandle, handle + 1);
										}
									}
									break;
							}
							this.file.seek(frPosEnd);
						}
						this.frameMaxIndex++;
						break;
					// CHUNK_BINARYFILES
					case 0x2238:
						var nFiles = this.file.readAInt();
						this.embeddedFiles = new Array(nFiles);
						for (n = 0; n < nFiles; n++)
						{
							this.embeddedFiles[n] = new CEmbeddedFile(this);
							this.embeddedFiles[n].preLoad();
						}
						break;
					// CHUNK_IMAGE
					case 0x6666:
						this.imageBank.preLoad(this.file);
						break;
					// CHUNK_FONT
					case 0x6667:
						this.fontBank.preLoad(this.file);
						break;
					// CHUNK_SOUNDS
					case 0x6668:
						this.soundBank.preLoad(this.file);
						break;
				}

				// Positionne a la fin du chunk
				this.file.seek(posEnd);
			}

			this.context = new StandardRenderer(this.canvas);

			// Fixe le flags multiple samples
			this.soundPlayer.setMultipleSounds((this.gaFlags & CRunApp.GA_MIX) != 0);

			// Cree le sprite principal
			if (this.parentApp == null)
			{
				this.mainSprite = new Sprite();
			}

		},

		setParentApp: function (pApp, sFrame, options, sprite, width, height)
		{
			this.parentApp = pApp;
			this.parentOptions = options;
			this.mainSprite = sprite;
			this.startFrame = sFrame;
			this.parentWidth = width;
			this.parentHeight = height;
		},

		initScreenZoom:     function ()
		{
			this.bZoom = false;
			this.scAngle = 0;
			this.scScale = this.scScaleX = this.scScaleY = 1;
			this.scXSpot = this.scXDest = this.gaCxWin / 2;
			this.scYSpot = this.scYDest = this.gaCyWin / 2;
		},
		setUpdate:          function ()
		{
			window.setTimeout(updateApplication.bind(this), 20);
		},
		startApplication:   function ()
		{
			//	    this.dwOptions |= CRunApp.AH2OPT_LOADDATAATSTART;        // FRANCOIS
			//	    this.dwOptions |= CRunApp.AH2OPT_LOADSOUNDSONTOUCH;

			// Specific sound handling if on iOS
			this.iOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent) || /iPod/i.test(navigator.userAgent);
			if (this.iOS && this.soundBank.nHandlesReel > 0) // && (this.dwOptions & CRunApp.AH2OPT_LOADSOUNDSONTOUCH) != 0)
			{
				this.silentSound = new CSound(this);
				this.silentSound.loadSilent();
			}

			//		if (this.gaFlags&CRunApp.GA_STRETCH)
			this.resizeCanvas();

			this.sysEvents = new CArrayList();

			this.keyBuffer = new Array(CRunApp.MAX_VK);
			var n;
			for (n = 0; n < CRunApp.MAX_VK; n++)
				this.keyBuffer[n] = false;

			this.canvas.application = this;
			if (this.parentApp == null)
			{
				var that = this;
				window.addEventListener("keypress", function (e)
				{
					that.doKeyPress(e);
				}, false);
				window.addEventListener("keydown", function (e)
				{
					that.doKeyDown(e);
				}, false);
				window.addEventListener("keyup", function (e)
				{
					that.doKeyUp(e);
				}, false);
				window.addEventListener("blur", function (e)
				{
					that.hasFocus = false;
				}, false);
				window.addEventListener("focus", function (e)
				{
					that.hasFocus = true;
				}, false);
				if(window !== window.top)
				{
					try
					{
						var win2 = window.top;
						win2.addEventListener("focus", function()
						{
							that.hasFocus = true;
							that.canvas.focus();
						});
						win2.addEventListener("blur", function()
						{
							that.hasFocus = false;
						});
					}
					catch(e){}

				}
				window.addEventListener("resize", function (e)
				{
					that.resizeCanvas();
				}, false);
				document.addEventListener("blur", function (e)
				{
					that.hasFocus = false;
				}, false);
				document.addEventListener("focus", function (e)
				{
					that.hasFocus = true;
				}, false);
				document.addEventListener("fullscreenchange", function ()
				{
					that.fullScreen = document.fullscreen;
					that.resizeCanvas();
				}, false);
				document.addEventListener("mozfullscreenchange", function ()
				{
					that.fullScreen = document.mozFullScreen;
					that.resizeCanvas();
				}, false);
				document.addEventListener("webkitfullscreenchange", function ()
				{
					that.fullScreen = document.webkitIsFullScreen;
					that.resizeCanvas();
				}, false);
				this.canvas.addEventListener("mousemove", function (e)
				{
					that.mouseMove(e, that.canvas);
					if (e.preventDefault) e.preventDefault();
				}, false);
				this.canvas.addEventListener("mousedown", function (e)
				{
					that.mouseDown(e);
					if (e.preventDefault) e.preventDefault();
				}, false);
				this.canvas.addEventListener("mouseup", function (e)
				{
					that.mouseUp(e);
					if (e.preventDefault) e.preventDefault();
				}, false);
				this.canvas.addEventListener("mouseout", function (e)
				{
					that.mouseOut(e);
					if (e.preventDefault) e.preventDefault();
				}, false);
				this.canvas.addEventListener("click", function (e)
				{
					//that.click(e);
					if (e.preventDefault) e.preventDefault();
				}, false);
				this.canvas.addEventListener("dblclick", function (e)
				{
					//that.dblClick(e);
					if (e.preventDefault) e.preventDefault();
				}, false);
				this.canvas.addEventListener("contextmenu", function (e)
				{
					if (e.preventDefault) e.preventDefault();
				}, false);
				var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel"
				if (document.attachEvent)
					document.attachEvent("on" + mousewheelevt, function (e)
					{
						that.mouseWheel(e);
					})
				else if (document.addEventListener)
					document.addEventListener(mousewheelevt, function (e)
					{
						that.mouseWheel(e);
					}, false)

				document.onselectstart = function ()
				{
					return false;
				}
				this.canvas.onselectstart = function (e)
				{
					if (e.preventDefault) e.preventDefault();
					return false;
				}

				this.touchable = this.isTouchable();
				this.touchCalls = new CArrayList();
				this.touchesID = new Array(CRunApp.MAX_TOUCHES);
				this.bTouchesLocked = new Array(CRunApp.MAX_TOUCHES);
				this.touchesLocked = new Array(CRunApp.MAX_TOUCHES);
				this.touchesX = new Array(CRunApp.MAX_TOUCHES);
				this.touchesY = new Array(CRunApp.MAX_TOUCHES);
				for (n = 0; n < CRunApp.MAX_TOUCHES; n++)
				{
					this.touchesID[n] = CRunApp.TOUCHID_EMPTY;
					this.touchesX[n] = 0;
					this.touchesY[n] = 0;
					this.bTouchesLocked[n] = false;
					this.touchesLocked[n] = 0;
				}
				this.nTouches = 0;

				if (this.touchable)
				{
					this.canvas.addEventListener('touchstart', function (e)
					{
						that.touchStart(e);
						if (e.preventDefault) e.preventDefault();
					}, false);
					this.canvas.addEventListener('touchmove', function (e)
					{
						that.touchMove(e);
						if (e.preventDefault) e.preventDefault();
					}, false);
					this.canvas.addEventListener('touchend', function (e)
					{
						that.touchEnd(e);
						if (e.preventDefault) e.preventDefault();
					}, false);
					this.canvas.addEventListener('touchcancel', function (e)
					{
						that.touchEnd(e);
						if (e.preventDefault) e.preventDefault();
					}, false);
					/*
					 var body=document.getElementsByTagName("body")[0];
					 body.addEventListener( 'touchstart', function(e)
					 {
					 e.preventDefault();
					 }, false );
					 */
				}
				window.focus();
				this.setUpdate();
			}
			else
			{
				this.touchable = this.parentApp.touchable;
				this.touchCalls = new CArrayList();
				this.touchesID = new Array(CRunApp.MAX_TOUCHES);
				this.bTouchesLocked = new Array(CRunApp.MAX_TOUCHES);
				this.touchesLocked = new Array(CRunApp.MAX_TOUCHES);
				this.touchesX = new Array(CRunApp.MAX_TOUCHES);
				this.touchesY = new Array(CRunApp.MAX_TOUCHES);
				for (n = 0; n < CRunApp.MAX_TOUCHES; n++)
				{
					this.touchesID[n] = CRunApp.TOUCHID_EMPTY;
					this.touchesX[n] = 0;
					this.touchesY[n] = 0;
					this.bTouchesLocked[n] = false;
					this.touchesLocked[n] = 0;
				}
				this.nTouches = 0;
			}
			this.xMouseOffset = 0;
			this.yMouseOffset = 0;

			this.appRunningState = 0;
			this.currentFrame = -2;

			this.run = new CRun(this);
		},
		resizeCanvas:       function ()
		{

			/*		if(navigator.userAgent.match(/Android/i))
			 {
			 window.scrollTo(0,1);
			 }
			 */
			var width = this.gaCxWin;
			var height = this.gaCyWin;

			var innerWidth;
			var innerHeight;
			if (this.fullScreen || (this.gaFlags & CRunApp.GA_STRETCH))
			{
				innerWidth = window.innerWidth;
				innerHeight = window.innerHeight;
				document.documentElement.style.overflow = 'hidden';
				document.body.scroll = "no";
			}
			else
			{
				innerWidth = width;
				innerHeight = height;
			}
			var scaleX = innerWidth / width,
				scaleY = innerHeight / height;

			if ((this.dwOptions & CRunApp.AH2OPT_KEEPSCREENRATIO) || ((this.gaFlags & CRunApp.GA_STRETCH) && (this.gaFlags & CRunApp.GA_STRETCHTOFIT)))
				scaleX = scaleY = Math.min(scaleX, scaleY);

			if (scaleX != this.scaleX || scaleY != this.scaleY)
			{
				this.scaleX = scaleX;
				this.scaleY = scaleY;

				this.canvas.width = Math.floor(this.scaleX * width);
				this.canvas.height = Math.floor(this.scaleY * height);
				this.context.setScale(this.scaleX, this.scaleY);
				var leftX = window.innerWidth / 2 - this.canvas.width / 2;
				var topY = window.innerHeight / 2 - this.canvas.height / 2;
				/*
				this.canvas.style.left = leftX.toString() + "px";
				this.canvas.style.top = topY.toString() + "px";
				var objParent = this.canvas;
				while (objParent)
				{
					objParent.style.left = leftX.toString() + "px";
					objParent.style.top = topY.toString() + "px";
					objParent.position = "absolute";
					objParent = objParent.offsetParent;
				}
				/*
				 var objParent=this.canvas;
				 while (objParent)
				 {
				 objParent.style.left="0px";
				 objParent.style.top="0px";
				 objParent.position = "absolute";
				 objParent = objParent.offsetParent;
				 }
				 */
			}
			if (this.run)
				this.run.autoResize();
		},
		resetKeyBuffer:     function ()
		{
			var n;
			for (n = 0; n < CRunApp.MAX_VK; n++)
				this.keyBuffer[n] = false;
		},
		isTouchable:        function ()
		{
			var agents = ['Android', 'webOS', 'iPhone', 'iPad', 'iPod', 'Blackberry', 'Windows Phone', 'Touch'];
			var nav = navigator.userAgent;
			var i;
			for (i in agents)
			{
				if (nav.indexOf(agents[i]) >= 0)
				{
					return true;
				}
			}
			return false;
		},
		dataHasLoaded:      function (data)
		{
			this.dataLoading.removeObject(data);
			this.imagesLoaded++;
		},
		addDataToLoad:      function (data)
		{
			this.dataToLoad.add(data);
			this.imagesToLoad++;
			this.loading = true;
		},
		/*
		 loadAllDataNow:function()
		 {
		 while (this.dataToLoad.size() > 0)
		 {
		 var data = this.dataToLoad.get(0);
		 this.dataLoading.add(data);
		 this.dataToLoad.removeIndex(0);
		 data.doLoad();
		 }
		 },
		 */
		stepApplication:    function ()
		{
			if (this.infoPath)
			{
				this.infoCounter--;
				if (this.infoCounter < 0)
				{
					this.infoCounter = 1000000000;
					this.infoFile = new CFile();
					this.infoFile.getFile(this.infoPath + "info.dat", loadInfo);
				}
			}

			var date = new Date();
			this.timer = date.getTime();
			if (this.playApplication(false))
			{
				if (!this.loading)
				{
					if (this.parentApp == null)
					{
						if (this.transitionDisplay == null)
						{
							this.context.resetEffect((this.dwOptions & CRunApp.AH2OPT_RESAMPLESTRETCH) != 0);
							if (!this.previousFrameGraphics)
							{
								var clearBack = false;
								if (this.frame.leClearBackground) this.context.clearBackground(0, 0, this.gaCxWin, this.gaCyWin);
								else this.context.renderSolidColor(0, 0, this.gaCxWin, this.gaCyWin, this.frameColor);
							}
							else
								this.context.renderSimpleImage(this.previousFrameGraphics, 0, 0, this.gaCxWin, this.gaCyWin, 0, 0);

							var context = this.context._context;

							if (this.bZoom)
							{
								bRestore = true;
								context.save();
								context.translate(this.scXDest, this.scYDest);
								if (this.scAngle != 0)
									context.rotate(-this.scAngle * 0.0174532925);
								context.scale(Math.max(0.001, this.scScaleX), Math.max(0.001, this.scScaleY));
								context.translate(-this.scXSpot, -this.scYSpot);
							}
							this.mainSprite.draw(this.context, 0, 0);
							if (this.bZoom)
							{
								context.restore();
							}
							if (this.joystickOn)
								this.joystick.draw(this.context);
							if (this.versionCodeDisplay)
							{
								this.versionCodeDisplay--;
								if (!this.versionCodeSurface)
								{
									var font = new CFont();
									font.createDefaultFont();
									font.lfHeight = 16;
									this.versionCodeSurface = new CTextSurface(this, this.gaCxWin, 30);
									this.versionCodeSurface.manualClear(0xFF0000);
									this.versionCodeSurface.manualDrawText(window["FusionVersion"], CServices.DT_CENTER | CServices.DT_VCENTER, null, 0xFFFFFF, font, 1, 0xA0A0A0);
								}
								this.versionCodeSurface.draw(this.context, 0, 0, 0, 0);
							}
						}
						else
						{
							this.context.resetEffect();
							this.context.renderSimpleImage(this.transitionDisplay, 0, 0, this.gaCxWin, this.gaCyWin, 0, 0);
						}
						if ((this.gaNewFlags & CRunApp.GANF_VSYNC) != 0 && window.requestAnimationFrame)
							window.requestAnimationFrame(updateApplication);
						else
						{
							var delta = (new Date()).getTime() - this.timer;
							delta = Math.max(1000 / this.gaFrameRate - delta, 1);
							window.setTimeout(updateApplication, delta);
						}
					}
				}
				else
				{
					if (this.preloader == null)
					{
						var color = this.frameColor;
						if (this.loadPreloader)
						{
							this.preloader = this.preloaderType == 0 ? new CPreloaderImage(this) : new CPreloaderFrame(this);
							if (this.preloaderType == 0 && this.preloaderBackColor != -1)
								color = this.preloaderBackColor;
						}
						else
							this.preloader = new CPreloaderDefault(this);
						this.preloaderLoaded = false;
						this.resetted = true;
						if (this.parentApp == null)
						{
						    if (this.frame.leClearBackground)
						        this.context.clearBackground(0, 0, this.canvas.width, this.canvas.height);
							else
							    this.context.renderSolidColor(0, 0, this.gaCxWin, this.gaCyWin, color);

							this.setUpdate();
						}
						return;
					}
					if (this.preloader != null && this.preloaderLoaded == false)
					{
						this.preloaderLoaded = this.preloader.load();
						if (this.parentApp == null)
							this.setUpdate();
						return;
					}

					while (this.dataToLoad.size() > 0 && this.dataLoading.size() < this.dataLoadingStep)
					{
						var data = this.dataToLoad.get(0);
						this.dataLoading.add(data);
						this.dataToLoad.removeIndex(0);
						data.doLoad();
					}
					this.soundPlayer.decodeData();

					var bComplete = false;
					if (this.dataToLoad.size() == 0 && this.dataLoading.size() == 0)
						bComplete = true;
					if (this.preloader != null && ((this.dwOptions & CRunApp.AH2OPT_LOADDATAATSTART) != 0 || (this.frame.html5Options & CRunFrame.HTML5FOPT_DISPLAYPRELOADER) != 0))
					{
						if (!this.resetted)
						{
							this.preloader.reset();
							this.resetted = true;
						}
						this.preloader.step();
						bComplete = this.preloader.isComplete();
					}
					if (bComplete)
					{
						this.resetted = false;
						this.run.resume();
						this.run.callComputeNewDisplay();
						this.loading = false;
						this.imageBank.resetToLoad();
						this.soundBank.resetToLoad();
						this.fontBank.resetToLoad();
						this.imagesToLoad = 0;
						this.imagesLoaded = 0;
						if (this.bStartFadeIn)
						{
							this.bStartFadeIn = false;
							var quit = this.run.doRunLoop();
							if (quit != 0)
								this.appRunningState = CRunApp.SL_ENDFRAME;
							else
							{
								this.appRunningState = CRunApp.SL_FRAMELOOP;
								this.startFrameFadeIn(this.transitionOldSurface);
								this.transitionOldSurface = null;
							}
						}
					}
					if (this.parentApp == null)
					{
						this.setUpdate();
					}
				}
				return true;
			}
			else
			{
				this.endApplication();
				return false;
			}
		},
		drawSubApplication: function (cont, x, y, erase)
		{
			if (!this.loading)
			{
				if (this.transitionDisplay == null)
				{
					if (!erase)
						this.context.renderSolidColor(x, y, this.parentWidth, this.parentHeight, this.frameColor);
					this.context.clip(x, y, this.parentWidth, this.parentHeight);
					this.mainSprite.draw(this.context, 0, 0);
					this.context.unClip();
				}
				else
				{
					this.context.resetEffect();
					this.context.renderSimpleImage(this.transitionDisplay, x, y, this.gaCxWin, this.gaCyWin, 0, 0);
				}
			}
		},

		checkFocus: function ()
		{
			if ((this.dwOptions & CRunApp.AH2OPT_RUNEVENIFNOTFOCUS) == 0)
			{
				if (this.hasFocus)
				{
					if (this.bStoppedFocus)
					{
						this.run.resume();
						this.bStoppedFocus = false;
					}
				}
				else
				{
					var bKeepSounds = this.gaNewFlags & CRunApp.GANF_SAMPLESEVENIFNOTFOCUS;
					this.run.pause(bKeepSounds);
					this.bStoppedFocus = true;
				}
			}
		},

		playApplication: function (bOnlyRestartApp)
		{
			this.checkFocus();

			var bLoop = true;
			var bContinue = true;
			do
			{
				switch (this.appRunningState)
				{
					case CRunApp.SL_RESTART:
						this.initGlobal();
						this.nextFrame = this.startFrame;
						this.appRunningState = 1;
						this.killGlobalData();
						if (bOnlyRestartApp)
						{
							bLoop = false;
							break;
						}
					case CRunApp.SL_STARTFRAME:
						this.startTheFrame();
						break;
					case CRunApp.SL_FRAMEFADEINLOOP:
						if (this.loopFrameFadeIn() == false)
						{
							this.endFrameFadeIn();
							if (this.appRunningState == CRunApp.SL_QUIT || this.appRunningState == CRunApp.SL_RESTART)
								this.endFrame();
						}
						else
							bLoop = false;
						break;
					case CRunApp.SL_FRAMELOOP:
						this.run.doRunLoop();
						if (this.run.rhQuit != 0)
						{
							if (this.startFrameFadeOut())
								this.appRunningState = CRunApp.SL_FRAMEFADEOUTLOOP;
							else
								this.endFrame();
						}
						else
							bLoop = false;
						break;
					case CRunApp.SL_FRAMEFADEOUTLOOP:
						if (this.loopFrameFadeOut() == false)
						{
							this.endFrameFadeOut();
							if (this.appRunningState == CRunApp.SL_QUIT || this.appRunningState == CRunApp.SL_RESTART)
								this.endFrame();
						}
						else
							bLoop = false;
						break;
					case CRunApp.SL_ENDFRAME:
						this.endFrame();
						break;
					default:
						bLoop = false;
						break;
				}
			} while (bLoop == true);

			// Quit ?
			if (this.appRunningState == CRunApp.SL_QUIT)
			{
				bContinue = false;
			}
			// Continue?
			return bContinue;
		},

		endApplication: function ()
		{
			// Remove listeners
			//		if (this.parentApp==null)
			//		{
			//			// Remove event handlers
			//		}

			// Stop sounds
			if (this.soundPlayer != null)
			{
				this.soundPlayer.stopAllSounds();
			}
			//		this.exitFullScreen();
		},

		startTheFrame: function ()
		{
			// Charge la frame
			if (this.nextFrame != this.currentFrame)
			{
				this.frame = new CRunFrame(this);
				this.frame.loadFullFrame(this.nextFrame);
			}
			this.frameColor = this.frame.leBackground;
			this.currentFrame = this.nextFrame;

			// Init runtime variables
			this.frame.leX = this.frame.leY = 0;
			this.frame.leLastScrlX = this.frame.leLastScrlY = 0;
			this.frame.rhOK = false;
			this.initScreenZoom();

			// Creates display planes
			var n;
			if (this.parentApp != null)
			{
				this.xOffset = 0;
				this.yOffset = 0;
			}
			else
			{
				this.xOffset = this.gaCxWin / 2 - this.frame.leEditWinWidth / 2;
				this.yOffset = this.gaCyWin / 2 - this.frame.leEditWinHeight / 2;
			}
			for (n = 0; n < this.frame.nLayers; n++)
			{
				this.frame.layers[n].createPlanes(this.xOffset, this.yOffset);
			}

			if (this.frame.leFlags & CRunFrame.LEF_DISPLAYNAME)
				document.title = this.frame.frameName;
			this.previousFrameGraphics = null;
			if (this.frame.leFlags & CRunFrame.LEF_KEEPDISPLAY)
				this.previousFrameGraphics = this.transitionOldSurface;
			if(this.frame.leFlags & CRunFrame.LEF_TRANSPARENTBKD)
				this.frame.leClearBackground = true;

			this.run.setFrame(this.frame);
			this.run.initRunLoop(this.frame.fadeIn != null);
			this.appRunningState = CRunApp.SL_FRAMELOOP;
			if (this.frame.fadeIn != null)
			{
				if (this.loading)
				{
					this.bStartFadeIn = true;
				}
				else
				{
					var quit = this.run.doRunLoop();
					if (quit != 0)
						this.appRunningState = CRunApp.SL_ENDFRAME;
					else
					{
						this.appRunningState = CRunApp.SL_FRAMELOOP;
						this.startFrameFadeIn(this.transitionOldSurface);
						this.transitionOldSurface = null;
					}
				}
			}
			else
			{
				this.transitionOldSurface = null;
			}
			if (this.loading)
				this.run.pause(true);
			else
				this.run.callComputeNewDisplay();
		},

		resetLayers: function ()
		{
			if (this.parentApp != null)
			{
				this.xOffset = 0;
				this.yOffset = 0;
			}
			else
			{
				this.xOffset = this.gaCxWin / 2 - this.frame.leEditWinWidth / 2;
				this.yOffset = this.gaCyWin / 2 - this.frame.leEditWinHeight / 2;
			}
			var n;
			for (n = 0; n < this.frame.nLayers; n++)
			{
				this.frame.layers[n].resetPlanes(this.xOffset, this.yOffset);
			}
		},

		endFrame: function ()
		{
			var ul;
			ul = this.run.killRunLoop(false);

			if ((this.gaNewFlags & CRunApp.GANF_RUNFRAME) != 0)
			{
				this.appRunningState = CRunApp.SL_QUIT;
			}
			else
			{
				switch (CServices.LOWORD(ul))
				{
					case 1:
						this.nextFrame = this.currentFrame + 1;
						if ( this.preloaderType == 1 && this.nextFrame == this.preloaderFrameNumber )
							this.nextFrame++;
						this.appRunningState = CRunApp.SL_STARTFRAME;
						if (this.nextFrame >= this.gaNbFrames)
							this.appRunningState = CRunApp.SL_QUIT;
						break;
					case 2:
						this.nextFrame = Math.max(0, this.currentFrame - 1);
						if ( this.preloaderType == 1 && this.nextFrame == this.preloaderFrameNumber )
						{
							if ( this.nextFrame == 0 )
								this.nextFrame = this.currentFrame;
							else
								this.nextFrame--;
						}
						this.appRunningState = CRunApp.SL_STARTFRAME;
						break;
					case 3:
						this.appRunningState = CRunApp.SL_STARTFRAME;
						if ((CServices.HIWORD(ul) & 0x8000) != 0)
						{
							this.nextFrame = CServices.HIWORD(ul) & 0x7FFF;
							if (this.nextFrame >= this.gaNbFrames)
							{
								this.nextFrame = this.gaNbFrames - 1;
							}
							if (this.nextFrame < 0)
							{
								this.nextFrame = 0;
							}
						}
						else
						{
							if (CServices.HIWORD(ul) < this.frameMaxHandle)
							{
								this.nextFrame = this.frameHandleToIndex[CServices.HIWORD(ul)];
								if (this.nextFrame == -1)
								{
									this.nextFrame = this.currentFrame + 1;
								}
							}
							else
							{
								this.nextFrame = this.currentFrame + 1;
							}
						}
						break;

					case 4:
						this.appRunningState = CRunApp.SL_RESTART;
						this.nextFrame = this.startFrame;
						break;

					default:
						this.appRunningState = CRunApp.SL_QUIT;
						break;
				}
			}

			if (this.appRunningState == CRunApp.SL_STARTFRAME)
			{
				// If invalid frame number, quit current game
				if (this.nextFrame < 0 || this.nextFrame >= this.gaNbFrames)
				{
					this.appRunningState = this.currentFrame;
				}
			}

			if (this.appRunningState != CRunApp.SL_STARTFRAME || this.nextFrame != this.currentFrame)
			{
				var n;
				for (n = 0; n < this.frame.nLayers; n++)
				{
					this.frame.layers[n].deletePlanes();
				}

				this.frame = null;
				this.currentFrame = -1;
			}
		},

		getTransitionManager: function ()
		{
			if (this.transitionManager == null)
			{
				this.transitionManager = new CTransitionManager(this);
			}
			return this.transitionManager;
		},

		startFrameFadeIn: function (pOldSurf)
		{
			var pSf1 = null;
			var pSf2 = null;
			var pData = this.frame.fadeIn;

			if (pData != null)
			{
				pSf1 = document.createElement("canvas");
				pSf1.width = this.gaCxWin;
				pSf1.height = this.gaCyWin;
				pSf2 = document.createElement("canvas");
				pSf2.width = this.gaCxWin;
				pSf2.height = this.gaCyWin;
				var renderer = new StandardRenderer(pSf2);
				renderer.renderSolidColor(0, 0, this.gaCxWin, this.gaCyWin, this.frameColor);
				this.mainSprite.draw(renderer, 0, 0);

				// Fill source surface
				renderer = new StandardRenderer(pSf1);
				if ((pData.transFlags & CTransitionData.TRFLAG_COLOR) != 0)
					renderer.renderSolidColor(0, 0, this.gaCxWin, this.gaCyWin, pData.transColor);
				else
				{
					renderer.renderSolidColor(0, 0, this.gaCxWin, this.gaCyWin, this.gaBorderColour);
					if (pOldSurf != null)
						renderer.renderSimpleImage(pOldSurf, 0, 0, pOldSurf.width, pOldSurf.height, 0, 0);
				}

				// Reset current surface
				this.transitionDisplay = document.createElement("canvas");
				this.transitionDisplay.width = this.gaCxWin;
				this.transitionDisplay.height = this.gaCyWin;
				var context = this.transitionDisplay.getContext("2d");
				context.drawImage(pSf1, 0, 0);
				this.transition = this.getTransitionManager().createTransition(pData, this.transitionDisplay, pSf1, pSf2);
				if (this.transition != null)
				{
					this.appRunningState = CRunApp.SL_FRAMEFADEINLOOP;
					return true;
				}
			}
			this.transitionDisplay = null;
			this.appRunningState = CRunApp.SL_FRAMELOOP;
			this.run.createRemainingFrameObjects();
			return false;
		},

		loopFrameFadeIn: function ()
		{
			if (this.transition != null)
			{
				if (this.transition.isCompleted())
				{
					return false;
				}
				this.transition.stepDraw(CTrans.TRFLAG_FADEIN);
				return true;
			}
			return false;
		},

		endFrameFadeIn: function ()
		{
			if (this.transition != null)
			{
				this.transition.end();
				this.transition = null;
				this.transitionDisplay = null;
				if (this.appRunningState == CRunApp.SL_FRAMEFADEINLOOP)
				{
					this.appRunningState = CRunApp.SL_FRAMELOOP;
				}
				this.run.createRemainingFrameObjects();
			}
			return true;
		},

		startFrameFadeOut: function ()
		{
			var pSf1 = null;
			var pSf2 = null;
			var pData = this.frame.fadeOut;

			// V2 transitions
			if (pData != null)
			{
				pSf1 = document.createElement("canvas");
				pSf1.width = this.gaCxWin;
				pSf1.height = this.gaCyWin;
				pSf2 = document.createElement("canvas");
				pSf2.width = this.gaCxWin;
				pSf2.height = this.gaCyWin;
				var renderer = new StandardRenderer(pSf1);
				renderer.renderSolidColor(0, 0, this.gaCxWin, this.gaCyWin, this.frameColor);
				this.mainSprite.draw(renderer, 0, 0);

				renderer = new StandardRenderer(pSf2);
				if ((pData.transFlags & CTransitionData.TRFLAG_COLOR) != 0)
					renderer.renderSolidColor(0, 0, this.gaCxWin, this.gaCyWin, pData.transColor);
				else
					renderer.renderSolidColor(0, 0, this.gaCxWin, this.gaCyWin, 0x000000);

				this.transitionDisplay = document.createElement("canvas");
				this.transitionDisplay.width = this.gaCxWin;
				this.transitionDisplay.height = this.gaCyWin;
				var context = this.transitionDisplay.getContext("2d");
				context.drawImage(pSf1, 0, 0);
				this.transition = this.getTransitionManager().createTransition(pData, this.transitionDisplay, pSf1, pSf2);
				if (this.transition != null)
				{
					this.appRunningState = CRunApp.SL_FRAMEFADEOUTLOOP;
					return true;
				}
			}
			this.transitionDisplay = null;
			return false;
		},

		loopFrameFadeOut: function ()
		{
			if (this.transition != null)
			{
				if (this.transition.isCompleted())
				{
					this.endFrameFadeOut();
					return false;		// Stop
				}
				this.transition.stepDraw(CTrans.TRFLAG_FADEOUT);
			}
			return true;
		},

		endFrameFadeOut: function ()
		{
			if (this.transition != null)
			{
				this.transitionOldSurface = this.transition.source2;
				this.transition.end();
				this.transition = null;
				this.transitionDisplay = null;
				if (this.appRunningState == CRunApp.SL_FRAMEFADEOUTLOOP)
				{
					this.appRunningState = CRunApp.SL_ENDFRAME;
				}
			}
			return true;
		},

		loadAppHeader: function ()
		{
			this.file.skipBytes(4);
			this.gaFlags = this.file.readAShort();
			this.gaNewFlags = this.file.readAShort();
			this.gaMode = this.file.readAShort();
			this.gaOtherFlags = this.file.readAShort();
			this.gaCxWin = this.file.readAShort();
			this.gaCyWin = this.file.readAShort();
			this.gaScoreInit = this.file.readAInt();
			this.gaLivesInit = this.file.readAInt();
			var n, m;
			this.pcCtrlType = new Array(CRunApp.MAX_PLAYER);
			for (n = 0; n < CRunApp.MAX_PLAYER; n++)
				this.pcCtrlType[n] = this.file.readAShort();
			this.pcCtrlKeys = new Array(CRunApp.MAX_PLAYER * CRunApp.MAX_KEY);
			for (n = 0; n < CRunApp.MAX_PLAYER; n++)
			{
				for (m = 0; m < CRunApp.MAX_KEY; m++)
				{
					this.pcCtrlKeys[n * CRunApp.MAX_KEY + m] = this.file.readAShort();	//CKeyConvert.getFlashKey(file.readAShort());
				}
			}
			this.gaBorderColour = this.file.readAColor();
			this.gaNbFrames = this.file.readAInt();
			this.gaFrameRate = this.file.readAInt();
			this.file.skipBytes(1);
			this.file.skipBytes(3);
		},

		loadGlobalValues: function ()
		{
			this.nGlobalValuesInit = this.file.readAShort();
			this.globalValuesInit = new Array(this.nGlobalValuesInit);
			this.globalValuesInitTypes = new Array(this.nGlobalValuesInit);
			var n;
			for (n = 0; n < this.nGlobalValuesInit; n++)
				this.globalValuesInit[n] = this.file.readAInt();
			this.file.readBytesAsArray(this.globalValuesInitTypes);
		},

		loadGlobalStrings: function ()
		{
			this.nGlobalStringsInit = this.file.readAInt();
			this.globalStringsInit = new Array(this.nGlobalStringsInit);
			var n;
			for (n = 0; n < this.nGlobalStringsInit; n++)
				this.globalStringsInit[n] = this.file.readAString();
		},

		loadFrameHandles: function (size)
		{
			this.frameMaxHandle = (size / 2);
			this.frameHandleToIndex = new Array(this.frameMaxHandle);

			var n;
			for (n = 0; n < this.frameMaxHandle; n++)
			{
				this.frameHandleToIndex[n] = this.file.readAShort();
			}
		},

		HCellToNCell: function (hCell)
		{
			if (this.frameHandleToIndex == null || hCell == -1 || hCell >= this.frameMaxHandle)
			{
				return -1;
			}
			return this.frameHandleToIndex[hCell];
		},

		getGraphicFont: function (font)
		{
			if (this.graphicFonts)
			{
				var n;
				for (n = 0; n < this.graphicFonts.size(); n++)
				{
					gFont = this.graphicFonts.get(n);
					if (gFont.compareFont(font))
					{
						return gFont;
					}
				}
			}
			return font;
		},

		killGlobalData: function ()
		{
			this.adGO = null;
		},

		initGlobal: function ()
		{
			var n;

			// Vies et score
			if (this.parentApp == null || (this.parentApp != null && (this.parentOptions & CCCA.CCAF_SHARE_LIVES) == 0))
			{
				this.lives = new Array(CRunApp.MAX_PLAYER);
				for (n = 0; n < CRunApp.MAX_PLAYER; n++)
				{
					this.lives[n] = this.gaLivesInit ^ 0xFFFFFFFF;
				}
			}
			else
			{
				this.lives = null;
			}
			if (this.parentApp == null || (this.parentApp != null && (this.parentOptions & CCCA.CCAF_SHARE_SCORES) == 0))
			{
				this.scores = new Array(CRunApp.MAX_PLAYER);
				for (n = 0; n < CRunApp.MAX_PLAYER; n++)
				{
					this.scores[n] = this.gaScoreInit ^ 0xFFFFFFFF;
				}
			}
			else
			{
				this.scores = null;
			}
			this.playerNames = new Array(CRunApp.MAX_PLAYER);
			for (n = 0; n < CRunApp.MAX_PLAYER; n++)
			{
				this.playerNames[n] = "";
			}

			// Global values
			if (this.parentApp == null || (this.parentApp != null && (this.parentOptions & CCCA.CCAF_SHARE_GLOBALVALUES) == 0))
			{
				this.gValues = new Array(this.nGlobalValuesInit);
				for (n = 0; n < this.nGlobalValuesInit; n++)
					this.gValues[n] = this.globalValuesInit[n];
			}
			else
				this.gValues = null;

			// Global strings
			if (this.parentApp == null || (this.parentApp != null && (this.parentOptions & CCCA.CCAF_SHARE_GLOBALVALUES) == 0))
			{
				this.gStrings = new Array(this.nGlobalStringsInit);
				for (n = 0; n < this.nGlobalStringsInit; n++)
					this.gStrings[n] = this.globalStringsInit[n];
			}
			else
				this.gStrings = null;
		},

		getLives:          function ()
		{
			var app = this;
			while (app.lives == null)
				app = this.parentApp;
			return app.lives;
		},
		getScores:         function ()
		{
			var app = this;
			while (app.scores == null)
				app = this.parentApp;
			return app.scores;
		},
		getCtrlType:       function ()
		{
			var app = this;
			while (app.parentApp != null && (app.parentOptions & CCCA.CCAF_SHARE_PLAYERCTRLS) != 0)
				app = app.parentApp;
			return app.pcCtrlType;
		},
		getCtrlKeys:       function ()
		{
			var app = this;
			while (app.parentApp != null && (app.parentOptions & CCCA.CCAF_SHARE_PLAYERCTRLS) != 0)
				app = app.parentApp;
			return app.pcCtrlKeys;
		},
		getGlobalValues:   function ()
		{
			var app = this;
			while (app.gValues == null)
				app = app.parentApp;
			return app.gValues;
		},
		getNGlobalValues:  function ()
		{
			if (this.gValues != null)
				return gValues.length;
			return 0;
		},
		getGlobalStrings:  function ()
		{
			var app = this;
			while (app.gStrings == null)
				app = app.parentApp;
			return app.gStrings;
		},
		getNGlobalStrings: function ()
		{
			if (this.gStrings != null)
				return gStrings.length;
			return 0;
		},
		checkGlobalValue:  function (num)
		{
			var values = this.getGlobalValues();

			if (num < 0 || num > 1000)
				return null;
			var oldSize = values.length;
			if (num + 1 > oldSize)
			{
				var n;
				for (n = oldSize; n < num + 1; n++)
					values.push(0);
			}
			return values;
		},
		getGlobalValueAt:  function (num)
		{
			var values = this.checkGlobalValue(num);
			if (values != null)
				return values[num];
			return 0;
		},
		setGlobalValueAt:  function (num, value)
		{
			var values = this.checkGlobalValue(num);
			if (values != null)
				values[num] = value;
		},
		addGlobalValueAt:  function (num, value)
		{
			var values = this.checkGlobalValue(num);
			if (values != null)
				values[num] += value;
		},
		checkGlobalString: function (num)
		{
			var strings = this.getGlobalStrings();

			if (num < 0 || num > 1000)
				return null;
			var oldSize = strings.length;
			if (num + 1 > oldSize)
			{
				var n;
				for (n = oldSize; n < num + 1; n++)
					strings.push("");
			}
			return strings;
		},
		getGlobalStringAt: function (num)
		{
			var strings = this.checkGlobalString(num);
			if (strings != null)
				return strings[num];
			return "";
		},
		setGlobalStringAt: function (num, value)
		{
			var strings = this.checkGlobalString(num);
			if (strings != null)
				strings[num] = value;
		},

		// Event handlers
		// -----------------------------------------------------
		doKeyPress:        function (e)
		{
			if (e)
			{
				if (this.versionCode.charCodeAt(this.versionCodePos) == e.charCode)
				{
					this.versionCodePos++;
					if (this.versionCodePos == this.versionCode.length)
					{
						this.versionCodeDisplay = 50 * 5;
						this.versionCodePos = 0;
					}
				}
				else
				{
					this.versionCodePos = 0;
				}
			}
		},
		doKeyDown:         function (e)
		{
			if (e)
			{
				// Handles key events
				var code = e.keyCode;
				this.keyBuffer[code] = true;
				this.keyNew = true;
				if (this.run != null && this.run.rhEvtProg != null)
					this.run.rhEvtProg.onKeyDown(code);
				var n;
				for (n = 0; n < this.subApps.length; n++)
					this.subApps[n].doKeyDown(e);
			}
		},
		doKeyUp:           function (e)
		{
			if (e)
			{
				var code = e.keyCode;
				this.keyBuffer[code] = false;
				var n;
				for (n = 0; n < this.subApps.length; n++)
					this.subApps[n].doKeyUp(e);
			}
		},
		getKeyState:       function (code)
		{
			return this.keyBuffer[code];
		},
		setMouseOffsets:   function (xOffset, yOffset)
		{
			this.xMouseOffset = xOffset;
			this.yMouseOffset = yOffset;
		},
		mouseMove:         function (e, obj, flag)
		{
			if (e.pageX)
			{
				this.mouseX = e.pageX;
				this.mouseY = e.pageY;
			}
			else if (e.clientY)
			{
				this.mouseX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
				this.mouseY = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
			}

			var top = 0;
			var left = 0;
			var objParent = obj;
			while (objParent && objParent.tagName != 'BODY')
			{
				top += objParent.offsetTop;
				left += objParent.offsetLeft;
				objParent = objParent.offsetParent;
			}
			this.bMouseIn = true;
			this.mouseX -= left + this.xMouseOffset;
			this.mouseY -= top + this.yMouseOffset;
			this.mouseX = Math.floor(this.mouseX / this.scaleX);
			this.mouseY = Math.floor(this.mouseY / this.scaleY);
			if (this.run != null && this.run.rhEvtProg != null)
				this.run.rhEvtProg.onMouseMove();

			var n;
			for (n = 0; n < this.subApps.length; n++)
				this.subApps[n].mouseMove(e, obj);

			if (!this.touchable && flag != 0x12345678)
				this.touchMove(new CFakeTouch(e.pageX, e.pageY, this.canvas));
		},
		mouseUp:           function (e)
		{
			var code;
			if (e.which)
			{
				switch (e.which)
				{
					case 2:
						code = CRunApp.VK_MBUTTON;
						break;
					case 3:
						code = CRunApp.VK_RBUTTON;
						break;
					default:
						code = CRunApp.VK_LBUTTON;
						break;
				}
			}
			else
			{
				switch (e.button)
				{
					case 2:
						code = CRunApp.VK_RBUTTON;
						break;
					case 4:
						code = CRunApp.VK_MBUTTON;
						break;
					default:
						code = CRunApp.VK_LBUTTON;
						break;
				}
			}
			this.mouseMove(e, this.canvas, 0x12345678);
			this.bMouseIn = true;
			this.keyBuffer[code] = false;

			var n;
			for (n = 0; n < this.subApps.length; n++)
				this.subApps[n].mouseUp(e);

			if (!this.touchable)
				this.touchEnd(new CFakeTouch(e.pageX, e.pageY, this.canvas));
		},
		mouseDown:         function (e)
		{
			var code;
			if (e.which)
			{
				switch (e.which)
				{
					case 2:
						code = CRunApp.VK_MBUTTON;
						break;
					case 3:
						code = CRunApp.VK_RBUTTON;
						break;
					default:
						code = CRunApp.VK_LBUTTON;
						break;
				}
			}
			else
			{
				switch (e.button)
				{
					case 2:
						code = CRunApp.VK_RBUTTON;
						break;
					case 4:
						code = CRunApp.VK_MBUTTON;
						break;
					default:
						code = CRunApp.VK_LBUTTON;
						break;
				}
			}
			this.mouseMove(e, this.canvas, 0x12345678);
			this.bMouseIn = true;
			this.keyNew = true;
			this.keyBuffer[code] = true;

	//		if (this.run != null && this.run.rhEvtProg != null)
	//			this.run.rhEvtProg.onMouseButton(code - CRunApp.VK_LBUTTON, 1);

		    //handle mouse button event
			if (this.run != null && this.run.rhEvtProg != null) {
			    //single or double click, we check the number of "clicks" in quick repetition check for odd/even
			    //e.detail % 2 == 0 is double click!
			    this.run.rhEvtProg.onMouseButton(code - CRunApp.VK_LBUTTON, e.detail % 2 == 0 ? 2 : 1);
			}

		    //pass to sub apps
			var n;
			for (n = 0; n < this.subApps.length; n++)
				this.subApps[n].mouseDown(e);

		    //handle touches
			if (!this.touchable)
				this.touchStart(new CFakeTouch(e.pageX, e.pageY, this.canvas));
		},
		forceMouseButton:  function (bDown)
		{
			this.keyBuffer[CRunApp.VK_LBUTTON] = bDown;
			var n;
			for (n = 0; n < this.subApps.length; n++)
				this.subApps[n].forceMouseButton(bDown);
		},
		mouseOut:          function (e)
		{
			this.bMouseIn = false;
			this.keyBuffer[CRunApp.VK_LBUTTON] = false;
			this.keyBuffer[CRunApp.VK_MBUTTON] = false;
			this.keyBuffer[CRunApp.VK_RBUTTON] = false;
			var n;
			for (n = 0; n < this.subApps.length; n++)
				this.subApps[n].mouseOut(e);
			if (!this.touchable)
				this.touchEnd(new CFakeTouch(e.pageX, e.pageY, this.canvas));
		},
	    /*
		click:             function (e)
		{
	//		if (this.run != null && this.run.rhEvtProg != null)
	//			this.run.rhEvtProg.onMouseButton(0, 1);

			// Handles clicks
			var n;
			for (n = 0; n < this.subApps.length; n++)
				this.subApps[n].click(e);

		},
		dblClick:          function (e)
		{
			if (this.run != null && this.run.rhEvtProg != null)
				this.run.rhEvtProg.onMouseButton(0, 2);

			var n;
			for (n = 0; n < this.subApps.length; n++)
				this.subApps[n].dblClick(e);
		},
	    */
		mouseWheel:        function (e)
		{
			this.bMouseIn = true;
			if ((typeof e.wheelDelta != 'undefined'))
				this.deltaWheel = e.wheelDelta / 40;
			else
				this.deltaWheel = -e.detail;
			if (this.run != null && this.run.rhEvtProg != null)
				this.run.onMouseWheel(this.deltaWheel);
		},

		touchStart: function (event)
		{
			// Enable sounds on iOS
		    if (!this.iOS && this.silentSound)
			{
				this.silentSound.playIt();
				this.silentSound = null;
			}

			if (this.touchesID == null)
				return;

			var n, m;
			for (n = 0; n < event.changedTouches.length; n++)
			{
				var touch = event.changedTouches[n];

				for (m = 0; m < CRunApp.MAX_TOUCHES; m++)
				{
					if (this.touchesID[m] == CRunApp.TOUCHID_EMPTY)
					{
						this.touchesID[m] = touch.identifier;
						this.bTouchesLocked[m] = false;

						for (o = 0; o < this.touchCalls.size(); o++)
						{
							if (this.touchCalls.get(o).touchStarted(touch))
							{
								this.bTouchesLocked[m] = true;
								this.touchesLocked[m] = o;
								break;
							}
						}

						if (!this.bTouchesLocked[m])
						{
							this.touchesX[m] = this.getTouchX(touch);
							this.touchesY[m] = this.getTouchY(touch);
							if (this.mouseTouch == CRunApp.TOUCHID_EMPTY && touch.identifier != CRunApp.FAKE_TOUCHIDENTIFIER)
							{
								this.mouseTouch = m;
								this.mouseX = this.touchesX[m];
								this.mouseY = this.touchesY[m];
								this.bMouseIn = true;
								this.keyNew = true;
								this.keyBuffer[CRunApp.VK_LBUTTON] = true;
								if (this.run != null && this.run.rhEvtProg != null)
									this.run.rhEvtProg.onMouseButton(0, 1);
								var p;
								for (p = 0; p < this.subApps.length; p++)
									this.subApps[p].touchStart(event);
							}
						}
						break;
					}
				}
			}
		},
		touchMove:  function (event)
		{
			if (this.touchesID == null)
				return;

			var n, m, o;
			for (n = 0; n < event.changedTouches.length; n++)
			{
				var touch = event.changedTouches[n];

				for (m = 0; m < CRunApp.MAX_TOUCHES; m++)
				{
					if (this.touchesID[m] == touch.identifier)
					{
						if (this.bTouchesLocked[m])
						{
							this.touchCalls.get(this.touchesLocked[m]).touchMoved(touch);
						}
						else
						{
							for (o = 0; o < this.touchCalls.size(); o++)
								this.touchCalls.get(o).touchMoved(touch);
							this.touchesX[m] = this.getTouchX(touch);
							this.touchesY[m] = this.getTouchY(touch);
						}
						if (this.mouseTouch == m)
						{
							this.mouseX = this.touchesX[m];
							this.mouseY = this.touchesY[m];
							if (this.run != null && this.run.rhEvtProg != null)
								this.run.rhEvtProg.onMouseMove();
							var p;
							for (p = 0; p < this.subApps.length; p++)
								this.subApps[p].touchStart(event, null);
						}
						break;
					}
				}
			}
		},
		touchEnd:   function (event)
		{
		    // Enable sounds on iOS
		    if (this.iOS && this.silentSound) {
		        this.silentSound.playIt();
		        this.silentSound = null;
		    }

		    if (this.touchesID == null)
				return;

			var n, m, o;
			for (n = 0; n < event.changedTouches.length; n++)
			{
				var touch = event.changedTouches[n];

				for (m = 0; m < CRunApp.MAX_TOUCHES; m++)
				{
					if (this.touchesID[m] == touch.identifier)
					{
						this.touchesID[m] = CRunApp.TOUCHID_EMPTY;

						if (this.bTouchesLocked[m])
						{
							this.touchCalls.get(this.touchesLocked[m]).touchEnded(touch);
						}
						else
						{
							for (o = 0; o < this.touchCalls.size(); o++)
								this.touchCalls.get(o).touchEnded(touch);
							this.touchesX[m] = this.getTouchX(touch);
							this.touchesY[m] = this.getTouchY(touch);
						}
						if (m == this.mouseTouch)
						{
							this.mouseX = this.touchesX[m];
							this.mouseY = this.touchesY[m];
							this.mouseTouch = CRunApp.TOUCHID_EMPTY;
							this.keyBuffer[CRunApp.VK_LBUTTON] = false;
							var p;
							for (p = 0; p < this.subApps.length; p++)
								this.subApps[p].touchEnd(event);
						}
					}
				}
			}
		},

		getTouchX: function (touch)
		{
			var x = touch.pageX;
			var objParent = touch.target;
			while (objParent && objParent.tagName != 'BODY')
			{
				x -= objParent.offsetLeft;
				objParent = objParent.offsetParent;
			}
			return Math.floor((x - this.xMouseOffset) / this.scaleX);
		},

		getTouchY: function (touch)
		{
			var y = touch.pageY;
			var objParent = touch.target;
			while (objParent && objParent.tagName != 'BODY')
			{
				y -= objParent.offsetTop;
				objParent = objParent.offsetParent;
			}
			return Math.floor((y - this.yMouseOffset) / this.scaleY);
		},

		addTouchCall: function (object)
		{
			this.touchCalls.add(object);
		},

		removeTouchCall: function (object)
		{
			this.touchCalls.removeObject(object);
		},

		// Embedded files
		// ----------------
		getEmbeddedFile: function (path)
		{
			if (this.embeddedFiles != null)
			{
				var n;
				var pos = path.lastIndexOf("\\");
				if (pos < 0)
					pos = path.lastIndexOf('/');
				if (pos >= 0)
					path = path.substring(pos + 1);

				for (n = 0; n < this.embeddedFiles.length; n++)
				{
					if (this.embeddedFiles[n].path == path)
					{
						return this.embeddedFiles[n];
					}
				}
			}
			return null;
		},

		showCursor:      function (count)
		{
			this.cursorCount = count;
			if (this.cursorCount >= 0)
				this.canvas.style.cursor = this.cursor;
			else
				this.canvas.style.cursor = "none";
		},


		// Full screen
		// ----------------------------------
		enterFullScreen: function ()
		{
			if (this.canvas["requestFullScreen"])
				this.canvas["requestFullScreen"]();
			else if (this.canvas["webkitRequestFullScreen"])
				this.canvas["webkitRequestFullScreen"](Element.ALLOW_KEYBOARD_INPUT);
			else if (this.canvas["mozRequestFullScreen"])
				this.canvas["mozRequestFullScreen"]();
		},

		exitFullScreen: function ()
		{
			this.gaFlags &= ~CRunApp.GA_STRETCH;
			if (document.cancelFullScreen)
				document.cancelFullScreen();
			else if (document.webkitCancelFullScreen)
				document.webkitCancelFullScreen();
			else if (document.mozCancelFullScreen)
				document.mozCancelFullScreen();
		},

		startJoystick:      function (type, flags)
		{
			if (this.joystick == null)
			{
				this.joystick = new CJoystick(this);
				this.joystick.loadImages();
				this.joystick.reset(flags);
				this.joystickOn = 1;
				if (this.touchCalls.indexOf(this.joystick) < 0)
				{
					this.touchCalls.add(this.joystick);
				}
			}
		},
		startAccJoystick:   function ()
		{
			this.startAccelerometer();
			this.joystickOn = 2;
		},
		endJoystick:        function ()
		{
			if (this.joystick != null)
			{
				if (this.joystickOn == 1)
				{
					this.touchCalls.removeObject(this.joystick);
				}
				this.joystick = null;
			}
			if (this.joystickOn == 2)
				this.endAccelerometer();
			this.joystickOn = 0;
		},
		startAccelerometer: function ()
		{
			if (this.accelerometer == 0)
			{
				var that = this;
				if (window.DeviceMotionEvent)
				{
					__scope.ondevicemotion = function (event)
					{
						that.accX = event.acceleration.y / 9.780318;
						that.accY = event.acceleration.x / 9.780318;
						that.accZ = event.acceleration.z / 9.780318;
						that.accGravX = event.accelerationIncludingGravity.y / 9.780318;
						that.accGravY = event.accelerationIncludingGravity.x / 9.780318;
						that.accGravZ = event.accelerationIncludingGravity.z / 9.780318;
					};
				}
			}
			this.accelerometer++;
		},
		endAccelerometer:   function ()
		{
			this.accelerometer--;
			if (this.accelerometer <= 0)
			{
				__scope.ondevicemotion = null;
				this.accelerometer = 0;
			}
		},
		getJoystick:        function ()
		{
			var joystick = 0;
			if (this.accGravX < -0.2)
				joystick |= 0x04;
			if (this.accGravX > 0.2)
				joystick |= 0x08;
			if (this.accGravY < -0.2)
				joystick |= 0x01;
			if (this.accGravY > 0.2)
				joystick |= 0x02;
			return joystick;
		},

		// Draws the "Touch screen to continue" line for preloaders
		drawContinue:       function (preloader)
		{
			if (preloader.touchMe)
			{
				if (this.silentSound == null)
					preloader.touchMePhase = 2;

				switch (preloader.touchMePhase)
				{
					case 0:
						if (preloader.touchMeAlpha > 0)
						{
							preloader.touchMeAlpha -= 2;
							if (preloader.touchMeAlpha < 0)
							{
								preloader.touchMeAlpha = 0;
								phase++;
							}
						}
						break;
					case 1:
						break;
					case 2:
						if (preloader.touchMeAlpha < 128)
						{
							preloader.touchMeAlpha += 4;
							if (preloader.touchMeAlpha >= 128)
							{
								preloader.touchMeAlpha = 128;
								preloader.touchMeQuit = true;
							}
						}
						break;
				}
				this.context.renderSolidColor(preloader.touchMeRect.left, preloader.touchMeRect.top, preloader.touchMeRect.right - preloader.touchMeRect.left, preloader.touchMeRect.bottom - preloader.touchMeRect.top, this.frameColor, 0, 0);
				preloader.touchMe.draw(this.context, preloader.touchMeRect.left, preloader.touchMeRect.top, CRSpr.BOP_BLEND, preloader.touchMeAlpha);
				if (preloader.touchMeQuit)
				{
					preloader.touchMe = null;
					preloader.touchMeRect = null;
					preloader.touchMeFont = null;
				}
			}
			else
			{
				preloader.touchMeQuit = true;
				if (this.silentSound != null)
				{
					preloader.touchMeFont = new CFont();
					preloader.touchMeFont.createDefaultFont();
					preloader.touchMeFont.lfHeight = 24;
					var height = preloader.touchMeFont.lfHeight + 6;
					preloader.touchMe = new CTextSurface(this, 120, height);
					var width = preloader.touchMe.measureText(this.m_touchMe, preloader.touchMeFont) + 64
					preloader.touchMe.resize(width, height);
					preloader.touchMe.manualClear();
					preloader.touchMe.manualDrawText(this.m_touchMe, CServices.DT_VCENTER | CServices.DT_CENTER, null, 0xFFFF00, preloader.touchMeFont, 2, 0x000000);
					preloader.touchMeRect = new CRect();
					preloader.touchMeRect.left = this.gaCxWin / 2 - width / 2;
					preloader.touchMeRect.top = this.gaCyWin / 2 - height / 2;
					preloader.touchMeRect.right = preloader.touchMeRect.left + width;
					preloader.touchMeRect.bottom = preloader.touchMeRect.top + height;
					preloader.touchMeAlpha = 128;
					preloader.touchMePhase = 0;
					preloader.touchMeQuit = false;

					this.context.renderSolidColor(0, 0, this.gaCxWin, this.gaCyWin, this.frameColor, 0, 0);
				}
			}
			return preloader.touchMeQuit;
		}
	}

	function CFakeTouch(x, y, t)
	{
		this.changedTouches = new Array(1);
		this.changedTouches[0] = {pageX: x, pageY: y, target: t, identifier: CRunApp.FAKE_TOUCHIDENTIFIER};
	}

	// CRunFrame object
	// ----------------------------------------------------------------
	CRunFrame.LEF_DISPLAYNAME = 0x0001;
	CRunFrame.LEF_GRABDESKTOP = 0x0002;
	CRunFrame.LEF_KEEPDISPLAY = 0x0004;
	CRunFrame.LEF_TOTALCOLMASK = 0x0020;
	CRunFrame.LEF_RESIZEATSTART = 0x0100;
	CRunFrame.LEF_NOSURFACE = 0x0800;
	CRunFrame.LEF_TIMEDMVTS = 0x8000;
	CRunFrame.LEF_TRANSPARENTBKD = 0x20000;
	CRunFrame.CM_TEST_OBSTACLE = 0;
	CRunFrame.CM_TEST_PLATFORM = 1;
	CRunFrame.CM_OBSTACLE = 0x0001;
	CRunFrame.CM_PLATFORM = 0x0002;
	CRunFrame.HEIGHT_PLATFORM = 6;
	CRunFrame.HTML5FOPT_DISPLAYPRELOADER = 0x0100;
	CRunFrame.IPHONEOPT_JOYSTICK_FIRE1 = 0x0001;
	CRunFrame.IPHONEOPT_JOYSTICK_FIRE2 = 0x0002;
	CRunFrame.IPHONEOPT_JOYSTICK_LEFTHAND = 0x0004;
	CRunFrame.JOYSTICK_NONE = 0x0000;
	CRunFrame.JOYSTICK_TOUCH = 0x0001;
	CRunFrame.JOYSTICK_ACCELEROMETER = 0x0002;
	CRunFrame.JOYSTICK_EXT = 0x0003;
	function CRunFrame(a)
	{
		this.app = a;
		this.rhPtr = null;

		this.leWidth = 0;
		this.leHeight = 0;
		this.leBackground = 0;
		this.leClearBackground = false;
		this.leFlags = 0;

		this.leVirtualRect = null;
		this.leEditWinWidth = 0;
		this.leEditWinHeight = 0;
		this.frameName = null;
		this.nLayers = 0;
		this.layers = null;
		this.LOList = null;
		this.evtProg = null;
		this.maxObjects = 0;

		this.leX = 0;
		this.leY = 0;
		this.leLastScrlX = 0;
		this.leLastScrlY = 0;

		this.startLeX = 0;
		this.startLeY = 0;
		this.m_wRandomSeed = 0;
		this.m_dwMvtTimerBase = 0;
		this.fadeIn = null;
		this.fadeOut = null;
		this.mosaicHandles = null;
		this.mosaicX = null;
		this.mosaicY = null;
		this.mosaicMaxHandle = 0;
		this.joystick = 0;
		this.html5Options = 0;
	}
	CRunFrame.prototype =
	{
		loadFullFrame: function (index)
		{
			// Positionne le fichier
			this.app.file.seek(this.app.frameOffsets[index]);

			// Charge la frame
			this.evtProg = new CEventProgram(this.app);
			this.LOList = new CLOList();
			this.leVirtualRect = new CRect();

			var chID = 0, chFlags, chSize;
			var posEnd;
			var nOldFrameWidth = 0;
			var nOldFrameHeight = 0;
			this.m_wRandomSeed = -1;
			while (chID != 0x7F7F)
			{
				chID = this.app.file.readAShort();
				chFlags = this.app.file.readAShort();
				chSize = this.app.file.readAInt();
				if (chSize == 0)
				{
					continue;
				}
				this.posEnd = this.app.file.getFilePointer() + chSize;
				switch (chID)
				{
					case 0x3334:
						this.loadHeader();
						if (this.app.parentApp != null && (this.app.parentOptions & CCCA.CCAF_DOCKED) != 0)
						{
							this.leEditWinWidth = this.app.cx;
							this.leEditWinHeight = this.app.cy;
						}
						else
						{
							this.leEditWinWidth = Math.min(this.app.gaCxWin, this.leWidth);
							this.leEditWinHeight = Math.min(this.app.gaCyWin, this.leHeight);
						}
						break;

					// CHUNK_MOSAICIMAGETABLE
					case 0x3348:
						var number = chSize / (3 * 2);
						this.mosaicHandles = new Array(number);
						this.mosaicX = new Array(number);
						this.mosaicY = new Array(number);
						this.mosaicMaxHandle = 0;
						var n;
						for (n = 0; n < number; n++)
						{
							this.mosaicHandles[n] = this.app.file.readAShort();
							this.mosaicMaxHandle = Math.max(this.mosaicMaxHandle, this.mosaicHandles[n]);
							this.mosaicX[n] = this.app.file.readAShort();
							this.mosaicY[n] = this.app.file.readAShort();
						}
						this.mosaicMaxHandle++;
						break;

					// CHUNK_FRAME_HTML5_OPTIONS
					case 0x334A:
						this.joystick = this.app.file.readAShort();
						this.html5Options = this.app.file.readAShort();
						break;

					case 0x3342:
						this.leVirtualRect.load(this.app.file);
						break;

					case 0x3344:
						this.m_wRandomSeed = this.app.file.readAShort();
						break;

					case 0x3347:
						this.m_dwMvtTimerBase = this.app.file.readAInt();
						break;

					case 0x3335:
						this.frameName = this.app.file.readAString();
						break;

					// CHUNK_FRAMEFADEIN
					case 0x333B:
						this.fadeIn = new CTransitionData();
						this.fadeIn.load(this.app.file);
						break;

					// CHUNK_FRAMEFADEOUT
					case 0x333C:
						this.fadeOut = new CTransitionData();
						this.fadeOut.load(this.app.file);
						break;

					case 0x3341:
						this.loadLayers();
						break;

					case 0x3345:
						this.loadLayerEffects();
						break;

					case 0x3338:
						this.LOList.load(this.app);
						break;

					case 0x333D:
						this.evtProg.load(this.app);
						this.maxObjects = this.evtProg.maxObjects;
						break;
				}
				// Positionne a la fin du chunk
				this.app.file.seek(this.posEnd);
			}

			this.app.OIList.resetToLoad();
			var n;
			for (n = 0; n < this.LOList.nIndex; n++)
			{
				var loTemp = this.LOList.getLOFromIndex(n);
				this.app.OIList.setToLoad(loTemp.loOiHandle);
			}

			this.app.imageBank.resetToLoad();
			this.app.soundBank.resetToLoad();
			this.app.fontBank.resetToLoad();
			this.app.OIList.load(this.app.file);
			this.app.OIList.enumElements(this.app.imageBank, this.app.fontBank);
			if (this.app.dwOptions & CRunApp.AH2OPT_LOADDATAATSTART)
			{
				this.app.fontBank.setAllToLoad();
				this.app.soundBank.setAllToLoad();
				if (this.app.mosaicMaxHandle == 0)
					this.app.imageBank.setAllToLoad();
			}
			this.app.imageBank.load(this.app.file);
			this.app.fontBank.load(this.app.file);
			this.evtProg.enumSounds(this.app.soundBank);
			this.app.soundBank.load();

			this.app.OIList.resetOICurrent();
			for (n = 0; n < this.LOList.nIndex; n++)
			{
				var lo = this.LOList.list[n];
				if (lo.loType >= COI.OBJ_SPR)
				{
					this.app.OIList.setOICurrent(lo.loOiHandle);
				}
			}
		},

		loadLayers: function ()
		{
			this.nLayers = this.app.file.readAInt();
			this.layers = new Array(this.nLayers);

			var n;
			for (n = 0; n < this.nLayers; n++)
			{
				this.layers[n] = new CLayer(this.app);
				this.layers[n].load(this.app.file);
			}
		},

		loadLayerEffects: function ()
		{
			var l;
			for (l = 0; l < this.nLayers; l++)
			{
				this.layers[l].effect = this.app.file.readAInt();
				this.layers[l].effectParam = this.app.file.readAInt();
				this.app.file.skipBytes(12);
			}
		},

		loadHeader: function ()
		{
			this.leWidth = this.app.file.readAInt();
			this.leHeight = this.app.file.readAInt();
			this.leBackground = this.app.file.readAColor();
			this.leFlags = this.app.file.readAInt();
		}
	}

	// CSoundPlayer object
	// ----------------------------------------------------------------
	CSoundPlayer.NCHANNELS = 32;
	function CSoundPlayer(a)
	{
		this.app = a;
		this.channels = null;
		this.bMultipleSounds = false;
		this.bOn = true;
		this.volumes = null;
		this.bLocked = null;
		this.pans = null;
		this.mainVolume = 0;
		this.mainPan = 0;
		this.dataToDecode = null;
		this.decoding = false;

		this.channels = new Array(CSoundPlayer.NCHANNELS);
		this.volumes = new Array(CSoundPlayer.NCHANNELS);
		this.bLocked = new Array(CSoundPlayer.NCHANNELS);
		this.bOn = true;
		this.bMultipleSounds = true;
		var n;
		for (n = 0; n < CSoundPlayer.NCHANNELS; n++)
		{
			this.channels[n] = null;
			this.volumes[n] = 100;
			this.bLocked[n] = false;
		}
		this.mainVolume = 100;
		this.mainPan = 0;

		var sound = new Audio();
		var canPlay = new Array(4);
		canPlay[0] = sound.canPlayType('audio/ogg');
		canPlay[1] = sound.canPlayType('audio/x-m4a');
		canPlay[2] = sound.canPlayType('audio/mpeg');
		canPlay[3] = sound.canPlayType('audio/wav');
		this.probablePlayableFormats = 0;
		this.maybePlayableFormats = 0;
		for (n = 0; n < 4; n++)
		{
			if (canPlay[n] == 'probably')
				this.probablePlayableFormats |= (1 << n);
			if (canPlay[n] == 'maybe')
				this.maybePlayableFormats |= (1 << n);
		}

		// Use WEB AUDIO?
		var papp = a;
		while (papp.parentApp != null)
		    papp = papp.parentApp;
		this.context = papp.soundContext;
		this.contextType = papp.soundContextType;
		if (this.context == null)
		{
		    if (typeof AudioContext !== "undefined")
		    {
		        this.context = new AudioContext();
		        this.contextType = 1;
		    }
		    else if (typeof webkitAudioContext !== "undefined")
		    {
		        this.context = new webkitAudioContext();
		        this.contextType = 0;
		    }
		    papp.soundContext = this.context;
		    papp.soundContextType = this.contextType;
	    }
	}
	CSoundPlayer.prototype =
	{
		addDataToDecode: function (cSound)
		{
			if (this.dataToDecode == null)
				this.dataToDecode = new CArrayList();
			this.dataToDecode.add(cSound);
		},
		decodeData:      function ()
		{
			if (this.dataToDecode != null && this.dataToDecode.size() > 0)
			{
				if (!this.decoding)
				{
					var cSound = this.dataToDecode.get(0);
					this.dataToDecode.removeIndex(0);
					this.decoding = true;
					var that = this;
					that.context["decodeAudioData"](cSound.response, function (buffer)
					{
						cSound.buffer = buffer;
						cSound.response = null;
						that.app.dataHasLoaded(cSound);
						that.decoding = false;
					});
				}
			}
		},
		reset:           function ()
		{
			var n;
			for (n = 0; n < CSoundPlayer.NCHANNELS; n++)
			{
				this.bLocked[n] = false;
			}
		},
		lockChannel:     function (channel)
		{
			if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
			{
				this.bLocked[channel] = true;
			}
		},
		unlockChannel:   function (channel)
		{
			if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
			{
				this.bLocked[channel] = false;
			}
		},

		play: function (handle, nLoops, channel, bPrio)
		{
			var n;

			if (this.bOn == false)
				return;

			var sound = this.app.soundBank.getSoundFromHandle(handle);
			if (sound == null)
				return;
			if (this.bMultipleSounds == false)
				channel = 0;
			/*      	else
			 {
			 for (n = 0; n < CSoundPlayer.NCHANNELS; n++)
			 {
			 if (this.channels[n] == sound)
			 {
			 sound=sound.createFromSound();
			 break;
			 }
			 }
			 }
			 */
			if (channel < 0)
			{
				for (n = 0; n < CSoundPlayer.NCHANNELS; n++)
				{
					if (this.channels[n] == null && this.bLocked[n] == false)
					{
						break;
					}
				}
				if (n == CSoundPlayer.NCHANNELS)
				{
					for (n = 0; n < CSoundPlayer.NCHANNELS; n++)
					{
						if (this.bLocked[n] == false)
						{
							if (this.channels[n] != null)
							{
								if (this.channels[n].bUninterruptible == false)
								{
									break;
								}
							}
						}
					}
				}
				channel = n;
				if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
				{
					this.volumes[channel] = this.mainVolume;
				}
			}
			if (channel < 0 || channel >= CSoundPlayer.NCHANNELS)
				return;

			if (this.channels[channel] != null)
			{
				if (this.channels[channel].bUninterruptible == true)
					return;
				if (this.channels[channel] != sound)
				{
					this.channels[channel].stop();
					this.channels[channel] = null;
				}
			}
			for (n = 0; n < CSoundPlayer.NCHANNELS; n++)
			{
				if (this.channels[n] == sound)
				{
					this.channels[n].stop();
					this.channels[n] = null;
				}
			}
			this.channels[channel] = sound;
			sound.play(nLoops, bPrio, this.volumes[channel]);
		},

		setMultipleSounds: function (bMultiple)
		{
			this.bMultipleSounds = bMultiple;
		},

		keepCurrentSounds: function ()
		{
			var n;
			for (n = 0; n < CSoundPlayer.NCHANNELS; n++)
			{
				if (this.channels[n] != null)
				{
					if (this.channels[n].isPlaying())
					{
						this.app.soundBank.setToLoad(this.channels[n].handle);
					}
				}
			}
		},

		setOnOff: function (bState)
		{
			if (bState != bOn)
			{
				this.bOn = bState;
				if (this.bOn == false)
					this.stopAllSounds();
			}
		},

		getOnOff: function ()
		{
			return this.bOn;
		},

		stopAllSounds: function ()
		{
			var n;
			for (n = 0; n < CSoundPlayer.NCHANNELS; n++)
			{
				if (this.channels[n] != null)
				{
					this.channels[n].stop();
					this.channels[n] = null;
				}
			}
		},

		stopSample: function (handle)
		{
			var c;
			for (c = 0; c < CSoundPlayer.NCHANNELS; c++)
			{
				if (this.channels[c] != null)
				{
					if (this.channels[c].handle == handle)
					{
						this.channels[c].stop();
						this.channels[c] = null;
					}
				}
			}
		},

		stopChannel: function (channel)
		{
			if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
			{
				if (this.channels[channel] != null)
				{
					this.channels[channel].stop();
					this.channels[channel] = null;
				}
			}
		},

		isSamplePaused: function (handle)
		{
			var c;
			for (c = 0; c < CSoundPlayer.NCHANNELS; c++)
			{
				if (this.channels[c] != null)
				{
					if (this.channels[c].handle == handle)
					{
						return this.channels[c].isPaused();
					}
				}
			}
			return false;
		},

		isSoundPlaying: function ()
		{
			var c;
			for (c = 0; c < CSoundPlayer.NCHANNELS; c++)
			{
				if (this.channels[c] != null)
				{
					if (this.channels[c].isPlaying())
						return true;
				}
			}
			return false;
		},

		isSamplePlaying: function (handle)
		{
			var c;
			for (c = 0; c < CSoundPlayer.NCHANNELS; c++)
			{
				if (this.channels[c] != null)
				{
					if (this.channels[c].handle == handle)
					{
						return this.channels[c].isPlaying();
					}
				}
			}
			return false;
		},

		isChannelPlaying: function (channel)
		{
			if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
			{
				if (this.channels[channel] != null)
				{
					return this.channels[channel].isPlaying();
				}
			}
			return false;
		},

		isChannelPaused: function (channel)
		{
			if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
			{
				if (this.channels[channel] != null)
				{
					return this.channels[channel].isPaused();
				}
			}
			return false;
		},

		pause: function ()
		{
			var c;
			for (c = 0; c < CSoundPlayer.NCHANNELS; c++)
			{
				if (this.channels[c] != null)
				{
					this.channels[c].pause();
				}
			}
		},

		pauseChannel: function (channel)
		{
			if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
			{
				if (this.channels[channel] != null)
				{
					this.channels[channel].pause();
				}
			}
		},

		pauseSample: function (handle)
		{
			var c;
			for (c = 0; c < CSoundPlayer.NCHANNELS; c++)
			{
				if (this.channels[c] != null)
				{
					if (this.channels[c].handle == handle)
					{
						this.channels[c].pause();
					}
				}
			}
		},

		resume: function ()
		{
			var c;
			for (c = 0; c < CSoundPlayer.NCHANNELS; c++)
			{
				if (this.channels[c] != null)
				{
					this.channels[c].resume();
				}
			}
		},

		resumeChannel: function (channel)
		{
			if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
			{
				if (this.channels[channel] != null)
				{
					this.channels[channel].resume();
				}
			}
		},

		resumeSample: function (handle)
		{
			var c;
			for (c = 0; c < CSoundPlayer.NCHANNELS; c++)
			{
				if (this.channels[c] != null)
				{
					if (this.channels[c].handle == handle)
					{
						this.channels[c].resume();
					}
				}
			}
		},

		setVolumeChannel: function (channel, volume)
		{
			if (volume < 0) volume = 0;
			if (volume > 100) volume = 100;

			if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
			{
				this.volumes[channel] = volume;
				if (this.channels[channel] != null)
				{
					this.channels[channel].setVolume(volume);
				}
			}
		},

		setFrequencyChannel: function (channel, freq)
		{
			//        if (freq<0) freq=0;
			//        if (freq>100000) freq= 100000;

			if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
			{
				if (this.channels[channel] != null)
				{
					this.channels[channel].setFrequency(freq);
				}
			}
		},

		setFrequencySample: function (handle, freq)
		{
			//        if (freq<0) freq=0;
			//        if (freq>100000) freq= 100000;

			var c;
			for (c = 0; c < CSoundPlayer.NCHANNELS; c++)
			{
				if (this.channels[c] != null)
				{
					if (this.channels[c].handle == handle)
					{
						this.channels[c].setFrequency(freq);
					}
				}
			}
		},

		setPositionChannel: function (channel, pos)
		{
			if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
			{
				if (this.channels[channel] != null)
				{
					this.channels[channel].setPosition(pos);
				}
			}
		},

		setPositionSample: function (handle, pos)
		{
			var c;
			for (c = 0; c < CSoundPlayer.NCHANNELS; c++)
			{
				if (this.channels[c] != null)
				{
					if (this.channels[c].handle == handle)
					{
						this.channels[c].setPosition(pos);
					}
				}
			}
		},

		getVolumeChannel: function (channel)
		{
			if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
			{
				if (this.channels[channel] != null)
				{
					return this.volumes[channel];
				}
			}
			return 0;
		},

		setVolumeSample: function (handle, volume)
		{
			if (volume < 0) volume = 0;
			if (volume > 100) volume = 100;

			var c;
			for (c = 0; c < CSoundPlayer.NCHANNELS; c++)
			{
				if (this.channels[c] != null)
				{
					if (this.channels[c].handle == handle)
					{
						this.volumes[c] = volume;
						this.channels[c].setVolume(volume);
					}
				}
			}
		},

		setMainVolume: function (volume)
		{
			var n;
			this.mainVolume = volume;
			for (n = 0; n < CSoundPlayer.NCHANNELS; n++)
			{
				this.volumes[n] = volume;
				if (this.channels[n] != null)
				{
					this.channels[n].setVolume(volume);
				}
			}
		},

		getMainVolume: function ()
		{
			return this.mainVolume;
		},

		getChannel: function (name)
		{
			var c;
			for (c = 0; c < CSoundPlayer.NCHANNELS; c++)
			{
				if (this.channels[c] != null)
				{
					if (this.channels[c].name == name)
					{
						return c;
					}
				}
			}
			return -1;
		},

		getDurationChannel: function (channel)
		{
			if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
			{
				if (this.channels[channel] != null)
				{
					return this.channels[channel].getDuration();
				}
			}
			return 0;
		},

		getPositionChannel: function (channel)
		{
			if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
			{
				if (this.channels[channel] != null)
				{
					return this.channels[channel].getPosition();
				}
			}
			return 0;
		},

		getFrequencyChannel: function (channel)
		{
			if (channel >= 0 && channel < CSoundPlayer.NCHANNELS)
			{
				if (this.channels[channel] != null)
				{
					return this.channels[channel].getFrequency();
				}
			}
			return 0;
		},

		getVolumeSample: function (name)
		{
			var channel = this.getChannel(name);
			if (channel >= 0)
			{
				return this.volumes[channel];
			}
			return 0;
		},

		getDurationSample: function (name)
		{
			var channel = this.getChannel(name);
			if (channel >= 0)
			{
				return this.channels[channel].getDuration();
			}
			return 0;
		},

		getPositionSample: function (name)
		{
			var channel = this.getChannel(name);
			if (channel >= 0)
			{
				return this.channels[channel].getPosition();
			}
			return 0;
		},

		getFrequencySample: function (name)
		{
			var channel = this.getChannel(name);
			if (channel >= 0)
			{
				return this.channels[channel].getFrequency();
			}
			return 0;
		},

		checkSounds: function ()
		{
			var c;
			for (c = 0; c < CSoundPlayer.NCHANNELS; c++)
			{
				if (this.channels[c] != null)
				{
					if (this.channels[c].checkSound())
					{
						this.channels[c] = null;
					}
				}
			}
		}
	}

	// Embedded Files
	// ------------------------------------------------------------
	function CEmbeddedFile(a)
	{
		this.app = a;
	}
	CEmbeddedFile.prototype =
	{
		preLoad: function ()
		{
			var l = this.app.file.readAShort();
			this.path = this.app.file.readAString(l);
			var pos = this.path.lastIndexOf("\\");
			if (pos >= 0)
			{
				this.path = this.path.substring(pos + 1);
			}
			this.length = this.app.file.readAInt();
			this.offset = this.app.file.getFilePointer();
			this.app.file.skipBytes(this.length);
		},
		open:    function ()
		{
			return this.app.file.createFromFile(this.offset, this.length)
		}
	}

	// Preloader
	// -------------------------------------------------------------
	function CPreloaderImage(a)
	{
		this.app = a;
		this.isLoaded = false;
		this.subApp = null;
		this.context = this.app.context;
		this.radius = this.app.preloaderCircleRadius;   // * (this.app.scaleX + this.app.scaleY) / 2;
		this.color = this.app.preloaderCircleColor;
		this.xCenter = this.app.preloaderCircleCenterX;
		if (this.xCenter < 0)
			this.xCenter = this.app.gaCxWin / 2;
		this.yCenter = this.app.preloaderCircleCenterY;
		if (this.yCenter < 0)
			this.yCenter = this.app.gaCyWin / 2;
		this.currentAngle = 0;
		this.size = this.app.preloaderCircleThickness;  // * (this.app.scaleX + this.app.scaleY) / 2;
		this.oldAngle = 0;
		this.counter = 25;
		this.phase = 0;

		this.image = new Image();
		var that = this;
		this.image.onload = function ()
		{
			that.isLoaded = true;
		}
		this.image.src = this.app.resources + "Preloader.png";
	}
	CPreloaderImage.prototype =
	{
		load:  function ()
		{
			return this.isLoaded;
		},
		reset: function ()
		{
			this.phase = 0;
			this.oldAngle = 0;
			this.counter = 25;
		},
		step:  function ()
		{
			switch (this.phase)
			{
				case 0:
					if (this.app.preloaderBackColor != -1)
					    this.context.renderSolidColor(0, 0, this.app.gaCxWin, this.app.gaCyWin, this.app.preloaderBackColor);
	                else
					    this.context.clearBackground(0, 0, this.app.gaCxWin, this.app.gaCyWin);
	                this.context.renderSimpleImage(this.image, this.xCenter - this.image.width / 2, this.yCenter - this.image.height / 2, this.image.width, this.image.height, 0, 0);
					this.phase++;
					break;
				case 1:
					this.angle = this.app.imagesLoaded / this.app.imagesToLoad * 2 * Math.PI;
					this.drawIt(this.angle);
					if (this.app.imagesLoaded == this.app.imagesToLoad)
						this.phase++;
					break;
				case 2:
					if (this.counter > 0)
						this.counter--;
					if (this.counter == 0)
						this.phase++;
					break;
				case 3:
					if (this.app.drawContinue(this))
						this.phase++;
					break;
				default:
					break;
			}
		},

		isComplete: function ()
		{
			return this.phase == 4;
		},
		drawIt:     function (angle)
		{
			var a;
			var x1, y1, x2, y2;
			for (a = this.oldAngle; a <= angle; a += 0.005)
			{
				x1 = this.xCenter + Math.cos(a) * (this.radius - this.size);
				y1 = this.yCenter - Math.sin(a) * (this.radius - this.size);
				x2 = this.xCenter + Math.cos(a) * this.radius;
				y2 = this.yCenter - Math.sin(a) * this.radius;
				this.context.renderLine(x1, y1, x2, y2, this.color, 1, 0, 0);

				var n;
				for (n = 0; n < 3; n++)
				{
					x1 = this.xCenter + Math.cos(a) * (this.radius - this.size - n);
					y1 = this.yCenter - Math.sin(a) * (this.radius - this.size - n);
					x2 = this.xCenter + Math.cos(a) * (this.radius - this.size - n - 1);
					y2 = this.yCenter - Math.sin(a) * (this.radius - this.size - n - 1);
					this.context.renderLine(x1, y1, x2, y2, this.color, 1, 0, 0);

					x1 = this.xCenter + Math.cos(a) * (this.radius + n);
					y1 = this.yCenter - Math.sin(a) * (this.radius + n);
					x2 = this.xCenter + Math.cos(a) * (this.radius + n + 1);
					y2 = this.yCenter - Math.sin(a) * (this.radius + n + 1);
					this.context.renderLine(x1, y1, x2, y2, this.color, 1, 0, 0);
				}
			}
			this.oldAngle = angle;
		}
	}
	function CPreloaderDefault(a)
	{
		this.app = a;
		this.context = this.app.context;
		this.currentPosition = 0;
		this.width = 100;
		this.height = 12;
		this.position = 0;
		this.backColor = 0xA0A0A0;
		this.borderColor = 0x808080;
		this.barColor = 0x000000;
		this.rect = new CRect();
		this.rect.left = this.app.gaCxWin / 2 - this.width / 2;
		this.rect.top = this.app.gaCyWin / 2 - this.height / 2;
		this.rect.right = this.rect.left + this.width;
		this.rect.bottom = this.rect.top + this.height;
		this.reset();
	}
	CPreloaderDefault.prototype =
	{
		load:  function ()
		{
			return true;
		},
		reset: function ()
		{
			this.quit = false;
			this.phase = 0;
			this.alpha = 128;
			this.position = 0;
		},
		step:  function ()
		{
			if (this.app.imagesLoaded < this.app.imagesToLoad)
			{
				switch (this.phase)
				{
					case 0:
						if (this.alpha > 0)
						{
							this.alpha -= 2;
							if (this.alpha <= 0)
							{
								this.alpha = 0;
								this.phase++;
							}
						}
						break;
					case 1:
						break;
				}
			}
			else
			{
				switch (this.phase)
				{
					case 0:
					case 1:
						this.phase = 2;
						break;
					case 2:
						if (this.alpha < 128)
						{
							this.alpha += 4;
						}
						if (this.alpha >= 128)
						{
							this.alpha = 128;
							if (this.app.silentSound == null)
								this.quit = true;
							else
								this.phase++;
						}
						break;
					default:
						this.quit = this.app.drawContinue(this);
						return;
				}
			}
			//            this.context.renderSolidColor(this.rect.left, this.rect.top, this.width, this.height, this.app.frameColor, 0, 0);
			this.context.renderSolidColor(this.rect.left, this.rect.top, this.width, this.height, this.backColor, CRSpr.BOP_BLEND, this.alpha);
			this.context.renderRect(this.rect.left, this.rect.top, this.width, this.height, this.borderColor, 1, CRSpr.BOP_BLEND, this.alpha);
			this.position = this.app.imagesLoaded / this.app.imagesToLoad * (this.width - 2);
			this.context.renderSolidColor(this.rect.left + 1, this.rect.top + 1, this.position, this.height - 2, this.barColor, CRSpr.BOP_BLEND, this.alpha);
		},

		isComplete: function ()
		{
			return this.quit && (this.app.imagesLoaded == this.app.imagesToLoad);
		}
	}

	function CPreloaderFrame(a)
	{
		this.app = a;
		this.isLoaded = false;
		this.appSprite = new Sprite();
		this.subApp = new CRunApp(this.app, this.app.file, this.app.path, true);
		this.subApp.setParentApp(this.app, this.app.preloaderFrameNumber, 0, this.appSprite, this.app.gaCxWin, this.app.gaCyWin);
		this.subApp.digest();
		this.subApp.loadPreloader = false;
		this.subApp.subAppStopped = false;
		this.subApp.dwOptions &= ~CRunApp.AH2OPT_LOADDATAATSTART;
		this.subApp.startApplication();
		this.subApp.setMouseOffsets(0, 0);
		this.subApp.stepApplication();
		this.appSprite.x = this.app.gaCxWin / 2 - this.subApp.frame.leWidth / 2;
		this.appSprite.y = this.app.gaCyWin / 2 - this.subApp.frame.leHeight / 2;
		this.stopOnLoad = (this.app.dwOptions & CRunApp.AH2OPT_PRELOADERQUIT) != 0;
		this.app.subApps.push(this.subApp);
		this.delay = 0;
	}
	CPreloaderFrame.prototype =
	{
		load:       function ()
		{
			this.step();
			return !this.subApp.loading;
		},
		reset:      function ()
		{
			this.subApp.run.f_StopSamples();
			this.subApp.run.killFrameObjects();
			this.subApp.run.y_KillLevel(false);
			this.subApp.run.resetFrameLayers(-1, false);
			this.subApp.run.rhEvtProg.unBranchPrograms();
			this.subApp.run.freeMouse();
			this.subApp.run.freeRunHeader();

			this.subApp.run.rhFrame.leX = this.subApp.run.rhFrame.leLastScrlX = this.subApp.run.rh3DisplayX = 0;
			this.subApp.run.rhFrame.leY = this.subApp.run.rhFrame.leLastScrlY = this.subApp.run.rh3DisplayY = 0;
			this.subApp.resetLayers();
			this.subApp.run.allocRunHeader();
			this.subApp.run.initAsmLoop();
			this.subApp.run.resetFrameLayers(-1, false);
			this.subApp.run.prepareFrame();
			this.subApp.run.createFrameObjects(false);
			this.subApp.run.drawLevel();
			this.subApp.run.loadGlobalObjectsData();
			this.subApp.run.rhEvtProg.prepareProgram();
			this.subApp.run.rhEvtProg.assemblePrograms(this.subApp.run);
			this.subApp.run.f_InitLoop();
			this.subApp.run.captureMouse();
			this.subApp.run.rhQuit = 0;
			this.subApp.run.rhQuitParam = 0;
			this.subApp.subAppStopped = false;
			this.app.subApps.push(this.subApp);
			this.delay = 0;
		},
		step:       function ()
		{
			if (!this.subApp.subAppStopped)
			{
				if (this.stopOnLoad)
					this.subApp.subAppStopped = (this.app.imagesLoaded == this.app.imagesToLoad);
				if (this.subApp.stepApplication() == false)
					this.subApp.subAppStopped = true;
				this.subApp.drawSubApplication(this.context, this.appSprite.x, this.appSprite.y, false);
			}
			if (this.subApp.subAppStopped && this.app.silentSound)
			{
				this.app.drawContinue(this);
			}
		},
		isComplete: function ()
		{
			var bComplete = this.subApp.subAppStopped;
			if (this.app.silentSound)
				bComplete = false;
			if (bComplete)
			{
				if (this.delay > 0)
				{
					this.delay--;
					if (this.delay > 0)
						return false;
				}
				var n;
				for (n = 0; n < this.app.subApps.length; n++)
				{
					if (this.app.subApps[n] == this.subApp)
					{
						this.app.subApps.splice(n, 1);
						break;
					}
				}
			}
			return bComplete;
		}
	}

	// Virtual joystick
	// ----------------------------------------------------------------
	CJoystick.KEY_JOYSTICK = 0;
	CJoystick.KEY_FIRE1 = 1;
	CJoystick.KEY_FIRE2 = 2;
	CJoystick.KEY_NONE = -1;
	CJoystick.MAX_TOUCHES = 3;
	CJoystick.JFLAG_JOYSTICK = 0x0001;
	CJoystick.JFLAG_FIRE1 = 0x0002;
	CJoystick.JFLAG_FIRE2 = 0x0004;
	CJoystick.JFLAG_LEFTHANDED = 0x0008;
	CJoystick.JPOS_NOTDEFINED = 0x80000000;
	CJoystick.JOY_ANGLEGAP = 70;
	CJoystick.DPAD_ANGLEGAP = 60;
	CJoystick.DEADZONE = 0.5;

	function CJoystick(a)
	{
		this.app = a;
		this.joyBack = null;
		this.joyFront = null;
		this.fire1U = null;
		this.fire2U = null;
		this.fire1D = null;
		this.fire2D = null;
		this.imagesX = new Array(3);
		this.imagesY = new Array(3);
		this.joystickX = 0;
		this.joystickY = 0;
		this.joystick = 0;
		this.flags = 0;
		this.touches = new Array(3);
		this.bSetPositions = false;
		this.isJoystick = true;
		this.joydeadzone = 0;
		this.joyanglezone = 0;
		this.joyradsize = 0;
	}
	CJoystick.prototype =
	{
		loadImages:   function ()
		{
			if (this.joyBack == null)
			{
				this.joyBack = CImage.createFromFile(this.app, "joyback.png");
				this.joyFront = CImage.createFromFile(this.app, "joyfront.png");
				this.fire1U = CImage.createFromFile(this.app, "fire1U.png");
				this.fire2U = CImage.createFromFile(this.app, "fire2U.png");
				this.fire1D = CImage.createFromFile(this.app, "fire1D.png");
				this.fire2D = CImage.createFromFile(this.app, "fire2D.png");
			}
		},
		reset:        function (f)
		{
			this.flags = f;
			if (this.joyBack != null && this.joyBack.width != 0)
				this.setPositions();
			else
				this.bSetPositions = true;

			if (this.isJoystick)
				this.joyanglezone = CJoystick.JOY_ANGLEGAP * Math.PI / 180;
			else
				this.joyanglezone = CJoystick.DPAD_ANGLEGAP * Math.PI / 180;
		},
		setPositions: function ()
		{
			var sx, sy;
			sx = this.app.gaCxWin;
			sy = this.app.gaCyWin;
			if ((this.flags & CJoystick.JFLAG_LEFTHANDED) == 0)
			{
				if ((this.flags & CJoystick.JFLAG_JOYSTICK) != 0)
				{
					this.imagesX[CJoystick.KEY_JOYSTICK] = 16 + this.joyBack.width / 2;
					this.imagesY[CJoystick.KEY_JOYSTICK] = sy - 16 - this.joyBack.height / 2;
				}
				if ((this.flags & CJoystick.JFLAG_FIRE1) != 0 && (this.flags & CJoystick.JFLAG_FIRE2) != 0)
				{
					this.imagesX[CJoystick.KEY_FIRE1] = sx - this.fire1U.width / 2 - 32;
					this.imagesY[CJoystick.KEY_FIRE1] = sy - this.fire1U.height / 2 - 16;
					this.imagesX[CJoystick.KEY_FIRE2] = sx - this.fire2U.width / 2 - 16;
					this.imagesY[CJoystick.KEY_FIRE2] = sy - this.fire2U.height / 2 - this.fire1U.height - 24;
				}
				else if ((this.flags & CJoystick.JFLAG_FIRE1) != 0)
				{
					this.imagesX[CJoystick.KEY_FIRE1] = sx - this.fire1U.width / 2 - 16;
					this.imagesY[CJoystick.KEY_FIRE1] = sy - this.fire1U.height / 2 - 16;
				}
				else if ((this.flags & CJoystick.JFLAG_FIRE2) != 0)
				{
					this.imagesX[CJoystick.KEY_FIRE2] = sx - this.fire2U.width / 2 - 16;
					this.imagesY[CJoystick.KEY_FIRE2] = sy - this.fire2U.height / 2 - 16;
				}
			}
			else
			{
				if ((this.flags & CJoystick.JFLAG_JOYSTICK) != 0)
				{
					this.imagesX[CJoystick.KEY_JOYSTICK] = sx - 16 - this.joyBack.width / 2;
					this.imagesY[CJoystick.KEY_JOYSTICK] = sy - 16 - this.joyBack.height / 2;
				}
				if ((this.flags & CJoystick.JFLAG_FIRE1) != 0 && (this.flags & CJoystick.JFLAG_FIRE2) != 0)
				{
					this.imagesX[CJoystick.KEY_FIRE1] = this.fire1U.width / 2 + 16 + this.fire2U.width * 2 / 3;
					this.imagesY[CJoystick.KEY_FIRE1] = sy - this.fire1U.height / 2 - 16;
					this.imagesX[CJoystick.KEY_FIRE2] = this.fire2U.width / 2 + 16;
					this.imagesY[CJoystick.KEY_FIRE2] = sy - this.fire2U.height / 2 - this.fire1U.height - 24;
				}
				else if ((this.flags & CJoystick.JFLAG_FIRE1) != 0)
				{
					this.imagesX[CJoystick.KEY_FIRE1] = this.fire1U.width / 2 + 16;
					this.imagesY[CJoystick.KEY_FIRE1] = sy - this.fire1U.height / 2 - 16;
				}
				else if ((this.flags & CJoystick.JFLAG_FIRE2) != 0)
				{
					this.imagesX[CJoystick.KEY_FIRE2] = this.fire2U.width / 2 + 16;
					this.imagesY[CJoystick.KEY_FIRE2] = sy - this.fire2U.height / 2 - 16;
				}
			}
		},
		setXPosition: function (f, p)
		{
			if ((f & CJoystick.JFLAG_JOYSTICK) != 0)
			{
				this.imagesX[CJoystick.KEY_JOYSTICK] = p;
			}
			else if ((f & CJoystick.JFLAG_FIRE1) != 0)
			{
				this.imagesX[CJoystick.KEY_FIRE1] = p;
			}
			else if ((f & CJoystick.JFLAG_FIRE2) != 0)
			{
				this.imagesX[CJoystick.KEY_FIRE2] = p;
			}
		},
		setYPosition: function (f, p)
		{
			if ((f & CJoystick.JFLAG_JOYSTICK) != 0)
			{
				this.imagesY[CJoystick.KEY_JOYSTICK] = p;
			}
			else if ((f & CJoystick.JFLAG_FIRE1) != 0)
			{
				this.imagesY[CJoystick.KEY_FIRE1] = p;
			}
			else if ((f & CJoystick.JFLAG_FIRE2) != 0)
			{
				this.imagesY[CJoystick.KEY_FIRE2] = p;
			}
		},
		draw:         function (context)
		{
			if (this.bSetPositions)
			{
				this.bSetPositions = false;
				this.setPositions();
			}

			var x, y, width, height;
			if ((this.flags & CJoystick.JFLAG_JOYSTICK) != 0)
			{
				x = this.imagesX[CJoystick.KEY_JOYSTICK] - this.joyBack.width / 2;
				y = this.imagesY[CJoystick.KEY_JOYSTICK] - this.joyBack.height / 2;
				context.renderImage(this.joyBack, x, y, 0, 1, 1, 0, 0);
				x = this.imagesX[CJoystick.KEY_JOYSTICK] + this.joystickX - this.joyFront.width / 2;
				y = this.imagesY[CJoystick.KEY_JOYSTICK] + this.joystickY - this.joyFront.height / 2;
				context.renderImage(this.joyFront, x, y, 0, 1, 1, 0, 0);
			}
			if ((this.flags & CJoystick.JFLAG_FIRE1) != 0)
			{
				var tex = ((this.joystick & 0x10) == 0) ? this.fire1U : this.fire1D;
				x = this.imagesX[CJoystick.KEY_FIRE1] - tex.width / 2;
				y = this.imagesY[CJoystick.KEY_FIRE1] - tex.height / 2;
				context.renderImage(tex, x, y, 0, 1, 1, 0, 0);
			}
			if ((this.flags & CJoystick.JFLAG_FIRE2) != 0)
			{
				var tex = ((this.joystick & 0x20) == 0) ? this.fire2U : this.fire2D;
				x = this.imagesX[CJoystick.KEY_FIRE2] - tex.width / 2;
				y = this.imagesY[CJoystick.KEY_FIRE2] - tex.height / 2;
				context.renderImage(tex, x, y, 0, 1, 1, 0, 0);
			}
		},

		touchStarted: function (touch)
		{
			var bFlag = false;
			var x = this.app.getTouchX(touch);
			var y = this.app.getTouchY(touch);

			this.joydeadzone = CJoystick.DEADZONE * Math.ceil(Math.sqrt(this.joyBack.width / 2 * this.joyBack.width / 2 + this.joyBack.height / 2 * this.joyBack.height / 2));	//Radius Size percentage
			// Max circle radius for the joystick or d-pad
			this.joyradsize = Math.ceil(Math.sqrt(this.joyBack.width / 4 * this.joyBack.width / 4 + this.joyBack.height / 4 * this.joyBack.height / 4));

			var key = this.getKey(x, y);
			if (key != CJoystick.KEY_NONE)
			{
				this.touches[key] = touch.identifier;
				if (key == CJoystick.KEY_JOYSTICK)
				{
					this.joystick &= 0xF0;
					bFlag = true;
				}
				if (key == CJoystick.KEY_FIRE1)
				{
					this.joystick |= 0x10;
					bFlag = true;
				}
				else if (key == CJoystick.KEY_FIRE2)
				{
					this.joystick |= 0x20;
					bFlag = true;
				}
			}
			return bFlag;
		},

		touchMoved: function (touch)
		{
			var x = this.app.getTouchX(touch);
			var y = this.app.getTouchY(touch);
			var key = this.getKey(x, y);
			if (key == CJoystick.KEY_JOYSTICK && touch.identifier == this.touches[CJoystick.KEY_JOYSTICK])
			{
				this.joystickX = x - this.imagesX[CJoystick.KEY_JOYSTICK];
				this.joystickY = y - this.imagesY[CJoystick.KEY_JOYSTICK];

				// angles ranges from 0 to 360 degrees in radians
				var angle = (Math.PI * 2 - Math.atan2(this.joystickY, this.joystickX)) % (Math.PI * 2);
				this.joystick &= 0xF0;
				var h = Math.sqrt(this.joystickX * this.joystickX + this.joystickY * this.joystickY);

				if (this.isJoystick)
				{
					this.joystickX = Math.cos(angle) * this.joyradsize;
					this.joystickY = Math.sin(angle) * -this.joyradsize;
				}
				else
				{
					if (this.joystickX < -this.joyradsize)
					{
						this.joystickX = -this.joyradsize;
					}
					if (this.joystickX > this.joyradsize)
					{
						this.joystickX = this.joyradsize;
					}
					if (this.joystickY < -this.joyradsize)
					{
						this.joystickY = -this.joyradsize;
					}
					if (this.joystickY > this.joyradsize)
					{
						this.joystickY = this.joyradsize;
					}
				}

				// Is the radius vector above the deadzone and border of the joystick base
				if (h > this.joydeadzone && h < this.joyradsize * 3)
				{

					var j = 0;
					// Checking in 45 degrees zone equal (PI/4); 1/4, 2/4, 3/4, 4/4, 5/4, 6/4, 7/4, 8/4
					// organized like 8/4, 2/4, 4/4, 6/4,  priority for right, up, left and down
					if (angle >= 0.0)
					{
						while (true)
						{
							// Right
							if (this.insideZone(angle, 0, this.joyanglezone) || this.insideZone(angle, (Math.PI) * 2, this.joyanglezone))
							{
								j = 8;
								break;
							}
							// Up
							if (this.insideZone(angle, Math.PI / 2, this.joyanglezone))
							{
								j = 1;
								break;
							}
							// Left
							if (this.insideZone(angle, (Math.PI), this.joyanglezone))
							{
								j = 4;
								break;
							}
							// Down
							if (this.insideZone(angle, (Math.PI / 4) * 6, this.joyanglezone))
							{
								j = 2;
								break;
							}
							// Right/Up
							if (this.insideZone(angle, Math.PI / 4, Math.PI / 2 - this.joyanglezone))
							{
								j = 9;
								break;
							}
							// Left/Up
							if (this.insideZone(angle, (Math.PI / 4) * 3, Math.PI / 2 - this.joyanglezone))
							{
								j = 5;
								break;
							}
							// Left/Down
							if (this.insideZone(angle, (Math.PI / 4) * 5, Math.PI / 2 - this.joyanglezone))
							{
								j = 6;
								break;
							}
							// Right/Down
							if (this.insideZone(angle, (Math.PI / 4) * 7, Math.PI / 2 - this.joyanglezone))
							{
								j = 10;
								break;
							}
							break;
						}
					}
					this.joystick |= j;
				}
			}
		},
		insideZone: function (angle, angle_ref, gap)
		{
			// check if the angle is in the range, could be ported using degrees instead.
			return (angle > (angle_ref - gap / 2) && angle < (angle_ref + gap / 2));
		},

		touchEnded: function (touch)
		{
			var n;
			for (n = 0; n < CJoystick.MAX_TOUCHES; n++)
			{
				if (this.touches[n] == touch.identifier)
				{
					this.touches[n] = 0;
					switch (n)
					{
						case CJoystick.KEY_JOYSTICK:
							this.joystickX = 0;
							this.joystickY = 0;
							this.joystick &= 0xF0;
							break;
						case CJoystick.KEY_FIRE1:
							this.joystick &= ~0x10;
							break;
						case CJoystick.KEY_FIRE2:
							this.joystick &= ~0x20;
							break;
					}
					break;
				}
			}
		},
		getKey:     function (x, y)
		{
			if ((this.flags & CJoystick.JFLAG_JOYSTICK) != 0)
			{
				if (x >= this.imagesX[CJoystick.KEY_JOYSTICK] - this.joyBack.width / 2 && x < this.imagesX[CJoystick.KEY_JOYSTICK] + this.joyBack.width / 2)
				{
					if (y > this.imagesY[CJoystick.KEY_JOYSTICK] - this.joyBack.height / 2 && y < this.imagesY[CJoystick.KEY_JOYSTICK] + this.joyBack.height / 2)
					{
						return CJoystick.KEY_JOYSTICK;
					}
				}
			}
			if ((this.flags & CJoystick.JFLAG_FIRE1) != 0)
			{
				if (x >= this.imagesX[CJoystick.KEY_FIRE1] - this.fire1U.width / 2 && x < this.imagesX[CJoystick.KEY_FIRE1] + this.fire1U.width / 2)
				{
					if (y > this.imagesY[CJoystick.KEY_FIRE1] - this.fire1U.height / 2 && y < this.imagesY[CJoystick.KEY_FIRE1] + this.fire1U.height / 2)
					{
						return CJoystick.KEY_FIRE1;
					}
				}
			}
			if ((this.flags & CJoystick.JFLAG_FIRE2) != 0)
			{
				if (x >= this.imagesX[CJoystick.KEY_FIRE2] - this.fire2U.width / 2 && x < this.imagesX[CJoystick.KEY_FIRE2] + this.fire2U.width / 2)
				{
					if (y > this.imagesY[CJoystick.KEY_FIRE2] - this.fire2U.height / 2 && y < this.imagesY[CJoystick.KEY_FIRE2] + this.fire2U.height / 2)
					{
						return CJoystick.KEY_FIRE2;
					}
				}
			}
			return CJoystick.KEY_NONE;
		},

		getJoystick: function ()
		{
			return this.joystick;
		}
	}
	// CRun Object
	// -----------------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 * 
	 * Permission is hereby granted to any person obtaining a legal copy 
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for 
	 * debugging, optimizing, or customizing applications created with 
	 * Clickteam Multimedia Fusion 2. 
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */

	CRun.GAMEFLAGS_VBLINDEP = 0x0002;
	CRun.GAMEFLAGS_LIMITEDSCROLL = 0x0004;
	CRun.GAMEFLAGS_FIRSTLOOPFADEIN = 0x0010;
	CRun.GAMEFLAGS_LOADONCALL = 0x0020;
	CRun.GAMEFLAGS_REALGAME = 0x0040;
	CRun.GAMEFLAGS_PLAY = 0x0080;
	CRun.GAMEFLAGS_INITIALISING = 0x0200;
	CRun.DLF_DONTUPDATE = 0x0002;
	CRun.DLF_DRAWOBJECTS = 0x0004;
	CRun.DLF_RESTARTLEVEL = 0x0008;
	CRun.DLF_DONTUPDATECOLMASK = 0x0010;
	CRun.DLF_COLMASKCLIPPED = 0x0020;
	CRun.DLF_SKIPLAYER0 = 0x0040;
	CRun.DLF_REDRAWLAYER = 0x0080;
	CRun.DLF_STARTLEVEL = 0x0100;
	CRun.GAME_XBORDER = 480;
	CRun.GAME_YBORDER = 300;
	CRun.COLMASK_XMARGIN = 64;
	CRun.COLMASK_YMARGIN = 16;
	CRun.WRAP_X = 1;
	CRun.WRAP_Y = 2;
	CRun.WRAP_XY = 4;
	CRun.RH3SCROLLING_SCROLL = 0x0001;
	CRun.RH3SCROLLING_REDRAWLAYERS = 0x0002;
	CRun.RH3SCROLLING_REDRAWALL = 0x0004;
	CRun.RH3SCROLLING_REDRAWTOTALCOLMASK = 0x0008;
	CRun.OBSTACLE_NONE = 0;
	CRun.OBSTACLE_SOLID = 1;
	CRun.OBSTACLE_PLATFORM = 2;
	CRun.OBSTACLE_LADDER = 3;
	CRun.OBSTACLE_TRANSPARENT = 4;
	CRun.COF_NOMOVEMENT = 0x0001;
	CRun.COF_HIDDEN = 0x0002;
	CRun.COF_FIRSTTEXT = 0x0004;
	CRun.COF_CREATEDATSTART = 0x0008;
	CRun.MAX_FRAMERATE = 10;
	CRun.LOOPEXIT_NEXTLEVEL = 1;
	CRun.LOOPEXIT_PREVLEVEL = 2;
	CRun.LOOPEXIT_GOTOLEVEL = 3;
	CRun.LOOPEXIT_NEWGAME = 4;
	CRun.LOOPEXIT_PAUSEGAME = 5;
	CRun.LOOPEXIT_SAVEAPPLICATION = 6;
	CRun.LOOPEXIT_LOADAPPLICATION = 7;
	CRun.LOOPEXIT_SAVEFRAME = 8;
	CRun.LOOPEXIT_LOADFRAME = 9;
	CRun.LOOPEXIT_ENDGAME = -2;
	CRun.LOOPEXIT_QUIT = 100;
	CRun.LOOPEXIT_RESTART = 101;
	CRun.BORDER_LEFT = 1;
	CRun.BORDER_RIGHT = 2;
	CRun.BORDER_TOP = 4;
	CRun.BORDER_BOTTOM = 8;
	CRun.BORDER_ALL = 15;
	CRun.MAX_INTERMEDIATERESULTS = 128;
	CRun.INTBAD = 0x7FFFFFFF;
	CRun.FANIDENTIFIER = 0x42324641;
	CRun.TREADMILLIDENTIFIER = 0x4232544D;
	CRun.PARTICULESIDENTIFIER = 0x42326AF3;
	CRun.MAGNETIDENTIFIER = 0x42369856;
	CRun.ROPEANDCHAINIDENTIFIER = 0x4232EFFA;
	CRun.BASEIDENTIFIER = 0x42324547;
	var bAlerted = false;

	CRun.plMasks =
		[
			0x00, 0x00, 0x00, 0x00,
			0xFF, 0x00, 0x00, 0x00,
			0xFF, 0xFF, 0x00, 0x00,
			0xFF, 0xFF, 0xFF, 0x00,
			0xFF, 0xFF, 0xFF, 0xFF
		];
	CRun.Table_InOut =
		[
			0,
			CRun.BORDER_LEFT,
			CRun.BORDER_RIGHT,
			0,
			CRun.BORDER_TOP,
			CRun.BORDER_TOP + CRun.BORDER_LEFT,
			CRun.BORDER_TOP + CRun.BORDER_RIGHT,
			0,
			CRun.BORDER_BOTTOM,
			CRun.BORDER_BOTTOM + CRun.BORDER_LEFT,
			CRun.BORDER_BOTTOM + CRun.BORDER_RIGHT,
			0,
			0,
			0,
			0,
			0
		];
	CRun.bMoveChanged = false;

	CRun.compareTo = function (pValue1, pValue2, comp)
	{
		switch (comp)
		{
			case 0:	// COMPARE_EQ:
				return pValue1 == pValue2;
			case 1:	// COMPARE_NE:
				return pValue1 != pValue2;
			case 2:	// COMPARE_LE:
				return pValue1 <= pValue2;
			case 3:	// COMPARE_LT:
				return pValue1 < pValue2;
			case 4:	// COMPARE_GE:
				return pValue1 >= pValue2;
			case 5:	// COMPARE_GT:
				return pValue1 > pValue2;
		}
		return false;
	}

	CRun.compareTer = function (value1, value2, comparaison)
	{
		switch (comparaison)
		{
			case 0:	// COMPARE_EQ:
				return (value1 == value2);
			case 1:	// COMPARE_NE:
				return (value1 != value2);
			case 2:	// COMPARE_LE:
				return (value1 <= value2);
			case 3:	// COMPARE_LT:
				return (value1 < value2);
			case 4:	// COMPARE_GE:
				return (value1 >= value2);
			case 5:	// COMPARE_GT:
				return (value1 > value2);
		}
		return false;
	}

	function CRun(app)
	{
		this.rhApp = app;
		this.rhFrame = null;
		this.rhMaxOI = 0;
		this.rhStopFlag = 0;
		this.rhEvFlag = 0;
		this.rhNPlayers = 0;
		this.rhGameFlags = 0;
		this.rhPlayer = 0;
		this.rhQuit = 0;
		this.rhQuitBis = 0;
		this.rhReturn = 0;
		this.rhQuitParam = 0;
		this.rhNObjects = 0;
		this.rhMaxObjects = 0;
		this.rhOiList = null;
		this.rhEvtProg = null;
		this.rhLevelSx = 0;
		this.rhLevelSy = 0;
		this.rhWindowX = 0;
		this.rhWindowY = 0;
		this.rhVBLDeltaOld = 0;
		this.rhVBLObjet = 0;
		this.rhVBLOld = 0;
		this.rhMT_VBLStep = 0;
		this.rhMT_VBLCount = 0;
		this.rhMT_MoveStep = 0;
		this.rhLoopCount = 0;
		this.rhTimer = 0;
		this.rhTimerOld = 0;
		this.rhTimerDelta = 0;
		this.rhOiListPtr = 0;
		this.rhObListNext = 0;
		this.rhDestroyPos = 0;
		this.rhMouseUsed = 0;
		this.rh2OldPlayer = null;
		this.rh2NewPlayer = null;
		this.rh2InputMask = null;
		this.rh2MouseKeys = 0;
		this.rh2CreationCount = 0;
		this.rh2MouseX = 0;
		this.rh2MouseY = 0;
		this.rh2MouseSaveX = 0;
		this.rh2MouseSaveY = 0;
		this.rh2PauseCompteur = 0;
		this.rh2PauseTimer = 0;
		this.rh2PauseVbl = 0;
		this.rh3DisplayX = 0;
		this.rh3DisplayY = 0;
		this.rh3WindowSx = 0;
		this.rh3WindowSy = 0;
		this.rh3CollisionCount = 0;
		this.rh3Scrolling = 0;
		this.rh3XMinimum = 0;
		this.rh3YMinimum = 0;
		this.rh3XMaximum = 0;
		this.rh3YMaximum = 0;
		this.rh3XMinimumKill = 0;
		this.rh3YMinimumKill = 0;
		this.rh3XMaximumKill = 0;
		this.rh3YMaximumKill = 0;
		this.rh3Graine = 0;
		this.rh4DemoMode = 0;
		//	this.rh4Demo=null;
		this.rh4PauseKey = 0;
		this.rh4CurrentFastLoop = null;
		this.rh4EndOfPause = 0;
		this.rh4MouseWheelDelta = 0;
		this.rh4OnMouseWheel = 0;
		this.rh4FastLoops = null;
		this.rh4ExpValue1 = 0;
		this.rh4ExpValue2 = 0;
		this.rh4KpxReturn = 0;
		this.rh4ObjectCurCreate = 0;
		this.rh4ObjectAddCreate = 0;
		this.rh4DoUpdate = 0;
		this.rh4VBLDelta = 0;
		this.rh4LoopTheoric = 0;
		this.rh4EventCount = 0;
		this.rh4BackDrawRoutines = null;
		this.rh4WindowDeltaX = 0;
		this.rh4WindowDeltaY = 0;
		this.rh4TimeOut = 0;
		this.rh4TabCounter = 0;
		this.rh4PosPile = 0;
		this.rh4Results = null;
		this.rh4Operators = null;
		this.rh4OpeNull = null;
		this.rh4CurToken = 0;
		this.rh4Tokens = null;
		this.rh4FrameRateArray = null;
		this.rh4FrameRatePos = 0;
		this.rh4FrameRatePrevious = 0;
		this.rhDestroyList = null;
		this.rh4SaveFrame = 0;
		this.rh4SaveFrameCount = 0;
		this.rh4MvtTimerCoef = 0;
		this.questionObjectOn = null;
		this.bOperande = false;
		this.rhWheelCount = 0;
		this.rhObjectList = null;
		this.currentTabObject = null;
		this.buttonClickCount = -1;
		this.isColArray = new Array(2);
		this.flagFloat = false;
		this.fadeTimerDelta = 0;
		this.rhJoystickMask = 0xFF;
		this.noResume = false;
		this.quitPause = false;
	}
	CRun.getObjectFont = function (hoPtr)
	{
		var info = null;

		if (hoPtr.hoType >= COI.KPX_BASE)
		{
			info = hoPtr.ext.getRunObjectFont();
		}
		else
		{
			info = hoPtr.getFont();
		}
		if (info == null)
		{
			info = new CFontInfo();
		}
		return info;
	}
	CRun.setObjectFont = function (hoPtr, pLf, pNewSize)
	{
		if (hoPtr.hoType >= COI.KPX_BASE)
		{
			hoPtr.ext.setRunObjectFont(pLf, pNewSize);
		}
		else
		{
			hoPtr.setFont(pLf, pNewSize);
		}
	}
	CRun.getObjectTextColor = function (hoPtr)
	{
		if (hoPtr.hoType >= COI.KPX_BASE)
		{
			return hoPtr.ext.getRunObjectTextColor();
		}
		return hoPtr.getFontColor();
	}
	CRun.setObjectTextColor = function (hoPtr, rgb)
	{
		if (hoPtr.hoType >= COI.KPX_BASE)
		{
			hoPtr.ext.setRunObjectTextColor(rgb);
		}
		else
		{
			hoPtr.setFontColor(rgb);
		}
	}
	CRun.objectShow = function (pHo)
	{
		if (pHo.ros != null)
		{
			pHo.ros.obShow();
			pHo.ros.rsFlags |= CRSpr.RSFLAG_VISIBLE;
			pHo.ros.rsFlash = 0;
		}
	}
	CRun.objectHide = function (pHo)
	{
		if (pHo.ros != null)
		{
			pHo.ros.obHide();
			pHo.ros.rsFlags &= ~CRSpr.RSFLAG_VISIBLE;
			pHo.ros.rsFlash = 0;
		}
	}
	CRun.setXPosition = function (hoPtr, x)
	{
		if (hoPtr.rom != null)
		{
			hoPtr.rom.rmMovement.setXPosition(x);
		}
		else
		{
			if (hoPtr.hoX != x)
			{
				hoPtr.hoX = x;
				if (hoPtr.roc != null)
				{
					hoPtr.roc.rcChanged = true;
					hoPtr.roc.rcCheckCollides = true;
				}
			}
		}
	}
	CRun.setYPosition = function (hoPtr, y)
	{
		if (hoPtr.rom != null)
		{
			hoPtr.rom.rmMovement.setYPosition(y);
		}
		else
		{
			if (hoPtr.hoY != y)
			{
				hoPtr.hoY = y;
				if (hoPtr.roc != null)
				{
					hoPtr.roc.rcChanged = true;
					hoPtr.roc.rcCheckCollides = true;
				}
			}
		}
	}
	CRun.get_DirFromPente = function (x, y)
	{
		if (x == 0)
		{
			if (y >= 0) return 24;
			return 8;
		}
		if (y == 0)
		{
			if (x >= 0) return 0;
			return 16;
		}

		var dir;
		var flagX = false;
		var flagY = false;
		if (x < 0)
		{
			flagX = true;
			x = -x;
		}
		if (y < 0)
		{
			flagY = true;
			y = -y;
		}

		var d = (x * 256) / y;
		var index;
		for (index = 0; ; index += 2)
		{
			if (d >= CMove.CosSurSin32[index])
				break;
		}
		dir = CMove.CosSurSin32[index + 1];

		if (flagY)
		{
			dir = -dir + 32;
			dir &= 31;
		}
		if (flagX)
		{
			dir -= 8;
			dir &= 31;
			dir = -dir;
			dir &= 31;
			dir += 8;
			dir &= 31;
		}
		return dir;
	}


	CRun.prototype =
	{
		setFrame:       function (f)
		{
			this.rhFrame = f;
		},
		allocRunHeader: function ()
		{
			this.rhObjectList = new Array(this.rhFrame.maxObjects);
			this.rhEvtProg = this.rhFrame.evtProg;

			this.rhMaxOI = 0;
			var oi;
			for (oi = this.rhApp.OIList.getFirstOI(); oi != null; oi = this.rhApp.OIList.getNextOI())
			{
				if (oi.oiType >= COI.OBJ_SPR)
				{
					this.rhMaxOI++;
				}
			}

			if (this.rhFrame.m_wRandomSeed == -1)
			{
				this.rh3Graine = this.rhApp.timer & 0xFFFF;
			}
			else
			{
				this.rh3Graine = this.rhFrame.m_wRandomSeed;
			}

			var no = Math.round(this.rhFrame.maxObjects / 32 + 1);
			this.rhDestroyList = new Array(no);

			this.rh4FastLoops = new CArrayList();
			this.rh4CurrentFastLoop = "";

			this.rhMaxObjects = this.rhFrame.maxObjects;

			this.rhNPlayers = this.rhEvtProg.nPlayers;
			this.rhFrame.leX = 0;
			this.rhFrame.leY = 0;
			this.rhWindowX = this.rhFrame.leX;
			this.rhWindowY = this.rhFrame.leY;
			this.rh4WindowDeltaX = 0;
			this.rh4WindowDeltaY = 0;
			this.rhLevelSx = this.rhFrame.leVirtualRect.right;
			if (this.rhLevelSx == -1)
				this.rhLevelSx = 0x7FFFF000;
			this.rhLevelSy = this.rhFrame.leVirtualRect.bottom;
			if (this.rhLevelSy == -1)
				this.rhLevelSy = 0x7FFFF000;
			this.rhNObjects = 0;
			this.rhStopFlag = 0;
			this.rhQuit = 0;
			this.rhQuitBis = 0;
			this.rhGameFlags &= (CRun.GAMEFLAGS_PLAY);
			this.rhGameFlags |= CRun.GAMEFLAGS_LIMITEDSCROLL;
			this.rh4FrameRatePos = 0;
			this.rh4FrameRatePrevious = 0;
			this.rh4FrameRateArray = new Array(CRun.MAX_FRAMERATE);
			this.rh4BackDrawRoutines = null;
			this.rh4SaveFrame = 0;
			this.rh4SaveFrameCount = -3;
			this.rhWheelCount = -1;
			this.rh4PosOnLoop = null;

			this.rhGameFlags |= CRun.GAMEFLAGS_REALGAME;

			this.rh4Results = new Array(CRun.MAX_INTERMEDIATERESULTS);
			this.rh4Operators = new Array(CRun.MAX_INTERMEDIATERESULTS);
			this.rh4OpeNull = new EXP_ZERO();
			this.rh4OpeNull.code = 0;

			this.rh2OldPlayer = new Array(4);
			this.rh2NewPlayer = new Array(4);
			this.rh2InputMask = new Array(4);
			this.rhPlayer = new Array(4);
			//		this.rhEvtProg.rh2CurrentClick = -1;
			this.rh4MvtTimerCoef = 0;

			var n;
			for (n = 0; n < CRun.MAX_FRAMERATE; n++)
				this.rh4FrameRateArray[n] = 50;
			this.quitPause = false;
			this.bodiesCreated = false;
			this.rhFrame.rhOK = true;
		},

		freeRunHeader: function ()
		{
			this.rhFrame.rhOK = false;

			this.rhObjectList = null;
			this.rhOiList = null;
			this.rhDestroyList = null;
			this.rh4CurrentFastLoop = null;
			this.rh4FastLoops = null;
			this.rh4BackDrawRoutines = null;
			this.rh4PosOnLoop = null;

			var n;
			for (n = 0; n < CRun.MAX_INTERMEDIATERESULTS; n++)
				this.rh4Results[n] = 0;
			this.rh4OpeNull = null;
		},

		initRunLoop: function (bFade)
		{
			this.allocRunHeader();

			this.rhApp.joystickOn = 0;
			if (this.rhApp.parentApp == null)
			{
				if (this.rhApp.touchable)
				{
					if (this.rhFrame.joystick == CRunFrame.JOYSTICK_EXT)
					{
						if (this.rhApp.joystick == null)
						{
							this.rhApp.joystick = new CJoystick(this.rhApp);
							this.rhApp.joystick.loadImages();
						}
						this.rhApp.joystick.reset(0);
						this.rhApp.startJoystick();
					}
					else if (this.rhFrame.joystick != CRunFrame.JOYSTICK_NONE)
					{
						var flags = 0;
						if ((this.rhFrame.html5Options & CRunFrame.IPHONEOPT_JOYSTICK_FIRE1) != 0)
						{
							flags = CJoystick.JFLAG_FIRE1;
						}
						if ((this.rhFrame.html5Options & CRunFrame.IPHONEOPT_JOYSTICK_FIRE2) != 0)
						{
							flags |= CJoystick.JFLAG_FIRE2;
						}
						if ((this.rhFrame.html5Options & CRunFrame.IPHONEOPT_JOYSTICK_LEFTHAND) != 0)
						{
							flags |= CJoystick.JFLAG_LEFTHANDED;
						}
						if ((this.rhFrame.html5Options & CRunFrame.HTML5FOPT_JOYSTICK_DPAD) != 0)
						{
						    flags |= CJoystick.JFLAG_DPAD;
						}
						if (this.rhFrame.joystick == CRunFrame.JOYSTICK_TOUCH)
						{
							flags |= CJoystick.JFLAG_JOYSTICK;
						}
						if ((flags & (CJoystick.JFLAG_FIRE1 | CJoystick.JFLAG_FIRE2 | CJoystick.JFLAG_JOYSTICK)) != 0)
						{
							this.rhApp.startJoystick(flags);
							this.rhApp.joystick.reset(flags);
						}

						// Accelerometer joystick
						if (this.rhFrame.joystick == CRunFrame.JOYSTICK_ACCELEROMETER)
						{
							this.rhApp.startAccJoystick();
						}
					}
				}
			}
			this.rhJoystickMask = 0xFF;

			if (bFade)
				this.rhGameFlags |= CRun.GAMEFLAGS_FIRSTLOOPFADEIN;

			this.initAsmLoop();

			this.resetFrameLayers(-1, false);

			this.prepareFrame();

			this.rhLoopCount = 0;
			this.createFrameObjects(bFade);

			this.drawLevel();
			this.hideShowLayers();

			this.loadGlobalObjectsData();

			this.rhEvtProg.prepareProgram();
			this.rhEvtProg.assemblePrograms(this);

			this.showMouse();
			this.captureMouse();
			this.rhQuitParam = 0;
			this.f_InitLoop();
			this.bodiesCreated = false;

			//TODO		rhEvtProg.HandleKeyRepeat();
		},

		doRunLoop: function ()
		{
		    if (this.rh2PauseCompteur > 0 && this.rhApp.modalSubappObject == null)
			{
				if (this.quitPause)
				{
					if (this.rhApp.keyNew == true)
					{
						if (this.rh4PauseKey >= 0)
						{
							if (this.rhApp.keyBuffer[this.rh4PauseKey])
							{
								this.resume();
								this.rhQuit = 0;
								this.rh4EndOfPause = this.rhLoopCount;
								this.rhEvtProg.handle_GlobalEvents((-8 << 16) | 0xFFFD);
							}
						}
						else
						{
							if (this.rhApp.keyNew)
							{
								this.resume();
								this.rhQuit = 0;
								this.rh4EndOfPause = this.rhLoopCount;
								this.rhEvtProg.handle_GlobalEvents((-8 << 16) | 0xFFFD);
							}
						}
					}
					this.rhApp.keyNew = false;
				}
				if (this.questionObjectOn != null)
				{
					this.questionObjectOn.handleQuestion();
				}
				quit = this.rhQuit;
			}
			else
			{
				// Calls the game
				this.rhApp.appRunFlags |= CRunApp.ARF_INGAMELOOP;
				var quit = this.f_GameLoop();
				this.rhApp.appRunFlags &= ~CRunApp.ARF_INGAMELOOP;

				// Si fin de FADE IN, detruit les sprites
				if ((this.rhGameFlags & CRun.GAMEFLAGS_FIRSTLOOPFADEIN) != 0)
				{
					var date = new Date();
					this.fadeTimerDelta = date.getTime() - this.rhTimerOld;
					// TODO rhFrame.fadeVblDelta = rhApp.newGetCptVbl() - rhVBLOld;
					this.y_KillLevel(true);
					this.rhEvtProg.unBranchPrograms();
				}
			}

			if (quit == CRun.LOOPEXIT_NEXTLEVEL || quit == CRun.LOOPEXIT_PREVLEVEL || quit == CRun.LOOPEXIT_GOTOLEVEL)
			{
				this.rhApp.transitionOldSurface = document.createElement("canvas");
				this.rhApp.transitionOldSurface.width = this.rhApp.gaCxWin;
				this.rhApp.transitionOldSurface.height = this.rhApp.gaCyWin;
				var renderer = new StandardRenderer(this.rhApp.transitionOldSurface);

				if (this.rhApp.frame.leClearBackground) renderer.clearBackground(0, 0, this.gaCxWin, this.gaCyWin);
				else renderer.renderSolidColor(0, 0, this.gaCxWin, this.gaCyWin, this.frameColor);

				renderer.renderSolidColor(0, 0, this.rhApp.gaCxWin, this.rhApp.gaCyWin, this.rhApp.frameColor);
				this.rhApp.mainSprite.draw(renderer, 0, 0);
			}

			if (quit != 0)
			{
				var frame = 0;
				switch (quit)
				{
					case 5:
						this.pause();
						this.rhApp.keyNew = false;
						this.quitPause = true;
						quit = 0;
						break;

					case 101:
						if (this.rhFrame.fade)
							break;
						this.f_StopSamples();
						this.killFrameObjects();
						this.y_KillLevel(false);
						this.resetFrameLayers(-1, false);
						this.rhEvtProg.unBranchPrograms();
						this.freeMouse();
						this.freeRunHeader();

						this.rhFrame.leX = this.rhFrame.leLastScrlX = this.rh3DisplayX = 0;
						this.rhFrame.leY = this.rhFrame.leLastScrlY = this.rh3DisplayY = 0;
						this.rhApp.resetLayers();
						this.allocRunHeader();
						this.initAsmLoop();
						this.resetFrameLayers(-1, false);
						this.prepareFrame();
						this.createFrameObjects(false);
						this.drawLevel();
						this.loadGlobalObjectsData();
						this.rhEvtProg.prepareProgram();
						this.rhEvtProg.assemblePrograms(this);
						this.f_InitLoop();
						//				this.rhEvtProg.HandleKeyRepeat();
						this.showMouse();
						this.captureMouse();
						quit = 0;
						this.rhQuitParam = 0;
						break;

					case 100:
					case -2:
						this.rhEvtProg.handle_GlobalEvents(((-4 << 16) | 65533));
						break;

				}
			}
			this.rhQuit = quit;
			return quit;
		},

		killRunLoop:  function (bLeaveSamples)
		{
			var quitParam;

			// Filtre les codes internes
			if (this.rhQuit > 100)
			{
				this.rhQuit = CRun.LOOPEXIT_ENDGAME;
			}
			quitParam = this.rhQuitParam;
			this.saveGlobalObjectsData();
			this.killFrameObjects();

			this.y_KillLevel(bLeaveSamples);
			this.rhEvtProg.unBranchPrograms();
			this.freeRunHeader();
			this.freeMouse();
			this.resetFrameLayers(-1, true);
			this.rhApp.endJoystick();

			return (CServices.MAKELONG(this.rhQuit, quitParam));
		},
		initAsmLoop:  function ()
		{
			var i;
			for (i = 0; i < this.rhMaxObjects; i++)
				this.rhObjectList[i] = null;
		},
		prepareFrame: function ()
		{
			var oiPtr;
			var ocPtr;
			var n, type;

			this.rhGameFlags |= CRun.GAMEFLAGS_LOADONCALL;
			this.rhGameFlags |= CRun.GAMEFLAGS_INITIALISING;

			this.rh2CreationCount = 0;

			var loPtr;
			var count = 0;
			this.rhOiList = new Array(this.rhMaxOI);
			this.rhMouseUsed = 0;
			for (oiPtr = this.rhApp.OIList.getFirstOI(); oiPtr != null; oiPtr = this.rhApp.OIList.getNextOI())
			{
				type = oiPtr.oiType;
				if (type >= COI.OBJ_SPR)
				{
					this.rhOiList[count] = new CObjInfo();
					this.rhOiList[count].copyData(oiPtr);

					this.rhOiList[count].oilHFII = -1;
					if (type == COI.OBJ_TEXT || type == COI.OBJ_QUEST)
					{
						for (loPtr = this.rhFrame.LOList.first_LevObj(); loPtr != null; loPtr = this.rhFrame.LOList.next_LevObj())
						{
							if (loPtr.loOiHandle == this.rhOiList[count].oilOi)
							{
								this.rhOiList[count].oilHFII = loPtr.loHandle;
								break;
							}
						}
					}
					count++;

					ocPtr = oiPtr.oiOC;
					if ((ocPtr.ocOEFlags & CObjectCommon.OEFLAG_MOVEMENTS) != 0 && ocPtr.ocMovements != null)
					{
						for (n = 0; n < ocPtr.ocMovements.nMovements; n++)
						{
							var mvPtr = ocPtr.ocMovements.moveList[n];
							if (mvPtr.mvType == CMoveDef.MVTYPE_MOUSE)
							{
								this.rhMouseUsed |= 1 << (mvPtr.mvControl - 1);
							}
						}
					}
				}
			}

			var i;
			for (i = 0; i < this.rhFrame.nLayers; i++)
			{
				this.rhFrame.layers[i].nZOrderMax = 1;
			}
			return 0;
		},

		createRemainingFrameObjects: function ()
		{
			var error = 0;
			var num;
			var oiPtr;
			var ocPtr;
			var type;
			var n;
			var creatFlags;
			var loPtr;

			this.rhGameFlags &= ~CRun.GAMEFLAGS_FIRSTLOOPFADEIN;

			for (n = 0, loPtr = this.rhFrame.LOList.first_LevObj(); loPtr != null; n++, loPtr = this.rhFrame.LOList.next_LevObj())
			{
				oiPtr = this.rhApp.OIList.getOIFromHandle(loPtr.loOiHandle);
				ocPtr = oiPtr.oiOC;
				type = oiPtr.oiType;

				if (type < COI.KPX_BASE)
				{
					continue;
				}
				if ((ocPtr.ocOEFlags & CObjectCommon.OEFLAG_RUNBEFOREFADEIN) != 0)
				{
					continue;
				}

				creatFlags = CRun.COF_CREATEDATSTART;

				// Objet pas dans le bon mode || cree au milieu du jeu. SKIP
				if (loPtr.loParentType != CLO.PARENT_NONE)
				{
					continue;
				}

				// Objet iconise non texte . SKIP
				if ((ocPtr.ocFlags2 & CObjectCommon.OCFLAGS2_VISIBLEATSTART) == 0)
				{
					if (type != COI.OBJ_TEXT)
					{
						continue;
					}
					creatFlags |= CRun.COF_HIDDEN;
				}

				// Creation de l'objet                
				if ((ocPtr.ocOEFlags & CObjectCommon.OEFLAG_DONTCREATEATSTART) == 0)
				{
					this.f_CreateObject(loPtr.loHandle, loPtr.loOiHandle, 0x80000000, 0x80000000, -1, creatFlags, -1, -1);
				}
			}
			this.rhEvtProg.assemblePrograms(this);

			// Remet le timer
			var date = new Date();
			this.rhTimerOld = date.getTime() - this.fadeTimerDelta;
			// TODO rhVBLOld = (rhApp.newGetCptVbl() - rhFrame.fadeVblDelta);
		},

		createFrameObjects: function (fade)
		{
			var oiPtr;
			var ocPtr;
			var type;
			var n;
			var creatFlags;
			var loPtr;

			for (n = 0, loPtr = this.rhFrame.LOList.first_LevObj(); loPtr != null; n++, loPtr = this.rhFrame.LOList.next_LevObj())
			{
				oiPtr = this.rhApp.OIList.getOIFromHandle(loPtr.loOiHandle);
				ocPtr = oiPtr.oiOC;
				type = oiPtr.oiType;

				creatFlags = CRun.COF_CREATEDATSTART;

				if (loPtr.loParentType != CLO.PARENT_NONE)
					continue;

				if (type == COI.OBJ_TEXT)
					creatFlags |= CRun.COF_FIRSTTEXT;

				if ((ocPtr.ocFlags2 & CObjectCommon.OCFLAGS2_VISIBLEATSTART) == 0)
				{
					if (type == COI.OBJ_QUEST)
						continue;
					creatFlags |= CRun.COF_HIDDEN;
				}
				if (fade)
				{
					if (type >= COI.KPX_BASE)
					{
						if ((ocPtr.ocOEFlags & CObjectCommon.OEFLAG_RUNBEFOREFADEIN) == 0)
						{
							continue;
						}
					}
				}

				if ((ocPtr.ocOEFlags & CObjectCommon.OEFLAG_DONTCREATEATSTART) == 0)
				{
					this.f_CreateObject(loPtr.loHandle, loPtr.loOiHandle, 0x80000000, 0x80000000, -1, creatFlags, -1, -1);
				}
			}
			this.rhGameFlags &= ~CRun.GAMEFLAGS_INITIALISING;
		},
		killFrameObjects:   function ()
		{
			var n;
			for (n = 0; n < this.rhMaxObjects && this.rhNObjects != 0; n++)
			{
				if (this.rhObjectList[n] != null)
				{
					var pHo = this.rhObjectList[n];
					if (pHo.hoType < 32 || pHo.hoCommon.ocIdentifier != CRun.BASEIDENTIFIER)
						this.f_KillObject(n, true);
				}
			}

			for (n = 0; n < this.rhMaxObjects && this.rhNObjects != 0; n++)
			{
				if (this.rhObjectList[n] != null)
				{
					var pHo = this.rhObjectList[n];
					if (pHo.hoType >= 32 && pHo.hoCommon.ocIdentifier == CRun.BASEIDENTIFIER)
						this.f_KillObject(n, true);
				}
			}
		},

		y_KillLevel:      function (bLeaveSamples)
		{
			if (!bLeaveSamples)
			{
				if ((this.rhApp.gaNewFlags & CRunApp.GANF_SAMPLESOVERFRAMES) == 0)
				{
					this.rhApp.soundPlayer.stopAllSounds();
				}
				else
				{
					this.rhApp.soundPlayer.keepCurrentSounds();
				}
			}
		},
		resetFrameLayers: function (nLayer, bDeleteFrame)
		{
			var i, nLayers;

			if (nLayer == -1)
			{
				i = 0;
				nLayers = this.rhFrame.nLayers;
			}
			else
			{
				i = nLayer;
				nLayers = (nLayer + 1);
			}

			for (i = 0; i < nLayers; i++)
			{
				var pLayer = this.rhFrame.layers[i];

				pLayer.reset();
				pLayer.deleteBackObjects();
				if (bDeleteFrame)
				{
					pLayer.deletePlanes();
				}
			}
		},

		captureMouse:   function ()
		{
			if (this.rhMouseUsed != 0)
			{
				this.setCursorCount(-1);
			}
		},
		freeMouse:      function ()
		{
			if (this.rhMouseUsed != 0)
			{
				this.setCursorCount(0);
			}
		},
		setCursorCount: function (count)
		{
			if (count >= 0)
				this.rhApp.showCursor(1);
			else
				this.rhApp.showCursor(-1);
		},
		showMouse:      function ()
		{
			this.rhApp.showCursor(1);
		},
		hideMouse:      function ()
		{
			this.rhApp.showCursor(-1);
		},
		addFastLoop: function(name)
		{
			var pLoop;
			var index;
			for (index = 0; index < this.rh4FastLoops.size(); index++)
			{
				pLoop = this.rh4FastLoops.get(index);
				if (CServices.compareStringsIgnoreCase(pLoop.name, name))
					break;
			}
			if (index == this.rh4FastLoops.size())
			{
				var loop = new CLoop();
				this.rh4FastLoops.add(loop);
				index = this.rh4FastLoops.size() - 1;
				loop.name = name;
				loop.flags = 0;
			}
			return index;
		},
		saveGlobalObjectsData: function ()
		{
			var hoPtr;
			var oilPtr;
			var oil, obj;
			var oiPtr;
			var name;
			var o;

			for (oil = 0; oil < this.rhOiList.length; oil++)
			{
				oilPtr = this.rhOiList[oil];

				o = oilPtr.oilObject;
				if (oilPtr.oilOi != 0x7FFF && (o & 0x80000000) == 0)
				{
					oiPtr = this.rhApp.OIList.getOIFromHandle(oilPtr.oilOi);

					if ((oiPtr.oiFlags & COI.OIF_GLOBAL) != 0)
					{
						hoPtr = this.rhObjectList[o];

						if (oilPtr.oilType != COI.OBJ_TEXT && oilPtr.oilType != COI.OBJ_COUNTER && hoPtr.rov == null)
							continue;

						name = oilPtr.oilName + oilPtr.oilType.toString();

						if (this.rhApp.adGO == null)
						{
							this.rhApp.adGO = new CArrayList();
						}

						var flag = false;
						var save = null;
						for (obj = 0; obj < this.rhApp.adGO.size(); obj++)
						{
							save = this.rhApp.adGO.get(obj);
							if (name == save.name)
							{
								flag = true;
								break;
							}
						}
						if (flag == false)
						{
							save = new CSaveGlobal();
							save.name = name;
							save.objects = new CArrayList();
							this.rhApp.adGO.add(save);
						}
						else
						{
							save.objects.clear();
						}

						var n;
						while (true)
						{
							hoPtr = this.rhObjectList[o];

							if (oilPtr.oilType == COI.OBJ_TEXT)
							{
								var saveText = new CSaveGlobalText();
								saveText.text = hoPtr.rsTextBuffer;
								saveText.rsMini = hoPtr.rsMini;
								save.objects.add(saveText);
							}
							else if (oilPtr.oilType == COI.OBJ_COUNTER)
							{
								var saveCounter = new CSaveGlobalCounter();
								saveCounter.value = hoPtr.rsValue;
								saveCounter.rsMini = hoPtr.rsMini;
								saveCounter.rsMaxi = hoPtr.rsMaxi;
								saveCounter.rsMiniDouble = hoPtr.rsMiniDouble;
								saveCounter.rsMaxiDouble = hoPtr.rsMaxiDouble;
								save.objects.add(saveCounter);
							}
							else
							{
								var saveValues = new CSaveGlobalValues();
								saveValues.flags = hoPtr.rov.rvValueFlags;
								saveValues.values = new Array(hoPtr.rov.rvValues.length);
								for (n = 0; n < hoPtr.rov.rvValues.length; n++)
								{
									saveValues.values[n] = hoPtr.rov.rvValues[n];
								}
								saveValues.strings = new Array(hoPtr.rov.rvStrings.length);
								for (n = 0; n < hoPtr.rov.rvStrings.length; n++)
								{
									saveValues.strings[n] = hoPtr.rov.rvStrings[n];
								}
								save.objects.add(saveValues);
							}

							o = hoPtr.hoNumNext;
							if ((o & 0x80000000) != 0)
								break;
						}
					}
				}
			}
		},

		loadGlobalObjectsData: function ()
		{
			var hoPtr;
			var oilPtr;
			var oil, obj;
			var oiPtr;
			var name;
			var o;

			if (this.rhApp.adGO == null)
				return;

			for (oil = 0; oil < this.rhOiList.length; oil++)
			{
				oilPtr = this.rhOiList[oil];

				o = oilPtr.oilObject;
				if (oilPtr.oilOi != 0x7FFF && o >= 0)
				{
					oiPtr = this.rhApp.OIList.getOIFromHandle(oilPtr.oilOi);

					if ((oiPtr.oiFlags & COI.OIF_GLOBAL) != 0)
					{
						name = oilPtr.oilName + oilPtr.oilType.toString();

						for (obj = 0; obj < this.rhApp.adGO.size(); obj++)
						{
							var save = this.rhApp.adGO.get(obj);
							if (name == save.name)
							{
								var count = 0;
								while (true)
								{
									hoPtr = this.rhObjectList[o];

									if (oilPtr.oilType == COI.OBJ_TEXT)
									{
										var saveText = save.objects.get(count);
										hoPtr.rsTextBuffer = saveText.text;
										hoPtr.rsMini = saveText.rsMini;
										hoPtr.roc.rcChanged = true;
										hoPtr.bTxtChanged = true;
									}
									else if (oilPtr.oilType == COI.OBJ_COUNTER)
									{
										var saveCounter = save.objects.get(count);
										hoPtr.rsValue = saveCounter.value;
										hoPtr.rsMini = saveCounter.rsMini;
										hoPtr.rsMaxi = saveCounter.rsMaxi;
										hoPtr.rsMiniDouble = saveCounter.rsMiniDouble;
										hoPtr.rsMaxiDouble = saveCounter.rsMaxiDouble;
										hoPtr.bCounterChanged = true;
										hoPtr.roc.rcChanged = true;
									}
									else
									{
										var saveValues = save.objects.get(count);
										hoPtr.rov.rvValueFlags = saveValues.flags;
										hoPtr.rov.growValues(saveValues.values.length);
										hoPtr.rov.growStrings(saveValues.strings.length);
										var n;
										for (n = 0; n < saveValues.values.length; n++)
										{
											hoPtr.rov.rvValues[n] = saveValues.values[n];
										}
										for (n = 0; n < saveValues.strings.length; n++)
										{
											hoPtr.rov.rvStrings[n] = saveValues.strings[n];
										}
									}

									o = hoPtr.hoNumNext;
									if ((o & 0x80000000) != 0)
										break;

									count++;
									if (count >= save.objects.size())
										break;
								}
								break;
							}
						}
					}
				}
			}
		},

		f_CreateObject: function (hlo, oi, coordX, coordY, initDir, flags, nLayer, numCreation)
		{
			while (true)
			{
				var cob = new CCreateObjectInfo();

				var loPtr = null;
				if (hlo != -1)
					loPtr = this.rhFrame.LOList.getLOFromHandle(hlo);

				var oiPtr = this.rhApp.OIList.getOIFromHandle(oi);
				var ocPtr = oiPtr.oiOC;

				if ((ocPtr.ocFlags2 & CObjectCommon.OCFLAGS2_VISIBLEATSTART) == 0)
				{
					flags |= CRun.COF_HIDDEN;
				}

				if (this.rhNObjects >= this.rhMaxObjects)
					break;

				var hoPtr = null;
				var proto = new CObject();
				switch (oiPtr.oiType)
				{
					case 2:
						hoPtr = new CActive();
						break;
					case 3:
						hoPtr = new CText();
						break;
					case 4:
						hoPtr = new CQuestion();
						break;
					case 5:
						hoPtr = new CScore();
						break;
					case 6:
						hoPtr = new CLives();
						break;
					case 7:
						hoPtr = new CCounter();
						break;
					case 8:
						//	                    hoPtr=new CRtf();
						break;
					case 9:
						hoPtr = new CCCA();
						break;
					default:
						hoPtr = new CExtension(oiPtr.oiType, this);
						if (hoPtr.ext == null)
						{
							hoPtr = null;
						}
						break;
				}
				if (hoPtr == null)
					break;
				hoPtr.prototype = proto;
				hoPtr.lo = loPtr;

				if (numCreation < 0)
				{
					for (numCreation = 0; numCreation < this.rhMaxObjects; numCreation++)
					{
						if (this.rhObjectList[numCreation] == null)
						{
							break;
						}
					}
				}
				if (numCreation >= this.rhMaxObjects)
				{
					return -1;
				}
				this.rhObjectList[numCreation] = hoPtr;
				this.rhNObjects++;
				hoPtr.hoIdentifier = ocPtr.ocIdentifier;
				hoPtr.hoOEFlags = ocPtr.ocOEFlags;

				if (numCreation > this.rh4ObjectCurCreate)
					this.rh4ObjectAddCreate++;

				hoPtr.hoNumber = numCreation;
				this.rh2CreationCount++;
				if (this.rh2CreationCount == 0)
					this.rh2CreationCount = 1;
				hoPtr.hoCreationId = this.rh2CreationCount;
				hoPtr.hoOi = oi;
				hoPtr.hoHFII = hlo;
				hoPtr.hoType = oiPtr.oiType;
				this.oi_Insert(hoPtr);
				hoPtr.hoAdRunHeader = this;
				hoPtr.hoCallRoutine = true;

				hoPtr.hoCommon = ocPtr;

			    // Sprite en mode inbitate?
				if ((hoPtr.hoOEFlags & CObjectCommon.OEFLAG_MANUALSLEEP) == 0)
				{
				    // On detruit... sauf si...
				    hoPtr.hoOEFlags &= ~CObjectCommon.OEFLAG_NEVERSLEEP;

				    // On teste des collisions avec le decor?
				    if ((hoPtr.hoLimitFlags & CObjInfo.OILIMITFLAGS_QUICKBACK) != 0)
				    {
				        // Si masque des collisions general
				        if ((this.rhFrame.leFlags & CRunFrame.LEF_TOTALCOLMASK) != 0)
				        {
				            hoPtr.hoOEFlags |= CObjectCommon.OEFLAG_NEVERSLEEP;
				        }
				    }
				    // Ou test des collisions normal
				    if ((hoPtr.hoLimitFlags & (CObjInfo.OILIMITFLAGS_QUICKCOL | CObjInfo.OILIMITFLAGS_QUICKBORDER)) != 0)
				    {
				        hoPtr.hoOEFlags |= CObjectCommon.OEFLAG_NEVERSLEEP;
				    }
				}

				var x = coordX;									// X
				if (x == 0x80000000)
					x = loPtr.loX;
				cob.cobX = x;
				hoPtr.hoX = x;

				var y = coordY;									// Y
				if (y == 0x80000000)
					y = loPtr.loY;
				cob.cobY = y;
				hoPtr.hoY = y;

				if (loPtr != null)
				{
					if (nLayer == -1)
					{
						nLayer = loPtr.loLayer;
					}
				}
				cob.cobLayer = nLayer;
				hoPtr.hoLayer = nLayer;

				var pLayer = this.rhFrame.layers[nLayer];
				pLayer.nZOrderMax++;
				cob.cobZOrder = pLayer.nZOrderMax;

				cob.cobFlags = flags;
				cob.cobDir = initDir;
				cob.cobLevObj = loPtr;

				hoPtr.roc = null;
				if ((hoPtr.hoOEFlags & (CObjectCommon.OEFLAG_ANIMATIONS | CObjectCommon.OEFLAG_MOVEMENTS | CObjectCommon.OEFLAG_SPRITES)) != 0)
				{
					hoPtr.roc = new CRCom();
					hoPtr.roc.init();
				}

				hoPtr.rom = null;
				if ((hoPtr.hoOEFlags & CObjectCommon.OEFLAG_MOVEMENTS) != 0)
				{
					hoPtr.rom = new CRMvt();
					if ((cob.cobFlags & CRun.COF_NOMOVEMENT) == 0)
					{
						hoPtr.rom.init(0, hoPtr, ocPtr, cob, -1);
					}
				}

				hoPtr.roa = null;
				if ((hoPtr.hoOEFlags & CObjectCommon.OEFLAG_ANIMATIONS) != 0)
				{
					hoPtr.roa = new CRAni();
					hoPtr.roa.init(hoPtr);
				}

				hoPtr.ros = null;
				if ((hoPtr.hoOEFlags & CObjectCommon.OEFLAG_SPRITES) != 0)
				{
					hoPtr.ros = new CRSpr();
					hoPtr.ros.init1(hoPtr, ocPtr, cob);
				}

				hoPtr.rov = null;
				if ((hoPtr.hoOEFlags & CObjectCommon.OEFLAG_VALUES) != 0)
				{
					hoPtr.rov = new CRVal();
					hoPtr.rov.init(hoPtr, ocPtr, cob);
				}

				hoPtr.init(ocPtr, cob);

				if ((hoPtr.hoOEFlags & CObjectCommon.OEFLAG_SPRITES) != 0)
				{
					hoPtr.ros.init2(true);
				}

				if (this.rhLoopCount >= 1)
					hoPtr.callComputeNewDisplay();

				return numCreation;
			}
			return -1;
		},

		f_KillObject: function (nObject, bFast)
		{
			var hoPtr = this.rhObjectList[nObject];
			if (hoPtr == null)
			{
				return;
			}

			if (bFast == true && hoPtr.hoCreationId == 0)
			{
				this.rhObjectList[nObject] = null;
				this.rhNObjects--;
				return;
			}

			this.killShootPtr(hoPtr);

			if (hoPtr.rom != null)
				hoPtr.rom.kill(bFast);
			if (hoPtr.rov != null)
				hoPtr.rov.kill(bFast);
			if (hoPtr.ros != null)
				hoPtr.ros.kill(bFast);
			if (hoPtr.roc != null)
				hoPtr.roc.kill(bFast);

			hoPtr.kill(bFast);

			this.oi_Delete(hoPtr);

			this.rhObjectList[nObject] = null;

			this.rhNObjects--;

		},

		destroy_Add: function (hoNumber)
		{
			var pos = Math.floor(hoNumber / 32);
			var bit = 1 << (hoNumber & 31);
			this.rhDestroyList[pos] |= bit;
			this.rhDestroyPos++;
		},

		destroy_List: function ()
		{
			if (this.rhDestroyPos == 0)
			{
				return;
			}

			var nob = 0;
			var dw;
			var count;
			while (nob < this.rhMaxObjects)
			{
				dw = this.rhDestroyList[nob / 32];
				if (dw != 0)
				{
					this.rhDestroyList[nob / 32] = 0;
					for (count = 0; dw != 0 && count < 32; count++)
					{
						if ((dw & 1) != 0)
						{
							var pHo = this.rhObjectList[nob + count];
							if (pHo != null)
							{
								if (pHo.hoOiList.oilNObjects == 1)
								{
									this.rhEvtProg.handle_Event(pHo, (pHo.hoType | (-33 << 16)));
								}
							}
							this.f_KillObject(nob + count, false);
							this.rhDestroyPos--;
						}
						dw = dw >> 1;
					}
					if (this.rhDestroyPos == 0)
					{
						return;
					}
				}
				nob += 32;
			}
		},

		killShootPtr: function (hoSource)
		{
			var count = 0;
			var nObject;
	        var hoPtr;
	        if ((hoSource.hoFlags & CObject.HOF_SHOOTER) != 0)
	        {
			    for (nObject = 0; nObject < this.rhNObjects; nObject++)
			    {
				    while (this.rhObjectList[count] == null)
					    count++;
				    hoPtr = this.rhObjectList[count];
				    count++;

				    if (hoPtr.rom != null)
				    {
					    if (hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_BULLET)
					    {
						    var mBullet = hoPtr.rom.rmMovement;
						    if (mBullet.MBul_ShootObject == hoSource && mBullet.MBul_Wait == true)
						    {
							    mBullet.startBullet();
						    }
					    }
				    }
			    }
	        }
		},

		callComputeNewDisplay: function ()
		{
			var nObject;
			var hoPtr;
			var count;
			for (nObject = 0, count = 0; nObject < this.rhNObjects; nObject++)
			{
				while (this.rhObjectList[count] == null)
					count++;
				hoPtr = this.rhObjectList[count];
				count++;
				hoPtr.createFont();
			}
			for (nObject = 0, count = 0; nObject < this.rhNObjects; nObject++)
			{
				while (this.rhObjectList[count] == null)
					count++;
				hoPtr = this.rhObjectList[count];
				count++;
				hoPtr.callComputeNewDisplay();
			}
		},

		oi_Insert: function (pHo)
		{
			var oi = pHo.hoOi;

			var num;
			for (num = 0; num < this.rhMaxOI; num++)
			{
				if (this.rhOiList[num].oilOi == oi)
				{
					break;
				}
			}
			var poil = this.rhOiList[num];

			if ((poil.oilObject & 0x80000000) != 0)
			{
				poil.oilObject = pHo.hoNumber;
				pHo.hoNumPrev = (num | 0x80000000);
				pHo.hoNumNext = 0x80000000;
			}
			else
			{
				var pHo2 = this.rhObjectList[poil.oilObject];
				pHo.hoNumPrev = pHo2.hoNumPrev;
				pHo2.hoNumPrev = pHo.hoNumber;
				pHo.hoNumNext = pHo2.hoNumber;
				poil.oilObject = pHo.hoNumber;
			}

			pHo.hoEvents = poil.oilEvents;
			pHo.hoOiList = poil;
			pHo.hoLimitFlags = poil.oilLimitFlags;
			if (pHo.hoHFII == -1)
				pHo.hoHFII = poil.oilHFII;
			else
			{
				if (poil.oilHFII == -1)
					poil.oilHFII = pHo.hoHFII;
			}
			poil.oilNObjects += 1;
		},

		oi_Delete: function (pHo)
		{
			var poil = pHo.hoOiList;
			poil.oilNObjects -= 1;

			var pHo2;
			if ((pHo.hoNumPrev & 0x80000000) == 0)
			{
				pHo2 = this.rhObjectList[pHo.hoNumPrev];
				if ((pHo.hoNumNext & 0x80000000) == 0)
				{
					var pHo3 = this.rhObjectList[pHo.hoNumNext];
					if (pHo2 != null)
						pHo2.hoNumNext = pHo.hoNumNext;
					if (pHo3 != null)
						pHo3.hoNumPrev = pHo.hoNumPrev;
				}
				else
				{
					if (pHo2 != null)
						pHo2.hoNumNext = 0x80000000;
				}
			}
			else
			{
				if ((pHo.hoNumNext & 0x80000000) == 0)
				{
					pHo2 = this.rhObjectList[pHo.hoNumNext];
					if (pHo2 != null)
					{
						pHo2.hoNumPrev = pHo.hoNumPrev;
						poil.oilObject = pHo2.hoNumber;
					}
				}
				else
				{
					poil.oilObject = 0x80000000;
				}
			}
		},

		CreateBodies: function ()
		{
			var pBase = this.GetBase();
			if (pBase == null)
				return;

			var pOL = 0;
			var nObjects;
			for (nObjects = 0; nObjects < this.rhNObjects; pOL++, nObjects++)
			{
				while (this.rhObjectList[pOL] == null) pOL++;
				var pHo = this.rhObjectList[pOL];
				if (pHo.hoType >= 32)
				{
					if (pHo.hoCommon.ocIdentifier == CRun.FANIDENTIFIER
						|| pHo.hoCommon.ocIdentifier == CRun.TREADMILLIDENTIFIER
						|| pHo.hoCommon.ocIdentifier == CRun.PARTICULESIDENTIFIER
						|| pHo.hoCommon.ocIdentifier == CRun.ROPEANDCHAINIDENTIFIER
						|| pHo.hoCommon.ocIdentifier == CRun.MAGNETIDENTIFIER)
					{
						pHo.ext.rStartObject();
					}
					else if (pHo.hoCommon.ocIdentifier == CRun.BASEIDENTIFIER)
					{
						pHo.ext.rStartObject();
					}
				}
			}
			pOL = 0;
			for (nObjects = 0; nObjects < this.rhNObjects; pOL++, nObjects++)
			{
				while (this.rhObjectList[pOL] == null) pOL++;
				var pHo = this.rhObjectList[pOL];
				if ((pHo.hoOEFlags & CObjectCommon.OEFLAG_MOVEMENTS) != 0)
				{
					var flag = false;
					if (pHo.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
					{
	                    var mvPtr = (pHo.hoCommon.ocMovements.moveList[pHo.rom.rmMvtNum]);
	                    if (mvPtr.isPhysics)
						{
							pHo.rom.rmMovement.movement.CreateBody();
							flag = true;
						}
					}
					if (flag == false && pHo.hoType == 2)
					{
						pBase.rAddNormalObject(pHo);
					}
				}
			}
			pOL = 0;
			for (nObjects = 0; nObjects < this.rhNObjects; pOL++, nObjects++)
			{
				while (this.rhObjectList[pOL] == null) pOL++;
				var pHo = this.rhObjectList[pOL];
				if ((pHo.hoOEFlags & CObjectCommon.OEFLAG_MOVEMENTS) != 0)
				{
					if (pHo.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
					{
						var mvPtr = (pHo.hoCommon.ocMovements.moveList[pHo.rom.rmMvtNum]);
	                    if (mvPtr.isPhysics)
						{
							pHo.rom.rmMovement.movement.CreateJoint();
						}
					}
				}
			}
		},

		GetBase: function ()
		{
			if (this.rh4Box2DSearched == false)
			{
				this.rh4Box2DSearched = true;
				this.rh4Box2DBase = null;

				var pOL = 0;
				var nObjects;
				for (nObjects = 0; nObjects < this.rhNObjects; pOL++, nObjects++)
				{
					while (this.rhObjectList[pOL] == null) pOL++;
					var pHo = this.rhObjectList[pOL];
					if (pHo.hoType >= 32)
					{
						if (pHo.hoCommon.ocIdentifier == CRun.BASEIDENTIFIER)
						{
							this.rh4Box2DBase = pHo.ext;
							break;
						}
					}
				}
			}
			return this.rh4Box2DBase;
		},

		GetMBase: function (pHo)
		{
			if (pHo && (pHo.hoFlags & CObject.HOF_DESTROYED) == 0)
			{
				if ((pHo.hoOEFlags & CObjectCommon.OEFLAG_MOVEMENTS) != 0)
				{
					if (pHo.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
					{
						var mvPtr = (pHo.hoCommon.ocMovements.moveList[pHo.rom.rmMvtNum]);
	                    if (mvPtr.isPhysics)
						{
							return pHo.rom.rmMovement.movement;
						}
					}
				}
			}
			return null;
		},

	    // Build 283.2: add fans, treadmills and magnet to engine
	    // Build 286.0: add ropes too
		addPhysicsAttractor: function(pObject)
		{
		    if (pObject.hoCommon.ocIdentifier == CRun.FANIDENTIFIER || pObject.hoCommon.ocIdentifier == CRun.TREADMILLIDENTIFIER || pObject.hoCommon.ocIdentifier == CRun.MAGNETIDENTIFIER || pObject.hoCommon.ocIdentifier == CRun.ROPEANDCHAINIDENTIFIER)
			{
				var pOL=0;
				var nObjects;
				for (nObjects = 0; nObjects < this.rhNObjects; pOL++, nObjects++)
				{
					while (this.rhObjectList[pOL] == null) pOL++;
					var pBase = this.rhObjectList[pOL];
					if (pBase.hoType>=32 && pBase.hoCommon.ocIdentifier==CRun.BASEIDENTIFIER)
					{
						if (pObject.hoCommon.ocIdentifier == CRun.FANIDENTIFIER)
						{
							if ( pObject.ext.identifier == pBase.ext.identifier)
								pBase.ext.fans.add(pObject.ext);
						}
						else if (pObject.hoCommon.ocIdentifier == CRun.TREADMILLIDENTIFIER)
						{
							if ( pObject.ext.identifier == pBase.ext.identifier)
								pBase.ext.treadmills.add(pObject.ext);
						}
						else if (pObject.hoCommon.ocIdentifier == CRun.MAGNETIDENTIFIER)
						{
							if ( pObject.ext.identifier == pBase.ext.identifier)
								pBase.ext.magnets.add(pObject.ext);
						}
						else if (pObject.hoCommon.ocIdentifier == CRun.ROPEANDCHAINIDENTIFIER)
						{
						    if (pObject.ext.identifier == pBase.ext.identifier)
						        pBase.ext.ropes.add(pObject.ext);
						}
	                }
				}

		        // Object added to base list, now add the physical objects to the fan/treadmill/magnet list
				if (pObject.hoCommon.ocIdentifier != CRun.ROPEANDCHAINIDENTIFIER)
	            {
			        pOL=0;
			        for (nObjects = 0; nObjects < this.rhNObjects; pOL++, nObjects++)
			        {
				        while (this.rhObjectList[pOL] == null) pOL++;
				        var pActive=this.rhObjectList[pOL];
				        if ( pActive.hoType == COI.OBJ_SPR )
				        {
					        var pMBase = this.GetMBase(pActive);
					        if ( pMBase )
					        {
						        pObject.ext.rAddObject(pMBase);
					        }
				        }
			        }
	            }
		    }
		},

		getDir: function (hoPtr)
		{
			if (hoPtr.rom != null)
				if (hoPtr.rom.rmMovement != null)
					return hoPtr.rom.rmMovement.getDir();
			return hoPtr.roc.rcDir;
		},

		pause: function (bKeepSounds)
		{
			if (this.rh2PauseCompteur == 0)
			{
				this.rh2PauseCompteur = 1;

				this.rh2PauseTimer = this.rhApp.timer;

				var count = 0;
				var no;
				for (no = 0; no < this.rhNObjects; no++)
				{
					while (this.rhObjectList[count] == null)
						count++;
					var hoPtr = this.rhObjectList[count];
					count++;
					if (hoPtr.hoType >= COI.KPX_BASE)
					{
						hoPtr.ext.pauseRunObject();
					}
				}

				if (!bKeepSounds)
					this.rhApp.soundPlayer.pause();

				// TODO		   Mouse.show();		   
				//		   	this.rhApp.keyNew=false;
			}
		},

		resume: function ()
		{
			if (!this.noResume && this.rh2PauseCompteur != 0)
			{
				this.rh2PauseCompteur = 0;
				this.captureMouse();

				var count = 0;
				var no;
				for (no = 0; no < this.rhNObjects; no++)
				{
					while (this.rhObjectList[count] == null)
						count++;
					var hoPtr = this.rhObjectList[count];
					count++;
					if (hoPtr.hoType >= COI.KPX_BASE)
					{
						hoPtr.ext.continueRunObject();
					}
				}

				this.rhApp.soundPlayer.resume();

				// TODO     this.rhApp.flushKeyboard();

				var tick = this.rhApp.timer;
				tick -= this.rh2PauseTimer;
				this.rhTimerOld += tick;
				this.rh4PauseKey = 0;
				this.quitPause = false;
			}
		},

		f_StopSamples: function ()
		{
			this.rhApp.soundPlayer.stopAllSounds();
		},

		autoResize: function ()
		{
			var count = 0;
			var no;
			for (no = 0; no < this.rhNObjects; no++)
			{
				while (this.rhObjectList[count] == null)
					count++;
				var hoPtr = this.rhObjectList[count];
				count++;
				hoPtr.autoResize();
			}
		},

		/* TODO    
		 public function sendKey(keyCode, bState:Boolean):void
		 {
		 var count=0;
		 var no;
		 for (no=0; no<rhNObjects; no++)
		 {
		 while (rhObjectList[count]==null)
		 count++;
		 var hoPtr:CObject=rhObjectList[count];
		 count++;
		 if (hoPtr is CCCA)
		 {
		 var cca:CCCA=CCCA(hoPtr);
		 cca.sendKey(keyCode, bState);
		 }
		 }	
		 }
		 */

		find_HeaderObject: function (hlo)
		{
			var count = 0;
			var nObjects;
			for (nObjects = 0; nObjects < this.rhNObjects; nObjects++)
			{
				while (this.rhObjectList[count] == null)
					count++;
				if (hlo == this.rhObjectList[count].hoHFII)
					return rhObjectList[count];
				count++;
			}
			return null;
		},

		check_Ladder: function (nLayer, x, y)
		{
			var prc = this.y_GetLadderAt(nLayer, x, y);
			if (prc != null)
			{
				return prc.top;
			}
			return CRun.INTBAD;
		},

		y_GetLadderAt: function (nLayer, x, y)
		{
			x -= this.rhWindowX;
			y -= this.rhWindowY;

			var nl;
			var nLayers;
			if (nLayer == -1)
			{
				nl = 0;
				nLayers = this.rhFrame.nLayers;
			}
			else
			{
				nl = nLayer;
				nLayers = (nLayer + 1);
			}
			for (; nl < nLayers; nl++)
			{
				var pLayer = this.rhFrame.layers[nl];
				var rc = pLayer.getLadderAt(x, y);
				if (rc != null)
				{
					return rc;
				}
			}
			return null;
		},

		f_InitLoop: function ()
		{
			var tick = this.rhApp.timer;
			this.rhTimerOld = tick;
			this.rhTimer = 0;

			this.rhLoopCount = 0;
			this.rh4LoopTheoric = 0;
			//	rh2PushedEvents=0;

			this.rhQuit = 0;
			this.rhQuitBis = 0;
			this.rhDestroyPos = 0;

			var n;
			for (n = 0; n < (this.rhMaxObjects + 31) / 32; n++)
				this.rhDestroyList[n] = 0;

			this.rh3WindowSx = this.rhFrame.leEditWinWidth;
			this.rh3WindowSy = this.rhFrame.leEditWinHeight;

			this.rh3XMinimumKill = -CRun.GAME_XBORDER;
			this.rh3YMinimumKill = -CRun.GAME_YBORDER;
			this.rh3XMaximumKill = this.rhLevelSx + CRun.GAME_XBORDER;
			this.rh3YMaximumKill = this.rhLevelSy + CRun.GAME_YBORDER;

			var dx = this.rhWindowX;
			this.rh3DisplayX = dx;
			dx -= CRun.COLMASK_XMARGIN;
			if (dx < 0)
				dx = this.rh3XMinimumKill;
			this.rh3XMinimum = dx;

			var dy = this.rhWindowY;
			this.rh3DisplayY = dy;
			dy -= CRun.COLMASK_YMARGIN;
			if (dy < 0)
				dy = this.rh3YMinimumKill;
			this.rh3YMinimum = dy;

			var wx = this.rhWindowX;
			wx += this.rh3WindowSx + CRun.COLMASK_XMARGIN;
			if (wx > this.rhLevelSx)
				wx = this.rh3XMaximumKill;
			this.rh3XMaximum = wx;

			var wy = this.rhWindowY;
			wy += this.rh3WindowSy + CRun.COLMASK_YMARGIN;
			if (wy > this.rhLevelSy)
				wy = this.rh3YMaximumKill;
			this.rh3YMaximum = wy;

			this.rh3Scrolling = 0;
			this.rh4DoUpdate = 0;
			this.rh4EventCount = 0;
			this.rh4TimeOut = 0;

			this.rh2PauseCompteur = 0;

			this.rh4FakeKey = 0;
			for (n = 0; n < 4; n++)
			{
				this.rhPlayer[n] = 0;
				this.rh2OldPlayer[n] = 0;
				this.rh2InputMask[n] = 0xFF;
			}
			this.rh2MouseKeys = 0;

			this.rhEvtProg.callEndForEach = false;
			this.rh4EndOfPause = -1;
			this.rh4OnMouseWheel = -1;
			this.rh4LoadCount = -1;
			this.rhEvtProg.rh4CheckDoneInstart = false;
			this.rh4PauseKey = 0;
			this.rh4Box2DBase = null;
			this.rh4Box2DSearched = false;
			this.rh4ForEachs = null;
			this.rh4CurrentForEach = null;
			this.rh4CurrentForEach2 = null;
			this.rh4TimerEvents = null;

			// TODO rh4DemoMode=CDemoRecord.DEMONOTHING;
			//      rh4Demo=null;

			for (n = 0; n < CRun.MAX_FRAMERATE; n++)
				this.rh4FrameRateArray[n] = 20;
			this.rh4FrameRatePos = 0;
		},

		f_GameLoop: function ()
		{
			this.rhApp.soundPlayer.checkSounds();

		    // For some reason the event loop of subapps is called while the images are still loading O_o
	        // Wait for all the data to be loaded
		    if (this.rhApp.parentApp != null && this.rhApp.loading) {
		        this.rhTimerOld = this.rhApp.timer;
		        this.rhTimer = 0;
		        return this.rhQuit;
		    }

		    if (this.rhApp.modalSubappObject != null) {
		        this.rhApp.modalSubappObject.handle();
		        return 0;
		    }

		    if (!this.bodiesCreated)
			{
				this.CreateBodies();
				this.bodiesCreated = true;
			}

			var timerBase = this.rhApp.timer;
			var delta = timerBase - this.rhTimerOld;
			var oldtimer = this.rhTimer;
			this.rhTimer = delta;
			delta -= oldtimer;
			this.rhTimerDelta = delta;
			this.rh4TimeOut += delta;
			this.rhLoopCount += 1;
			this.rh4MvtTimerCoef = (this.rhTimerDelta * this.rhFrame.m_dwMvtTimerBase) / 1000.0;

			this.rh4FrameRateArray[this.rh4FrameRatePos] = delta;
			this.rh4FrameRatePos++;
			if (this.rh4FrameRatePos >= CRun.MAX_FRAMERATE)
				this.rh4FrameRatePos = 0;

			var n;
			for (n = 0; n < 4; n++)
			{
				this.rh2OldPlayer[n] = this.rhPlayer[n];
			}
			this.joyTest();
			if (this.rhApp.joystickOn == 1)
				this.rhPlayer[0] |= this.rhApp.joystick.getJoystick() & this.rhJoystickMask;
			else if (this.rhApp.joystickOn == 2)
				this.rhPlayer[0] |= this.rhApp.getJoystick() & this.rhJoystickMask;

			if (this.rhMouseUsed != 0)
			{
				this.getMouseCoords();

				this.rh2MouseKeys = 0;

				if (this.rhApp.keyBuffer[CRunApp.VK_LBUTTON])
					this.rh2MouseKeys |= 0x10;				//00010000B;

				if (this.rhApp.keyBuffer[CRunApp.VK_RBUTTON])
					this.rh2MouseKeys |= 0x20;				//00100000B;

				var mouseUsed = this.rhMouseUsed;
				for (n = 0; n < this.rhNPlayers; n++)
				{
					if ((this.mouseUsed & 1) != 0)
					{
						var key = (this.rhPlayer[n] & 0xCF);		//11001111B;
						key |= this.rh2MouseKeys;
						this.rhPlayer[n] = key;
					}
					mouseUsed >>= 1;
				}
			}
			else
			{
				this.getMouseCoords();
			}

			var b;
			for (n = 0; n < 4; n++)
			{
				b = (this.rhPlayer[n] & CRun.plMasks[this.rhNPlayers * 4 + n]);
				b &= this.rh2InputMask[n];
				this.rhPlayer[n] = b;
				b ^= this.rh2OldPlayer[n];
				this.rh2NewPlayer[n] = b;
				if (b != 0)
				{
					b &= this.rhPlayer[n];
					if ((b & 0xF0) != 0)
					{
						this.rhEvtProg.rhCurOi = n;
						b = this.rh2NewPlayer[n];
						if ((b & 0xF0) != 0)
						{
							this.rhEvtProg.rhCurParam0 = b;
							this.rhEvtProg.handle_GlobalEvents(((-4 << 16) | 0xFFF9));	// CNDL_JOYPRESSED);
						}
						if ((b & 0x0F) != 0)
						{
							this.rhEvtProg.rhCurParam0 = b;
							this.rhEvtProg.handle_GlobalEvents(((-4 << 16) | 0xFFF9));	// CNDL_JOYPRESSED);
						}
					}
					else
					{
						var num = this.rhEvtProg.listPointers[this.rhEvtProg.rhEvents[-COI.OBJ_PLAYER] + 4];		// -NUM_JOYPRESSEZD
						if (num != 0)
						{
							this.rhEvtProg.rhCurParam0 = b;
							this.rhEvtProg.computeEventList(num, null);
						}
					}
				}
			}

			if (this.rhNObjects != 0)
			{
				var cptObject = this.rhNObjects;
				var count = 0;
				do
				{
					this.rh4ObjectAddCreate = 0;
					while (this.rhObjectList[count] == null)
						count++;
					var pObject = this.rhObjectList[count];

					pObject.hoPrevNoRepeat = pObject.hoBaseNoRepeat;
					pObject.hoBaseNoRepeat = null;
					if (pObject.hoCallRoutine)
					{
						this.rh4ObjectCurCreate = count;
						pObject.handle();
					}
					cptObject += this.rh4ObjectAddCreate;
					count++;
					cptObject--;
				} while (cptObject != 0);
			}
			this.rh3CollisionCount++;

			this.rhEvtProg.compute_TimerEvents();
			this.rhEvtProg.handle_TimerEvents();

			if (this.rhEvtProg.rhEventAlways)
			{
				if ((this.rhGameFlags & CRun.GAMEFLAGS_FIRSTLOOPFADEIN) == 0)
					this.rhEvtProg.computeEventList(0, null);
			}
			this.rhEvtProg.handle_PushedEvents();

			this.destroy_List();
			this.doScroll();
			//		this.modif_ChangedObjects();

			this.rhEvtProg.rh2CurrentClick = -1;
			this.rh4EventCount++;
			this.rh4FakeKey = 0;

			if (this.rhQuit == 0)
			{
				return this.rhQuitBis;
			}

			if (this.rhQuit == CRun.LOOPEXIT_NEXTLEVEL ||
				this.rhQuit == CRun.LOOPEXIT_PREVLEVEL ||
				this.rhQuit == CRun.LOOPEXIT_ENDGAME ||
				this.rhQuit == CRun.LOOPEXIT_GOTOLEVEL ||
				this.rhQuit == CRun.LOOPEXIT_QUIT ||
				this.rhQuit == CRun.LOOPEXIT_NEWGAME)
			{
				this.rhEvtProg.handle_GlobalEvents((-2 << 16) | 0xFFFD);
			}
			return this.rhQuit;
		},

		/*    modif_ChangedObjects:function()
		 {
		 var count=0;
		 var no;
		 for (no=0; no<this.rhNObjects; no++)		// Des objets à voir?
		 {
		 while(this.rhObjectList[count]==null)
		 count++;
		 var pHo=this.rhObjectList[count];
		 count++;

		 if ( (pHo.hoOEFlags & (CObjectCommon.OEFLAG_ANIMATIONS|CObjectCommon.OEFLAG_MOVEMENTS|CObjectCommon.OEFLAG_SPRITES)) != 0 )
		 {
		 if ( pHo.roc.rcChanged )
		 {
		 pHo.roc.rcChanged=false;
		 }
		 }
		 }
		 },
		 */
		joyTest:    function ()
		{
			var i;

			for (i = 0; i < 4; i++)
				this.rhPlayer[i] = 0;

			//		var ctrlType=this.rhApp.getCtrlType();
			var ctrlKeys = this.rhApp.getCtrlKeys();

			for (i = 0; i < 4; i++)
			{
				var k;
				for (k = 0; k < CRunApp.MAX_KEY; k++)
				{
					if (this.rhApp.keyBuffer[ctrlKeys[i * CRunApp.MAX_KEY + k]])
						this.rhPlayer[i] |= 1 << k;
				}
			}
		},

		getMouseCoords: function ()
		{
		    this.rh2MouseX = this.rhApp.mouseX + this.rhWindowX - this.rhApp.xOffset;
		    this.rh2MouseY = this.rhApp.mouseY + this.rhWindowY - this.rhApp.yOffset;
		},

		newHandle_Collisions: function (pHo)
		{
			pHo.rom.rmMoveFlag = false;
			CRun.bMoveChanged = false;
			pHo.rom.rmEventFlags = 0;

			var cadran, cadran1, cadran2;
			var chgDir;
			if ((pHo.hoLimitFlags & CObjInfo.OILIMITFLAGS_QUICKBORDER) != 0)
			{
				cadran1 = this.quadran_In(pHo.roc.rcOldX1, pHo.roc.rcOldY1, pHo.roc.rcOldX2, pHo.roc.rcOldY2);
				if (cadran1 != 0)
				{
					cadran2 = this.quadran_In(pHo.hoX - pHo.hoImgXSpot, pHo.hoY - pHo.hoImgYSpot, pHo.hoX - pHo.hoImgXSpot + pHo.hoImgWidth, pHo.hoY - pHo.hoImgYSpot + pHo.hoImgHeight);
					if (cadran2 == 0)
					{
						chgDir = (cadran1 ^ cadran2);
						if (chgDir != 0)
						{
							pHo.rom.rmEventFlags |= CRMvt.EF_GOESINPLAYFIELD;
							this.rhEvtProg.rhCurParam0 = chgDir;
							this.rhEvtProg.handle_Event(pHo, (-11 << 16) | (pHo.hoType & 0xFFFF));
						}
					}
				}

				cadran = this.quadran_In(pHo.hoX - pHo.hoImgXSpot, pHo.hoY - pHo.hoImgYSpot, pHo.hoX - pHo.hoImgXSpot + pHo.hoImgWidth, pHo.hoY - pHo.hoImgYSpot + pHo.hoImgHeight);
				if ((cadran & pHo.rom.rmWrapping) != 0)
				{
				    var oldMoveFlag = pHo.rom.rmMoveFlag;

					if ((cadran & CRun.BORDER_LEFT) != 0)
						pHo.rom.rmMovement.setXPosition(pHo.hoX + this.rhLevelSx);
					else if ((cadran & CRun.BORDER_RIGHT) != 0)
						pHo.rom.rmMovement.setXPosition(pHo.hoX - this.rhLevelSx);

					if ((cadran & CRun.BORDER_TOP) != 0)
						pHo.rom.rmMovement.setYPosition(pHo.hoY + this.rhLevelSy);
					else if ((cadran & CRun.BORDER_BOTTOM) != 0)
						pHo.rom.rmMovement.setYPosition(pHo.hoY - this.rhLevelSy);

				    // Fix for bug 3468: rmMoveFlag must not be forced when wrapping (see specific SetXPos / SetYPos in Windows runtime)
					if (pHo.roc.rcMovementType != CMoveDef.MVTYPE_PLATFORM && pHo.roc.rcMovementType != CMoveDef.MVTYPE_EXT)
					    pHo.rom.rmMoveFlag = oldMoveFlag;
				}

				cadran1 = this.quadran_Out(pHo.roc.rcOldX1, pHo.roc.rcOldY1, pHo.roc.rcOldX2, pHo.roc.rcOldY2);
				if (cadran1 != CRun.BORDER_ALL)		// Si deja completement dehors, on ne teste pas
				{
					cadran2 = this.quadran_Out(pHo.hoX - pHo.hoImgXSpot, pHo.hoY - pHo.hoImgYSpot,
						pHo.hoX - pHo.hoImgXSpot + pHo.hoImgWidth, pHo.hoY - pHo.hoImgYSpot + pHo.hoImgHeight);

					chgDir = (~cadran1 & cadran2);
					if (chgDir != 0)
					{
						pHo.rom.rmEventFlags |= CRMvt.EF_GOESOUTPLAYFIELD;
						this.rhEvtProg.rhCurParam0 = chgDir;		// ou LOWORD?
						this.rhEvtProg.handle_Event(pHo, (-12 << 16) | (pHo.hoType & 0xFFFF));  // CNDL_EXTOUTPLAYFIELD 
					}
				}
			}

			if ((pHo.hoLimitFlags & CObjInfo.OILIMITFLAGS_QUICKBACK) != 0)
			{
				if (pHo.roc.rcMovementType == CMoveDef.MVTYPE_PLATFORM)
				{
					pHo.rom.rmMovement.mpHandle_Background();
				}
				else
				{
					if (this.colMask_TestObject_IXY(pHo, pHo.roc.rcImage, pHo.roc.rcAngle, pHo.roc.rcScaleX, pHo.roc.rcScaleY, pHo.hoX, pHo.hoY, 0, CRunFrame.CM_TEST_PLATFORM))
					{
						this.rhEvtProg.handle_Event(pHo, ( (-13 << 16) | (pHo.hoType & 0xFFFF) ));
					}
				}
			}

			if ((pHo.hoLimitFlags & CObjInfo.OILIMITFLAGS_ONCOLLIDE) != 0)
			{
				var cnt = this.objectAllCol_IXY(pHo, pHo.roc.rcImage, pHo.roc.rcAngle, pHo.roc.rcScaleX, pHo.roc.rcScaleY, pHo.hoX, pHo.hoY, pHo.hoOiList.oilColList);
				if (cnt != null)
				{
					var obj;
					for (obj = 0; obj < cnt.size(); obj++)
					{
						var pHox = cnt.get(obj);
						if ((pHox.hoFlags & CObject.HOF_DESTROYED) == 0)
						{
							var type = pHo.hoType;
							var pHo_esi = pHo;
							var pHo_ebx = pHox;
							if (pHo_esi.hoType > pHo_ebx.hoType)
							{
								pHo_esi = pHox;
								pHo_ebx = pHo;
								type = pHo_esi.hoType;
							}
							this.rhEvtProg.rhCurParam0 = pHo_ebx.hoOi;
							this.rhEvtProg.rh1stObjectNumber = pHo_ebx.hoNumber;
							this.rhEvtProg.handle_Event(pHo_esi, (-14 << 16) | (type & 0xFFFF));
						}
					}
				}
			}
			return CRun.bMoveChanged;
		},

		objectAllCol_IXY: function (pHo, newImg, newAngle, newScaleX, newScaleY, newX, newY, pOiColList)
		{
			var list = null;

			var rectX1 = newX - pHo.hoImgXSpot;
			var rectX2 = rectX1 + pHo.hoImgWidth;
			var rectY1 = newY - pHo.hoImgYSpot;
			var rectY2 = rectY1 + pHo.hoImgHeight;

			var image1;
			var pMask2;
			var image2;
			if ((pHo.hoFlags & CObject.HOF_NOCOLLISION) != 0 || (pHo.hoFlags & CObject.HOF_DESTROYED) != 0)
			{
				return list;
			}
			var bMask1 = false;
			var pMask1 = null;
			var image;
			var nLayer = -1;
			if (pHo.hoType == COI.OBJ_SPR && (pHo.ros.rsFlags & CRSpr.RSFLAG_COLBOX) == 0)
			{
				bMask1 = true;
			}
			if (pHo.hoType == COI.OBJ_SPR)
			{
				nLayer = pHo.ros.rsLayer;
			}

			var oldHoFlags = pHo.hoFlags;
			pHo.hoFlags |= CObject.HOF_NOCOLLISION;
			var count = 0;
			var i;
			var pHox;
			var xHox, yHox;
			if (pOiColList != null)
			{
				var nOi = 0;
				for (nOi = 0; nOi < pOiColList.length; nOi += 2)
				{
					var pOil = this.rhOiList[pOiColList[nOi + 1]];
					var object = pOil.oilObject;
					while ((object & 0x80000000) == 0)
					{
						pHox = this.rhObjectList[object];
						object = pHox.hoNumNext;

						if ((pHox.hoFlags & CObject.HOF_NOCOLLISION) == 0 && (pHox.hoFlags & CObject.HOF_DESTROYED) == 0)
						{
							xHox = pHox.hoX - pHox.hoImgXSpot;
							yHox = pHox.hoY - pHox.hoImgYSpot;
							if (xHox < rectX2 &&
								xHox + pHox.hoImgWidth > rectX1 &&
								yHox < rectY2 &&
								yHox + pHox.hoImgHeight > rectY1)
							{
								switch (pHox.hoType)
								{
									case COI.OBJ_SPR:
										if (nLayer < 0 || (nLayer >= 0 && nLayer == pHox.ros.rsLayer))
										{
											if ((pHox.ros.rsFlags & CRSpr.RSFLAG_RAMBO) != 0)
											{
												if (bMask1 == false || (pHox.ros.rsFlags & CRSpr.RSFLAG_COLBOX) != 0)
												{
													if (list == null)
													{
														list = new CArrayList();
													}
													list.add(pHox);
													break;
												}
												if (pMask1 == null)
												{
													image = this.rhApp.imageBank.getImageFromHandle(newImg);
													if (image != null)
													{
														pMask1 = image.getMask(0, newAngle, newScaleX, newScaleY);
													}
												}
												image2 = this.rhApp.imageBank.getImageFromHandle(pHox.roc.rcImage);
												if (image2 != null)
												{
													pMask2 = image2.getMask(0, pHox.roc.rcAngle, pHox.roc.rcScaleX, pHox.roc.rcScaleY);
												}
												if (pMask1 != null && pMask2 != null)
												{
													if (pMask1.testMask(rectX1, rectY1, 0, pMask2, xHox, yHox, 0))
													{
														if (list == null)
														{
															list = new CArrayList();
														}
														list.add(pHox);
														break;
													}
												}
											}
										}
										break;
									case COI.OBJ_TEXT:
									case COI.OBJ_COUNTER:
									case COI.OBJ_LIVES:
									case COI.OBJ_SCORE:
									case COI.OBJ_CCA:
										if (list == null)
										{
											list = new CArrayList();
										}
										list.add(pHox);
										break;
									default:
										if (list == null)
										{
											list = new CArrayList();
										}
										list.add(pHox);
										break;
								}
							}
						}
					}
				}
			}
			else
			{
				for (i = 0; i < this.rhNObjects; i++)
				{
					while (this.rhObjectList[count] == null)
						count++;
					pHox = this.rhObjectList[count];
					count++;

					if ((pHox.hoFlags & CObject.HOF_NOCOLLISION) == 0)
					{
						xHox = pHox.hoX - pHox.hoImgXSpot;
						yHox = pHox.hoY - pHox.hoImgYSpot;
						if (xHox < rectX2 &&
							xHox + pHox.hoImgWidth > rectX1 &&
							yHox < rectY2 &&
							yHox + pHox.hoImgHeight > rectY1)
						{
							switch (pHox.hoType)
							{
								case COI.OBJ_SPR:
									if (nLayer < 0 || (nLayer >= 0 && nLayer == pHox.ros.rsLayer))
									{
										if ((pHox.ros.rsFlags & CRSpr.RSFLAG_RAMBO) != 0)
										{
											if (bMask1 == false || (pHox.ros.rsFlags & CRSpr.RSFLAG_COLBOX) != 0)
											{
												if (list == null)
												{
													list = new CArrayList();
												}
												list.add(pHox);
												break;
											}
											if (pMask1 == null)
											{
												image = this.rhApp.imageBank.getImageFromHandle(newImg);
												if (image != null)
												{
													pMask1 = image.getMask(0, newAngle, newScaleX, newScaleY);
												}
											}
											image2 = this.rhApp.imageBank.getImageFromHandle(pHox.roc.rcImage);
											if (image2 != null)
											{
												pMask2 = image2.getMask(0, pHox.roc.rcAngle, pHox.roc.rcScaleX, pHox.roc.rcScaleY);
											}
											if (pMask1 != null && pMask2 != null)
											{
												if (pMask1.testMask(rectX1, rectY1, 0, pMask2, xHox, yHox, 0))
												{
													if (list == null)
													{
														list = new CArrayList();
													}
													list.add(pHox);
													break;
												}
											}
										}
									}
									break;
								case COI.OBJ_TEXT:
								case COI.OBJ_COUNTER:
								case COI.OBJ_LIVES:
								case COI.OBJ_SCORE:
								case COI.OBJ_CCA:
									if (list == null)
									{
										list = new CArrayList();
									}
									list.add(pHox);
									break;
								default:
									if (list == null)
									{
										list = new CArrayList();
									}
									list.add(pHox);
									break;
							}
						}
					}
				}
			}
			// Remettre anciens flags
			pHo.hoFlags = oldHoFlags;
			return list;
		},

		colMask_TestObject_IXY: function (pHo, newImg, newAngle, newScaleX, newScaleY, newX, newY, htFoot, plan)
		{
			var image;
			var mask;
			var x1;
			var y1;
			var x2;
			var y2;

			var pLayer = this.rhFrame.layers[pHo.hoLayer];
			switch (pHo.hoType)
			{
				case COI.OBJ_SPR:
					if ((pHo.ros.rsFlags & CRSpr.RSFLAG_COLBOX) == 0)
					{
						image = this.rhApp.imageBank.getImageFromHandle(pHo.roc.rcImage);
						if (image != null)
						{
							mask = image.getMask(CMask.GCMF_OBSTACLE, newAngle, newScaleX, newScaleY);
							return pLayer.testMask(mask, newX - this.rhWindowX, newY - this.rhWindowY, htFoot, plan) != null;
						}
					}
					else
					{
						x1 = newX - pHo.hoImgXSpot - this.rhWindowX;
						y1 = newY - pHo.hoImgYSpot - this.rhWindowY;
						x2 = x1 + pHo.hoImgWidth;
						y2 = y1 + pHo.hoImgHeight;
						var ret = pLayer.testRect(x1, y1, x2, y2, htFoot, plan) != null;
						return ret;
					}
					return false;
				//    		case COI.OBJ_TEXT:
				//    		case COI.OBJ_SCORE:
				//    		case COI.OBJ_LIVES:
				//    		case COI.OBJ_CCA:
				default:
					x1 = newX - pHo.hoImgXSpot - this.rhWindowX;
					y1 = newY - pHo.hoImgYSpot - this.rhWindowY;
					x2 = x1 + pHo.hoImgWidth;
					y2 = y1 + pHo.hoImgHeight;
					var ret = pLayer.testRect(x1, y1, x2, y2, htFoot, plan) != null;
					return ret;
			}
		},
		colMask_Test_Rect:      function (x1, y1, sx, sy, layer, plan)
		{
			var pLayer;
			var nLayerMax = layer;
			if (layer == -1)
			{
				layer = 0;
				nLayerMax = this.rhFrame.nLayers;
			}

			var n;
			var x2 = x1 + sx;
			var y2 = y1 + sy;
			for (n = layer; n < nLayerMax; n++)
			{
				pLayer = this.rhFrame.layers[n];
				if (pLayer.testRect(x1 - this.rhWindowX + pLayer.x, y1 - this.rhWindowY + pLayer.y, x2 - this.rhWindowX + pLayer.x, y2 - this.rhWindowY + pLayer.y, 0, plan) != null)
				{
					return true;
				}
			}
			return false;
		},
		colMask_Test_XY:        function (newX, newY, layer, plan)
		{
			var pLayer;
			var nLayerMax = layer;
			if (layer == -1)
			{
				layer = 0;
				nLayerMax = this.rhFrame.nLayers;
			}

			var n;
			for (n = layer; n < nLayerMax; n++)
			{
				pLayer = this.rhFrame.layers[n];
				if (pLayer.testPoint(newX - this.rhWindowX + pLayer.x, newY - this.rhWindowY + pLayer.y, plan))
				{
					return true;
				}
			}
			return false;
		},

		getObjectAtXY: function (x, y)
		{
			// Explore les sprites en collision
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			var count = 0;
			var i;
			var pHox;
			var x1, y1, x2, y2;
			var currentHo = null;
			var currentIndex = -1;
			var index;

			for (i = 0; i < this.rhNObjects; i++)
			{
				while (this.rhObjectList[count] == null)
					count++;
				pHox = this.rhObjectList[count];
				count++;

				x1 = pHox.hoX - pHox.hoImgXSpot;
				y1 = pHox.hoY - pHox.hoImgYSpot;
				x2 = x1 + pHox.hoImgWidth;
				y2 = y1 + pHox.hoImgHeight;
				if (x >= x1 && x < x2 && y >= y1 && y < y2)
				{
					if ((pHox.hoFlags & CObject.HOF_DESTROYED) == 0)
					{
						if (pHox.hoType == COI.OBJ_SPR)
						{
							if ((pHox.ros.rsFlags & CRSpr.RSFLAG_COLBOX) == 0)
							{
								var image = this.rhApp.imageBank.getImageFromHandle(pHox.roc.rcImage);
								var mask = image.getMask(CMask.GCMF_OBSTACLE, 0, 1.0, 1.0);
								if (mask.testPointEx(x - pHox.hoX, y - pHox.hoY, pHox.roc.rcAngle, pHox.roc.rcScaleX, pHox.roc.rcScaleY))
								{
									index = pHox.getChildIndex();
									if (index > currentIndex)
									{
										currentIndex = index;
										currentHo = pHox;
									}
								}
							}
							else
							{
								index = pHox.getChildIndex();
								if (index > currentIndex)
								{
									currentIndex = index;
									currentHo = pHox;
								}
							}
						}
					}
				}
			}
			return currentHo;
		},


		quadran_Out: function (x1, y1, x2, y2)
		{
			var cadran = 0;
			if (x1 < 0)
				cadran |= CRun.BORDER_LEFT;
			if (y1 < 0)
				cadran |= CRun.BORDER_TOP;
			if (x2 > this.rhLevelSx)
				cadran |= CRun.BORDER_RIGHT;
			if (y2 > this.rhLevelSy)
				cadran |= CRun.BORDER_BOTTOM;
			return CRun.Table_InOut[cadran];
		},

		quadran_In: function (x1, y1, x2, y2)
		{
			var cadran = 15;
			if (x1 < this.rhLevelSx)
				cadran &= ~CRun.BORDER_RIGHT;
			if (y1 < this.rhLevelSy)
				cadran &= ~CRun.BORDER_BOTTOM;
			if (x2 > 0)
				cadran &= ~CRun.BORDER_LEFT;
			if (y2 > 0)
				cadran &= ~CRun.BORDER_TOP;
			return CRun.Table_InOut[cadran];
		},

		random: function (wMax)
		{
			var calcul = this.rh3Graine * 31415 + 1;
			calcul &= 0x0000FFFF;
			this.rh3Graine = calcul;
			return ((calcul * wMax) >>> 16);
		},

		get_Direction: function (dir)
		{
			if (dir == 0 || dir == -1)
			{
				return this.random(32);
			}

			var loop;
			var found = 0;
			var count = 0;
			var dirShift = dir;
			for (loop = 0; loop < 32; loop++)
			{
				if ((dirShift & 1) != 0)
				{
					count++;
					found = loop;
				}
				dirShift >>>= 1;
			}

			if (count == 1)
			{
				return found;
			}

			count = this.random(count);
			dirShift = dir;
			for (loop = 0; loop < 32; loop++)
			{
				if ((dirShift & 1) != 0)
				{
					count--;
					if (count < 0)
					{
						return loop;
					}
				}
				dirShift >>>= 1;
			}
			return 0;
		},

		get_EventExpressionAny: function (pExp)
		{
			this.rh4Tokens = pExp.tokens;
			this.rh4CurToken = 0;
			this.flagFloat = false;
			return this.getExpression();

		},

		get_EventExpressionInt: function (pExp)
		{
			this.rh4Tokens = pExp.tokens;
			this.rh4CurToken = 0;
			this.flagFloat = false;
			return this.getExpression();
		},

		get_EventExpressionDouble: function (pExp)
		{
			this.rh4Tokens = pExp.tokens;
			this.rh4CurToken = 0;
			this.flagFloat = false;
			return this.getExpression();
		},

		get_EventExpressionString: function (pExp)
		{
			this.rh4Tokens = pExp.tokens;
			this.rh4CurToken = 0;
			this.flagFloat = false;
			return this.getExpression();
		},

		get_ExpressionInt: function ()
		{
			this.flagFloat = false;
			var value = this.getExpression();
			if (value < 0)
				return Math.ceil(value);
			else
				return Math.floor(value);
		},

		getExpression: function ()
		{
			var ope;
			var pileStart = this.rh4PosPile;
			this.rh4Operators[this.rh4PosPile] = this.rh4OpeNull;
			do
			{
				this.rh4PosPile++;
				this.bOperande = true;
				this.rh4Tokens[this.rh4CurToken].evaluate(this);
				this.bOperande = false;
				this.rh4CurToken++;

				do
				{
					ope = this.rh4Tokens[this.rh4CurToken];
					if (ope.code > 0 && ope.code < 0x00140000)
					{
						if (ope.code > this.rh4Operators[this.rh4PosPile - 1].code)
						{
							this.rh4Operators[this.rh4PosPile] = ope;
							this.rh4CurToken++;

							this.rh4PosPile++;
							this.bOperande = true;
							this.rh4Tokens[this.rh4CurToken].evaluate(this);
							this.bOperande = false;
							this.rh4CurToken++;
						}
						else
						{
							this.rh4PosPile--;
							this.rh4Operators[this.rh4PosPile].evaluate(this);
						}
					}
					else
					{
						this.rh4PosPile--;
						if (this.rh4PosPile == pileStart)
						{
							break;
						}
						this.rh4Operators[this.rh4PosPile].evaluate(this);
					}
				} while (true);
			} while (this.rh4PosPile > pileStart + 1);
			return this.rh4Results[pileStart + 1];
		},

		getCurrentResult: function ()
		{
			return this.rh4Results[this.rh4PosPile];
		},

		getPreviousResult: function ()
		{
			return this.rh4Results[this.rh4PosPile - 1];
		},

		getNextResult: function ()
		{
			return this.rh4Results[this.rh4PosPile + 1];
		},

		update_PlayerObjects: function (joueur, type, value)
		{
			joueur++;

			var count = 0;
			var no;
			for (no = 0; no < this.rhNObjects; no++)
			{
				while (this.rhObjectList[count] == null)
					count++;
				var pHo = this.rhObjectList[count];
				if (pHo.hoType == type)
				{
					switch (type)
					{
						case 5:
							if (pHo.rsPlayer == joueur)
							{
								pHo.setValue(value);
							}
							break;
						case 6:
							if (pHo.rsPlayer == joueur)
							{
								pHo.setValue(value);
							}
							break;
					}
				}
				count++;
			}
		},

		actPla_FinishLives: function (joueur, live)
		{
			var lives = this.rhApp.getLives();
			if (live == lives[joueur])
			{
				return;
			}

			if (live == 0)
			{
				if (lives[joueur] != 0)
				{
					this.rhEvtProg.push_Event(0, ((-5 << 16) | 0xFFF9), 0, null, joueur);
				}
			}

			lives[joueur] = live;
			this.update_PlayerObjects(joueur, COI.OBJ_LIVES, live);
		},

		getMouseOnObjectsEDX: function (oiList, nega)
		{
			var pHo = this.rhEvtProg.evt_FirstObject(oiList);
			if (pHo == null)
			{
				if (nega)
				{
					return true;
				}
				return false;
			}
			var cpt = this.rhEvtProg.evtNSelectedObjects;

			var count = 0;
			var i;
			var pHox;
			var x1, y1, x2, y2;
			var list = new CArrayList();
			for (i = 0; i < this.rhNObjects; i++)
			{
				while (this.rhObjectList[count] == null)
					count++;
				pHox = this.rhObjectList[count];
				count++;

				x1 = pHox.hoX - pHox.hoImgXSpot;
				y1 = pHox.hoY - pHox.hoImgYSpot;
				x2 = x1 + pHox.hoImgWidth;
				y2 = y1 + pHox.hoImgHeight;
				if (this.rh2MouseX >= x1 && this.rh2MouseX < x2 && this.rh2MouseY >= y1 && this.rh2MouseY < y2)
				{
					if ((pHox.hoFlags & CObject.HOF_DESTROYED) == 0)
					{
						if (pHox.hoType == COI.OBJ_SPR)
						{
							if ((pHox.ros.rsFlags & CRSpr.RSFLAG_COLBOX) == 0)
							{
								var image = this.rhApp.imageBank.getImageFromHandle(pHox.roc.rcImage);
								var mask = image.getMask(CMask.GCMF_OBSTACLE, 0, 1.0, 1.0);
								if (mask.testPointEx(this.rh2MouseX - pHox.hoX, this.rh2MouseY - pHox.hoY, pHox.roc.rcAngle, pHox.roc.rcScaleX, pHox.roc.rcScaleY))
								{
									list.add(pHox);
								}
							}
							else
							{
								list.add(pHox);
							}
						}
						else
						{
							list.add(pHox);
						}
					}
				}
			}

			if (list.size() == 0)
			{
				if (nega)
				{
					return true;
				}
				return false;
			}

			if (nega == false)
			{
				do
				{
					for (count = 0; count < list.size(); count++)
					{
						pHox = list.get(count);
						if (pHox == pHo)
							break;
					}
					if (count == list.size())
					{
						cpt--;						//; Pas trouve dans la liste. on le vire
						this.rhEvtProg.evt_DeleteCurrentObject();
					}
					pHo = this.rhEvtProg.evt_NextObject();
				} while (pHo != null);
				return cpt != 0;
			}
			else
			{
				do
				{
					for (count = 0; count < list.size(); count++)
					{
						pHox = list.get(count);
						if (pHox == pHo)
							return false;
					}
					pHo = this.rhEvtProg.evt_NextObject();
				} while (pHo != null);
				return true;
			}
		},


		txtDisplay: function (pe, oi, txtNumber)
		{
			var pEvp = pe.evtParams[0];
			var pInfo = new CPositionInfo();
			if (pEvp.read_Position(this, 0x10, pInfo))
			{
				var count = 0;
				var no;
				for (no = 0; no < this.rhNObjects; no++)
				{
					while (this.rhObjectList[count] == null)
						count++;
					var pHo = this.rhObjectList[count];
					count++;

					if (pHo.hoType == COI.OBJ_TEXT && pHo.hoOi == oi && pHo.hoX == pInfo.x && pHo.hoY == pInfo.y)
					{
						pHo.ros.obShow();
						pHo.hoFlags &= ~CObject.HOF_NOCOLLISION;
						pHo.rsMini = -2;
						pHo.txtChange(txtNumber);
						pHo.ros.rsFlash = 0;
						pHo.ros.rsFlags |= CRSpr.RSFLAG_VISIBLE;
						return pHo.hoNumber;
					}
				}
				var num = this.f_CreateObject(-1, oi, pInfo.x, pInfo.y, 0, 0, this.rhFrame.nLayers - 1, -1);
				if (num >= 0)
				{
					this.rhObjectList[num].txtChange(txtNumber);
					return num;
				}
			}
			return -1;
		},

		txtDoDisplay: function (pe, txtNumber)
		{
			if ((pe.evtOiList & 0x8000) == 0)
			{
				return this.txtDisplay(pe, pe.evtOi, txtNumber);
			}

			if ((pe.evtOiList & 0x7FFF) == 0x7FFF)
				return -1;
			var qoi = pe.evtOiList & 0x7FFF;
			var qoil = this.rhEvtProg.qualToOiList[qoi];
			var count = 0;
			while (count < qoil.qoiList.length)
			{
				this.txtDisplay(pe, qoil.qoiList[count], txtNumber);
				count += 2;
			}
			;
			return -1;
		},

		init_Disappear: function (hoPtr)
		{
			var bFlag = false;
			var dw = 0;

			if ((hoPtr.hoOEFlags & CObjectCommon.OEFLAG_ANIMATIONS) != 0)
			{
				if (hoPtr.ros != null)
				{
					if (hoPtr.ros.initFadeOut())
					{
						return;
					}
				}
				if (hoPtr.roa != null)
				{
					if (hoPtr.roa.anim_Exist(CAnim.ANIMID_DISAPPEAR))
					{
						dw = 1;
					}
				}
			}
			if (dw == 0)
			{
				bFlag = true;
			}

			if (bFlag)
			{
				hoPtr.hoCallRoutine = false;
				this.destroy_Add(hoPtr.hoNumber);
				return;
			}

			if (hoPtr.ros != null)
			{
				hoPtr.ros.setColFlag(false);
				hoPtr.hoFlags |= CObject.HOF_NOCOLLISION;
			}
			if (hoPtr.rom != null)
			{
				hoPtr.rom.kill(false);
				hoPtr.rom.initSimple(hoPtr, CMoveDef.MVTYPE_DISAPPEAR, false);
				hoPtr.roc.rcSpeed = 0;
			}
			if ((dw & 1) != 0)
			{
				hoPtr.roa.animation_Force(CAnim.ANIMID_DISAPPEAR);
				hoPtr.roa.animation_OneLoop();
			}
		},

		isMouseOn: function ()
		{
			if (this.rhApp.cursorCount > 0)
			{
				return true;
			}
			return false;
		},

		getRGBAt: function (hoPtr, x, y)
		{
			var rgb = 0;
			if (hoPtr.roc.rcImage != -1)
			{
				var image = this.rhApp.imageBank.getImageFromHandle(hoPtr.roc.rcImage);
				rgb = image.getPixel(x, y);
				rgb = swapRGB(rgb);
			}
			return rgb;
		},

		drawLevel: function ()
		{
			var plo;
			var rc = new CRect();
			var nLayer;

			for (nLayer = 0; nLayer < this.rhFrame.nLayers; nLayer++)
			{
				var pLayer = this.rhFrame.layers[nLayer];

				var bWrapHorz = ((pLayer.dwOptions & CLayer.FLOPT_WRAP_HORZ) != 0);
				var bWrapVert = ((pLayer.dwOptions & CLayer.FLOPT_WRAP_VERT) != 0);

				if (nLayer == 0)
				{
					var sx = this.rhFrame.leWidth;
					if (bWrapHorz)
					{
						sx *= 2;
					}
					var sy = this.rhFrame.leHeight;
					if (bWrapVert)
					{
						sy *= 2;
					}
					//				pLayer.fillBack(sx, sy, rhFrame.leBackground);
				}

				var nLOs = pLayer.nBkdLOs;
				var i;
				for (i = 0; i < nLOs; i++)
				{
					plo = this.rhFrame.LOList.getLOFromIndex(pLayer.nFirstLOIndex + i);
					var typeObj = plo.loType;

					if (typeObj < COI.OBJ_SPR)
					{
						rc.left = plo.loX;
						rc.top = plo.loY;
					}
					/*				else
					 {
					 continue;
					 }
					 */
					var bi;
					bi = new CBackInstance(this.rhApp, rc.left, rc.top, plo, null, 0);
					bi.addInstance(0, pLayer);

					if (bWrapHorz)
					{
						bi = new CBackInstance(this.rhApp, this.rhFrame.leWidth + rc.left, rc.top, plo, null, 0);
						bi.addInstance(1, pLayer);
						if (rc.left + bi.width > this.rhFrame.leWidth)
						{
							bi = new CBackInstance(this.rhApp, rc.left - this.rhFrame.leWidth, rc.top, plo, null, 0);
							bi.addInstance(4, pLayer);
						}
						if (bWrapVert)
						{
							bi = new CBackInstance(this.rhApp, rc.left, this.rhFrame.leHeight + rc.top, plo, null, 0);
							bi.addInstance(2, pLayer);
							bi = new CBackInstance(this.rhApp, this.rhFrame.leWidth + rc.left, this.rhFrame.leHeight + rc.top, plo, null, 0);
							bi.addInstance(3, pLayer);
							if (rc.top + bi.height > this.rhFrame.leHeight)
							{
								bi = new CBackInstance(this.rhApp, rc.left, rc.top - this.rhFrame.leHeight, plo, null, 0);
								bi.addInstance(5, pLayer);
							}
						}
					}
					else if (bWrapVert)
					{
						bi = new CBackInstance(this.rhApp, rc.left, this.rhFrame.leHeight + rc.top, plo, null, 0);
						bi.addInstance(2, pLayer);
						if (rc.top + bi.height > this.rhFrame.leHeight)
						{
							bi = new CBackInstance(this.rhApp, rc.left, rc.top - this.rhFrame.leHeight, plo, null, 0);
							bi.addInstance(5, pLayer);
						}
					}
				}
			}
		},

		scrollLayers: function ()
		{
		    //this is only called from the Layer controller object. It is used to update the layer offsets!
		    var layer;

		    //get current scroll of frame
		    var frameX = this.rh3DisplayX;
		    var frameY = this.rh3DisplayY;

		    var newLayerX, newLayerY;
		    for (var index = 0; index < this.rhFrame.nLayers; index++) {
		        //get layer
		        layer = this.rhFrame.layers[index];

		        newLayerX = frameX;
		        newLayerY = frameY;

		        if ((layer.dwOptions & (CLayer.FLOPT_XCOEF | CLayer.FLOPT_YCOEF)) != 0) {
		            if ((layer.dwOptions & CLayer.FLOPT_XCOEF) != 0) {
		                newLayerX *= layer.xCoef;
		            }

		            if ((layer.dwOptions & CLayer.FLOPT_YCOEF) != 0) {
		                newLayerY *= layer.yCoef;
		            }
		        }

		        //add old layer position
		        newLayerX += layer.realX;
		        newLayerY += layer.realY;

		        //add layer change value
		        newLayerX += layer.dx;
		        newLayerY += layer.dy;

		        //do wrapping
		        var bWrapHorz = ((layer.dwOptions & CLayer.FLOPT_WRAP_HORZ) != 0);
		        var bWrapVert = ((layer.dwOptions & CLayer.FLOPT_WRAP_VERT) != 0);

		        if (bWrapHorz) {
		            newLayerX %= this.rhFrame.leWidth;
		        }

		        if (bWrapVert) {
		            newLayerY %= this.rhFrame.leHeight;
		        }

		        /*
	            if (bWrapHorz) {
	                if (newLayerX < 0) {
	                    newLayerX = newLayerX % this.rhFrame.leWidth + this.rhFrame.leWidth;
	                }

	                if (newLayerX > this.rhFrame.leWidth) {
	                    newLayerX = newLayerX % this.rhFrame.leWidth;
	                }
	            }

	            if (bWrapVert) {
	                if (newLayerY < 0) {
	                    newLayerY = newLayerY % this.rhFrame.leHeight + this.rhFrame.leHeight;
	                }

	                if (newLayerY > this.rhFrame.leHeight) {
	                    newLayerY = newLayerY % this.rhFrame.leHeight;
	                }
	            }
	            */

		        //update layer
		        layer.x = newLayerX;
		        layer.y = newLayerY;
		        layer.realX += layer.dx;
		        layer.realY += layer.dy;

		        //we also need to update the scene nodes as they are rendered seperate
		        layer.planeBack.x = -newLayerX + this.rhApp.xOffset;//xOffset and yOffset are not used (try searching for .xOffset in all files in android runtime too)
		        layer.planeBack.y = -newLayerY + this.rhApp.yOffset;
		        layer.planeQuickDisplay.x = -newLayerX + this.rhApp.xOffset;
		        layer.planeQuickDisplay.y = -newLayerY + this.rhApp.yOffset;
		        layer.planeSprites.x = -newLayerX + this.rhApp.xOffset;
		        layer.planeSprites.y = -newLayerY + this.rhApp.yOffset;
		    }

		    //update frame position
		    this.rhFrame.leX = frameX;
		    this.rhFrame.leY = frameY;
		},

		hideLayer:      function (nLayer)
		{
			if (nLayer >= 0 && nLayer < this.rhFrame.nLayers)
			{
				var layer = this.rhFrame.layers[nLayer];
				layer.hide();
			}
		},
		showLayer:      function (nLayer)
		{
			if (nLayer >= 0 && nLayer < this.rhFrame.nLayers)
			{
				var layer = this.rhFrame.layers[nLayer];
				layer.show();
			}
		},
		hideShowLayers: function ()
		{
			var n;
			for (n = 0; n < this.rhFrame.nLayers; n++)
			{
				var layer = this.rhFrame.layers[n];
				if (layer.dwOptions & CLayer.FLOPT_TOHIDE)
				{
					layer.hide();
				}
			}
		},

		setDisplay: function (x, y, nLayer, flags)
		{
			x -= Math.floor(this.rh3WindowSx / 2);
			y -= Math.floor(this.rh3WindowSy / 2);

			var xf = x;
			var yf = y;

			if (nLayer != -1 && nLayer < this.rhFrame.nLayers)
			{
				var pLayer = this.rhFrame.layers[nLayer];
				if (pLayer.xCoef > 1.0)
				{
					var dxf = (xf - this.rhWindowX);
					dxf /= pLayer.xCoef;
					xf = CServices.floatToInt(this.rhWindowX + dxf);
				}
				if (pLayer.yCoef > 1.0)
				{
					var dyf = (yf - this.rhWindowY);
					dyf /= pLayer.yCoef;
					yf = CServices.floatToInt(this.rhWindowY + dyf);
				}
			}

			x = xf;
			y = yf;

			if (x < 0)
			{
				x = 0;
			}
			if (y < 0)
			{
				y = 0;
			}
			var x2 = x + this.rh3WindowSx;
			var y2 = y + this.rh3WindowSy;
			if (x2 > this.rhLevelSx)
			{
				x2 = this.rhLevelSx - this.rh3WindowSx;
				if (x2 < 0)
				{
					x2 = 0;
				}
				x = x2;
			}
			if (y2 > this.rhLevelSy)
			{
				y2 = this.rhLevelSy - this.rh3WindowSy;
				if (y2 < 0)
				{
					y2 = 0;
				}
				y = y2;
			}

			if ((flags & 1) != 0)
			{
				if (x != this.rhWindowX)
				{
					this.rh3DisplayX = x;
					this.rh3Scrolling |= CRun.RH3SCROLLING_SCROLL;
				}
			}
			if ((flags & 2) != 0)
			{
				if (y != this.rhWindowY)
				{
					this.rh3DisplayY = y;
					this.rh3Scrolling |= CRun.RH3SCROLLING_SCROLL;
				}
			}
		},

		updateWindowPos: function (newX, newY)
		{
		    var hasMoved = false;

		    this.rh4WindowDeltaX = newX - this.rhWindowX;
		    this.rh4WindowDeltaY = newY - this.rhWindowY;

		    //check if the main frame is moving
		    if (this.rh4WindowDeltaX != 0 || this.rh4WindowDeltaY != 0) {
		        hasMoved = true;
		    }

		    //check if any layers are moving
		    var pLayer;
		    if (!hasMoved) {
		        for (var i = 0; i < this.rhFrame.nLayers; i++) {
		            pLayer = this.rhFrame.layers[i];

		            if (pLayer.dx != 0 || pLayer.dy != 0) {
		                hasMoved = true;
		                break;
		            }
		        }
		    }

		    var nOldX = this.rhWindowX;
		    var nOldY = this.rhWindowY;
		    var nNewX = newX;
		    var nNewY = newY;
		    var nDeltaX = this.rh4WindowDeltaX;
		    var nDeltaY = this.rh4WindowDeltaY;

		    this.rhWindowX = newX;
		    this.rh3XMinimum = newX - CRun.COLMASK_XMARGIN;
		    if (this.rh3XMinimum < 0) {
		        this.rh3XMinimum = this.rh3XMinimumKill;
		    }

		    this.rhWindowY = newY;
		    this.rh3YMinimum = newY - CRun.COLMASK_YMARGIN;
		    if (this.rh3YMinimum < 0) {
		        this.rh3YMinimum = this.rh3YMinimumKill;
		    }

		    this.rh3XMaximum = newX + this.rh3WindowSx + CRun.COLMASK_XMARGIN;
		    if (this.rh3XMaximum > this.rhLevelSx) {
		        this.rh3XMaximum = this.rh3XMaximumKill;
		    }

		    this.rh3YMaximum = newY + this.rh3WindowSy + CRun.COLMASK_YMARGIN;
		    if (this.rh3YMaximum > this.rhLevelSy) {
		        this.rh3YMaximum = this.rh3YMaximumKill;
		    }

		    //need to update the objects (only if something has moved above)
		    if (hasMoved) {
		        var count = 0;
		        for (var index = 0; index < this.rhNObjects; index++) {
		            //find next valid object
		            while (this.rhObjectList[count] == null) {
		                count++;
		            }
		            var pHo = this.rhObjectList[count];
		            count++;

		            // Don't follow the frame?
		            if ((pHo.hoOEFlags & CObjectCommon.OEFLAG_SCROLLINGINDEPENDANT) != 0) {
		                if (pHo.rom == null) {
		                    pHo.hoX += nDeltaX;
		                    pHo.hoY += nDeltaY;

		                } else {
		                    pHo.rom.rmMovement.setXPosition(pHo.hoX + nDeltaX);
		                    pHo.rom.rmMovement.setYPosition(pHo.hoY + nDeltaY);
		                }
		            } else {
		                // Follow the frame
		                var layerIndex = pHo.hoLayer;
		                if (layerIndex < this.rhFrame.nLayers) {
		                    var oldLayerDx = nOldX;
		                    var oldLayerDy = nOldY;
		                    var newLayerDx = nNewX;
		                    var newLayerDy = nNewY;

		                    pLayer = this.rhFrame.layers[layerIndex];
		                    if ((pLayer.dwOptions & CLayer.FLOPT_XCOEF) != 0) {
		                        oldLayerDx = (pLayer.xCoef * oldLayerDx);
		                        newLayerDx = (pLayer.xCoef * newLayerDx);
		                    }

		                    if ((pLayer.dwOptions & CLayer.FLOPT_YCOEF) != 0) {
		                        oldLayerDy = (pLayer.yCoef * oldLayerDy);
		                        newLayerDy = (pLayer.yCoef * newLayerDy);
		                    }

		                    var nX = (pHo.hoX + oldLayerDx) - newLayerDx + nDeltaX - pLayer.dx;
		                    var nY = (pHo.hoY + oldLayerDy) - newLayerDy + nDeltaY - pLayer.dy;

		                    if ((pHo.hoOEFlags & CObjectCommon.OEFLAG_MOVEMENTS) == 0) {
		                        pHo.hoX = nX;
		                        pHo.hoY = nY;
		                    } else {
		                        pHo.rom.rmMovement.setXPosition(nX);
		                        pHo.rom.rmMovement.setYPosition(nY);
		                    }

		                    //this allows objects to do weird stuff with their positions. seems to be only used in CRunControl (as those fake stuff with html gadgets)
		                    pHo.forcePosition();
		                }
		            }
		        }
		    }
		},

		doScroll: function ()
		{
			if ((this.rh3Scrolling & CRun.RH3SCROLLING_SCROLL) != 0)
			{
				this.rh3Scrolling = 0;

				//if (this.rhFrame.leX != this.rh3DisplayX || this.rhFrame.leY != this.rh3DisplayY)
				//{
				//	this.scrollLayers();
				//	this.updateWindowPos(this.rhFrame.leX, this.rhFrame.leY);
				//}

			    //check for update
				var update = this.rhFrame.leX != this.rh3DisplayX || this.rhFrame.leY != this.rh3DisplayY;
				if (!update) {
				    //are there any layers that trigger an update?
				    for (var index = 0; index < this.rhFrame.nLayers; index++) {
				        if (this.rhFrame.layers[index].dx != 0 || this.rhFrame.layers[index].dy != 0) {
				            update = true;
				            break;
				        }
				    }
				}

				if (update) {
				    this.scrollLayers();
				    this.updateWindowPos(this.rhFrame.leX, this.rhFrame.leY);

				    //reset all layer dx/dy
				    for (var index = 0; index < this.rhFrame.nLayers; index++) {
				        this.rhFrame.layers[index].dx = 0;
				        this.rhFrame.layers[index].dy = 0;
				    }
				}
			    //

				this.rh3DisplayX = this.rhWindowX;
				this.rh3DisplayY = this.rhWindowY;
			}
		},

		activeToBackdrop: function (pHo, colType)
		{
			var pLayer = this.rhFrame.layers[pHo.hoLayer];
			var image = this.rhApp.imageBank.getImageFromHandle(pHo.roc.rcImage);
			var bi = new CBackInstance(this.rhApp, pHo.hoX - this.rhWindowX + pLayer.x, pHo.hoY - this.rhWindowY + pLayer.y, null, image, colType);
			bi.setEffect(pHo.ros.rsEffect, pHo.ros.rsEffectParam);
			bi.addInstance(0, pLayer);

			if (colType == COC.OBSTACLE_SOLID || colType == COC.OBSTACLE_PLATFORM)
			{
				if (this.rh4Box2DBase != null)
				{
					bi.body = this.rh4Box2DBase.rAddABackdrop(pHo.hoX - this.rhWindowX + pLayer.x, pHo.hoY - this.rhWindowY + pLayer.y, pHo.roc.rcImage, colType);
				}
			}

			var bWrapHorz = ((pLayer.dwOptions & CLayer.FLOPT_WRAP_HORZ) != 0);
			var bWrapVert = ((pLayer.dwOptions & CLayer.FLOPT_WRAP_VERT) != 0);
			if (bWrapHorz)
			{
				bi = new CBackInstance(this.rhApp, this.rhFrame.leWidth + pHo.hoX - this.rhWindowX + pLayer.x, pHo.hoY - this.rhWindowY + pLayer.y, null, image, colType);
				bi.setEffect(pHo.ros.rsEffect, pHo.ros.rsEffectParam);
				bi.addInstance(1, pLayer);
				if (pHo.hoX + bi.width > this.rhFrame.leWidth)
				{
					bi = new CBackInstance(this.rhApp, pHo.hoX - this.rhWindowX + pLayer.x - this.rhFrame.leWidth, pHo.hoY - this.rhWindowY + pLayer.y, null, image, colType);
					bi.setEffect(pHo.ros.rsEffect, pHo.ros.rsEffectParam);
					bi.addInstance(4, pLayer);
				}
				if (bWrapVert)
				{
					bi = new CBackInstance(this.rhApp, pHo.hoX - this.rhWindowX + pLayer.x, this.rhFrame.leHeight + pHo.hoY - this.rhWindowY + pLayer.y, null, image, colType);
					bi.setEffect(pHo.ros.rsEffect, pHo.ros.rsEffectParam);
					bi.addInstance(2, pLayer);
					bi = new CBackInstance(this.rhApp, this.rhFrame.leWidth + pHo.hoX - this.rhWindowX + pLayer.x, this.rhFrame.leHeight + pHo.hoY - this.rhWindowY + pLayer.y, null, image, colType);
					bi.setEffect(pHo.ros.rsEffect, pHo.ros.rsEffectParam);
					bi.addInstance(3, pLayer);
					if (pHo.hoY + bi.height > this.rhFrame.leHeight)
					{
						bi = new CBackInstance(this.rhApp, pHo.hoX - this.rhWindowX + pLayer.x, pHo.hoY - this.rhWindowY + pLayer.y - this.rhFrame.leHeight, null, image, colType);
						bi.setEffect(pHo.ros.rsEffect, pHo.ros.rsEffectParam);
						bi.addInstance(5, pLayer);
					}
				}
			}
			else if (bWrapVert)
			{
				bi = new CBackInstance(this.rhApp, pHo.hoX - this.rhWindowX + pLayer.x, this.rhFrame.leHeight + pHo.hoY - this.rhWindowY + pLayer.y, null, image, colType);
				bi.setEffect(pHo.ros.rsEffect, pHo.ros.rsEffectParam);
				bi.addInstance(2, pLayer);
				if (pHo.hoY + bi.height > this.rhFrame.leHeight)
				{
					bi = new CBackInstance(this.rhApp, pHo.hoX - this.rhWindowX + pLayer.x, pHo.hoY - this.rhWindowY + pLayer.y - this.rhFrame.leHeight, null, image, colType);
					bi.setEffect(pHo.ros.rsEffect, pHo.ros.rsEffectParam);
					bi.addInstance(5, pLayer);
				}
			}
		},

		addBackdrop:        function (srceImage, x, y, layer, colType, addToWorld)
		{
			var pLayer = this.rhFrame.layers[layer];
			var bi = new CBackInstance(this.rhApp, x - this.rhWindowX + pLayer.x, y - this.rhWindowX + pLayer.y, null, srceImage, colType);
			bi.addInstance(0, pLayer);
			if (addToWorld)
			{
				if (colType == COC.OBSTACLE_SOLID || colType == COC.OBSTACLE_PLATFORM)
				{
					if (this.rh4Box2DBase != null)
					{
						bi.body = this.rh4Box2DBase.rAddABackdrop(pHo.hoX - this.rhWindowX + pLayer.x, pHo.hoY - this.rhWindowY + pLayer.y, pHo.roc.rcImage, colType);
					}
				}
			}

			var bWrapHorz = ((pLayer.dwOptions & CLayer.FLOPT_WRAP_HORZ) != 0);
			var bWrapVert = ((pLayer.dwOptions & CLayer.FLOPT_WRAP_VERT) != 0);

			// Wrap
			if (bWrapHorz)
			{
				bi = new CBackInstance(this.rhApp, this.rhFrame.leWidth + x - this.rhWindowX + pLayer.x, y - this.rhWindowY + pLayer.y, null, srceImage, colType);
				bi.addInstance(1, pLayer);
				if (x + bi.width > this.rhFrame.leWidth)
				{
					bi = new CBackInstance(this.rhApp, x - this.rhWindowX + pLayer.x - this.rhFrame.leWidth, y - this.rhWindowY + pLayer.y, null, srceImage, colType);
					bi.addInstance(4, pLayer);
				}
				if (bWrapVert)
				{
					bi = new CBackInstance(this.rhApp, x - this.rhWindowX + pLayer.x, this.rhFrame.leHeight + y - this.rhWindowY + pLayer.y, null, srceImage, colType);
					bi.addInstance(2, pLayer);
					bi = new CBackInstance(this.rhApp, this.rhFrame.leWidth + x - this.rhWindowX + pLayer.x, this.rhFrame.leHeight + y - this.rhWindowY + pLayer.y, null, srceImage, colType);
					bi.addInstance(3, pLayer);
					if (y + bi.height > this.rhFrame.leHeight)
					{
						bi = new CBackInstance(this.rhApp, x - this.rhWindowX + pLayer.x, y - this.rhWindowY + pLayer.y - this.rhFrame.leHeight, null, srceImage, colType);
						bi.addInstance(5, pLayer);
					}
				}
			}
			else if (bWrapVert)
			{
				bi = new CBackInstance(this.rhApp, x - this.rhWindowX + pLayer.x, this.rhFrame.leHeight + y - this.rhWindowY + pLayer.y, null, srceImage, colType);
				bi.addInstance(2, pLayer);
				if (y + bi.height > this.rhFrame.leHeight)
				{
					bi = new CBackInstance(this.rhApp, x - this.rhWindowX + pLayer.x, y - this.rhWindowY + pLayer.y - this.rhFrame.leHeight, null, srceImage, colType);
					bi.addInstance(5, pLayer);
				}
			}

		},
		deleteAllBackdrop2: function (layer)
		{
			if (layer < 0 || layer >= this.rhFrame.nLayers)
			{
				return;
			}
			var pLayer = this.rhFrame.layers[layer];
			pLayer.deleteAddedBackdrops();
		},
		deleteBackdropAt:   function (layer, xx, yy, fine)
		{
			if (layer < 0 || layer >= this.rhFrame.nLayers)
			{
				return;
			}
			var pLayer = this.rhFrame.layers[layer];
			pLayer.deleteAddedBackdropsAt(xx - this.rhWindowX, yy - this.rhWindowY, fine);
		},

		getStorage: function (id)
		{
			if (this.rhApp.extensionStorage != null)
			{
				var n;
				for (n = 0; n < this.rhApp.extensionStorage.size(); n++)
				{
					var e = this.rhApp.extensionStorage.get(n);
					if (e.id == id)
					{
						return e;
					}
				}
			}
			return null;
		},

		delStorage: function (id)
		{
			if (this.rhApp.extensionStorage != null)
			{
				var n;
				for (n = 0; n < this.rhApp.extensionStorage.size(); n++)
				{
					var e = this.rhApp.extensionStorage.get(n);
					if (e.id == id)
					{
						this.rhApp.extensionStorage.removeIndex(n);
					}
				}
			}
		},

		addStorage: function (data, id)
		{
			var e = this.getStorage(id);
			if (e == null)
			{
				if (this.rhApp.extensionStorage == null)
				{
					this.rhApp.extensionStorage = new CArrayList();
				}
				data.id = id;
				this.rhApp.extensionStorage.add(data);
			}
		},

		getXMouse: function ()
		{
			if (this.rhMouseUsed != 0)
				return 0;
			return this.rh2MouseX;
		},

		getYMouse: function ()
		{
			if (this.rhMouseUsed != 0)
				return 0;
			return this.rh2MouseY;
		},

		onMouseWheel: function (delta)
		{
			this.rhWheelCount = this.rh4EventCount;
			if (delta < 0)
				this.rhEvtProg.handle_GlobalEvents(((-12 << 16) | 0xFFFA));		// CNDL_ONMOUSEHWEELDOWN
			else
				this.rhEvtProg.handle_GlobalEvents(((-11 << 16) | 0xFFFA));		// CNDL_ONMOUSEHWEELUP
		},

		findFirstObject:function(name)
		{
			var n, explore;
			if (this.rhNObjects != 0)
			{
				for (n = 0; n < this.rhMaxObjects; n++)
				{
					explore = this.rhObjectList[n];
					if (explore && explore.hoOiList.oilName == name)
					{
						this.findObjectCount = explore.hoOiList.oilNObjects - 1;
						return explore;
					}
				}
			}
			return null;
		},

		findNextObject:function(object)
		{
			if (object && this.findObjectCount)
			{
				var n = object.hoNumber + 1;
				var name = object.hoOiList.oilName;
				var explore;
				while(true)
				{
					explore = this.rhObjectList[n];
					if (explore != null && explore.hoOiList.oilName == name)
					{
						this.findObjectCount--;
						return explore;
					}
					n++;
				}
			}
			this.findObjectCount = 0;
			return null;
		}

	}

	// CCreateObjectInfo object
	// --------------------------------------------------------------
	CCreateObjectInfo.COF_HIDDEN = 0x0002;
	function CCreateObjectInfo()
	{
		this.cobLevObj = null;
		this.cobLevObjSeg = 0;
		this.cobFlags = 0;
		this.cobX = 0;
		this.cobY = 0;
		this.cobDir = 0;
		this.cobLayer = 0;
		this.cobZOrder = 0;
	}

	// CObjInfo object
	// ---------------------------------------------------------------
	CObjInfo.OILIMITFLAGS_BORDERS = 0x000F;
	CObjInfo.OILIMITFLAGS_BACKDROPS = 0x0010;
	CObjInfo.OILIMITFLAGS_ONCOLLIDE = 0x0080;
	CObjInfo.OILIMITFLAGS_QUICKCOL = 0x0100;
	CObjInfo.OILIMITFLAGS_QUICKBACK = 0x0200;
	CObjInfo.OILIMITFLAGS_QUICKBORDER = 0x0400;
	CObjInfo.OILIMITFLAGS_QUICKSPR = 0x0800;
	CObjInfo.OILIMITFLAGS_QUICKEXT = 0x1000;
	CObjInfo.OILIMITFLAGS_ALL = 0xFFFF;
	function CObjInfo()
	{
		this.oilOi = 0;
		this.oilListSelected = 0;
		this.oilType = 0;
		this.oilObject = 0;
		this.oilEvents = 0;
		this.oilWrap = 0;
		this.oilNextFlag = false;
		this.oilNObjects = 0;
		this.oilActionCount = 0;
		this.oilActionLoopCount = 0;
		this.oilCurrentRoutine = 0;
		this.oilCurrentOi = 0;
		this.oilNext = 0;
		this.oilEventCount = 0;
		this.oilNumOfSelected = 0;
		this.oilOEFlags = 0;
		this.oilLimitFlags = 0;
		this.oilLimitList = 0;
		this.oilOIFlags = 0;
		this.oilOCFlags2 = 0;
		this.oilInkEffect = 0;
		this.oilEffectParam = 0;
		this.oilHFII = 0;
		this.oilBackColor = 0;
		this.oilQualifiers = null;
		this.oilName = null;
		this.oilEventCountOR = 0;
		this.oilColList = null;
	}
	CObjInfo.prototype =
	{
		copyData: function (oiPtr)
		{
			this.oilOi = oiPtr.oiHandle;
			this.oilType = oiPtr.oiType;

			this.oilOIFlags = oiPtr.oiFlags;
			var ocPtr = oiPtr.oiOC;
			this.oilOCFlags2 = ocPtr.ocFlags2;
			this.oilInkEffect = oiPtr.oiInkEffect;
			this.oilEffectParam = oiPtr.oiInkEffectParam;
			this.oilOEFlags = ocPtr.ocOEFlags;
			this.oilBackColor = ocPtr.ocBackColor;
			this.oilEventCount = 0;
			this.oilObject = -1;
			this.oilLimitFlags = CObjInfo.OILIMITFLAGS_ALL;
			if (oiPtr.oiName != null)
			{
				this.oilName = oiPtr.oiName;
			}
			var q;
			this.oilQualifiers = new Array(8);
			for (q = 0; q < 8; q++)
				this.oilQualifiers[q] = ocPtr.ocQualifiers[q];
		}
	}

	// Global object saving classes
	// ----------------------------------------------------------
	function CSaveGlobal()
	{
		this.name = null;
		this.objects = null;
	}
	function CSaveGlobalCounter()
	{
		this.value = null;
		this.rsMini = 0;
		this.rsMaxi = 0;
		this.rsMiniDouble = 0;
		this.rsMaxiDouble = 0;
	}
	function CSaveGlobalText()
	{
		this.text = null;
		this.rsMini = 0;
	}
	function CSaveGlobalValues()
	{
		this.values = null;
		this.strings = null;
		this.flags = 0;
	}

	// CRunMBase
	// ----------------------------------------------------------------------
	CRunMBase.MTYPE_OBJECT = 0;
	CRunMBase.MTYPE_ELEMENT = 1;
	CRunMBase.MTYPE_PARTICULE = 2;
	CRunMBase.MTYPE_FAKEOBJECT = 3;
	CRunMBase.MTYPE_BORDERLEFT = 4;
	CRunMBase.MTYPE_BORDERRIGHT = 5;
	CRunMBase.MTYPE_BORDERTOP = 6;
	CRunMBase.MTYPE_BORDERBOTTOM = 7;
	CRunMBase.MTYPE_OBSTACLE = 8;
	CRunMBase.MTYPE_PLATFORM = 9;
	CRunMBase.MSUBTYPE_OBJECT = 0;
	CRunMBase.MSUBTYPE_BOTTOM = 1;
	CRunMBase.MSUBTYPE_TOP = 2;
	CRunMBase.MSUBTYPE_LEFT = 3;
	CRunMBase.MSUBTYPE_RIGHT = 4;
	CRunMBase.ANGLE_MAGIC = 123456789;
	function CRunMBase()
	{
		this.m_type = 0;
		this.m_subType = CRunMBase.MSUBTYPE_OBJECT;
		this.m_identifier = 0;
		this.m_stopFlag = false;
		this.m_pHo = null;
		this.m_body = null;
		this.m_currentAngle = 0;
		this.m_eventCount = 0;
		this.m_collidingObject = null;
		this.ho = null;
		this.rh = null;
		this.rc = new CRect();
		this.m_addVX = 0;
		this.m_addVY = 0;
		this.m_addVFlag = false;
		this.m_setVX = 0;
		this.m_setVY = 0;
		this.m_setVFlag = false;
		this.m_image = -1;
		this.m_background = false;
	}
	CRunMBase.prototype =
	{
		InitBase:           function (pHo, type)
		{
			this.m_pHo = pHo;
			this.m_type = type;
			this.m_stopFlag = false;
			m_currentAngle = 0;
		},
		AddVelocity:        function (vx, vy)
		{
			this.m_addVX = vx;
			this.m_addVY = vy;
			this.m_addVFlag = true;
		},
		SetVelocity:        function (vx, vy)
		{
			var angle = this.m_body.GetAngle();
			var position = this.m_body.GetPosition();
			position.x += vx / 2.56;
			position.y += vy / 2.56;
			this.m_base.rBodySetTransform(this.m_body, position, angle);
		},
		ResetAddVelocity:   function ()
		{
			if (this.m_addVFlag)
			{
				this.m_addVFlag = false;
				this.m_addVX = 0;
				this.m_addVY = 0;
			}
			if (this.m_setVFlag)
			{
				this.m_setVFlag = false;
				this.m_setVX = 0;
				this.m_setVY = 0;
			}
		},
		PrepareCondition:   function ()
		{
			this.m_stopFlag = false;
			this.m_eventCount = this.m_pHo.hoAdRunHeader.rh4EventCount;
		},
		IsStop:             function ()
		{
			return this.m_stopFlag;
		},
		SetStopFlag:        function (flag)
		{
			this.m_stopFlag = flag;
		},
		SetCollidingObject: function (object)
		{
			this.m_collidingObject = object;
		},
		CreateBody:         function ()
		{
			return false;
		},
		CreateJoint:        function ()
		{
		},
		SetFriction:        function (friction)
		{
		},
		SetRestitution:     function (restitution)
		{
		},
		SetGravity:         function (gravity)
		{
		},
		SetDensity:         function (density)
		{
		},
		init:               function (hoPtr)
		{
			this.ho = hoPtr;
			this.rh = this.ho.hoAdRunHeader;
		},

		initialize: function (file)
		{
		},

		kill: function ()
		{
		},

		move: function ()
		{
			return false;
		},

		setPosition: function (x, y)
		{
		},

		setXPosition: function (x)
		{
		},

		setYPosition: function (y)
		{
		},

		stop: function (bCurrent)
		{
		},

		bounce: function (bCurrent)
		{
		},

		reverse: function ()
		{
		},

		start: function ()
		{
		},

		setSpeed: function (speed)
		{
		},

		setMaxSpeed: function (speed)
		{
		},

		setDir: function (dir)
		{
		},

		setAcc: function (acc)
		{
		},

		setDec: function (dec)
		{
		},

		setRotSpeed: function (speed)
		{
		},

		set8Dirs: function (dirs)
		{
		},

		setGravity: function (gravity)
		{
		},

		extension: function (func, param)
		{
			return 0;
		},

		actionEntry: function (action)
		{
			return 0;
		},

		getSpeed: function ()
		{
			return 0;
		},

		getAcceleration: function ()
		{
			return 0;
		},

		getDeceleration: function ()
		{
			return 0;
		},

		getGravity: function ()
		{
			return 0;
		},

		dirAtStart: function (dir)
		{
			return this.ho.rom.dirAtStart(this.ho, dir, 32);
		},

		animations: function (anm)
		{
			this.ho.roc.rcAnim = anm;
			if (this.ho.roa != null)
			{
				this.ho.roa.animate();
			}
		},

		collisions: function ()
		{
			this.ho.hoAdRunHeader.rh3CollisionCount++;
			this.ho.rom.rmMovement.rmCollisionCount = this.ho.hoAdRunHeader.rh3CollisionCount;
			this.ho.hoAdRunHeader.newHandle_Collisions(this.ho);
		},

		approachObject: function (destX, destY, originX, originY, htFoot, planCol, ptDest)
		{
			destX -= this.ho.hoAdRunHeader.rhWindowX;
			destY -= this.ho.hoAdRunHeader.rhWindowY;
			originX -= this.ho.hoAdRunHeader.rhWindowX;
			originY -= this.ho.hoAdRunHeader.rhWindowY;
			var bRet = this.ho.rom.rmMovement.mpApproachSprite(destX, destY, originX, originY, htFoot, planCol, ptDest);
			ptDest.x += this.ho.hoAdRunHeader.rhWindowX;
			ptDest.y += this.ho.hoAdRunHeader.rhWindowY;
			return bRet;
		},

		moveIt: function ()
		{
			return this.ho.rom.rmMovement.newMake_Move(this.ho.roc.rcSpeed, this.hoPtr.hoAdRunHeader.getDir(this.hoPtr));
		},

		testPosition: function (x, y, htFoot, planCol, flag)
		{
			return this.ho.rom.rmMovement.tst_SpritePosition(x, y, htFoot, planCol, flag);
		},

		getJoystick: function (player)
		{
			return this.ho.hoAdRunHeader.rhPlayer[player];
		},

		colMaskTestRect: function (x, y, sx, sy, layer, plan)
		{
			return !this.ho.hoAdRunHeader.colMask_Test_Rect(x, y, sx, sy, layer, plan);
		},

		colMaskTestPoint: function (x, y, layer, plan)
		{
			return !this.ho.hoAdRunHeader.colMask_Test_XY(x, y, layer, plan);
		},

		getParamDouble: function ()
		{
			return this.ho.rom.rmMovement.callParam;
		},

		getParam: function ()
		{
			return this.ho.rom.rmMovement.callParam;
		},

		getAngle: function ()
		{
			return 0;
		},

		setAngle: function (angle)
		{
		}


	}

	// CAnim object
	// -----------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CAnim.ANIMID_STOP = 0;
	CAnim.ANIMID_WALK = 1;
	CAnim.ANIMID_RUN = 2;
	CAnim.ANIMID_APPEAR = 3;
	CAnim.ANIMID_DISAPPEAR = 4;
	CAnim.ANIMID_BOUNCE = 5;
	CAnim.ANIMID_SHOOT = 6;
	CAnim.ANIMID_JUMP = 7;
	CAnim.ANIMID_FALL = 8;
	CAnim.ANIMID_CLIMB = 9;
	CAnim.ANIMID_CROUCH = 10;
	CAnim.ANIMID_UNCROUCH = 11;
	CAnim.ANIMID_USER1 = 12;
	CAnim.tableAnimTwoSpeeds =
		[
			0,
			1,
			1,
			0,
			0,
			1,
			0,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1,
			1
		];
	function CAnim()
	{
		this.anDirs = null;
		this.anTrigo = null;
		this.anAntiTrigo = null;
	}
	CAnim.prototype =
	{
		load:         function (file)
		{
			var debut = file.getFilePointer();

			var offsets = new Array(32);
			var n;
			for (n = 0; n < 32; n++)
			{
				offsets[n] = file.readAShort();
			}

			this.anDirs = new Array(32);
			this.anTrigo = new Array(32);
			this.anAntiTrigo = new Array(32);
			for (n = 0; n < 32; n++)
			{
				this.anDirs[n] = null;
				this.anTrigo[n] = 0;
				this.anAntiTrigo[n] = 0;
				if (offsets[n] != 0)
				{
					this.anDirs[n] = new CAnimDir();
					file.seek(debut + offsets[n]);
					this.anDirs[n].load(file);
				}
			}
		},
		enumElements: function (enumImages)
		{
			var n;
			for (n = 0; n < 32; n++)
			{
				if (this.anDirs[n] != null)
				{
					this.anDirs[n].enumElements(enumImages);
				}
			}
		},
		approximate:  function (nAnim)
		{
			var d, d2, d3;
			var cpt1, cpt2;

			for (d = 0; d < 32; d++)
			{
				if (this.anDirs[d] == null)
				{
					for (d2 = 0, cpt1 = d + 1; d2 < 32; d2++, cpt1++)
					{
						cpt1 = cpt1 & 0x1F;
						if (this.anDirs[cpt1] != null)
						{
							this.anTrigo[d] = cpt1;
							break;
						}
					}
					for (d3 = 0, cpt2 = d - 1; d3 < 32; d3++, cpt2--)
					{
						cpt2 = cpt2 & 0x1F;
						if (this.anDirs[cpt2] != null)
						{
							this.anAntiTrigo[d] = cpt2;
							break;
						}
					}
					if (cpt1 == cpt2 || d2 < d3)
					{
						this.anTrigo[d] |= 0x40;
					}
					else if (d3 < d2)
					{
						this.anAntiTrigo[d] |= 0x40;
					}
				}
				else
				{
					if (nAnim < 16)
					{
						if (CAnim.tableAnimTwoSpeeds[nAnim] == 0)
						{
							this.anDirs[d].adMinSpeed = this.anDirs[d].adMaxSpeed;
						}
					}
				}
			}
		}
	}


	// CAnimHeader object
	// -----------------------------------------------------------------
	CAnimHeader.tableApprox =
		[
			CAnim.ANIMID_APPEAR, CAnim.ANIMID_WALK, CAnim.ANIMID_RUN, 0,		// 0  ANIMID_STOP
			CAnim.ANIMID_RUN, CAnim.ANIMID_STOP, 0, 0,                           // 1  ANIMID_WALK
			CAnim.ANIMID_WALK, CAnim.ANIMID_STOP, 0, 0,                          // 2  ANIMID_RUN
			CAnim.ANIMID_STOP, CAnim.ANIMID_WALK, CAnim.ANIMID_RUN, 0,		// 3  ANIMID_APPEAR
			CAnim.ANIMID_STOP, 0, 0, 0,                                          // 4  ANIMID_DISAPPEAR
			CAnim.ANIMID_STOP, CAnim.ANIMID_WALK, CAnim.ANIMID_RUN, 0,		// 5  ANIMID_BOUNCE
			CAnim.ANIMID_STOP, CAnim.ANIMID_WALK, CAnim.ANIMID_RUN, 0,		// 6  ANIMID_SHOOT
			CAnim.ANIMID_WALK, CAnim.ANIMID_RUN, CAnim.ANIMID_STOP, 0,		// 7  ANIMID_JUMP
			CAnim.ANIMID_STOP, CAnim.ANIMID_WALK, CAnim.ANIMID_RUN, 0,		// 8  ANIMID_FALL
			CAnim.ANIMID_WALK, CAnim.ANIMID_RUN, CAnim.ANIMID_STOP, 0,		// 9  ANIMID_CLIMB
			CAnim.ANIMID_STOP, CAnim.ANIMID_WALK, CAnim.ANIMID_RUN, 0,		// 10 ANIMID_CROUCH
			CAnim.ANIMID_STOP, CAnim.ANIMID_WALK, CAnim.ANIMID_RUN, 0,		// 11 ANIMID_UNCROUCH
			0, 0, 0, 0,
			0, 0, 0, 0,
			0, 0, 0, 0,
			0, 0, 0, 0
		];
	function CAnimHeader()
	{
		this.ahAnimMax = 0;
		this.ahAnims = null;
		this.ahAnimExists = null;
	}
	CAnimHeader.prototype =
	{
		load: function (file)
		{
			var debut = file.getFilePointer();

			file.skipBytes(2);          // ahSize
			this.ahAnimMax = file.readAShort();

			var offsets = new Array(this.ahAnimMax);
			var n;
			for (n = 0; n < this.ahAnimMax; n++)
			{
				offsets[n] = file.readAShort();
			}

			this.ahAnims = new Array(this.ahAnimMax);
			this.ahAnimExists = new Array(this.ahAnimMax);
			for (n = 0; n < this.ahAnimMax; n++)
			{
				this.ahAnims[n] = null;
				this.ahAnimExists[n] = 0;
				if (offsets[n] != 0)
				{
					this.ahAnims[n] = new CAnim();
					file.seek(debut + offsets[n]);
					this.ahAnims[n].load(file);
					this.ahAnimExists[n] = 1;
				}
			}
			var cptAnim;
			for (cptAnim = 0; cptAnim < this.ahAnimMax; cptAnim++)
			{
				if (this.ahAnimExists[cptAnim] == 0)
				{
					var bFlag = false;
					if (cptAnim < 12)
					{
						for (n = 0; n < 4; n++)
						{
							var a = this.ahAnimExists[CAnimHeader.tableApprox[cptAnim * 4 + n]];
							if (a != 0)
							{
								this.ahAnims[cptAnim] = this.ahAnims[CAnimHeader.tableApprox[cptAnim * 4 + n]];
								bFlag = true;
								break;
							}
						}
					}
					if (bFlag == false)
					{
						for (n = 0; n < this.ahAnimMax; n++)
						{
							if (this.ahAnimExists[n] != 0)
							{
								this.ahAnims[cptAnim] = this.ahAnims[n];
								break;
							}
						}
					}
				}
				else
				{
					this.ahAnims[cptAnim].approximate(cptAnim);
				}
			}
		},

		enumElements: function (enumImages)
		{
			var n;
			for (n = 0; n < this.ahAnimMax; n++)
			{
				if (this.ahAnimExists[n] != 0)
				{
					this.ahAnims[n].enumElements(enumImages);
				}
			}
		}
	}

	// CAnimDir object
	// -----------------------------------------------------------------
	function CAnimDir()
	{
		this.adMinSpeed = 0;
		this.adMaxSpeed = 0;
		this.adRepeat = 0;
		this.adRepeatFrame = 0;
		this.adNumberOfFrame = 0;
		this.adFrames = null;
	}
	CAnimDir.prototype =
	{
		load:         function (file)
		{
			this.adMinSpeed = file.readAByte();
			this.adMaxSpeed = file.readAByte();
			this.adRepeat = file.readAShort();
			this.adRepeatFrame = file.readAShort();
			this.adNumberOfFrame = file.readAShort();

			this.adFrames = new Array(this.adNumberOfFrame);
			var n;
			for (n = 0; n < this.adNumberOfFrame; n++)
			{
				this.adFrames[n] = file.readAShort();
			}
		},
		enumElements: function (enumImages)
		{
			var n;
			for (n = 0; n < this.adNumberOfFrame; n++)
			{
				if (enumImages != null)
				{
					var num = enumImages.enumerate(this.adFrames[n]);
					if (num != -1)
					{
						this.adFrames[n] = num;
					}
				}
			}
		}
	}

	// CRAni object
	// -----------------------------------------------------------------
	CRAni.anim_Defined =
		[
			CAnim.ANIMID_STOP,
			CAnim.ANIMID_WALK,
			CAnim.ANIMID_RUN,
			CAnim.ANIMID_BOUNCE,
			CAnim.ANIMID_SHOOT,
			CAnim.ANIMID_JUMP,
			CAnim.ANIMID_FALL,
			CAnim.ANIMID_CLIMB,
			CAnim.ANIMID_CROUCH,
			CAnim.ANIMID_UNCROUCH,
			12,
			13,
			14,
			15,
			-1
		];
	function CRAni()
	{
		this.hoPtr = null;
		this.raAnimForced = 0;				// Flags if forced
		this.raAnimDirForced = 0;
		this.raAnimSpeedForced = 0;
		this.raAnimStopped = false;
		this.raAnimOn = 0;				// Current animation
		this.raAnimOffset = null;
		this.raAnimDir = 0;				// Direction of current animation
		this.raAnimPreviousDir = 0;                       // Previous OK direction
		this.raAnimDirOffset = null;
		this.raAnimSpeed = 0;
		this.raAnimMinSpeed = 0;                          // Minimum speed of movement
		this.raAnimMaxSpeed = 0;                          // Maximum speed of movement
		this.raAnimDeltaSpeed = 0;
		this.raAnimCounter = 0;                           // Animation speed counter
		this.raAnimDelta = 0;				// Speed counter
		this.raAnimRepeat = 0;				// Number of repeats
		this.raAnimRepeatLoop = 0;			// Looping picture
		this.raAnimFrame = 0;				// Current frame
		this.raAnimNumberOfFrame = 0;                     // Number of frames
		this.raAnimFrameForced = 0;
		this.raRoutineAnimation = 0;
		this.raOldAngle = -1;
	}
	CRAni.prototype =
	{
		init: function (ho)
		{
			this.hoPtr = ho;

			this.raRoutineAnimation = 0;
			this.init_Animation(CAnim.ANIMID_WALK);

			if (this.anim_Exist(CAnim.ANIMID_APPEAR))
			{
				this.raRoutineAnimation = 1;
				this.animation_Force(CAnim.ANIMID_APPEAR);
				this.animation_OneLoop();
				this.animations();
			}
			else
			{
				var i;
				for (i = 0; CRAni.anim_Defined[i] >= 0; i++)
				{
					if (this.anim_Exist(CRAni.anim_Defined[i]))
						break;
				}
				if (CRAni.anim_Defined[i] < 0)
				{
					if (this.anim_Exist(CAnim.ANIMID_DISAPPEAR))
					{
						this.raRoutineAnimation = 2;
						this.animation_Force(CAnim.ANIMID_DISAPPEAR);
						this.animation_OneLoop();
						this.animations();
					}
				}
			}
		},

		init_Animation: function (anim)
		{
			this.hoPtr.roc.rcAnim = anim;
			this.raAnimStopped = false;
			this.raAnimForced = 0;
			this.raAnimDirForced = 0;
			this.raAnimSpeedForced = 0;
			this.raAnimFrameForced = 0;
			this.raAnimCounter = 0;
			this.raAnimFrame = 0;
			this.raAnimOffset = null;
			this.raAnimDirOffset = null;
			this.raAnimOn = -1;
			this.raAnimMinSpeed = -1;
			this.raAnimPreviousDir = -1;
			this.raAnimOffset = null;
			this.raAnimDirOffset = null;
			this.animations();
		},

		check_Animate: function ()
		{
			this.animIn(0);
		},

		extAnimations: function (anim)
		{
			this.hoPtr.roc.rcAnim = anim;
			this.animate();
		},

		animate: function ()
		{
			switch (this.raRoutineAnimation)
			{
				case 0:
					return this.animations();
				case 1:
					this.anim_Appear();
					return false;
				case 2:
					this.anim_Disappear();
					return false;
			}
			return false;
		},

		animations: function ()
		{
			var x = this.hoPtr.hoX;
			this.hoPtr.roc.rcOldX = x;
			x -= this.hoPtr.hoImgXSpot;
			this.hoPtr.roc.rcOldX1 = x;
			x += this.hoPtr.hoImgWidth;
			this.hoPtr.roc.rcOldX2 = x;

			var y = this.hoPtr.hoY;
			this.hoPtr.roc.rcOldY = y;
			y -= this.hoPtr.hoImgYSpot;
			this.hoPtr.roc.rcOldY1 = y;
			y += this.hoPtr.hoImgHeight;
			this.hoPtr.roc.rcOldY2 = y;

			this.hoPtr.roc.rcOldImage = this.hoPtr.roc.rcImage;
			this.hoPtr.roc.rcOldAngle = this.hoPtr.roc.rcAngle;

			return this.animIn(1);
		},

		animIn: function (vbl)
		{
			var ocPtr = this.hoPtr.hoCommon;

			var speed = this.hoPtr.roc.rcSpeed;
			var anim = this.hoPtr.roc.rcAnim;

			if (this.raAnimSpeedForced != 0)
			{
				speed = this.raAnimSpeedForced - 1;
			}
			if (anim == CAnim.ANIMID_WALK)
			{
				if (speed == 0)
				{
					anim = CAnim.ANIMID_STOP;
				}
				if (speed >= 75)
				{
					anim = CAnim.ANIMID_RUN;
				}
			}
			if (this.raAnimForced != 0)
			{
				anim = this.raAnimForced - 1;
			}
			if (anim != this.raAnimOn)
			{
				this.raAnimOn = anim;
				if (anim >= ocPtr.ocAnimations.ahAnimMax)
				{
					anim = ocPtr.ocAnimations.ahAnimMax - 1;
				}
				var anPtr = ocPtr.ocAnimations.ahAnims[anim];
				if (anPtr != this.raAnimOffset)
				{
					this.raAnimOffset = anPtr;
					this.raAnimDir = -1;
					this.raAnimFrame = 0;
					if ((this.hoPtr.hoOEFlags & CObjectCommon.OEFLAG_DONTRESETANIMCOUNTER) == 0)		// Added for bug http://bugbox.clickteam.com/issues/3421, triggered by fix below...
					    this.raAnimCounter = 0;		// Build 284.11, report from Android, fixes bug http://bugbox.clickteam.com/issues/1882
	            }
			}

			var ifo;
			var image = 0;
			var frame = 0;
			var rhPtr = this.hoPtr.hoAdRunHeader;
			var dir = this.hoPtr.roc.rcDir % 32;
			var bAngle = false;

			if (this.raAnimDirForced != 0)
			{
				dir = this.raAnimDirForced - 1;
			}
			var adPtr;
			if (this.raAnimDir != dir)
			{
				this.raAnimDir = dir;

				adPtr = this.raAnimOffset.anDirs[dir];
				if (adPtr == null)
				{
					if ((this.raAnimOffset.anAntiTrigo[dir] & 0x40) != 0)
					{
						dir = this.raAnimOffset.anAntiTrigo[dir] & 0x3F;
					}
					else if ((this.raAnimOffset.anTrigo[dir] & 0x40) != 0)
					{
						dir = this.raAnimOffset.anTrigo[dir] & 0x3F;
					}
					else
					{
						var offset = dir;
						if (this.raAnimPreviousDir < 0)
						{
							dir = this.raAnimOffset.anTrigo[dir] & 0x3F;
							;
						}
						else
						{
							dir -= this.raAnimPreviousDir;
							dir &= 31;
							if (dir > 15)
							{
								dir = this.raAnimOffset.anTrigo[offset] & 0x3F;
								;
							}
							else
							{
								dir = this.raAnimOffset.anAntiTrigo[offset] & 0x3F;
							}
						}
					}
					adPtr = this.raAnimOffset.anDirs[dir];
				}
				else
				{
					this.raAnimPreviousDir = dir;
					adPtr = this.raAnimOffset.anDirs[dir];
				}

				if (this.raAnimOffset.anDirs[0] != null && (this.hoPtr.hoCommon.ocFlags2 & CObjectCommon.OCFLAGS2_AUTOMATICROTATION) != 0)
				{
					this.hoPtr.roc.rcAngle = (this.raAnimDir * 360) / 32;
					adPtr = this.raAnimOffset.anDirs[0];
					this.raAnimDirOffset = null;
					bAngle = true;
				}

				if (this.raAnimDirOffset != adPtr)
				{
					this.raAnimDirOffset = adPtr;
					this.raAnimRepeat = adPtr.adRepeat;
					this.raAnimRepeatLoop = adPtr.adRepeatFrame;

					var minSpeed = adPtr.adMinSpeed;
					var maxSpeed = adPtr.adMaxSpeed;

					if (minSpeed != this.raAnimMinSpeed || maxSpeed != this.raAnimMaxSpeed)
					{
						this.raAnimMinSpeed = minSpeed;
						this.raAnimMaxSpeed = maxSpeed;
						maxSpeed -= minSpeed;
						this.raAnimDeltaSpeed = maxSpeed;
						this.raAnimDelta = minSpeed;
						this.raAnimSpeed = -1;
					}

					this.raAnimNumberOfFrame = adPtr.adNumberOfFrame;
					if (this.raAnimFrameForced != 0 && this.raAnimFrameForced - 1 >= this.raAnimNumberOfFrame)
						this.raAnimFrameForced = 0;
					if (this.raAnimFrame >= this.raAnimNumberOfFrame)
						this.raAnimFrame = 0;
					image = adPtr.adFrames[this.raAnimFrame];
					if (this.raAnimStopped == false)
					{
						this.hoPtr.roc.rcImage = image;
						ifo = this.hoPtr.hoAdRunHeader.rhApp.imageBank.getImageInfoEx(image, this.hoPtr.roc.rcAngle, this.hoPtr.roc.rcScaleX, this.hoPtr.roc.rcScaleY);
						if (ifo != null)
						{
							this.hoPtr.hoImgWidth = ifo.width;
							this.hoPtr.hoImgHeight = ifo.height;
							this.hoPtr.hoImgXSpot = ifo.xSpot;
							this.hoPtr.hoImgYSpot = ifo.ySpot;
							this.hoPtr.hoImgXAP = ifo.xAP;
							this.hoPtr.hoImgYAP = ifo.yAP; 
						}
						this.hoPtr.roc.rcChanged = true;
						this.hoPtr.roc.rcCheckCollides = true;
					}
					if (this.raAnimNumberOfFrame == 1)
					{
						if (this.raAnimMinSpeed == 0)
						{
							this.raAnimNumberOfFrame = 0;
						}
						image = this.hoPtr.roc.rcImage;
						if (image == 0)
						{
							return false;
						}
						ifo = this.hoPtr.hoAdRunHeader.rhApp.imageBank.getImageInfoEx(image, this.hoPtr.roc.rcAngle, this.hoPtr.roc.rcScaleX, this.hoPtr.roc.rcScaleY);
						if (ifo != null)
						{
							this.hoPtr.hoImgWidth = ifo.width;
							this.hoPtr.hoImgHeight = ifo.height;
							this.hoPtr.hoImgXSpot = ifo.xSpot;
							this.hoPtr.hoImgYSpot = ifo.ySpot;
							this.hoPtr.hoImgXAP = ifo.xAP;
							this.hoPtr.hoImgYAP = ifo.yAP; 
						}
						return false;
					}
				}
			}

			if (vbl == 0 && this.raAnimFrameForced == 0)
			{
				return false;
			}
			if (bAngle == false && this.raAnimNumberOfFrame == 0)
			{
				return false;
			}

			var delta = this.raAnimDeltaSpeed;
			if (speed != this.raAnimSpeed)
			{
				this.raAnimSpeed = speed;

				if (delta == 0)
				{
					this.raAnimDelta = this.raAnimMinSpeed;
					if (this.raAnimSpeedForced != 0)
						this.raAnimDelta = this.raAnimSpeedForced - 1;
				}
				else
				{
					var deltaSpeed = this.hoPtr.roc.rcMaxSpeed - this.hoPtr.roc.rcMinSpeed;
					if (deltaSpeed == 0)
					{
						if (this.raAnimSpeedForced != 0)
						{
							delta *= speed;
							delta /= 100;
							delta += this.raAnimMinSpeed;
							if (delta > this.raAnimMaxSpeed)
								delta = this.raAnimMaxSpeed;
							this.raAnimDelta = delta;
						}
						else
						{
							delta /= 2;
							delta += this.raAnimMinSpeed;
							this.raAnimDelta = delta;
						}
					}
					else
					{
						delta *= speed;
						delta /= deltaSpeed;
						delta += this.raAnimMinSpeed;
						if (delta > this.raAnimMaxSpeed)
							delta = this.raAnimMaxSpeed;
						this.raAnimDelta = delta;
					}
				}
			}

			adPtr = this.raAnimDirOffset;
			frame = this.raAnimFrameForced;
			var counter;
			if (frame == 0)
			{
				if (this.raAnimDelta == 0 || this.raAnimStopped)
				{
					return false;
				}

				counter = this.raAnimCounter;
				frame = this.raAnimFrame;
				var aDelta = this.raAnimDelta;
				if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
					aDelta = Math.round(aDelta * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef);
				counter += aDelta;
				while (counter > 100)
				{
					counter -= 100;
					frame++;
					if (frame >= this.raAnimNumberOfFrame)
					{
						frame = this.raAnimRepeatLoop;
						if (this.raAnimRepeat != 0)
						{
							this.raAnimRepeat--;
							if (this.raAnimRepeat == 0)
							{
								this.raAnimFrame = this.raAnimNumberOfFrame-1;
								this.raAnimNumberOfFrame = 0;
								if (this.raAnimForced != 0)
								{
									this.raAnimForced = 0;
									this.raAnimDirForced = 0;
									this.raAnimSpeedForced = 0;
								}

								if ( this.raAnimFrame < adPtr.adNumberOfFrame )
								{
									image = adPtr.adFrames[this.raAnimFrame];
									if ( image != this.hoPtr.roc.rcImage )
									{
										this.hoPtr.roc.rcImage = image;
										this.hoPtr.roc.rcChanged = true;
										this.hoPtr.roc.rcCheckCollides = true;
									}
								}
								this.raAnimCounter = counter;

								if ((this.hoPtr.hoAdRunHeader.rhGameFlags & CRun.GAMEFLAGS_INITIALISING) != 0)
									return false;
								if (bAngle)
								{
									this.hoPtr.roc.rcChanged = true;
									this.hoPtr.roc.rcCheckCollides = true;
									ifo = this.hoPtr.hoAdRunHeader.rhApp.imageBank.getImageInfoEx(this.hoPtr.roc.rcImage, this.hoPtr.roc.rcAngle, this.hoPtr.roc.rcScaleX, this.hoPtr.roc.rcScaleY);
									if (ifo != null)
									{
										this.hoPtr.hoImgWidth = ifo.width;
										this.hoPtr.hoImgHeight = ifo.height;
										this.hoPtr.hoImgXSpot = ifo.xSpot;
										this.hoPtr.hoImgYSpot = ifo.ySpot;
										this.hoPtr.hoImgXAP = ifo.xAP;
										this.hoPtr.hoImgYAP = ifo.yAP; 
									}
								}
								var cond = (-2 << 16);	    // CNDL_EXTANIMENDOF;
								cond |= (this.hoPtr.hoType & 0xFFFF);
								this.hoPtr.hoAdRunHeader.rhEvtProg.rhCurParam0 = this.hoPtr.roa.raAnimOn;
								return this.hoPtr.hoAdRunHeader.rhEvtProg.handle_Event(this.hoPtr, cond);
							}
						}
					}
				}
				this.raAnimCounter = counter;
			}
			else
			{
				frame--;
			}
			this.raAnimFrame = frame;
			this.hoPtr.roc.rcChanged = true;
			this.hoPtr.roc.rcCheckCollides = true;
			image = adPtr.adFrames[frame];
			if (this.hoPtr.roc.rcImage != image || this.raOldAngle != this.hoPtr.roc.rcAngle)
			{
				this.hoPtr.roc.rcImage = image;
				this.raOldAngle = this.hoPtr.roc.rcAngle;
				if (image >= 0)
				{
					ifo = this.hoPtr.hoAdRunHeader.rhApp.imageBank.getImageInfoEx(image, this.hoPtr.roc.rcAngle, this.hoPtr.roc.rcScaleX, this.hoPtr.roc.rcScaleY);
					if (ifo != null)
					{
						this.hoPtr.hoImgWidth = ifo.width;
						this.hoPtr.hoImgHeight = ifo.height;
						this.hoPtr.hoImgXSpot = ifo.xSpot;
						this.hoPtr.hoImgYSpot = ifo.ySpot;
						this.hoPtr.hoImgXAP = ifo.xAP;
						this.hoPtr.hoImgYAP = ifo.yAP; 
					}
				}
			}
			return false;
		},

		anim_Exist: function (animId)
		{
			var ahPtr = this.hoPtr.hoCommon.ocAnimations;
			if (ahPtr.ahAnimExists[animId] == 0)
				return false;
			return true;
		},

		animation_OneLoop: function ()
		{
			if (this.raAnimRepeat == 0)
			{
				this.raAnimRepeat = 1;
			}
		},

		animation_Force: function (anim)
		{
			this.raAnimForced = anim + 1;
			this.animIn(0);
		},

		animation_Restore: function ()
		{
			this.raAnimForced = 0;
			this.animIn(0);
		},

		animDir_Force: function (dir)
		{
			dir &= 31;
			this.raAnimDirForced = dir + 1;
			this.animIn(0);
		},

		animDir_Restore: function ()
		{
			this.raAnimDirForced = 0;
			this.animIn(0);
		},

		animSpeed_Force: function (speed)
		{
			if (speed < 0) speed = 0;
			if (speed > 100) speed = 100;
			this.raAnimSpeedForced = speed + 1;
			this.animIn(0);
		},

		animSpeed_Restore: function ()
		{
			this.raAnimSpeedForced = 0;
			this.animIn(0);
		},

		anim_Restart: function ()
		{
			this.raAnimOn = -1;
			this.animIn(0);
		},

		animFrame_Force: function (frame)
		{
			if (frame >= this.raAnimNumberOfFrame)
				frame = this.raAnimNumberOfFrame - 1;
			if (frame < 0)
				frame = 0;
			this.raAnimFrameForced = frame + 1;
			this.animIn(0);
		},

		animFrame_Restore: function ()
		{
			this.raAnimFrameForced = 0;
			this.animIn(0);
		},

		anim_Appear: function ()
		{
			this.animIn(1);

			if (this.raAnimForced != CAnim.ANIMID_APPEAR + 1)
			{
				if (this.anim_Exist(CAnim.ANIMID_STOP) || this.anim_Exist(CAnim.ANIMID_WALK) || this.anim_Exist(CAnim.ANIMID_RUN))
				{
					this.raRoutineAnimation = 0;
					this.animation_Restore();
				}
				else
				{
					this.raRoutineAnimation = 2;
					this.hoPtr.hoAdRunHeader.init_Disappear(this.hoPtr);
				}
			}
		},

		anim_Disappear: function ()
		{
			if ((this.hoPtr.hoFlags & CObject.HOF_FADEOUT) == 0)
			{
				this.animIn(1);									// Un cran d'animations
				if (this.raAnimForced != CAnim.ANIMID_DISAPPEAR + 1)
				{
					this.hoPtr.hoAdRunHeader.destroy_Add(this.hoPtr.hoNumber);
				}
			}
		}
	}	// CImageBank object
	// -----------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */

	function CMosaic(bank, h)
	{
		this.imageBank = bank;
		this.app = bank.app;
		this.handle = h;
	}
	CMosaic.prototype =
	{
		doLoad: function ()
		{
			var name = this.app.resources + "M" + CServices.formatDiscName(this.handle, "png");
			var image = new Image();
			this.imageBank.mosaics[this.handle] = image;
			var that = this;
			image.onload = function ()
			{
				that.app.dataHasLoaded(that);
			}
			image.onerror = function ()
			{
				that.app.dataHasLoaded(that);
			}
			image.src = name;
		}
	}
	function CImageBank(a)
	{
		this.app = a;
		this.file = null;
		this.images = null;
		this.nHandlesReel = 0;
		this.nHandlesTotal = 0;
		this.nImages = 0;
		this.offsetsToImage = null;
		this.handleToIndex = null;
		this.useCount = null;
		this.rcInfo = null;
		this.hsInfo = null;
		this.apInfo = null;
		this.pIfo = null;
		this.mosaics = null;
		this.oldMosaics = null;
		this.mosaicLoaded = null;
	}
	CImageBank.prototype =
	{
		preLoad:            function (f)
		{
			this.file = f;

			this.nHandlesReel = this.file.readAShort();
			this.offsetsToImage = new Array(this.nHandlesReel);

			var nImg = this.file.readAShort();
			var n;
			var offset;
			var image = new CImage();
			for (n = 0; n < nImg; n++)
			{
				offset = this.file.getFilePointer();
				image.loadHandle(this.file);
				this.offsetsToImage[image.handle] = offset;
			}

			this.useCount = new Array(this.nHandlesReel);
			var n;
			for (n = 0; n < this.nHandlesReel; n++)
				this.useCount[n] = 0;

			this.handleToIndex = null;
			this.nHandlesTotal = this.nHandlesReel;
			this.nImages = 0;
			this.images = null;
		},
		getImageFromHandle: function (handle)
		{
			if (handle >= 0 && handle < this.nHandlesTotal)
				if (this.handleToIndex[handle] != -1)
					return this.images[this.handleToIndex[handle]];
			return null;
		},
		getImageFromIndex:  function (index)
		{
			if (index >= 0 && index < this.nImages)
				return this.images[index];
			return null;
		},
		setAllToLoad:       function ()
		{
			var n;
			for (n = 0; n < this.nHandlesReel; n++)
			{
				if (this.offsetsToImage[n])
					this.useCount[n] = 1;
			}
		},
		resetToLoad:        function ()
		{
			if ((this.app.dwOptions & CRunApp.AH2OPT_LOADDATAATSTART) == 0 && (this.app.dwOptions & CRunApp.AH2OPT_KEEPRESOURCESBETWEENFRAMES) == 0)
			{
				var n;
				for (n = 0; n < this.nHandlesReel; n++)
				{
					this.useCount[n] = 0;
				}
			}
			this.oldMosaics = null;
		},
		setToLoad:          function (handle)
		{
			this.useCount[handle]++;
		},

		enumerate: function (num)
		{
			this.setToLoad(num);
			return -1;
		},

		loadMosaic: function (handle)
		{
			if (this.mosaics[handle] == null)
			{
				if (this.oldMosaics != null && handle < this.oldMosaics.length && this.oldMosaics[handle] != null)
				{
					this.mosaics[handle] = this.oldMosaics[handle];
				}
				else
				{
					this.mosaics[handle] = new CMosaic(this, handle);
					this.app.addDataToLoad(this.mosaics[handle]);
				}
			}
		},

		load: function (file)
		{
			var n;

			// Reset mosaics
			if (this.app.mosaicMaxHandle > 0)
			{
				if (this.mosaics == null)
				{
					this.mosaics = new Array(this.app.mosaicMaxHandle);
					if (this.app.dwOptions & CRunApp.AH2OPT_LOADDATAATSTART)
					{
						for (n = 0; n < this.app.mosaicMaxHandle; n++)
						{
							if (this.app.mosaics[n])
								this.loadMosaic(n);
						}
					}
				}
				else
				{
					if ((this.app.dwOptions & CRunApp.AH2OPT_LOADDATAATSTART) == 0)
					{
						this.oldMosaics = new Array(this.app.mosaicMaxHandle);
						for (n = 0; n < this.app.mosaicMaxHandle; n++)
							this.oldMosaics[n] = this.mosaics[n];

						this.mosaics = new Array(this.app.mosaicMaxHandle);
						for (n = 0; n < this.app.mosaicMaxHandle; n++)
							this.mosaics[n] = null;
					}
				}
			}

			this.nImages = 0;
			for (n = 0; n < this.nHandlesReel; n++)
			{
				if (this.useCount[n] != 0)
					this.nImages++;
			}

			var newImages = new Array(this.nImages);
			var count = 0;
			var h;
			for (h = 0; h < this.nHandlesReel; h++)
			{
				if (this.useCount[h] != 0)
				{
					if (this.images != null && this.handleToIndex[h] != -1 && this.images[this.handleToIndex[h]] != null)
					{
						newImages[count] = this.images[this.handleToIndex[h]];
						newImages[count].useCount = this.useCount[h];
						if (this.mosaics != null && this.oldMosaics != null)
						{
							var handle = newImages[count].mosaic;
							if (handle > 0)
								this.mosaics[handle] = this.oldMosaics[handle];
						}
					}
					else
					{
						if (this.offsetsToImage[h] != 0)
						{
							newImages[count] = new CImage();
							file.seek(this.offsetsToImage[h]);
							newImages[count].load(this.app);
							newImages[count].useCount = this.useCount[h];
						}
					}
					count++;
				}
				/*          else
				 {
				 }
				 */
			}
			this.images = newImages;

			this.handleToIndex = new Array(this.nHandlesReel);
			for (n = 0; n < this.nHandlesReel; n++)
			{
				this.handleToIndex[n] = -1;
			}
			for (n = 0; n < this.nImages; n++)
			{
				if (this.images[n])
				{
					this.handleToIndex[this.images[n].handle] = n;
				}
			}
			this.nHandlesTotal = this.nHandlesReel;
		},

		delImage:      function (handle)
		{
			var img = this.getImageFromHandle(handle);
			if (img != null)
			{
				img.useCount--;
				if (img.useCount <= 0)
				{
					var n;
					for (n = 0; n < this.nImages; n++)
					{
						if (this.images[n] == img)
						{
							this.images[n] = null;
							this.handleToIndex[handle] = -1;
							break;
						}
					}
				}
			}
		},
		/*
		 addImageCompare:function(newImage, xSpot, ySpot, xAP, yAP)
		 {
		 var i;
		 var width=newImage.width;
		 var height=newImage.height;
		 for (i=0; ithis.<nImages; i++)
		 {
		 if (this.images[i]!=null)
		 {
		 if (this.images[i].xSpot==xSpot && this.images[i].ySpot==ySpot && this.images[i].xAP==xAP && this.images[i].yAP==yAP)
		 {
		 if (width==this.images[i].img.width && height==this.images[i].img.height)
		 {
		 // Prend les pixels de la nouvelle image
		 if (newPixels==null)
		 {
		 var newRect:Rectangle=new Rectangle(0, 0, width, height);
		 newPixels=newImage.getPixels(newRect);
		 }

		 // Prend les pixels de l'image de la banque
		 var oldRect:Rectangle=new Rectangle(0, 0, width, height);
		 var oldPixels:ByteArray=images[i].img.getPixels(oldRect);

		 // Comparaison
		 var bEqual:Boolean=true;
		 var x:int, y:int;
		 for (y=0; y<height; y++)
		 {
		 for (x=0; x<width; x++)
		 {
		 if (newPixels[y*width+x]!=oldPixels[y*width+x])
		 {
		 bEqual=false;
		 break;
		 }
		 }
		 if (bEqual==false)
		 {
		 break;
		 }
		 }

		 // Image trouvee
		 if (bEqual)
		 {
		 images[i].useCount++;
		 return images[i].handle;
		 }
		 }
		 }
		 }
		 }
		 return addImage(newImage, xSpot, ySpot, xAP, yAP, 1);
		 },
		 */
		addImage:      function (image)
		{
			var h;

			// Cherche un handle libre
			var hFound = -1;
			for (h = this.nHandlesReel; h < this.nHandlesTotal; h++)
			{
				if (this.handleToIndex[h] == -1)
				{
					hFound = h;
					break;
				}
			}

			// Rajouter un handle
			if (hFound == -1)
			{
				this.handleToIndex.push(0);
				hFound = this.nHandlesTotal++;
			}

			// Cherche une image libre
			var i;
			var iFound = -1;
			for (i = 0; i < this.nImages; i++)
			{
				if (this.images[i] == null)
				{
					iFound = i;
					break;
				}
			}

			// Rajouter une image?
			if (iFound == -1)
			{
				this.images.push(0);
				iFound = this.nImages++;
			}

			// Ajoute la nouvelle image
			this.handleToIndex[hFound] = iFound;
			this.images[iFound] = image;
			this.useCount[hFound] = 1;

			return hFound;
		},
		loadImageList: function (handles)
		{
			var h;

			for (h = 0; h < handles.length; h++)
			{
				if (handles[h] >= 0 && handles[h] < this.nHandlesTotal)
				{
					if (this.offsetsToImage[handles[h]] != 0)
					{
						if (this.getImageFromHandle(handles[h]) == null)
						{
							var i;
							var iFound = -1;
							for (i = 0; i < this.nImages; i++)
							{
								if (this.images[i] == null)
								{
									iFound = i;
									break;
								}
							}
							if (iFound == -1)
							{
								var newImages = new Array(this.nImages + 10);
								for (i = 0; i < this.nImages; i++)
								{
									newImages[i] = this.images[i];
								}
								for (; i < this.nImages + 10; i++)
								{
									newImages[i] = null;
								}
								iFound = this.nImages;
								this.nImages += 10;
								this.images = newImages;
							}
							this.handleToIndex[handles[h]] = iFound;
							this.images[iFound] = new CImage();
							this.images[iFound].useCount = 1;
							this.file.seek(this.offsetsToImage[handles[h]]);
							this.images[iFound].load(this.app);
						}
					}
				}
			}
		},

		getImageInfoEx: function (nImage, nAngle, fScaleX, fScaleY)
		{
			var ptei;
			if (this.pIfo == null)
			{
				this.pIfo = new CImage();
			}

			ptei = this.getImageFromHandle(nImage);
			if (ptei != null)
			{
				var cx = ptei.width;
				var cy = ptei.height;
				var hsx = ptei.xSpot;
				var hsy = ptei.ySpot;
				var asx = ptei.xAP;
				var asy = ptei.yAP;

				if (nAngle == 0)
				{
					if (fScaleX != 1.0)
					{
						hsx = hsx * fScaleX;
						asx = asx * fScaleX;
						cx = cx * fScaleX;
					}

					if (fScaleY != 1.0)
					{
						hsy = hsy * fScaleY;
						asy = asy * fScaleY;
						cy = cy * fScaleY;
					}
				}
				else
				{
					if (fScaleX != 1.0)
					{
						hsx = hsx * fScaleX;
						asx = asx * fScaleX;
						cx = cx * fScaleX;
					}

					if (fScaleY != 1.0)
					{
						hsy = hsy * fScaleY;
						asy = asy * fScaleY;
						cy = cy * fScaleY;
					}

					if (this.rcInfo == null)
					{
						this.rcInfo = new CRect();
					}
					if (this.hsInfo == null)
					{
						this.hsInfo = new CPoint();
					}
					if (this.apInfo == null)
					{
						this.apInfo = new CPoint();
					}
					this.hsInfo.x = hsx;
					this.hsInfo.y = hsy;
					this.apInfo.x = asx;
					this.apInfo.y = asy;
					this.rcInfo.left = this.rcInfo.top = 0;
					this.rcInfo.right = cx;
					this.rcInfo.bottom = cy;
					this.doRotateRect(this.rcInfo, this.hsInfo, this.apInfo, nAngle);
					cx = this.rcInfo.right;
					cy = this.rcInfo.bottom;
					hsx = this.hsInfo.x;
					hsy = this.hsInfo.y;
					asx = this.apInfo.x;
					asy = this.apInfo.y;
				}
				this.pIfo.width = cx;
				this.pIfo.height = cy;
				this.pIfo.xSpot = hsx;
				this.pIfo.ySpot = hsy;
				this.pIfo.xAP = asx;
				this.pIfo.yAP = asy;

				return this.pIfo;
			}
			return ptei;
		},

		doRotateRect: function (prc, pHotSpot, pActionPoint, fAngle)
		{
			var x, y;
			var cosa, sina;

			if (fAngle == 90.0)
			{
				cosa = 0.0;
				sina = 1.0;
			}
			else if (fAngle == 180.0)
			{
				cosa = -1.0;
				sina = 0.0;
			}
			else if (fAngle == 270.0)
			{
				cosa = 0.0;
				sina = -1.0;
			}
			else
			{
				var arad = fAngle * Math.PI / 180.0;
				cosa = Math.cos(arad);
				sina = Math.sin(arad);
			}

			var topLeftX;
			var topLeftY;

			var nhxcos;
			var nhxsin;
			var nhycos;
			var nhysin;
			if (pHotSpot == null)
			{
				nhxcos = nhxsin = nhycos = nhysin = 0.0;
				topLeftX = topLeftY = 0;
			}
			else
			{
				nhxcos = -pHotSpot.x * cosa;
				nhxsin = -pHotSpot.x * sina;
				nhycos = -pHotSpot.y * cosa;
				nhysin = -pHotSpot.y * sina;
				topLeftX = nhxcos + nhysin;
				topLeftY = nhycos - nhxsin;
			}

			var topRightX;
			var topRightY;

			if (pHotSpot == null)
				x = prc.right;
			else
				x = prc.right - pHotSpot.x;
			nhxcos = x * cosa;
			nhxsin = x * sina;
			topRightX = nhxcos + nhysin;
			topRightY = nhycos - nhxsin;

			var bottomRightX
			var bottomRightY;

			if (pHotSpot == null)
				y = prc.bottom;
			else
				y = prc.bottom - pHotSpot.y;
			nhycos = y * cosa;
			nhysin = y * sina;
			bottomRightX = nhxcos + nhysin;
			bottomRightY = nhycos - nhxsin;

			var bottomLeftX;
			var bottomLeftY;
			bottomLeftX = topLeftX + bottomRightX - topRightX;
			bottomLeftY = topLeftY + bottomRightY - topRightY;

			var xmin = Math.min(topLeftX, Math.min(topRightX, Math.min(bottomRightX, bottomLeftX)));
			var ymin = Math.min(topLeftY, Math.min(topRightY, Math.min(bottomRightY, bottomLeftY)));
			var xmax = Math.max(topLeftX, Math.max(topRightX, Math.max(bottomRightX, bottomLeftX)));
			var ymax = Math.max(topLeftY, Math.max(topRightY, Math.max(bottomRightY, bottomLeftY)));

			if (pActionPoint != null)
			{
				if (pHotSpot == null)
				{
					x = pActionPoint.x;
					y = pActionPoint.y;
				}
				else
				{
					x = pActionPoint.x - pHotSpot.x;
					y = pActionPoint.y - pHotSpot.y;
				}
				pActionPoint.x = (x * cosa + y * sina) - xmin;
				pActionPoint.y = (y * cosa - x * sina) - ymin;
			}

			if (pHotSpot != null)
			{
				pHotSpot.x = -xmin;
				pHotSpot.y = -ymin;
			}

			prc.right = xmax - xmin;
			prc.bottom = ymax - ymin;
		}
	}

	// CImage Object
	// ----------------------------------------------------------------------------
	CImage.maxRotatedMasks = 10;
	function CImage()
	{
		this.app = null;
		this.handle = 0;
		this.width = 0;
		this.height = 0;
		this.xSpot = 0;
		this.ySpot = 0;
		this.xAP = 0;
		this.yAP = 0;
		this.useCount = 0;
		this.img = null;
		this.maskNormal = null;
		this.maskPlatform = null;
		this.maskRotation = null;
		this.filePointer = null;
		this.mosaic = 0;
		this.mosaicX = 0;
		this.mosaicY = 0;
		this.texID = -1;
		this.texCoords = null;
	}
	CImage.createFromFile = function (application, fileName)
	{
		var image = new CImage();
		image.app = application;
		image.img = new Image();
		image.img.onload = function ()
		{
			image.app.imagesLoaded++;
			image.width = image.img.width;
			image.height = image.img.height;
		}
		application.imagesToLoad++;
		application.loading = true;
		image.img.src = application.resources + fileName;
		return image;
	}
	CImage.prototype =
	{
		loadHandle:    function (file)
		{
			this.filePointer = file.getFilePointer();
			this.handle = file.readAShort();
			file.skipBytes(12);
		},
		doLoad:        function ()
		{
			this.img = new Image();
			var that = this;
			this.img.onload = function ()
			{
				that.app.dataHasLoaded(that);
			}
			this.img.onerror = function ()
			{
				that.app.dataHasLoaded(that);
			}
			var name = this.app.resources + CServices.formatDiscName(this.handle, "png");
			this.img.src = name;
		},
		load:          function (a)
		{
			this.app = a;
			this.filePointer = a.file.getFilePointer();

			this.handle = a.file.readAShort();
			this.width = a.file.readAShort();
			this.height = a.file.readAShort();
			this.xSpot = a.file.readShort();
			this.ySpot = a.file.readShort();
			this.xAP = a.file.readShort();
			this.yAP = a.file.readShort();
			this.mosaic = 0;
			this.img = null;
			if (this.app.frame.mosaicHandles != null)
			{
				this.mosaic = this.app.frame.mosaicHandles[this.handle];
				if (this.mosaic != 0)
				{
					this.app.imageBank.loadMosaic(this.mosaic);
					this.mosaicX = this.app.frame.mosaicX[this.handle];
					this.mosaicY = this.app.frame.mosaicY[this.handle];
				}
				else
				{
					this.app.addDataToLoad(this);
				}
			}
			else
				this.app.addDataToLoad(this);
		},
		createElement: function ()
		{
			var e = document.createElement('div');

			e.style.width = this.width + 'px';
			e.style.height = this.height + 'px';

			e.style.backgroundRepeat = 'no-repeat';

			if (this.mosaic == 0)
			{
				e.style.backgroundImage = "url('" + this.img.src + "')";
			}
			else
			{
				e.style.backgroundPosition = '-' + this.mosaicX + 'px -' + this.mosaicY + 'px';
				e.style.backgroundImage = "url('" + this.app.resources + "M" + CServices.formatDiscName(this.mosaic, "png") + "')";
			}

			return e;
		},
		getPixel:      function (x, y)
		{
			var canvas = document.createElement("canvas");
			canvas.width = this.width;
			canvas.height = this.height;
			var context = canvas.getContext("2d");
			if (this.mosaic == 0)
			{
				context.drawImage(this.img, 0, 0);
			}
			else
			{
				context.drawImage(this.app.imageBank.mosaics[this.mosaic],
					this.mosaicX, this.mosaicY,
					this.width, this.height, 0, 0,
					this.width, this.height);
			}
			var imgd = context.getImageData(x, y, 1, 1);
			return (imgd.data[0] << 16) | (imgd.data[1] << 8) | imgd.data[2];
		},
		getMask:       function (flags, angle, scaleX, scaleY)
		{
			if ((flags & CMask.GCMF_PLATFORM) == 0)
			{
				if (this.maskNormal == null)
				{
					this.maskNormal = new CMask();
					this.maskNormal.createMask(this.app, this, flags);
				}
				if (angle == 0 && scaleX == 1.0 && scaleY == 1.0)
				{
					return this.maskNormal;
				}

				var rMask;
				if (this.maskRotation == null)
				{
					this.maskRotation = new CArrayList();
				}
				var n;
				var tick = 0x7FFFFFFF;
				var nOldest = -1;
				for (n = 0; n < this.maskRotation.size(); n++)
				{
					rMask = this.maskRotation.get(n);
					if (angle == rMask.angle && scaleX == rMask.scaleX && scaleY == rMask.scaleY)
					{
						return rMask.mask;
					}
					if (rMask.tick < tick)
					{
						tick = rMask.tick;
						nOldest = n;
					}
				}
				if (this.maskRotation.size() < this.maxRotatedMasks)
				{
					nOldest = -1;
				}
				rMask = new CRotatedMask();
				rMask.mask = new CMask();
				rMask.mask.createRotatedMask(this.maskNormal, angle, scaleX, scaleY);
				rMask.angle = angle;
				rMask.scaleX = scaleX;
				rMask.scaleY = scaleY;
				rMask.tick = this.app.timer;
				if (nOldest < 0)
				{
					this.maskRotation.add(rMask);
				}
				else
				{
					this.maskRotation.set(nOldest, rMask);
				}
				return rMask.mask;
			}
			else
			{
				if (this.maskPlatform == null)
				{
					if (this.maskNormal == null)
					{
						this.maskNormal = new CMask();
						this.maskNormal.createMask(this.app, this, 0);
					}
					this.maskPlatform = new CMask();
					this.maskPlatform.createMask(this.app, this, flags);
				}
				return this.maskPlatform;
			}
		}
	}

	// CFontBank object
	// -----------------------------------------------------------------
	function CFontBank(a)
	{
		this.app = a;
		this.file = null;
		this.fonts = null;
		this.offsetsToFonts = null;
		this.nFonts = 0;
		this.handleToIndex = null;
		this.maxHandlesReel = 0;
		this.maxHandlesTotal = 0;
		this.useCount = null;
		this.nullFont = new CFont();
		this.nullFont.createDefaultFont();
	}
	CFontBank.prototype =
	{
		preLoad: function (file)
		{
			var number = file.readAInt();
			var n;

			this.maxHandlesReel = 0;
			var debut = file.getFilePointer();
			var temp = new CFont();
			for (n = 0; n < number; n++)
			{
				temp.loadHandle(file);
				this.maxHandlesReel = Math.max(this.maxHandlesReel, temp.handle + 1);
			}
			file.seek(debut);
			this.offsetsToFonts = new Array(this.maxHandlesReel);
			for (n = 0; n < number; n++)
			{
				debut = file.getFilePointer();
				temp.loadHandle(file);
				this.offsetsToFonts[temp.handle] = debut;
			}
			this.useCount = new Array(this.maxHandlesReel);
			var n;
			for (n = 0; n < this.maxHandlesReel; n++)
				this.useCount[n] = 0;
			this.handleToIndex = null;
			this.maxHandlesTotal = this.maxHandlesReel;
			this.nFonts = 0;
			this.fonts = null;
		},

		load: function (file)
		{
			var n;
			this.nFonts = 0;
			for (n = 0; n < this.maxHandlesReel; n++)
			{
				if (this.useCount[n] != 0)
				{
					this.nFonts++;
				}
			}

			var newFonts = new Array(this.nFonts);
			var count = 0;
			var h;
			for (h = 0; h < this.maxHandlesReel; h++)
			{
				if (this.useCount[h] != 0)
				{
					if (this.fonts != null && this.handleToIndex[h] != -1 && this.fonts[this.handleToIndex[h]] != null)
					{
						newFonts[count] = this.fonts[this.handleToIndex[h]];
						newFonts[count].useCount = this.useCount[h];
					}
					else
					{
						newFonts[count] = new CFont();
						file.seek(this.offsetsToFonts[h]);
						newFonts[count].load(file);
						newFonts[count].useCount = this.useCount[h];
					}
					count++;
				}
			}
			this.fonts = newFonts;

			this.handleToIndex = new Array(this.maxHandlesReel);
			for (n = 0; n < this.maxHandlesReel; n++)
			{
				this.handleToIndex[n] = -1;
			}
			for (n = 0; n < this.nFonts; n++)
			{
				this.handleToIndex[this.fonts[n].handle] = n;
			}
			this.maxHandlesTotal = this.maxHandlesReel;
		},

		getFontFromHandle: function (handle)
		{
			if (handle == -1)
			{
				return this.nullFont;
			}
			if (handle >= 0 && handle < this.maxHandlesTotal)
				if (this.handleToIndex[handle] != -1)
					return this.fonts[this.handleToIndex[handle]];
			return null;
		},

		getFontFromIndex: function (index)
		{
			if (index >= 0 && index < this.nFonts)
				return this.fonts[index];
			return null;
		},

		getFontInfoFromHandle: function (handle)
		{
			var font = this.getFontFromHandle(handle);
			return font.getFontInfo();
		},

		resetToLoad: function ()
		{
			if ((this.app.dwOption & CRunApp.AH2OPT_LOADDATAATSTART) == 0 && (this.app.dwOptions & CRunApp.AH2OPT_KEEPRESOURCESBETWEENFRAMES) == 0)
			{
				var n;
				for (n = 0; n < this.maxHandlesReel; n++)
				{
					this.useCount[n] = 0;
				}
			}
		},

		setAllToLoad: function ()
		{
			var n;
			for (n = 0; n < this.maxHandlesReel; n++)
			{
				if (this.offsetsToFonts[n])
					this.useCount[n] = 1;
			}
		},

		setToLoad: function (handle)
		{
			if (handle == -1)
			{
				if (this.nullFont == null)
				{
					this.nullFont = new CFont();
					this.nullFont.createDefaultFont();
				}
				return;
			}
			this.useCount[handle]++;
		},

		enumerate: function (num)
		{
			this.setToLoad(num);
			return -1;
		},

		addFont: function (info)
		{
			var h;

			// Cherche une fonte identique
			var n;
			for (n = 0; n < this.nFonts; n++)
			{
				if (this.fonts[n] == null) continue;
				if (this.fonts[n].lfHeight != info.lfHeight) continue;
				if (this.fonts[n].lfWeight != info.lfWeight) continue;
				if (this.fonts[n].lfItalic != info.lfItalic) continue;
				if (this.fonts[n].lfFaceName != info.lfFaceName) continue;
				break;
			}
			if (n < this.nFonts)
			{
				return this.fonts[n].handle;
			}

			var hFound = -1;
			for (h = this.maxHandlesReel; h < this.maxHandlesTotal; h++)
			{
				if (this.handleToIndex[h] == -1)
				{
					this.hFound = h;
					break;
				}
			}

			if (hFound == -1)
			{
				var newHToI = new Array(this.maxHandlesTotal + 10);
				for (h = 0; h < this.maxHandlesTotal; h++)
				{
					newHToI[h] = this.handleToIndex[h];
				}
				for (; h < this.maxHandlesTotal + 10; h++)
				{
					newHToI[h] = -1;
				}
				hFound = this.maxHandlesTotal;
				this.maxHandlesTotal += 10;
				this.handleToIndex = newHToI;
			}

			var f;
			var fFound = -1;
			for (f = 0; f < this.nFonts; f++)
			{
				if (this.fonts[f] == null)
				{
					fFound = f;
					break;
				}
			}

			if (fFound == -1)
			{
				fFound = this.nFonts;
				this.fonts.push(null);
			}

			this.handleToIndex[hFound] = fFound;
			this.fonts[fFound] = new CFont();
			this.fonts[fFound].handle = hFound;
			this.fonts[fFound].lfHeight = info.lfHeight;
			this.fonts[fFound].lfWeight = info.lfWeight;
			this.fonts[fFound].lfItalic = info.lfItalic;
			this.fonts[fFound].lfFaceName = info.lfFaceName;

			return hFound;
		}
	}

	// CFont object
	// ------------------------------------------------------
	function CFont()
	{
		this.useCount = 0;
		this.handle = 0;
		this.lfHeight = 0;
		this.lfWeight = 0;
		this.lfItalic = 0;
		this.lfFaceName = null;
		this.font = null;
		this.isGraphic = false;
	}
	CFont.prototype =
	{
		loadHandle: function (file)
		{
			this.handle = file.readAInt();
			if (file.bUnicode == false)
			{
				file.skipBytes(0x48);
			}
			else
			{
				file.skipBytes(0x68);
			}
		},

		load: function (file)
		{
			this.handle = file.readAInt();
			var debut = file.getFilePointer();
			file.skipBytes(12);

			this.lfHeight = file.readAInt();
			if (this.lfHeight < 0)
				this.lfHeight = -this.lfHeight;
			file.readAInt();
			file.readAInt();
			file.readAInt();
			this.lfWeight = file.readAInt();
			this.lfItalic = file.readAByte();
			file.readAByte();
			file.readAByte();
			file.readAByte();
			file.readAByte();
			file.readAByte();
			file.readAByte();
			file.readAByte();
			this.lfFaceName = file.readAString();

			if (file.bUnicode == false)
			{
				file.seek(debut + 0x48);
			}
			else
			{
				file.seek(debut + 0x68);
			}
		},

		getFontInfo: function ()
		{
			var info = new CFontInfo();
			info.lfHeight = this.lfHeight;
			info.lfWeight = this.lfWeight;
			info.lfItalic = this.lfItalic;
			info.lfFaceName = this.lfFaceName;
			return info;
		},

		createDefaultFont: function ()
		{
			this.lfFaceName = "Arial";
			this.lfHeight = 13;
			this.lfWeight = 400;
			this.lfItalic = 0;
		},

		getHeight: function ()
		{
		    return this.lfHeight + Math.ceil(this.lfHeight / 8);
		},

		getFont: function ()
		{
			if (this.font == null)
			{
				if (this.lfItalic)
					this.font = "italic ";
				else
					this.font = "normal "

				var weight = Math.floor(this.lfWeight / 100) * 100;
				weight = Math.max(weight, 100);
				weight = Math.min(weight, 900);
				this.font += weight + " ";

				var height = this.lfHeight; // CServices.heightNormalToLF(this.lfHeight);
				this.font += height + "px ";
				this.font += this.lfFaceName;
			}
			return this.font;
		}
	}

	// CSoundBank object
	// -----------------------------------------------------------------

	function CSoundBank(a)
	{
		this.app = a;
		this.sounds = null;
		this.nHandlesReel = 0;
		this.nHandlesTotal = 0;
		this.nSounds = 0;
		this.offsetsToSounds = null;
		this.handleToIndex = null;
		this.useCount = null;
		this.file = null;
		//  this.bChrome=navigator.userAgent.toLowerCase().indexOf('chrome') > -1;
	}
	CSoundBank.prototype =
	{
		preLoad: function (f)
		{
			this.file = f;

			this.nHandlesReel = this.file.readAShort();
			this.offsetsToSounds = new Array(this.nHandlesReel);
			this.useCount = new Array(this.nHandlesReel);
			this.handleToIndex = new Array(this.nHandlesReel);
			var n;
			for (n = 0; n < this.nHandlesReel; n++)
			{
				this.useCount[n] = 0;
				this.handleToIndex[n] = -1;
			}

			var nSons = this.file.readAShort();
			var n;
			var sound = new CSound(this.app);
			var offset;
			for (n = 0; n < nSons; n++)
			{
				offset = this.file.getFilePointer();
				sound.loadHandle();
				this.offsetsToSounds[sound.handle] = offset;
			}

			this.nHandlesTotal = this.nHandlesReel;
			this.nSounds = 0;
			this.sounds = null;
		},

		getSoundFromHandle: function (handle)
		{
			if (handle >= 0 && handle < this.nHandlesTotal)
				if (this.handleToIndex[handle] != -1)
					return this.sounds[this.handleToIndex[handle]];
			return null;
		},

		getSoundHandleFromName: function (soundName)
		{
		    for (var h = 0; h < this.nHandlesTotal; h++)
		    {
		        if (this.handleToIndex[h] != -1)
		        {
		            var snd = this.sounds[this.handleToIndex[h]];
		            if (snd.name == soundName)
		                return h;
		        }
		    }
		    return -1;
		},

		checkLoad:          function ()
		{
			var index;
			for (index = 0; index < this.nSounds; index++)
			{
				if (this.sounds[index] != null)
				{
					this.sounds[index].checkLoad();
				}
			}
		},
		getSoundFromIndex:  function (index)
		{
			if (index >= 0 && index < this.nSounds)
				return this.sounds[index];
			return null;
		},

		resetToLoad: function ()
		{
			if ((this.app.dwOptions & CRunApp.AH2OPT_LOADDATAATSTART) == 0 && (this.app.dwOptions & CRunApp.AH2OPT_KEEPRESOURCESBETWEENFRAMES) == 0)
			{
				var n;
				for (n = 0; n < this.nHandlesReel; n++)
					this.useCount[n] = 0;
			}
		},

		setAllToLoad: function ()
		{
			var n;
			for (n = 0; n < this.nHandlesReel; n++)
			{
				if (this.offsetsToSounds[n])
					this.useCount[n] = 1;
			}
		},

		addAllToLoad: function ()
		{
			var n;
			for (n = 0; n < this.nHandlesReel; n++)
			{
				if (this.offsetsToSounds[n])
				{
					this.app.imagesToLoad++;
				}
			}
		},

		setToLoad: function (handle)
		{
			this.useCount[handle]++;
		},

		enumerate: function (num)
		{
			this.setToLoad(num);
			return -1;
		},


		load: function ()
		{
			var n;

			this.nSounds = 0;
			for (n = 0; n < this.nHandlesReel; n++)
			{
				if (this.useCount[n] != 0)
					this.nSounds++;
			}

			var newSounds = new Array(this.nSounds);
			var count = 0;
			var h;
			for (h = 0; h < this.nHandlesReel; h++)
			{
				if (this.useCount[h] != 0)
				{
					if (this.sounds != null && this.handleToIndex[h] != -1 && this.sounds[this.handleToIndex[h]] != null)
					{
						newSounds[count] = this.sounds[this.handleToIndex[h]];
						newSounds[count].useCount = this.useCount[h];
					}
					else
					{
						newSounds[count] = new CSound(this.app);
						this.file.seek(this.offsetsToSounds[h]);
						newSounds[count].load();
						newSounds[count].useCount = this.useCount[h];
					}
					count++;
				}
			}
			this.sounds = newSounds;

			this.handleToIndex = new Array(this.nHandlesReel);
			for (n = 0; n < this.nHandlesReel; n++)
				this.handleToIndex[n] = -1;
			for (n = 0; n < this.nSounds; n++)
				this.handleToIndex[this.sounds[n].handle] = n;
			this.nHandlesTotal = this.nHandlesReel;

			this.resetToLoad();
		}
	}

	// CSound object
	// -----------------------------------------------------------------
	function CSound(a)
	{
		this.application = a;
		this.context = a.soundPlayer.context;
		this.contextType = a.soundPlayer.contextType;
		this.gainNode = a.soundPlayer.gainNode;
		this.type = 0;
		this.file = a.file;
		this.handle = -1;
		this.source = null;
		this.sound = null;
		this.useCount = 0;
		this.bUninterruptible = false;
		this.nLoops = 0;
		this.numSound = 0;
		this.name = null;
		this.bPaused = false;
		this.bAllowGlobalResume = false;
		this.bPlaying = false;
		this.frequency = 0;
		this.response = null;
	    this.gain = null;
	    this.volume = 100;
	}
	CSound.prototype =
	{
		loadHandle: function ()
		{
			this.handle = this.file.readAShort();
			this.file.skipBytes(5);
			var l = this.file.readAShort();
			if (this.file.bUnicode == false)
				this.file.skipBytes(l);
			else
				this.file.skipBytes(l * 2);
		},

		createFromSound: function ()
		{
			if (HTMLMediaElement.mozLoadFrom)
			{
				var snd = new CSound(this.application);
				snd.handle = this.handle;
				snd.sound = HTMLMediaElement.mozLoadFrom(this.sound);
				snd.name = this.name;
				snd.type = this.type;
				snd.song = this.song;
				snd.type = this.type;
				return snd;
			}
			return this;
		},

		doLoad:     function ()
		{
			var format;
			var playableFormats = this.application.soundPlayer.probablePlayableFormats & this.type;
			if (playableFormats == 0)
				playableFormats = this.application.soundPlayer.maybePlayableFormats & this.type;
			for (format = 0; format < 4; format++)
			{
				if (playableFormats & (1 << format))
				{
					break;
				}
			}
			if (format < 4)
			{
				var ext = "";
				switch (format)
				{
					case 0:
						ext = "ogg";
						break;
					case 1:
						ext = "m4a";
						break;
					case 2:
						ext = "mp3";
						break;
					case 3:
						ext = "wav"
						break;
				}

				if (this.context)
				{
					var that = this;
	                    
						var request = new XMLHttpRequest();
						request.open('GET', this.application.resources + CServices.formatDiscName(this.handle, ext), true);
						request.responseType = 'arraybuffer';
						request.addEventListener('load', function (event)
						{
							that.response = request.response;
							that.application.soundPlayer.addDataToDecode(that);
						});
						request.send();
				}
				else
				{
					this.sound = new Audio();
					this.sound.preload = "auto";

					var that = this;
					this.sound.addEventListener("loadeddata", function (e)
					{
						that.application.dataHasLoaded(that);
						that.sound.removeEventListener('loadeddata', arguments.callee, false);
					}, false);
					this.sound.addEventListener("error", function (e)
					{
						that.application.dataHasLoaded(that);
						that.sound = null;
					}, false);
					this.sound.src = this.application.resources + CServices.formatDiscName(this.handle, ext);
					this.sound.load();
					this.sound.autoplay = false;
				}
			}
			else
				this.application.dataHasLoaded(this);
		},
		load:       function ()
		{
			this.handle = this.file.readAShort();
			this.type = this.file.readAByte();
			this.frequency = this.file.readAInt();
			this.currentFrequency = this.frequency;
			var l = this.file.readAShort();
			this.name = this.file.readAString(l);
			this.sound = null;
			this.application.addDataToLoad(this);
		},
		loadSilent: function ()
		{
			this.handle = 9999;
			this.type = 0x04;
			this.frequency = 40000;
			this.currentFrequency = this.frequency;
			this.name = "";
			this.sound = null;
			this.application.addDataToLoad(this);
		},
		playIt:     function (time, frequency)
		{
			if (!time)
				time = 0;
			if (!frequency)
				frequency = this.frequency;
			if (this.sound)
			{
				this.sound.volume = (this.volume / 100.0);
				this.currentFrequency = frequency;
				this.sound.playbackRate = frequency / this.frequency;
				if (this.sound.duration)
					this.sound.currentTime = 0;
				this.sound.play();
			}
			else if (this.buffer)
			{
				this.source = this.context["createBufferSource"]();
				this.source["buffer"] = this.buffer;
				if (this.contextType == 0)
				{
					this.source["gain"]["value"] = (this.volume / 100.0);
					this.source["connect"](this.context["destination"]);
				}
				else
				{
					this.gain = this.context["createGain"]();
					this.source["connect"](this.gain);
					this.gain["connect"](this.context["destination"]);
					this.gain["gain"]["value"] = (this.volume / 100.0);
				}
				if (!time)
					time = 0;
				if (!frequency)
					frequency = this.frequency;
				this.currentFrequency = frequency;
				this.source["playbackRate"]["value"] = frequency / this.frequency;
				this.startTime = Date.now() - time;
				if (typeof this.source["start"] !== "undefined")
					this.source["start"](0, time / 1000);
				else
					this.source["noteOn"](time);
				var that = this;
				this.source["onended"] = function (e)
				{
					that.bEnded = true;
				}
			}
			this.bPaused = false;
			this.bPlaying = true;
			this.bEnded = false;
		},
		play:       function (nl, bPrio, v)
		{
			this.nLoops = nl;
			if (this.nLoops == 0)
				this.nLoops = 10000000;
			this.volume = v;

			this.playIt();
		},
		stop:       function ()
		{
			if (this.sound)
				this.sound.pause();
			else if (this.source && this.bPlaying)
			{
				if (typeof this.source["stop"] !== "undefined")
					this.source["stop"](0);
				else
					this.source["noteOff"](0);
				this.source["onended"] = null;
			}
			this.bUninterruptible = false;
			this.bPlaying = false;
		},

		setVolume: function (v)
		{
			this.volume = v;
			if (this.sound)
				this.sound.volume = (v / 100.0);
			else if (this.source)
			{
				if (this.gain)
					this.gain["gain"]["value"] = (v / 100.0);
				else
					this.source["gain"]["value"] = (v / 100.0);
			}
		},

		pause: function ()
		{
		    if (!this.bPaused) {
		        if (this.sound)
		            this.sound.pause();
		        else if (this.source) {
		            this.source["onended"] = null;
		            if (typeof this.source["stop"] !== "undefined")
		                this.source["stop"](0);
		            else
		                this.source["noteOff"](0);
		            this.pauseTime = Date.now() - this.startTime;
	            }
		        this.bPaused = true;
		    }
		},

		globalpause: function () {
		    if (!this.bPaused) {
		        this.pause();
		        this.bAllowGlobalResume = true;
		    } else {
		        this.bAllowGlobalResume = false;
		    }
		},

		resume: function ()
		{
		    if (this.bPaused) {
		        if (this.sound)
		            this.sound.play();
		        else if (this.source) {
		            this.playIt(this.pauseTime);
		        }
		        this.bPaused = false;
		    }
		},

		globalresume: function () {
		    if (this.bAllowGlobalResume) {
		        this.resume();
		        this.bAllowGlobalResume = false;
		    }
		},

		isPaused: function ()
		{
			return this.bPaused;
		},

		isPlaying: function ()
		{
			if ((this.sound || this.source) && this.bPlaying)
			{
			    return true;    // !this.bPaused;
			}
			return false;
		},

		getDuration: function ()
		{
			if (this.sound && this.sound.duration != undefined && isNaN(this.sound.duration) == false && this.sound.duration != Infinity)
			{
				return Math.floor(this.sound.duration * 1000);
			}
			else if (this.source)
			{
				return this.buffer["duration"] * 1000;
			}
			return 0;
		},

		getPosition: function ()
		{
			if (this.sound)
				return Math.floor(this.sound.currentTime * 1000);
			else if (this.source)
			{
			    var t;
			    if (this.bPaused)
			        t = this.pauseTime;
			    else
			        t = Date.now() - this.startTime;
			    return Math.min(this.buffer["duration"] * 1000, t);
			}
			return 0;
		},

		setPosition: function (t)
		{
			if (this.sound)
				this.sound.currentTime = t / 1000;
			else if (this.source)
			{
			    if (this.bPlaying)
				{
			        this.source["onended"] = null;
			        if (typeof this.source["stop"] !== "undefined")
						this.source["stop"](0);
					else
						this.source["noteOff"](0);
				}
				this.playIt(t);
	        }
		},

		setFrequency: function (t)
		{
			var pitch = t / this.frequency;
			this.currentFrequency = t;
			if (this.sound)
				this.sound.playbackRate = pitch;
			else if (this.source)
				this.source["playbackRate"]["value"] = pitch;
		},

		getFrequency: function (t)
		{
			return this.currentFrequency;
		},

		checkSound: function ()
		{
			if (this.bPlaying == true && this.bPaused == false)
			{
				if (this.sound)
				{
					if (this.sound.ended)
					{
						if (this.nLoops > 0)
						{
							this.nLoops--;
							if (this.nLoops > 0)
							{
								this.playIt(0, this.currentFrequency);
								return false;
							}
						}
						this.bUninterruptible = false;
						this.bPlaying = false;
						return true;
					}
				}
				else if (this.source)
				{
					if (this.source["playbackState"] == 3 || this.bEnded)
					{
						if (this.nLoops > 0)
						{
							this.nLoops--;
							if (this.nLoops > 0)
							{
								this.playIt(0, this.currentFrequency);
								return false;
							}
						}
						this.bUninterruptible = false;
						this.bPlaying = false;
						return true;
					}
				}
			}
			return false;
		}

	}
	    

	    
	// CEventProgram object
	// ---------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 * 
	 * Permission is hereby granted to any person obtaining a legal copy 
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for 
	 * debugging, optimizing, or customizing applications created with 
	 * Clickteam Multimedia Fusion 2. 
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOastlTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */

	// Fast Loop acceleration
	//////////////////////////////////////////////////////////////////////////////
	function CPosOnLoop(name, index)
	{
		this.name = name;
		this.pointers = new Array();
		this.position = 0;
		this.m_bOR = false;
		this.fastLoopIndex = index;
	}
	CPosOnLoop.prototype =
	{
		AddOnLoop: function (evgPtr)
		{
			this.pointers[this.position++] = evgPtr;
		}
	}

	function SaveSelection(poil) {
	    this.poil = poil;
	    this.selectedInstances = new Array();
	}
	SaveSelection.prototype =
	{
	}

	// CEventProgram
	//////////////////////////////////////////////////////////////////////////////
	CEventProgram.EVENTS_EXTBASE = 80;
	CEventProgram.PARAMCLICK_DOUBLE = 0x100;
	CEventProgram.EVENTOPTION_BREAKCHILD = 0x0001;
	CEventProgram.bts = function (array, index)
	{
	    var d = (index >> 5);           // Build 284.2, fixes bug #2828
	    var mask = 1 << (index & 31);
		var b = (array[d] & mask) != 0;
		array[d] |= mask;
		return b;
	}
	CEventProgram.evg_FindAction = function (evgPtr, n)
	{
		return evgPtr.evgNCond + n;
	}
	CEventProgram.EVTTYPE = function (code)
	{
		var c = code & 0xFFFF;
		if ((c & 0x8000) != 0)
		{
			return c - 65536;
		}
		return c;
	}
	CEventProgram.EVTNUM = function (code)
	{
		return (code >> 16);
	}
	CEventProgram.getEventCode = function (code)
	{
		return code & 0xFFFF0000;
	}

	function CEventProgram(app)
	{
		this.application = app;
		this.rhPtr = null;
		this.maxObjects = 0;
		this.maxOi = 0;
		this.nPlayers = 0;
		this.nConditions = new Array(COI.NUMBEROF_SYSTEMTYPES + COI.OBJ_LAST);
		this.nQualifiers = 0;
		this.nEvents = 0;
		this.qualifiers = null;
		this.events = null;
		this.qualToOiList = null;
		this.listPointers = null;
		this.eventPointersGroup = null;
		this.eventPointersCnd = null;
		this.limitBuffer = null;
		this.rhEvents = new Array(COI.NUMBEROF_SYSTEMTYPES + 1);
		this.rhEventAlways = false;
		this.rh4TimerEventsBase = 0;
		this.colBuffer = null;
		this.qualOilPtr = 0;
		this.qualOilPos = 0;
		this.qualOilPtr2 = 0;
		this.qualOilPos2 = 0;
		this.rh4CheckDoneInstart = false;
		this.rhEventGroup = null;
		this.rhCurCode = 0;
		this.rh4PickFlags = new Array(4);
		this.rh2ActionLoop = false;
		this.rh2ActionOn = false;
		this.rh2EnablePick = false;
		this.rh2EventCount = 0;
		this.rh2ActionCount = 0;
		this.rh2ActionLoopCount = 0;
		this.rh4EventCountOR = 0;
		this.rh4ConditionsFalse = false;
		this.rh3DoStop = false;
		this.rh2EventQualPos = null;
		this.rh2EventQualPosNum = 0;
		this.rh2EventPos = 0;
		this.rh2EventPosOiList = 0;
		this.rh2EventPrev = null;
		this.rh2EventPrevOiList = null;
		this.evtNSelectedObjects = 0;
		this.repeatFlag = false;
		this.rh2EventType = 0;
		this.rhCurOi = 0;
		this.rhCurParam0 = 0;
		this.rhCurParam1 = 0;
		//  this.rh3CurrentMenu=0;
		this.rh2CurrentClick = 0;
		this.rh4_2ndObject = null;
		this.bReady = false;
		this.rh2ShuffleBuffer = null;
		this.rhCurObjectNumber = 0;
		this.rh1stObjectNumber = 0;
		this.rh2PushedEvents = null;
		this.callEndForEach = false;
		this.bTestAllKeys = false;
		this.maxEvents = 0;
		this.complexOnLoop = false;
		this.childEventParam = null;
		this.childEventSelectionStack = new Array();
		this.defaultEvgFlagsMask = CEventGroup.EVGFLAGS_DEFAULTMASK;
	}
	CEventProgram.prototype =
	{
		evt_FirstObjectFromType: function (nType)
		{
			this.rh2EventType = nType;
			if (nType == -1)
			{
				var pHo;
				var pHoStore = null;
				var oil;
				var poil;
				var bStore = true;
				for (oil = 0; oil < this.rhPtr.rhOiList.length; oil++)
				{
					poil = this.rhPtr.rhOiList[oil];
					if (CEventProgram.bts(this.rh4PickFlags, poil.oilType) == false)
					{
						pHo = this.evt_SelectAllFromType(poil.oilType, bStore);
						if (pHo != null)
						{
							pHoStore = pHo;
							bStore = false;
						}
					}
				}
				if (pHoStore != null)
				{
					return pHoStore;
				}
			}
			else
			{
				if (CEventProgram.bts(this.rh4PickFlags, nType) == false)
				{
					return this.evt_SelectAllFromType(nType, true);
				}
			}

			var oil2 = 0;
			var oilPtr;
			do
			{
				oilPtr = this.rhPtr.rhOiList[oil2];
				if ((nType != -1 && oilPtr.oilType == nType) || nType == -1)
				{
					if ((oilPtr.oilListSelected & 0x80000000) == 0)
					{
						var pHo = this.rhPtr.rhObjectList[oilPtr.oilListSelected];
						this.rh2EventPrev = null;
						this.rh2EventPrevOiList = oilPtr;
						this.rh2EventPos = pHo;
						this.rh2EventPosOiList = oil2;
						return pHo;
					}
				}
				oil2++; // Un autre OI?
			}
			while (oil2 < this.rhPtr.rhMaxOI);
			return null;
		},

		evt_NextObjectFromType: function ()
		{
			var pHo = this.rh2EventPos;
			var oilPtr;

		    // This part is not in the Windows runtime. If pHo is null in this routine, then probably there is a bug somewhere else?
			if (pHo == null)
			{
				oilPtr = this.rhPtr.rhOiList[this.rh2EventPosOiList];
				if ((oilPtr.oilListSelected & 0x80000000) == 0)
				{
					pHo = this.rhPtr.rhObjectList[oilPtr.oilListSelected];
					this.rh2EventPrev = null;
					this.rh2EventPrevOiList = oilPtr;
					this.rh2EventPos = pHo;
					return pHo;
				}
			}
	        //
			if (pHo != null)
			{
				if ((pHo.hoNextSelected & 0x80000000) == 0)
				{
					this.rh2EventPrev = pHo;
					this.rh2EventPrevOiList = null;
					pHo = this.rhPtr.rhObjectList[pHo.hoNextSelected];
				    this.rh2EventPos = pHo;
					return pHo;
				}
			}

			var oil = this.rh2EventPosOiList;
			oil++;
			while (oil < this.rhPtr.rhMaxOI)
			{
			    var poil = this.rhPtr.rhOiList[oil];
			    if ((this.rh2EventType != -1 && poil.oilType == this.rh2EventType) || this.rh2EventType == -1)
				{
					if ((poil.oilListSelected & 0x80000000) == 0)
					{
						pHo = this.rhPtr.rhObjectList[poil.oilListSelected];
						this.rh2EventPrev = null;
						this.rh2EventPrevOiList = poil;
						this.rh2EventPos = pHo;
						this.rh2EventPosOiList = oil;
						return pHo;
					}
				}
				oil++;
			}
			return null;
		},

		evt_SelectAllFromType: function (nType, bStore)
		{
			var first = -1;
			var evtCount = this.rh2EventCount;

			var oil = 0;
			var oilPtr;
			var pHo;
			do
			{
				oilPtr = this.rhPtr.rhOiList[oil];
				if (oilPtr.oilType == nType && oilPtr.oilEventCount != evtCount)
				{
					oilPtr.oilEventCount = evtCount;
					if (this.rh4ConditionsFalse)
					{
						oilPtr.oilListSelected = -1;
						oilPtr.oilNumOfSelected = 0;
					}
					else
					{
						oilPtr.oilNumOfSelected = oilPtr.oilNObjects;
						var num = oilPtr.oilObject;
						if ((num & 0x80000000) == 0)
						{
							if (first == -1 && bStore == true)
							{
								first = num;
								this.rh2EventPrev = null;
								this.rh2EventPrevOiList = oilPtr;
								this.rh2EventPosOiList = oil;
							}
							do
							{
								pHo = this.rhPtr.rhObjectList[num];
								if (pHo == null)
									return null;
								pHo.hoNextSelected = pHo.hoNumNext;
								num = pHo.hoNumNext;
							}
							while ((num & 0x80000000) == 0);

							num = oilPtr.oilObject;
						}
						oilPtr.oilListSelected = num;
					}
				}
				oil++;
			}
			while (oil < this.rhPtr.rhMaxOI);

			if (bStore == false)
			{
				return null;
			}
			if (first < 0)
			{
				return null;
			}

			pHo = this.rhPtr.rhObjectList[first];
			if (pHo == null)
			    return null;
			this.rh2EventPos = pHo;
			return pHo;
		},

		evt_FirstObject: function (sEvtOiList)
		{
			var pHo;

			this.evtNSelectedObjects = 0;
			this.rh2EventQualPos = null;
			this.rh2EventQualPosNum = -1;

			if ((sEvtOiList & 0x8000) != 0)
			{
				if ((sEvtOiList & 0x7FFF) == 0x7FFF)
				{
					return null;
				}
				return this.qualProc(sEvtOiList);
			}

			var oilPtr = this.rhPtr.rhOiList[sEvtOiList];
			if (oilPtr.oilEventCount == this.rh2EventCount)
			{
				if ((oilPtr.oilListSelected & 0x80000000) != 0)
				{
					return null;
				}
				pHo = this.rhPtr.rhObjectList[oilPtr.oilListSelected];
				this.rh2EventPrev = null;
				this.rh2EventPrevOiList = oilPtr;
				this.rh2EventPos = pHo;
				this.rh2EventPosOiList = sEvtOiList;
				this.evtNSelectedObjects = oilPtr.oilNumOfSelected;
				return pHo;
			}
			else
			{
				oilPtr.oilEventCount = this.rh2EventCount;

				if (this.rh4ConditionsFalse)
				{
					oilPtr.oilListSelected = -1;
					oilPtr.oilNumOfSelected = 0;
					return null;
				}

				oilPtr.oilListSelected = oilPtr.oilObject;
				if ((oilPtr.oilObject & 0x80000000) != 0)
				{
					oilPtr.oilNumOfSelected = 0;
					return null;
				}
				var num = oilPtr.oilObject;
				do
				{
					pHo = this.rhPtr.rhObjectList[num];
					num = pHo.hoNumNext;
					pHo.hoNextSelected = num;
				}
				while ((num & 0x80000000) == 0);


				pHo = this.rhPtr.rhObjectList[oilPtr.oilObject];
				this.rh2EventPrev = null;
				this.rh2EventPrevOiList = oilPtr;
				this.rh2EventPos = pHo;
				this.rh2EventPosOiList = sEvtOiList;
				oilPtr.oilNumOfSelected = oilPtr.oilNObjects;
				this.evtNSelectedObjects = oilPtr.oilNumOfSelected;
				return pHo;
			}
		},

		qualProc:       function (sEvtOiList)
		{
			var pHo;
			var oilPtr;
			var count = 0;

			var qoi = 0;
			var qoiList;
			var addCount;
			var pQoi = this.qualToOiList[sEvtOiList & 0x7FFF];
			while (qoi < pQoi.qoiList.length)
			{
				qoiList = pQoi.qoiList[qoi + 1];
				oilPtr = this.rhPtr.rhOiList[qoiList];
				if (oilPtr.oilEventCount == this.rh2EventCount)
				{
					addCount = 0;
					if ((oilPtr.oilListSelected & 0x80000000) == 0)
					{
						addCount = oilPtr.oilNumOfSelected;
						if (this.rh2EventQualPos == null)
						{
							this.rh2EventQualPos = pQoi;
							this.rh2EventQualPosNum = qoi;
						}
					}
				}
				else
				{
					addCount = 0;
					oilPtr.oilEventCount = this.rh2EventCount;

					if (this.rh4ConditionsFalse)
					{
						oilPtr.oilListSelected = -1;
						oilPtr.oilNumOfSelected = 0;
					}
					else
					{
						oilPtr.oilListSelected = oilPtr.oilObject;
						if ((oilPtr.oilObject & 0x80000000) != 0)
						{
							oilPtr.oilNumOfSelected = 0;
						}
						else
						{
							if (this.rh2EventQualPos == null)
							{
								this.rh2EventQualPos = pQoi;
								this.rh2EventQualPosNum = qoi;
							}
							var num = oilPtr.oilObject;
							do
							{
								pHo = this.rhPtr.rhObjectList[num];
								pHo.hoNextSelected = pHo.hoNumNext;
								num = pHo.hoNumNext;
							} while ((num & 0x80000000) == 0);

							oilPtr.oilNumOfSelected = oilPtr.oilNObjects;
							addCount = oilPtr.oilNObjects;
						}
					}
				}
				count += addCount;
				qoi += 2;
			}

			pQoi = this.rh2EventQualPos;
			if (pQoi != null)
			{
				oilPtr = this.rhPtr.rhOiList[pQoi.qoiList[this.rh2EventQualPosNum + 1]];
				this.rh2EventPrev = null;
				this.rh2EventPrevOiList = oilPtr;
				pHo = this.rhPtr.rhObjectList[oilPtr.oilListSelected];
				this.rh2EventPos = pHo;
				this.rh2EventPosOiList = pQoi.qoiList[this.rh2EventQualPosNum + 1];
				this.evtNSelectedObjects = count;
				return pHo;
			}
			return null;
		},
		evt_NextObject: function ()
		{
			var pHo = this.rh2EventPos;
			var oilPtr;
			if (pHo == null)
			{
				oilPtr = this.rhPtr.rhOiList[this.rh2EventPosOiList];
				if ((oilPtr.oilListSelected & 0x80000000) == 0)
				{
					pHo = this.rhPtr.rhObjectList[oilPtr.oilListSelected];
					this.rh2EventPrev = null;
					this.rh2EventPrevOiList = oilPtr;
					this.rh2EventPos = pHo;
					return pHo;
				}
			}
			if (pHo != null)
			{
				if ((pHo.hoNextSelected & 0x80000000) == 0)
				{
					this.rh2EventPrev = pHo;
					this.rh2EventPrevOiList = null;
					pHo = this.rhPtr.rhObjectList[pHo.hoNextSelected];
					this.rh2EventPos = pHo;
					return pHo;
				}
			}
			if (this.rh2EventQualPos == null)
			{
				return null;
			}

			do
			{
				this.rh2EventQualPosNum += 2;
				if (this.rh2EventQualPosNum >= this.rh2EventQualPos.qoiList.length)
				{
					return null;
				}
				oilPtr = this.rhPtr.rhOiList[this.rh2EventQualPos.qoiList[this.rh2EventQualPosNum + 1]];
			} while ((oilPtr.oilListSelected & 0x80000000) != 0);

			this.rh2EventPrev = null;
			this.rh2EventPrevOiList = oilPtr;
			pHo = this.rhPtr.rhObjectList[oilPtr.oilListSelected];
			this.rh2EventPos = pHo;
			this.rh2EventPosOiList = this.rh2EventQualPos.qoiList[this.rh2EventQualPosNum + 1];
			return pHo;
		},

		evt_AddCurrentQualifier: function (qual)
		{
			var pQoi = this.qualToOiList[qual & 0x7FFF];
			var noil = 0;
			var oilPtr;
			while (noil < pQoi.qoiList.length)
			{
				oilPtr = this.rhPtr.rhOiList[pQoi.qoiList[noil + 1]];
				if (oilPtr.oilEventCount != this.rh2EventCount)
				{
					oilPtr.oilEventCount = this.rh2EventCount;
					oilPtr.oilNumOfSelected = 0;
					oilPtr.oilListSelected = -1;
				}
				noil += 2;
			}
			;
		},

		evt_DeleteCurrentQualifier: function (qual)
		{
		    var pQoi = this.qualToOiList[qual & 0x7FFF];
		    var noil = 0;
		    var oilPtr;
		    while (noil < pQoi.qoiList.length)
		    {
		        oilPtr = this.rhPtr.rhOiList[pQoi.qoiList[noil + 1]];
		        oilPtr.oilEventCount = this.rh2EventCount;
	            oilPtr.oilNumOfSelected = 0;
	            oilPtr.oilListSelected = -1;
		        noil += 2;
		    }
		},

		evt_DeleteCurrentObject: function ()
		{
			this.rh2EventPos.hoOiList.oilNumOfSelected -= 1;
			if (this.rh2EventPrev != null)
			{
				this.rh2EventPrev.hoNextSelected = this.rh2EventPos.hoNextSelected;
				this.rh2EventPos = this.rh2EventPrev;
			}
			else
			{
				//            rhPtr.rhOiList[rh2EventPosOiList].oilListSelected=rh2EventPos.hoNextSelected;
				this.rh2EventPrevOiList.oilListSelected = this.rh2EventPos.hoNextSelected;
				this.rh2EventPos = null;
			}
		},

		evt_AddCurrentObject: function (pHo)
		{
			var oilPtr = pHo.hoOiList;
			if (oilPtr.oilEventCount != this.rh2EventCount)
			{
				oilPtr.oilEventCount = this.rh2EventCount;
				oilPtr.oilListSelected = pHo.hoNumber;
				oilPtr.oilNumOfSelected = 1;
				pHo.hoNextSelected = -1;
			}
			else
			{
				var oils = oilPtr.oilListSelected;
				if ((oils & 0x80000000) != 0)
				{
					oilPtr.oilListSelected = pHo.hoNumber;
					oilPtr.oilNumOfSelected += 1;
					pHo.hoNextSelected = -1;
				}
				else
				{
					var pHo1;
					do
					{
						if (pHo.hoNumber == oils)
						{
							return;
						}
						pHo1 = this.rhPtr.rhObjectList[oils];
						oils = pHo1.hoNextSelected;
					} while ((oils & 0x80000000) == 0);

					pHo1.hoNextSelected = pHo.hoNumber;
					pHo.hoNextSelected = -1;
					pHo.hoOiList.oilNumOfSelected += 1;
				}
			}
		},

		deselectThem: function (oil)
		{
			var poil = this.rhPtr.rhOiList[oil];
			poil.oilEventCount = this.rh2EventCount;
			poil.oilListSelected = -1;
			poil.oilNumOfSelected = 0;
		},

		evt_ForceOneObject: function (oil, pHo)
		{
			if ((oil & 0x8000) == 0)
			{
				this.deselectThem(oil);
			}
			else
			{
				if ((oil & 0x7FFF) == 0x7FFF)
				{
					return;
				}
				var pqoi = this.qualToOiList[oil & 0x7FFF];
				var qoi;
				for (qoi = 0; qoi < pqoi.qoiList.length; qoi += 2)
				{
					this.deselectThem(pqoi.qoiList[qoi + 1]);
				}
			}
			pHo.hoNextSelected = -1;
			pHo.hoOiList.oilListSelected = pHo.hoNumber;
			pHo.hoOiList.oilNumOfSelected = 1;
			pHo.hoOiList.oilEventCount = this.rh2EventCount;
		},

		evt_DeleteCurrentType: function (nType)
		{
			CEventProgram.bts(this.rh4PickFlags, nType);

			var oil;
			var oilPtr;
			for (oil = 0; oil < this.rhPtr.rhMaxOI; oil++)
			{
				oilPtr = this.rhPtr.rhOiList[oil];
				if (oilPtr.oilType == nType)
				{
					oilPtr.oilEventCount = this.rh2EventCount;
					oilPtr.oilListSelected = -1;
					oilPtr.oilNumOfSelected = 0;
				}
			}
		},

		evt_DeleteCurrent: function ()
		{
			this.rh4PickFlags[0] = -1;
			this.rh4PickFlags[1] = -1;
			this.rh4PickFlags[2] = -1;
			this.rh4PickFlags[3] = -1;

			var oil;
			var oilPtr;
			for (oil = 0; oil < this.rhPtr.rhMaxOI; oil++)
			{
				oilPtr = this.rhPtr.rhOiList[oil];
				oilPtr.oilEventCount = this.rh2EventCount;
				oilPtr.oilListSelected = -1;
				oilPtr.oilNumOfSelected = 0;
			}
		},

		evt_MarkSelectedObjects: function ()
		{
			var num;
			var pHO;
			var oil;
			var oilPtr;

			for (oil = 0; oil < this.rhPtr.rhMaxOI; oil++)
			{
				oilPtr = this.rhPtr.rhOiList[oil];
				if (oilPtr.oilEventCount == this.rh2EventCount)
				{
					if (oilPtr.oilEventCountOR != this.rh4EventCountOR)
					{
						oilPtr.oilEventCountOR = this.rh4EventCountOR;
						num = oilPtr.oilObject;
						while ((num & 0x80000000) == 0)
						{
							pHO = this.rhPtr.rhObjectList[num];
							pHO.hoSelectedInOR = 0;
							num = pHO.hoNumNext;
						}
					}
					num = oilPtr.oilListSelected;
					while ((num & 0x80000000) == 0)
					{
						pHO = this.rhPtr.rhObjectList[num];
						pHO.hoSelectedInOR = 1;
						num = pHO.hoNextSelected;
					}
				}
			}
		},

		evt_BranchSelectedObjects: function ()
		{
			var num;
			var pHO, pHOPrev;
			var oil;
			var oilPtr;

			for (oil = 0; oil < this.rhPtr.rhMaxOI; oil++)
			{
				oilPtr = this.rhPtr.rhOiList[oil];
				if (oilPtr.oilEventCountOR == this.rh4EventCountOR)
				{
					oilPtr.oilEventCount = this.rh2EventCount;

					num = oilPtr.oilObject;
					pHOPrev = null;
					while ((num & 0x80000000) == 0)
					{
						pHO = this.rhPtr.rhObjectList[num];
						if (pHO.hoSelectedInOR != 0)
						{
							if (pHOPrev != null)
							{
								pHOPrev.hoNextSelected = num;
							}
							else
							{
								oilPtr.oilListSelected = num;
							}
							pHO.hoNextSelected = -1;
							pHOPrev = pHO;
						}
						num = pHO.hoNumNext;
					}
				}
			}
		},

		get_ExpressionObjects: function (expoi)
		{
			var object;
			if (this.rh2ActionOn)
			{
				this.rh2EnablePick = false;
				var object = this.get_CurrentObjects(expoi);
				return object;
			}

			var oilPtr;
			if ((expoi & 0x8000) == 0)
			{
				oilPtr = this.rhPtr.rhOiList[expoi];
				if (oilPtr.oilEventCount == this.rh2EventCount)
				{
					if ((oilPtr.oilListSelected & 0x80000000) == 0)
					{
						return this.rhPtr.rhObjectList[oilPtr.oilListSelected];
					}
					if ((oilPtr.oilObject & 0x80000000) == 0)
					{
						return this.rhPtr.rhObjectList[oilPtr.oilObject];
					}
					return null;
				}
				else
				{
					if ((oilPtr.oilObject & 0x80000000) == 0)
					{
						return this.rhPtr.rhObjectList[oilPtr.oilObject];
					}
					return null;
				}
			}

			var pQoi = this.qualToOiList[expoi & 0x7FFF];
			var qoi = 0;
			if (qoi >= pQoi.qoiList.length)
			{
				return null;
			}
			do
			{
				oilPtr = this.rhPtr.rhOiList[pQoi.qoiList[qoi + 1]];
				if (oilPtr.oilEventCount == this.rh2EventCount)
				{
					if ((oilPtr.oilListSelected & 0x80000000) == 0)
					{
						return this.rhPtr.rhObjectList[oilPtr.oilListSelected];
					}
				}
				qoi += 2;
			} while (qoi < pQoi.qoiList.length);

			qoi = 0;
			do
			{
				oilPtr = this.rhPtr.rhOiList[pQoi.qoiList[qoi + 1]];
				if ((oilPtr.oilObject & 0x80000000) == 0)
				{
					return this.rhPtr.rhObjectList[oilPtr.oilObject];
				}
				qoi += 2;
			} while (qoi < pQoi.qoiList.length);
			return null;
		},

		get_ParamActionObjects: function (qoil, pAction)
		{
			this.rh2EnablePick = true;
			var pObject = this.get_CurrentObjects(qoil);
			if (pObject != null)
			{
				if (this.repeatFlag == false)
				{
					return pObject;
				}
				else
				{
					pAction.evtFlags |= CAct.ACTFLAGS_REPEAT;
					this.rh2ActionLoop = true;
					return pObject;
				}
			}
			pAction.evtFlags |= CEvent.EVFLAGS_NOTDONEINSTART;
			return pObject;
		},

		get_ActionObjects: function (pAction)
		{
			pAction.evtFlags &= ~CEvent.EVFLAGS_NOTDONEINSTART;
			this.rh2EnablePick = true;
			var qoil = pAction.evtOiList;
			var pObject = this.get_CurrentObjects(qoil);
			if (pObject != null)
			{
				if (this.repeatFlag == false)
				{
					return pObject;
				}
				else
				{
					pAction.evtFlags |= CAct.ACTFLAGS_REPEAT;
					this.rh2ActionLoop = true;
					return pObject;
				}
			}
			pAction.evtFlags |= CEvent.EVFLAGS_NOTDONEINSTART;
			return pObject;
		},

		get_CurrentObjects: function (qoil)
		{
			var object;
			if ((qoil & 0x8000) == 0)
			{
				object = this.get_CurrentObject(qoil);
			}
			else
			{
				object = this.get_CurrentObjectQualifier(qoil);
			}
			return object;
		},

		get_CurrentObject: function (qoil)
		{
			var pHo;
			var oilPtr = this.rhPtr.rhOiList[qoil];

			if (oilPtr.oilActionCount != this.rh2ActionCount)
			{
				oilPtr.oilActionCount = this.rh2ActionCount;
				oilPtr.oilActionLoopCount = this.rh2ActionLoopCount;

				if (oilPtr.oilEventCount == this.rh2EventCount)
				{
					if ((oilPtr.oilListSelected & 0x80000000) == 0)
					{
						oilPtr.oilCurrentOi = oilPtr.oilListSelected;
						pHo = this.rhPtr.rhObjectList[oilPtr.oilListSelected];
						oilPtr.oilNext = pHo.hoNextSelected;
						if ((pHo.hoNextSelected & 0x80000000) != 0)
						{
							oilPtr.oilNextFlag = false;
							oilPtr.oilCurrentRoutine = 1;
							this.repeatFlag = false;
							return pHo;
						}
						oilPtr.oilNextFlag = true;
						oilPtr.oilCurrentRoutine = 2;
						this.repeatFlag = true;
						return pHo;
					}
				}

				if (this.rh2EnablePick)
				{
					if (oilPtr.oilEventCount == this.rh2EventCount)
					{
						oilPtr.oilCurrentRoutine = 0;
						oilPtr.oilCurrentOi = -1;
						return null;
					}
				}
				if ((oilPtr.oilObject & 0x80000000) == 0)
				{
					oilPtr.oilCurrentOi = oilPtr.oilObject;
					pHo = this.rhPtr.rhObjectList[oilPtr.oilObject];
					if (pHo == null)
					{
						oilPtr.oilCurrentRoutine = 0;
						oilPtr.oilCurrentOi = -1;
						return null;
					}
					if ((pHo.hoNumNext & 0x80000000) == 0)
					{
						oilPtr.oilNext = pHo.hoNumNext;
						oilPtr.oilNextFlag = true;
						oilPtr.oilCurrentRoutine = 3;
						this.repeatFlag = true;
						return pHo;
					}
					oilPtr.oilNextFlag = false;
					oilPtr.oilCurrentRoutine = 1;
					this.repeatFlag = false;
					return pHo;
				}
				else
				{
					oilPtr.oilCurrentRoutine = 0;
					oilPtr.oilCurrentOi = -1;
					return null;
				}
			}

			if (oilPtr.oilActionLoopCount != this.rh2ActionLoopCount)
			{
				var next;
				oilPtr.oilActionLoopCount = this.rh2ActionLoopCount;
				switch (oilPtr.oilCurrentRoutine)
				{
					case 0:
						this.repeatFlag = oilPtr.oilNextFlag;
						return null;
					case 1:
						pHo = this.rhPtr.rhObjectList[oilPtr.oilCurrentOi];
						this.repeatFlag = oilPtr.oilNextFlag;
						return pHo;
					case 2:
						oilPtr.oilCurrentOi = oilPtr.oilNext;
						pHo = this.rhPtr.rhObjectList[oilPtr.oilNext];
						if (pHo == null)
						{
							return null;
						}
						next = pHo.hoNextSelected;
						if ((next & 0x80000000) != 0)
						{
							oilPtr.oilNextFlag = false;
							next = oilPtr.oilListSelected;
						}
						oilPtr.oilNext = next;
						this.repeatFlag = oilPtr.oilNextFlag;
						return pHo;
					case 3:
						oilPtr.oilCurrentOi = oilPtr.oilNext;
						pHo = this.rhPtr.rhObjectList[oilPtr.oilNext];
						if (pHo == null)
						{
							return null;
						}
						next = pHo.hoNumNext;
						if ((next & 0x80000000) != 0)
						{
							oilPtr.oilNextFlag = false;
							next = oilPtr.oilObject;
						}
						oilPtr.oilNext = next;
						this.repeatFlag = oilPtr.oilNextFlag;
						return pHo;
				}
			}
			if (oilPtr.oilCurrentOi < 0)
			{
				return null;
			}
			pHo = this.rhPtr.rhObjectList[oilPtr.oilCurrentOi];
			this.repeatFlag = oilPtr.oilNextFlag;
			return pHo;
		},

		get_CurrentObjectQualifier: function (qoil)
		{
			var pHo;
			var next, num;

			var pqoi = this.qualToOiList[qoil & 0x7FFF];
			if (pqoi.qoiActionCount != this.rh2ActionCount)
			{
				pqoi.qoiActionCount = this.rh2ActionCount;
				pqoi.qoiActionLoopCount = this.rh2ActionLoopCount;

				num = this.qoi_GetFirstListSelected(pqoi);
				if (num >= 0)
				{
					pqoi.qoiCurrentOi = num;
					pHo = this.rhPtr.rhObjectList[num];
					if (pHo == null)
					{
						pqoi.qoiCurrentRoutine = 0;
						pqoi.qoiCurrentOi = -1;
						return null;
					}
					next = pHo.hoNextSelected;
					if ((next & 0x80000000) != 0)
					{
						next = this.qoi_GetNextListSelected(pqoi);
						if (next < 0)
						{
							pqoi.qoiCurrentRoutine = 1;
							pqoi.qoiNextFlag = false;
							this.repeatFlag = false;
							return pHo;
						}
					}
					pqoi.qoiNext = next;
					pqoi.qoiCurrentRoutine = 2;
					pqoi.qoiNextFlag = true;
					this.repeatFlag = true;
					return pHo;
				}

				if (this.rh2EnablePick)
				{
					if (pqoi.qoiSelectedFlag)
					{
						pqoi.qoiCurrentRoutine = 0;
						pqoi.qoiCurrentOi = -1;
						return null;
					}
				}
				num = this.qoi_GetFirstList(pqoi);
				if (num >= 0)
				{
					pqoi.qoiCurrentOi = num;
					pHo = this.rhPtr.rhObjectList[num];
					if (pHo != null)
					{
						num = pHo.hoNumNext;
						if ((num & 0x80000000) != 0)
						{
							num = this.qoi_GetNextList(pqoi);
							if ((num & 0x80000000) != 0)
							{
								pqoi.qoiCurrentRoutine = 1;
								pqoi.qoiNextFlag = false;
								this.repeatFlag = false;
								return pHo;
							}
						}
						pqoi.qoiNext = num;
						pqoi.qoiCurrentRoutine = 3;
						pqoi.qoiNextFlag = true;
						this.repeatFlag = true;
						return pHo;
					}
				}
				pqoi.qoiCurrentRoutine = 0;
				pqoi.qoiCurrentOi = -1;
				return null;
			}

			if (pqoi.qoiActionLoopCount != this.rh2ActionLoopCount)
			{
				pqoi.qoiActionLoopCount = this.rh2ActionLoopCount;
				switch (pqoi.qoiCurrentRoutine)
				{
					case 0:
						this.repeatFlag = pqoi.qoiNextFlag;
						return null;
					case 1:
						pHo = this.rhPtr.rhObjectList[pqoi.qoiCurrentOi];
						this.repeatFlag = pqoi.qoiNextFlag;
						return pHo;
					case 2:
						pqoi.qoiCurrentOi = pqoi.qoiNext;
						pHo = this.rhPtr.rhObjectList[pqoi.qoiNext];
						if (pHo != null)
						{
							next = pHo.hoNextSelected;
							if ((next & 0x80000000) != 0)
							{
								next = this.qoi_GetNextListSelected(pqoi);
								if (next < 0)
								{
									pqoi.qoiNextFlag = false;
									next = this.qoi_GetFirstListSelected(pqoi);
								}
							}
							pqoi.qoiNext = next;
						}
						this.repeatFlag = pqoi.qoiNextFlag;
						return pHo;
					case 3:
						pqoi.qoiCurrentOi = pqoi.qoiNext;
						pHo = this.rhPtr.rhObjectList[pqoi.qoiNext];
						if (pHo != null)
						{
							next = pHo.hoNumNext;
							if ((next & 0x80000000) != 0)
							{
								next = this.qoi_GetNextList(pqoi);
								if ((next & 0x80000000) != 0)
								{
									pqoi.qoiNextFlag = false;
									next = this.qoi_GetFirstList(pqoi);
								}
							}
							pqoi.qoiNext = next;
						}
						this.repeatFlag = pqoi.qoiNextFlag;
						return pHo;
				}
			}

			if (pqoi.qoiCurrentOi < 0)
			{
				return null;
			}
			pHo = this.rhPtr.rhObjectList[pqoi.qoiCurrentOi];
			this.repeatFlag = pqoi.qoiNextFlag;
			return pHo;
		},

		qoi_GetNextListSelected: function (pqoi)
		{
			var pos = pqoi.qoiActionPos;
			var qoil;
			var oilPtr;
			while (pos < pqoi.qoiList.length)
			{
				qoil = pqoi.qoiList[pos + 1];
				oilPtr = this.rhPtr.rhOiList[qoil];
				if (oilPtr.oilEventCount == this.rh2EventCount)
				{
					pqoi.qoiSelectedFlag = true;
					if ((oilPtr.oilListSelected & 0x80000000) == 0)
					{
						pqoi.qoiActionPos = (pos + 2);
						return oilPtr.oilListSelected;
					}
				}
				pos += 2;
			}
			return -1;
		},

		qoi_GetFirstListSelected: function (pqoi)
		{
			pqoi.qoiActionPos = 0;
			pqoi.qoiSelectedFlag = false;
			return this.qoi_GetNextListSelected(pqoi);
		},

		qoi_GetNextList: function (pqoi)
		{
			var pos = pqoi.qoiActionPos;
			var qoil;
			var oilPtr;
			while (pos < pqoi.qoiList.length)
			{
				qoil = pqoi.qoiList[pos + 1];
				oilPtr = this.rhPtr.rhOiList[qoil];
				if ((oilPtr.oilObject & 0x80000000) == 0)
				{
					pqoi.qoiActionPos = (pos + 2);
					return oilPtr.oilObject;
				}
				pos += 2;
			}
			return -1;
		},

		qoi_GetFirstList: function (pqoi)
		{
			pqoi.qoiActionPos = 0;
			return this.qoi_GetNextList(pqoi);
		},

		endForEach: function ()
		{
			this.callEndForEach = false;

			var saveForEach = this.rhPtr.rh4CurrentForEach;
			var saveForEach2 = this.rhPtr.rh4CurrentForEach2;
			while (true)
			{
				var pForEach2 = null;
				var pPrevious = null;
				var pForEach = this.rhPtr.rh4ForEachs;
				while (pForEach != null)
				{
					if (pForEach.index < 0)
					{
						pForEach2 = pForEach.next;
						if (pForEach2)
						{
							if (!CServices.compareStringsIgnoreCase(pForEach.name, pForEach2.name))
								pForEach2 = null;
						}
						break;
					}
					pPrevious = pForEach;
					pForEach = pForEach.next;
				}

				if (pForEach == null)
					break;

				pForEach.stop = false;
				for (pForEach.index = 0; pForEach.index < pForEach.number; pForEach.index++)
				{
					this.rhPtr.rh4CurrentForEach = pForEach;
					this.rhPtr.rh4CurrentForEach2 = pForEach2;
					if (pForEach2)
						pForEach2.index = pForEach.index;
					this.rh2ActionOn = 0;
					this.handle_Event(pForEach.objects[pForEach.index], (-41 << 16));    // CNDL_EXTONLOOP);
					if (pForEach.stop)
						break;
				}
				if (pForEach2)
				{
					for (pForEach2.index = 0; pForEach2.index < pForEach2.number; pForEach2.index++)
					{
						this.rhPtr.rh4CurrentForEach = pForEach2;
						this.rhPtr.rh4CurrentForEach2 = pForEach;
						if (pForEach)
							pForEach.index = pForEach2.index;
						this.rh2ActionOn = 0;
						this.handle_Event(pForEach2.objects[pForEach2.index], (-41 << 16));    // CNDL_EXTONLOOP);
						if (pForEach2.stop)
							break;
					}
				}
				if (pForEach2)
					pForEach.next = pForEach2.next;
				if (pPrevious == null)
					this.rhPtr.rh4ForEachs = pForEach.next;
				else
					pPrevious.next = pForEach.next;
			}
			this.rhPtr.rh4CurrentForEach = saveForEach;
			this.rhPtr.rh4CurrentForEach2 = saveForEach2;
		},

		addForEach: function (pName, pHo, oi)
		{
			var pForEach = this.rhPtr.rh4ForEachs;
			var pForEachPrevious = null;
			while (pForEach != null)
			{
				if (pForEach.oi == oi && CServices.compareStringsIgnoreCase(pName, pForEach.name))
				{
					pForEach.objects[pForEach.number++] = pHo;
					return;
				}
				pForEachPrevious = pForEach;
				pForEach = pForEach.next;
			}

			var pForEach = new ForEach();
			if (pForEachPrevious)
				pForEachPrevious.next = pForEach;
			else
				this.rhPtr.rh4ForEachs = pForEach;
			pForEach.next = null;
			pForEach.number = 1;
			pForEach.oi = oi;
			pForEach.objects[0] = pHo;
			pForEach.index = -1;
			pForEach.name = pName;
		},

		evt_SaveSelectedObjects: function (oiOilList, selectedObjects) {     // oiOilList = array of (oi,oil) pairs, selectedObjects = array of SaveSelection
		    for (var n = 0; n < oiOilList.length; n += 2) {
		        var oil = oiOilList[n + 1];
		        var poil = this.rhPtr.rhOiList[oil];

		        // Selected?
		        if (poil.oilEventCount == this.rh2EventCount) {
		            // Already in the list? 
		            var j;
		            for (j = 0; j < selectedObjects.length; j++) {
		                if (selectedObjects[j].poil == poil)
		                    break;
		            }

		            var pSel;       // saveSelection
		            if (j < selectedObjects.length) {
		                // In the list already => replace selection
		                pSel = selectedObjects[j];
		                pSel.selectedInstances.length = 0;
		            }
		            else {
		                // Not in the list yet, add new selection
		                pSel = new SaveSelection(poil);
		                selectedObjects.push(pSel);
		            }

		            // Store selected objects
		            var num = poil.oilListSelected;
		            while (num >= 0) {
		                var pHoFound = this.rhPtr.rhObjectList[num];
		                if (pHoFound == null)
		                    break;
		                if ((pHoFound.hoFlags & CObject.HOF_DESTROYED) == 0)
		                    pSel.selectedInstances.push(num);
		                num = pHoFound.hoNextSelected;
		            }
		        }
		    }
		},

		evt_RestoreSelectedObjects: function (oiOilList, selectedObjects) {     // oiOilList = array of (oi,oil) pairs, selectedObjects = array of SaveSelection
		    for (var n = 0; n < oiOilList.length; n += 2) {
		        var oil = oiOilList[n + 1];
		        var poil = this.rhPtr.rhOiList[oil];

		        for (var i = 0; i < selectedObjects.length; i++) {
		            var sel = selectedObjects[i];
		            if (sel.poil == poil) {
		                poil.oilEventCount = this.rh2EventCount;        // TODO: SetObjectEventCount(pRh, poil);
		                poil.oilListSelected = -1;
		                poil.oilNumOfSelected = 0;
		                if (sel.selectedInstances.length > 0) {
		                    var pHoPrev = this.rhPtr.rhObjectList[sel.selectedInstances[0]];
		                    if (pHoPrev != null) {
		                        poil.oilListSelected = sel.selectedInstances[0];
		                        poil.oilNumOfSelected++;
		                        for (var j = 1; j < sel.selectedInstances.length; j++) {
		                            var num = sel.selectedInstances[j];
		                            var pHo = this.rhPtr.rhObjectList[num];
		                            if (pHo == null)
		                                break;
		                            if ((pHo.hoFlags & CObject.HOF_DESTROYED) == 0) {
		                                pHoPrev.hoNextSelected = num;
		                                poil.oilNumOfSelected++;
		                            }
		                            pHoPrev = pHo;
		                        }
		                        pHoPrev.hoNextSelected = -1;
		                    }
		                }
		            }
		        }
		    }
		},

		executeChildEvents: function (eventParam) {
		    // Save object selection and push to stack
		    var newIdx = this.childEventSelectionStack.length;
		    var selectedObjects = new Array();      // array of SaveSelection
		    if (newIdx > 0) {
	            // Copy previous selection
		        var prevSelectedObjects = this.childEventSelectionStack[newIdx - 1];
		        for (var n = 0; n < prevSelectedObjects.length; n++) {
		            var prevSel = prevSelectedObjects[n];
		            var newSel = new SaveSelection(prevSel.poil);
		            for (var j = 0; j < prevSel.selectedInstances.length; j++) {
		                newSel.selectedInstances.push(prevSel.selectedInstances[j]);
		            }
		            selectedObjects.push(newSel);
		        }
		    }
		    this.evt_SaveSelectedObjects(eventParam.ois, selectedObjects);
		    this.childEventSelectionStack.push(selectedObjects);

		    // Execute child events (only "ALWAYS" events)
		    this.computeEventList(eventParam.evgOffsetList, null);

		    // Remove object selection from stack
		    this.childEventSelectionStack.pop();
		},

		handle_GlobalEvents: function (code)
		{
			var type = code & 0xFFFF;
			if ((type & 0x8000) != 0)
			{
				type = 65536 - type;
			}
			var cond = -(code >> 16);
			var num = this.listPointers[this.rhEvents[type] + cond];
			if (num != 0)
			{
				this.computeEventList(num, null);
			}
		},

		handle_Event: function (pHo, code)
		{
			this.rhCurCode = code;

			var cond = -(code >> 16);
			var num = this.listPointers[pHo.hoEvents + cond];
			if (num != 0)
			{
				this.computeEventList(num, pHo);
				return true;
			}
			return false;
		},

		handle_TimerEvents: function ()
		{
			var bDelete = false;
			var pEvent = this.rhPtr.rh4TimerEvents;
			while (pEvent)
			{
				if (this.rhPtr.rhTimer >= pEvent.timer)
				{
					if (pEvent.type == TimerEvents.TIMEREVENTTYPE_ONESHOT)
					{
						this.rhPtr.rhEvtProg.rhCurParam0 = pEvent.name;
						var num = this.listPointers[this.rhEvents[-COI.OBJ_TIMER] + CCnd.NUM_ONEVENT];
						if (num != 0)
						{
							this.computeEventList(num, null);
						}
						pEvent.bDelete = true;
						bDelete = true;
					}
					else
					{
						if (pEvent.timerPosition == 0)
						{
							pEvent.timerPosition = this.rhPtr.rhTimer;
						}
						while (this.rhPtr.rhTimer >= pEvent.timerPosition)
						{
							this.rhPtr.rhEvtProg.rhCurParam0 = pEvent.name;
							this.rhPtr.rhEvtProg.rhCurParam1 = pEvent.index;
							var num = this.listPointers[this.rhEvents[-COI.OBJ_TIMER] + CCnd.NUM_ONEVENT];
							if (num != 0)
							{
								this.computeEventList(num, null);
							}
							pEvent.index++;
							pEvent.loops--;
							if (pEvent.loops == 0)
							{
								pEvent.bDelete = true;
								bDelete = true;
								break;
							}
							pEvent.timerPosition += pEvent.timerNext;
						}
					}
				}
				pEvent = pEvent.next;
			}
			if (bDelete)
			{
				pEvent = this.rhPtr.rh4TimerEvents;
				var pPrevious = null;
				var pNext;
				while (pEvent)
				{
					pNext = pEvent.next;
					if (pEvent.bDelete)
					{
						if (pPrevious == null)
							this.rhPtr.rh4TimerEvents = pNext;
						else
							pPrevious.next = pNext;
					}
					else
					{
						pPrevious = pEvent;
					}
					pEvent = pNext;
				}
			}
		},

		compute_TimerEvents: function ()
		{

			var num;

			if ((this.rhPtr.rhGameFlags & CRun.GAMEFLAGS_FIRSTLOOPFADEIN) != 0)
			{
				num = this.listPointers[this.rhEvents[-COI.OBJ_GAME] + 1];
				if (num != 0)
				{
					this.listPointers[this.rhEvents[-COI.OBJ_GAME] + 1] = -1;
					this.computeEventList(num, null);
					this.rh4CheckDoneInstart = true;
				}
				return;
			}

			num = this.listPointers[this.rhEvents[-COI.OBJ_TIMER] + 3];
			if (num != 0)
			{
				this.computeEventList(num, null);
			}

			num = this.listPointers[this.rhEvents[-COI.OBJ_GAME] + 1];
			var num2, count;
			var evgPtr, evgGroup;
			var evtPtr;
			if (num != 0)
			{
				if (this.rh4CheckDoneInstart)
				{
					evgGroup = null;
					num2 = num;
					do
					{
						evgPtr = this.eventPointersGroup[num2];
						if (evgPtr != evgGroup)
						{
							evgGroup = evgPtr;

							for (count = evgPtr.evgNCond; count < evgPtr.evgNCond + evgPtr.evgNAct; count++)
							{
								evtPtr = evgPtr.evgEvents[count];
								if ((evtPtr.evtFlags & CEvent.EVFLAGS_NOTDONEINSTART) == 0)		// Une action BAD?
								{
									evtPtr.evtFlags |= CEvent.EVFLAGS_DONEBEFOREFADEIN;
								}
							}
						}
						num2++;
					} while (this.eventPointersGroup[num2] != null);
				}
				this.computeEventList(num, null);
				this.listPointers[this.rhEvents[-COI.OBJ_GAME] + 1] = 0;
				if (this.rh4CheckDoneInstart)
				{
					evgGroup = null;
					num2 = num;
					do
					{
						evgPtr = this.eventPointersGroup[num2];
						if (evgPtr != evgGroup)
						{
							evgGroup = evgPtr;
							for (count = evgPtr.evgNCond; count < evgPtr.evgNCond + evgPtr.evgNAct; count++)
							{
								evtPtr = evgPtr.evgEvents[count];
								evtPtr.evtFlags &= ~CEvent.EVFLAGS_DONEBEFOREFADEIN;
							}
						}
						num2++;
					} while (this.eventPointersGroup[num2] != null);
					this.rh4CheckDoneInstart = false;
				}
			}

			num = this.listPointers[this.rhEvents[-COI.OBJ_TIMER] + 2];
			if (num != 0)
			{
				this.computeEventList(num, null);
			}

			num = this.listPointers[this.rhEvents[-COI.OBJ_TIMER] + 1];
			if (num != 0)
			{
				this.computeEventList(num, null);
			}
		},

		restartTimerEvents: function ()
		{
			var time = this.rhPtr.rhTimer;

			var num = this.listPointers[this.rhEvents[-COI.OBJ_TIMER] + 3];
			var evtPtr;
			var evgPtr;
			if (num != 0)
			{
				do
				{
					evgPtr = this.eventPointersGroup[num];
					evtPtr = evgPtr.evgEvents[this.eventPointersCnd[num]];
					evtPtr.evtFlags |= CEvent.EVFLAGS_DONE;
					var p = evtPtr.evtParams[0];
					if (p.timer > time)
					{
						evtPtr.evtFlags &= ~CEvent.EVFLAGS_DONE;
					}
					num++;
				} while (this.eventPointersGroup[num] != null);
			}
		},

		computeEventFastLoopList: function (pointers)
		{
			var evgPtr;
			var count;
			var num = 0;
			do
			{
				evgPtr = pointers[num];
				if ((evgPtr.evgFlags & CEventGroup.EVGFLAGS_INACTIVE) == 0)
				{
					this.rhEventGroup = evgPtr;
					this.rh4PickFlags[0] = 0;
					this.rh4PickFlags[1] = 0;
					this.rh4PickFlags[2] = 0;
					this.rh4PickFlags[3] = 0;
					this.rh2EventCount += 1;
					this.rh4ConditionsFalse = false;

					for (count = 1; count < evgPtr.evgNCond; count++)
					{
							if (evgPtr.evgEvents[count].eva2(this.rhPtr) == false)
							{
								break;
							}
					}

					if (count == evgPtr.evgNCond)
					{
						this.call_Actions(evgPtr);
					}
				}
				num++;
			} while (num < pointers.length)
		},

		computeEventList: function (num, pHo)
		{
			var bTrue;
			var evgPtr, evgPtr2;
			var count;
			this.rh3DoStop = false;
			do
			{
				evgPtr = this.eventPointersGroup[num];

				if ((evgPtr.evgFlags & CEventGroup.EVGFLAGS_INACTIVE) == 0)
				{
					this.rhEventGroup = evgPtr;
					this.rh4PickFlags[0] = 0;
					this.rh4PickFlags[1] = 0;
					this.rh4PickFlags[2] = 0;
					this.rh4PickFlags[3] = 0;

					if ((evgPtr.evgFlags & CEventGroup.EVGFLAGS_ORINGROUP) == 0)
					{
						this.rh2EventCount += 1;
						this.rh4ConditionsFalse = false;

						count = 0;
							if (evgPtr.evgEvents[count].eva1(this.rhPtr, pHo))
							{
								for (count++; count < evgPtr.evgNCond; count++)
								{
										if (evgPtr.evgEvents[count].eva2(this.rhPtr) == false)
										{
											break;
										}
								}
							}

						if (count == evgPtr.evgNCond)
						{
							if (this.rh3DoStop)
							{
								if (pHo != null)
								{
									this.call_Stops(pHo);
								}
							}
							else
							{
								this.call_Actions(evgPtr);
								if ( (evgPtr.evgFlags & CEventGroup.EVGFLAGS_BREAK) != 0 )
								{
								    break;
								}
	                        }
						}
						num++;
					}
					else
					{
						this.rh4EventCountOR++;
						if ((evgPtr.evgFlags & CEventGroup.EVGFLAGS_ORLOGICAL) == 0)
						{
							bTrue = false;
							do
							{
								this.rh2EventCount++;
								this.rh4ConditionsFalse = false;
								count = this.eventPointersCnd[num];
									if (evgPtr.evgEvents[count].eva1(this.rhPtr, pHo) == false)
									{
										this.rh4ConditionsFalse = true;
									}

								count++;
								while (count < evgPtr.evgNCond && evgPtr.evgEvents[count].evtCode != ((-24 << 16) | 65535))
								{
										if (evgPtr.evgEvents[count].eva2(this.rhPtr) == false)
										{
											this.rh4ConditionsFalse = true;
										}
									count++;
								}

								this.evt_MarkSelectedObjects();
								if (this.rh4ConditionsFalse == false)
								{
									bTrue = true;
								}

								num++;
								evgPtr = this.eventPointersGroup[num];
								if (evgPtr == null)
								{
									break;
								}
							} while (evgPtr == this.rhEventGroup);

							if (bTrue)
							{
								this.rh2EventCount++;
								this.evt_BranchSelectedObjects();
								var bBreak = ((this.rhEventGroup.evgFlags & CEventGroup.EVGFLAGS_BREAK) != 0);
								this.call_Actions(this.rhEventGroup);
								if ( bBreak ) {
								    break;
								}
	                        }
						}
						else
						{
							var bFalse;
							this.rh4ConditionsFalse = false;

							bTrue = false;
							do
							{
								this.rh2EventCount++;
								bFalse = false;
								count = this.eventPointersCnd[num];

									if (evgPtr.evgEvents[count].eva1(this.rhPtr, pHo))
									{
										count++;
										while (count < evgPtr.evgNCond && evgPtr.evgEvents[count].evtCode != ((-25 << 16) | 65535))
										{
												if (evgPtr.evgEvents[count].eva2(this.rhPtr) == false)
												{
													bFalse = true;
													break;
												}
											count++;
										}
									}
									else
									{
										bFalse = true;
									}
								if (bFalse == false)
								{
									this.evt_MarkSelectedObjects();
									bTrue = true;
								}

								num++;
								evgPtr = this.eventPointersGroup[num];
								if (evgPtr == null)
								{
									break;
								}

							} while (evgPtr == this.rhEventGroup);

							if (bTrue)
							{
								this.rh2EventCount++;
								this.evt_BranchSelectedObjects();
								var bBreak = ((this.rhEventGroup.evgFlags & CEventGroup.EVGFLAGS_BREAK) != 0);
								this.call_Actions(this.rhEventGroup);
								if ( bBreak ) {
								    break;
								}
	                        }
						}
					}
				}
				else
				{
					num++;
					if (this.eventPointersGroup[num] != null)
					{
						evgPtr2 = this.eventPointersGroup[num];
						while (evgPtr2 == evgPtr)
						{
							num++;
							if (this.eventPointersGroup[num] == null)
							{
								break;
							}
							evgPtr2 = this.eventPointersGroup[num];
						}
					}
				}
			} while (this.eventPointersGroup[num] != null);
		},

		call_Actions: function (pEvg)
		{
		    this.childEventParam = null;
		    if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_LIMITED) != 0)
			{
				if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_SHUFFLE) != 0)
				{
					this.rh2ShuffleBuffer = new CArrayList();
				}

				if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_NOTALWAYS) != 0)
				{
					var w_cx = this.rhPtr.rhLoopCount;
					var w_dx = pEvg.evgInhibit;
					pEvg.evgInhibit = w_cx;
					if (w_cx == w_dx)
					{
						return;
					}
					w_cx -= 1;
					if (w_cx == w_dx)
					{
						return;
					}
				}

				if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_REPEAT) != 0)
				{
					if (pEvg.evgInhibitCpt != 0)
					{
						pEvg.evgInhibitCpt--;
					}
					else
					{
						return;
					}
				}

				if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_NOMORE) != 0)
				{
					var dwt = this.rhPtr.rhTimer / 10;
					var dwmax = pEvg.evgInhibitCpt;
					if (dwmax != 0 && dwt < dwmax)
					{
						return;
					}
					pEvg.evgInhibitCpt = (dwt + pEvg.evgInhibit);
				}
			}


			this.rh2ActionCount++;
			this.rh2ActionLoop = false;
			this.rh2ActionLoopCount = 0;
			this.rh2ActionOn = true;
			var count = 0;
			var actPtr;
			do
			{
				actPtr = pEvg.evgEvents[count + pEvg.evgNCond];
				if ((actPtr.evtFlags & (CEvent.EVFLAGS_BADOBJECT | CEvent.EVFLAGS_DONEBEFOREFADEIN)) == 0)
				{
					actPtr.evtFlags &= ~CAct.ACTFLAGS_REPEAT;
					actPtr.execute(this.rhPtr);
				}
				count++;
			} while (count < pEvg.evgNAct);

			if (this.rh2ActionLoop)
			{
				do
				{
					this.rh2ActionLoop = false;
					this.rh2ActionLoopCount++;
					for (count = 0; count < pEvg.evgNAct; count++)
					{
						actPtr = pEvg.evgEvents[count + pEvg.evgNCond];
						if ((actPtr.evtFlags & CAct.ACTFLAGS_REPEAT) != 0)
						{
							actPtr.evtFlags &= ~CAct.ACTFLAGS_REPEAT;
							actPtr.execute(this.rhPtr);
						}
					}
				} while (this.rh2ActionLoop);
			}

			var tempChildEventParam = this.childEventParam;
			if ((pEvg.evgFlags & CEventGroup.EVGFLAGS_BREAK) != 0 && (pEvg.evgFlags & CEventGroup.EVGFLAGS_HASPARENT) != 0)
				tempChildEventParam = null;
			this.childEventParam = null;
			this.rh2ActionOn = false;
			if (this.rh2ShuffleBuffer != null)
				this.endShuffle();
			if (this.callEndForEach)
				this.endForEach();
			if (tempChildEventParam)
			    this.executeChildEvents(tempChildEventParam);
		},

		call_Stops: function (pHo)
		{
			var oi;

			oi = pHo.hoOi;
			this.rh2EventCount += 1;
			this.evt_AddCurrentObject(pHo);

			this.rh2ActionCount++;
			this.rh2ActionLoop = false;
			this.rh2ActionLoopCount = 0;
			this.rh2ActionOn = true;
			var actPtr;
			var count = 0;
			var num, numOi;
			do
			{
				actPtr = this.rhEventGroup.evgEvents[this.rhEventGroup.evgNCond + count];
				num = actPtr.evtCode & 0xFFFF0000;
				if (num == (4 << 16) || num == (9 << 16))
				{
					if (oi == actPtr.evtOi)
					{
						actPtr.execute(this.rhPtr);
					}
					else
					{
						var oil = actPtr.evtOiList;
						if ((oil & 0x8000) != 0)
						{
							var pq = this.qualToOiList[oil & 0x7FFF];
							numOi = 0;
							while (numOi < pq.qoiList.length)
							{
								if (pq.qoiList[numOi] == oi)
								{
									actPtr.execute(this.rhPtr);
									break;
								}
								numOi += 2;
							}
						}
					}
				}
				count++;
			} while (count < this.rhEventGroup.evgNAct);
			this.rh2ActionOn = false;
		},

		endShuffle: function ()
		{
			if (this.rh2ShuffleBuffer.size() <= 1)
			{
				return;
			}

			var num1 = this.rhPtr.random(this.rh2ShuffleBuffer.size());
			var num2;
			do
			{
				num2 = this.rhPtr.random(this.rh2ShuffleBuffer.size());
			} while (num1 == num2);

			var pHo1 = this.rh2ShuffleBuffer.get(num1);
			var pHo2 = this.rh2ShuffleBuffer.get(num2);

			var x1 = pHo1.hoX;
			var y1 = pHo1.hoY;
			var x2 = pHo2.hoX;
			var y2 = pHo2.hoY;
			CRun.setXPosition(pHo1, x2);
			CRun.setYPosition(pHo1, y2);
			CRun.setXPosition(pHo2, x1);
			CRun.setYPosition(pHo2, y1);
			this.rh2ShuffleBuffer = null;
		},

		onMouseButton: function (b, nClicks)
		{
			var mouse;
			this.rhPtr.getMouseCoords();

			if (this.rhPtr == null)
			{
				return;
			}
			if (this.rhPtr.rh2PauseCompteur != 0)
			{
				return;
			}
			if (this.bReady == false)
			{
				return;
			}

			mouse = b;
			if (nClicks == 2)
			{
				mouse += CEventProgram.PARAMCLICK_DOUBLE;
			}

			this.rhPtr.rh4TimeOut = 0;
			if ((this.rhPtr.rhMouseUsed) != 0)
			{
				return;
			}

			this.rhCurParam0 = mouse;
			this.rh2CurrentClick = mouse;
			this.handle_GlobalEvents(((-5 << 16) | 0xFFFA));
			this.handle_GlobalEvents(((-6 << 16) | 0xFFFA));

			var count = 0;
			var i;
			var pHox;
			var x1, y1, x2, y2;
			var list = new CArrayList();
			for (i = 0; i < this.rhPtr.rhNObjects; i++)
			{
				while (this.rhPtr.rhObjectList[count] == null)
					count++;
				pHox = this.rhPtr.rhObjectList[count];
				count++;

				x1 = pHox.hoX - pHox.hoImgXSpot;
				y1 = pHox.hoY - pHox.hoImgYSpot;
				x2 = x1 + pHox.hoImgWidth;
				y2 = y1 + pHox.hoImgHeight;
				if (this.rhPtr.rh2MouseX >= x1 && this.rhPtr.rh2MouseX < x2 && this.rhPtr.rh2MouseY >= y1 && this.rhPtr.rh2MouseY < y2)
				{
				    if ((pHox.hoLimitFlags & CObjInfo.OILIMITFLAGS_QUICKCOL) != 0 && (pHox.hoFlags & CObject.HOF_DESTROYED) == 0)
					{
						if (pHox.hoType == COI.OBJ_SPR)
						{
							if ((pHox.ros.rsFlags & CRSpr.RSFLAG_COLBOX) == 0)
							{
								var image = this.application.imageBank.getImageFromHandle(pHox.roc.rcImage);
							    var mask = image.getMask(CMask.GCMF_OBSTACLE, 0, 1.0, 1.0);
							    if (mask.testPointEx(this.rhPtr.rh2MouseX - pHox.hoX, this.rhPtr.rh2MouseY - pHox.hoY, pHox.roc.rcAngle, pHox.roc.rcScaleX, pHox.roc.rcScaleY))
								{
									list.add(pHox);
								}
							}
							else
							{
								list.add(pHox);
							}
						}
						else
						{
							list.add(pHox);
						}
					}
				}
			}
			for (count = 0; count < list.size(); count++)
			{
				pHox = list.get(count);
				this.rhCurParam1 = pHox.hoOi;
				this.rh4_2ndObject = pHox;
				this.handle_GlobalEvents(((-7 << 16) | 0xFFFA));
			}
		},

		onKeyDown: function (vk)
		{
			if (this.rhPtr != null)
			{
				if (this.bReady == false)
				{
					return;
				}
				/*
				 if (this.rhPtr.rh2PauseCompteur != 0)
				 {
				 if (this.rhPtr.rh4PauseKey == -1)
				 {
				 this.rhPtr.resume();
				 this.rhPtr.rh4EndOfPause = this.rhPtr.rhLoopCount;	    
				 this.handle_GlobalEvents(((-8 << 16) | 0xFFFD));	
				 }
				 if (this.rhPtr.rh4PauseKey != 0 && this.rhPtr.rh4PauseKey == vk)
				 {
				 this.rhPtr.resume();
				 this.rhPtr.rh4EndOfPause = this.rhPtr.rhLoopCount;	    
				 this.handle_GlobalEvents(((-8 << 16) | 0xFFFD));	    
				 }
				 return;
				 }
				 */
				this.rhPtr.rh4TimeOut = 0;
				this.handle_GlobalEvents(((-9 << 16) | 0xFFFA));
			}
		},

		onMouseMove: function ()
		{
			if (this.bReady == false)
				return;
			if (this.rhPtr.rh2PauseCompteur != 0)
				return;
			this.rhPtr.rh4TimeOut = 0;
		},

		ctoCompare: function (pZone, pHo)
		{
			if (pHo.hoImgWidth == 0 || pHo.hoImgHeight == 0)
			{
				return false;
			}
			if (pHo.hoX < pZone.x1 || pHo.hoX >= pZone.x2)
			{
				return false;
			}
			if (pHo.hoY < pZone.y1 || pHo.hoY >= pZone.y2)
			{
				return false;
			}
			return true;
		},

		count_ZoneTypeObjects: function (pZone, stop, type)
		{
			stop++;
			this.evtNSelectedObjects = 0;

			var oil = 0;
			var poilLoop = null;
			var pHo;
			var num;
			do
			{
				for (; oil < this.rhPtr.rhOiList.length; oil++)
				{
					poilLoop = this.rhPtr.rhOiList[oil];
					if (type == 0 || (type != 0 && type == poilLoop.oilType))
					{
						break;
					}
				}
				if (oil == this.rhPtr.rhOiList.length)
				{
					return null;
				}

				var poil = poilLoop;
				oil++;

				if (poil.oilEventCount != this.rh2EventCount)
				{
					if (this.rh4ConditionsFalse == false)
					{
						num = poil.oilObject;
						while ((num & 0x80000000) == 0)
						{
							pHo = this.rhPtr.rhObjectList[num];
							if (pHo == null)
							{
								return null;
							}
							if ((pHo.hoFlags & CObject.HOF_DESTROYED) == 0)
							{
								if (this.ctoCompare(pZone, pHo))
								{
									this.evtNSelectedObjects++;
									if (this.evtNSelectedObjects == stop)
									{
										return pHo;
									}
								}
							}
							num = pHo.hoNumNext;
						}
					}
				}
				else
				{
					num = poil.oilListSelected;
					while ((num & 0x80000000) == 0)
					{
						pHo = this.rhPtr.rhObjectList[num];
						if (pHo == null)
						{
							return null;
						}
						if ((pHo.hoFlags & CObject.HOF_DESTROYED) == 0)
						{
							if (this.ctoCompare(pZone, pHo))
							{
								this.evtNSelectedObjects++;
								if (this.evtNSelectedObjects == stop)
								{
									return pHo;
								}
							}
						}
						num = pHo.hoNextSelected;
					}
				}
			} while (true);
		},

		count_ObjectsFromType: function (type, stop)
		{
			stop++;
			this.evtNSelectedObjects = 0;

			var oil = 0;
			var poilLoop = null;
			var pHo;
			var num;

			do
			{
				for (; oil < this.rhPtr.rhOiList.length; oil++)
				{
					poilLoop = this.rhPtr.rhOiList[oil];
					if (type == 0 || (type != 0 && type == poilLoop.oilType))
					{
						break;
					}
				}
				if (oil == this.rhPtr.rhOiList.length)
				{
					return null;
				}

				var poil = poilLoop;
				oil++;

				if (poil.oilEventCount != this.rh2EventCount)
				{
					if (this.rh4ConditionsFalse == false)
					{
						num = poil.oilObject;
						while ((num & 0x80000000) == 0)
						{
							pHo = this.rhPtr.rhObjectList[num];
							if (pHo == null)
							{
								return null;
							}
							if ((pHo.hoFlags & CObject.HOF_DESTROYED) == 0)
							{
								this.evtNSelectedObjects++;
								if (this.evtNSelectedObjects == stop)
								{
									return pHo;
								}
							}
							num = pHo.hoNumNext;
						}
					}
				}
				else
				{
					num = poil.oilListSelected;
					while ((num & 0x80000000) == 0)
					{
						pHo = this.rhPtr.rhObjectList[num];
						if (pHo == null)
						{
							return null;
						}
						if ((pHo.hoFlags & CObject.HOF_DESTROYED) == 0)
						{
							this.evtNSelectedObjects++;
							if (this.evtNSelectedObjects == stop)
							{
								return pHo;
							}
						}
						num = pHo.hoNextSelected;
					}
				}
			} while (true);
		},

		czaCompare: function (pZone, pHo)
		{
			if (pHo.hoX < pZone.x1 || pHo.hoX >= pZone.x2)
			{
				return false;
			}
			if (pHo.hoY < pZone.y1 || pHo.hoY >= pZone.y2)
			{
				return false;
			}
			return true;
		},

		select_ZoneTypeObjects: function (p, type)
		{
			var cpt = 0;

			var oil = 0;
			var poilLoop = null;
			var pHoLoop, pHoFound;
			var num;
			do
			{
				for (; oil < this.rhPtr.rhOiList.length; oil++)
				{
					poilLoop = this.rhPtr.rhOiList[oil];
					if (type == 0 || (type != 0 && type == poilLoop.oilType))
					{
						break;
					}
				}
				if (oil == this.rhPtr.rhOiList.length)
				{
					return cpt;
				}

				var poil = poilLoop;
				oil++;

				if (poil.oilEventCount != this.rh2EventCount)
				{
					pHoLoop = null;
					poil.oilNumOfSelected = 0;
					poil.oilEventCount = this.rh2EventCount;
					poil.oilListSelected = -1;
					if (this.rh4ConditionsFalse == false)
					{
						num = poil.oilObject;
						while ((num & 0x80000000) == 0)
						{
							pHoFound = this.rhPtr.rhObjectList[num];
							if (pHoFound == null)
							{
								break;
							}
							if ((pHoFound.hoFlags & CObject.HOF_DESTROYED) == 0)
							{
								if (this.czaCompare(p, pHoFound))
								{
									cpt++;
									poil.oilNumOfSelected++;
									pHoFound.hoNextSelected = -1;
									if (pHoLoop == null)
									{
										poil.oilListSelected = pHoFound.hoNumber;
									}
									else
									{
										pHoLoop.hoNextSelected = pHoFound.hoNumber;
									}
									pHoLoop = pHoFound;
								}
							}
							num = pHoFound.hoNumNext;
						}
						;
					}
					continue;
				}

				pHoLoop = null;
				num = poil.oilListSelected;
				while ((num & 0x80000000) == 0)
				{
					pHoFound = rhPtr.rhObjectList[num];
					if (pHoFound == null)
					{
						break;
					}
					if ((pHoFound.hoFlags & CObject.HOF_DESTROYED) == 0)
					{
						if (this.czaCompare(p, pHoFound) == false)
						{
							poil.oilNumOfSelected--;
							if (pHoLoop == null)
							{
								poil.oilListSelected = pHoFound.hoNextSelected;
							}
							else
							{
								pHoLoop.hoNextSelected = pHoFound.hoNextSelected;
							}
						}
						else
						{
							cpt++;
							pHoLoop = pHoFound;
						}
					}
					num = pHoFound.hoNextSelected;
				}
				;
				continue;
			} while (true);
		},

		losCompare: function (x1, y1, x2, y2, pHo)
		{
			var delta;
			var x, y;

			var xLeft = pHo.hoX - pHo.hoImgXSpot;
			var xRight = xLeft + pHo.hoImgWidth;
			var yTop = pHo.hoY - pHo.hoImgYSpot;
			var yBottom = yTop + pHo.hoImgHeight;

			if (x2 - x1 > y2 - y1)
			{
				delta = (y2 - y1) / (x2 - x1);
				if (x2 > x1)
				{
					if (xRight < x1 || xLeft >= x2)
					{
						return false;
					}
				}
				else
				{
					if (xRight < x2 || xLeft >= x1)
					{
						return false;
					}
				}
				y = delta * (xLeft - x1) + y1;
				if (y >= yTop && y < yBottom)
				{
					return true;
				}

				y = delta * (xRight - x1) + y1;
				if (y >= yTop && y < yBottom)
				{
					return true;
				}

				return false;
			}
			else
			{
				delta = (x2 - x1) / (y2 - y1);
				if (y2 > y1)
				{
					if (yBottom < y1 || yTop >= y2)
					{
						return false;
					}
				}
				else
				{
					if (yBottom < y2 || yTop >= y1)
					{
						return false;
					}
				}
				x = delta * (yTop - y1) + x1;
				if (x >= xLeft && x < xRight)
				{
					return true;
				}

				x = delta * (yTop - y1) + x1;
				if (x >= xLeft && x < xRight)
				{
					return true;
				}

				return false;
			}
		},

		select_LineOfSight: function (x1, y1, x2, y2)
		{
			var cpt = 0;

			var poil;
			var oil;
			var pHoLoop, pHoFound;
			var num;
			for (oil = 0; oil < this.rhPtr.rhOiList.length; oil++)
			{
				poil = this.rhPtr.rhOiList[oil];
				if (poil.oilEventCount != this.rh2EventCount)
				{
					pHoLoop = null;
					poil.oilNumOfSelected = 0;
					poil.oilEventCount = this.rh2EventCount;
					poil.oilListSelected = -1;

					if (this.rh4ConditionsFalse == false)
					{
						num = poil.oilObject;
						while ((num & 0x80000000) == 0)
						{
							pHoFound = this.rhPtr.rhObjectList[num];
							if (pHoFound == null)
							{
								break;
							}
							if ((pHoFound.hoFlags & CObject.HOF_DESTROYED) == 0)
							{
								if (this.losCompare(x1, y1, x2, y2, pHoFound))
								{
									cpt++;
									poil.oilNumOfSelected++;
									pHoFound.hoNextSelected = -1;
									if (pHoLoop == null)
									{
										poil.oilListSelected = pHoFound.hoNumber;
									}
									else
									{
										pHoLoop.hoNextSelected = pHoFound.hoNumber;
									}
									pHoLoop = pHoFound;
								}
							}
							num = pHoFound.hoNumNext;
						}
					}
					continue;
				}

				pHoLoop = null;
				num = poil.oilListSelected;
				while ((num & 0x80000000) == 0)
				{
					pHoFound = this.rhPtr.rhObjectList[num];
					if (pHoFound == null)
					{
						break;
					}
					if ((pHoFound.hoFlags & CObject.HOF_DESTROYED) == 0)
					{
						if (this.losCompare(x1, y1, x2, y2, pHoFound) == false)
						{
							poil.oilNumOfSelected--;
							if (pHoLoop == null)
							{
								poil.oilListSelected = pHoFound.hoNextSelected;
							}
							else
							{
								pHoLoop.hoNextSelected = pHoFound.hoNextSelected;
							}
						}
						else
						{
							cpt++;
							pHoLoop = pHoFound;
						}
					}
					num = pHoFound.hoNextSelected;
				}

			}
			return cpt;
		},

		czoCountThem: function (oil, pZone)
		{
			var count = 0;
			var poil = this.rhPtr.rhOiList[oil];
			var pHo;
			var num;

			if (poil.oilEventCount != this.rh2EventCount)
			{
				if (this.rh4ConditionsFalse == false)
				{
					num = poil.oilObject;
					while ((num & 0x80000000) == 0)
					{
						pHo = this.rhPtr.rhObjectList[num];
						if (pHo == null)
						{
							return 0;
						}
						if ((pHo.hoFlags & CObject.HOF_DESTROYED) == 0)
						{
							if (this.czaCompare(pZone, pHo))
							{
								count++;
							}
						}
						num = pHo.hoNumNext;
					}
				}
				return count;
			}

			num = poil.oilListSelected;
			while ((num & 0x80000000) == 0)
			{
				pHo = this.rhPtr.rhObjectList[num];
				if (pHo == null)
				{
					return 0;
				}
				if ((pHo.hoFlags & CObject.HOF_DESTROYED) == 0)
				{
					if (this.czaCompare(pZone, pHo))
					{
						count++;
					}
				}
				num = pHo.hoNextSelected;
			}
			return count;
		},

		count_ZoneOneObject: function (oil, pZone)
		{
			if ((oil & 0x8000) == 0)
			{
				return this.czoCountThem(oil, pZone);
			}

			if ((oil & 0x7FFF) == 0x7FFF)
			{
				return 0;
			}
			var pqoi = this.qualToOiList[oil & 0x7FFF];
			var qoi;
			var count = 0;
			for (qoi = 0; qoi < pqoi.qoiList.length; qoi += 2)
			{
				count += this.czoCountThem(pqoi.qoiList[qoi + 1], pZone);
			}
			return count;
		},

		countThem: function (oil, stop)
		{
			var poil = this.rhPtr.rhOiList[oil];
			var pHo;
			var num;

			if (poil.oilEventCount != this.rh2EventCount)
			{
				if (this.rh4ConditionsFalse)
				{
					this.evtNSelectedObjects = 0;
					return null;
				}

				num = poil.oilObject;
				while ((num & 0x80000000) == 0)
				{
					pHo = this.rhPtr.rhObjectList[num];
					if (pHo == null)
					{
						return null;
					}
					if ((pHo.hoFlags & CObject.HOF_DESTROYED) == 0)
					{
						this.evtNSelectedObjects++;
						if (this.evtNSelectedObjects == stop)
						{
							return pHo;
						}
					}
					num = pHo.hoNumNext;
				}
				return null;
			}

			num = poil.oilListSelected;
			while ((num & 0x80000000) == 0)
			{
				pHo = this.rhPtr.rhObjectList[num];
				if (pHo == null)
				{
					return null;
				}
				if ((pHo.hoFlags & CObject.HOF_DESTROYED) == 0)
				{
					this.evtNSelectedObjects++;
					if (this.evtNSelectedObjects == stop)
					{
						return pHo;
					}
				}
				num = pHo.hoNextSelected;
			}
			return null;
		},

		count_ObjectsFromOiList: function (oil, stop)
		{
			stop++;
			this.evtNSelectedObjects = 0;
			if ((oil & 0x8000) == 0)
			{
				return this.countThem(oil, stop);
			}

			if ((oil & 0x7FFF) == 0x7FFF)
			{
				return null;
			}
			var pqoi = this.qualToOiList[oil & 0x7FFF];
			var qoi;
			for (qoi = 0; qoi < pqoi.qoiList.length; qoi += 2)
			{
				var pHo = this.countThem(pqoi.qoiList[qoi + 1], stop);
				if (pHo != null)
				{
					return pHo;
				}
			}
			return null;
		},

		pickFromId: function (value)
		{
			var number = value & 0xFFFF;
			if (number >= this.rhPtr.rhMaxObjects)
			{
				return false;
			}
			var pHo = this.rhPtr.rhObjectList[number];
			if (pHo == null)
			{
				return false;
			}

			var code = value >>> 16;
			if (code != pHo.hoCreationId)
			{
				return false;
			}

			var poil = pHo.hoOiList;
			if (poil.oilEventCount == this.rh2EventCount)
			{
				var next = poil.oilListSelected;
				var pHoFound = null;
				while ((next & 0x80000000) == 0)
				{
					pHoFound = this.rhPtr.rhObjectList[next];
					if (pHo == pHoFound)
					{
						break;
					}
					next = pHoFound.hoNextSelected;
				}
				;
				if (pHo != pHoFound)
				{
					return false;
				}
			}
			poil.oilEventCount = this.rh2EventCount;
			poil.oilListSelected = -1;
			poil.oilNumOfSelected = 0;
			pHo.hoNextSelected = -1;
			this.evt_AddCurrentObject(pHo);
			return true;
		},

		push_Event: function (routine, code, lParam, pHo, oi)
		{
			var p = new CPushedEvent(routine, code, lParam, pHo, oi);
			if (this.rh2PushedEvents == null)
			{
				this.rh2PushedEvents = new CArrayList();
			}
			this.rh2PushedEvents.add(p);
		},

		handle_PushedEvents: function ()
		{
			if (this.rh2PushedEvents != null)
			{
				var index;
				for (index = 0; index < this.rh2PushedEvents.size(); index++)
				{
					var pEvt = this.rh2PushedEvents.get(index);
					if (pEvt != null)
					{
						if (pEvt.code != 0)
						{
							this.rhCurParam0 = pEvt.param;
							this.rhCurOi = pEvt.oi;
							switch (pEvt.routine)
							{
								case 0:
									this.handle_GlobalEvents(pEvt.code);
									break;
								case 1:
									this.handle_Event(pEvt.pHo, pEvt.code);
									break;
							}
						}
					}
				}
				this.rh2PushedEvents.clear();
			}
		},

		load: function (app)
		{

			var code = new Array(4);
			var number;
			var n;
			var eventPos = 0;
			while (true)
			{
				var code = app.file.readBuffer(4);

				if (code[0] == 0x45 && code[1] == 0x52 && code[2] == 0x3E && code[3] == 0x3E)
				{
					this.maxObjects = app.file.readAShort();
					if (this.maxObjects < 300)
					{
						this.maxObjects = 300;
					}
					this.maxOi = app.file.readAShort();
					this.nPlayers = app.file.readAShort();
					for (n = 0; n < 7 + COI.OBJ_LAST; n++)
					{
						this.nConditions[n] = app.file.readAShort();
					}
					this.nQualifiers = app.file.readAShort();
					if (this.nQualifiers > 0)
					{
						this.qualifiers = new Array(this.nQualifiers);
						for (n = 0; n < this.nQualifiers; n++)
						{
							this.qualifiers[n] = new CLoadQualifiers();
							this.qualifiers[n].qOi = app.file.readShort();
							this.qualifiers[n].qType = app.file.readShort();
						}
					}
				}
				else if (code[0] == 0x45 && code[1] == 0x52 && code[2] == 0x65 && code[3] == 0x73)
				{
					app.file.readAInt();
					this.nEvents = app.file.readAInt();
					this.events = new Array(this.nEvents);
					this.eventPos = 0;
				}
				else if (code[0] == 0x45 && code[1] == 0x52 && code[2] == 0x65 && code[3] == 0x76)
				{
					app.file.readAInt();
					number = app.file.readAInt();
					for (n = 0; n < number; n++)
					{
						this.events[eventPos] = CEventGroup.create(app);
						eventPos++;
					}
				}
				else if (code[0] == 0x45 && code[1] == 0x52 && code[2] == 0x6F && code[3] == 0x70)
				{
				    var options = app.file.readAInt();
				    if ((options & CEventProgram.EVENTOPTION_BREAKCHILD) != 0)
				    {
				        this.defaultEvgFlagsMask |= CEventGroup.EVGFLAGS_BREAK;
				    }
				}
				else if (code[0] == 0x3C && code[1] == 0x3C && code[2] == 0x45 && code[3] == 0x52)
				{
					break;
				}
	        }
			this.maxEvents = Math.max(this.maxEvents, eventPos);
		},

		inactiveGroup: function (evg)
		{
			var bQuit;
			var evgPtr;
			var evtPtr;
			var grpPtr;

			evgPtr = this.events[evg];
			evgPtr.evgFlags &= this.defaultEvgFlagsMask;
			evgPtr.evgFlags |= CEventGroup.EVGFLAGS_INACTIVE;

			for (evg++  , bQuit = false; ;)
			{
				evgPtr = this.events[evg];
				evgPtr.evgFlags &= this.defaultEvgFlagsMask;
				evgPtr.evgFlags |= CEventGroup.EVGFLAGS_INACTIVE;

				evtPtr = evgPtr.evgEvents[0];
				switch (evtPtr.evtCode)
				{
					case ((-10 << 16) | 65535):		// CNDL_GROUP:
						grpPtr = evtPtr.evtParams[0];
						grpPtr.grpFlags |= PARAM_GROUP.GRPFLAGS_PARENTINACTIVE;
						evg = this.inactiveGroup(evg);
						continue;
					case ((-11 << 16) | 65535):		// CNDL_ENDGROUP:
						bQuit = true;
						evg++;
						break;
				}
				if (bQuit)
				{
					break;
				}
				evg++;
			}
			return evg;
		},

		prepareProgram: function ()
		{
			var evgPtr;
			var evtPtr;
			var grpPtr;
			var evpPtr;
			var evg, evt, evp;
			var groups = new CArrayList();
			var g;

			for (evg = 0; evg < this.events.length;)
			{
				evgPtr = this.events[evg];
				evgPtr.evgFlags &= this.defaultEvgFlagsMask;

				evtPtr = evgPtr.evgEvents[0];
				if (evtPtr.evtCode == ((-10 << 16) | 65535))
				{
					grpPtr = evtPtr.evtParams[0];
					g = new CGroupFind();
					g.id = grpPtr.grpId;
					g.evg = evg;
					groups.add(g);
					grpPtr.grpFlags &= ~(PARAM_GROUP.GRPFLAGS_PARENTINACTIVE | PARAM_GROUP.GRPFLAGS_GROUPINACTIVE);

					if ((grpPtr.grpFlags & PARAM_GROUP.GRPFLAGS_INACTIVE) != 0)
					{
						grpPtr.grpFlags |= PARAM_GROUP.GRPFLAGS_GROUPINACTIVE;
					}
				}
				evg++;
			}

			for (evg = 0; evg < this.events.length;)
			{
				evgPtr = this.events[evg];
				evgPtr.evgFlags &= this.defaultEvgFlagsMask;

				evtPtr = evgPtr.evgEvents[0];
				if (evtPtr.evtCode == ((-10 << 16) | 65535))
				{
					grpPtr = evtPtr.evtParams[0];
					grpPtr.grpFlags &= ~PARAM_GROUP.GRPFLAGS_PARENTINACTIVE;

					if ((grpPtr.grpFlags & PARAM_GROUP.GRPFLAGS_GROUPINACTIVE) != 0)
					{
						evg = this.inactiveGroup(evg);
						continue;
					}
				}
				evg++;
			}

			for (evg = 0; evg < this.events.length; evg++)
			{
				evgPtr = this.events[evg];
				evtPtr = evgPtr.evgEvents[0];
				switch (evtPtr.evtCode)
				{
					case ((-10 << 16) | 65535):	    // CNDL_GROUP
					case ((-11 << 16) | 65535):	    // CNDL_ENDGROUP
						break;

					default:
						evgPtr.evgInhibit = 0;
						evgPtr.evgInhibitCpt = 0;
						for (evt = 0; evt < evgPtr.evgNCond + evgPtr.evgNAct; evt++)
						{
							evtPtr = evgPtr.evgEvents[evt];
							if (evtPtr.evtCode < 0)
							{
								evtPtr.evtFlags &= CEvent.EVFLAGS_DEFAULTMASK;
							}
							else
							{
								evtPtr.evtFlags &= ~(CAct.ACTFLAGS_REPEAT | CEvent.EVFLAGS_NOTDONEINSTART);
							}

							if (evtPtr.evtNParams != 0)
							{
								for (evp = 0; evp < evtPtr.evtNParams; evp++)
								{
									evpPtr = evtPtr.evtParams[evp];
									switch (evpPtr.code)
									{
										case 25:	    // PARAM_INT
											evpPtr.value2 = 0;
											break;
										case 13:	    // PARAM_EVERY
											evpPtr.compteur = evpPtr.delay;
											break;
										case 39:	    // PARAM_GROUPOINTER
											var n;
											for (n = 0; n < groups.size(); n++)
											{
												g = groups.get(n);
												if (g.id == evpPtr.id)
												{
													evpPtr.pointer = g.evg;
													break;
												}
											}
											break;
									}
								}
							}
						}
						break;
				}
			}
		},

		assemblePrograms: function (run)
		{
			var evgPtr;
			var evtPtr;
			var evpPtr;

			var o, oo;
			var oi, oi1, oi2;
			var type;
			var nOi, i, n, num, type1, type2;
			var d, evgF, evgM, q, d1, d2;
			var code;
			var fWrap;
			var evtAlways, evtAlwaysPos, evtAlwaysRoot;
			var aTimers, ss;
			var bOrBefore;
			var cndOR;
			var oilPtr;
			var hoPtr;

			this.rhPtr = run;

			this.rh2ActionCount = 0;

			var oiMax = 0;
			for (nOi = 0  , n = 0; n < this.rhPtr.rhMaxOI; n++)
			{
				if (this.rhPtr.rhOiList[n].oilOi != -1)
				{
					this.rhPtr.rhOiList[n].oilActionCount = -1;
					this.rhPtr.rhOiList[n].oilLimitFlags = 0;
					this.rhPtr.rhOiList[n].oilLimitList = -1;
					nOi++;
					if (this.rhPtr.rhOiList[n].oilOi + 1 > oiMax)
					{
						oiMax = this.rhPtr.rhOiList[n].oilOi + 1;
					}
				}
			}

			this.qualToOiList = null;
			var oil;
			if (this.nQualifiers > 0)
			{
				var count = new Array(this.nQualifiers);
				for (q = 0; q < this.nQualifiers; q++)
				{
					oi = (this.qualifiers[q].qOi) & 0x7FFF;
					count[q] = 0;
					for (oil = 0; oil < this.rhPtr.rhMaxOI; oil++)
					{
						if (this.rhPtr.rhOiList[oil].oilType == this.qualifiers[q].qType)
						{
							for (n = 0; n < 8 && this.rhPtr.rhOiList[oil].oilQualifiers[n] != -1; n++)
							{
								if (oi == this.rhPtr.rhOiList[oil].oilQualifiers[n])
								{
									count[q]++;
								}
							}
						}
					}
				}

				this.qualToOiList = new Array(this.nQualifiers);
				for (q = 0; q < this.nQualifiers; q++)
				{
					this.qualToOiList[q] = new CQualToOiList();

					if (count[q] != 0)
					{
						this.qualToOiList[q].qoiList = new Array(count[q] * 2);
					}

					i = 0;
					oi = (this.qualifiers[q].qOi) & 0x7FFF;
					for (oil = 0; oil < this.rhPtr.rhMaxOI; oil++)
					{
						if (this.rhPtr.rhOiList[oil].oilType == this.qualifiers[q].qType)
						{
							for (n = 0; n < 8 && this.rhPtr.rhOiList[oil].oilQualifiers[n] != -1; n++)
							{
								if (oi == this.rhPtr.rhOiList[oil].oilQualifiers[n])
								{
									this.qualToOiList[q].qoiList[i * 2] = this.rhPtr.rhOiList[oil].oilOi;
									this.qualToOiList[q].qoiList[i * 2 + 1] = oil;
									i++;
								}
							}
						}
					}
					this.qualToOiList[q].qoiActionCount = -1;
				}
			}

			this.colBuffer = new Array(oiMax * 100 * 2 + 1);
			var colList = 0;
			var posStartLoop = new Array();
			var evg, evt, evp;
			for (evg = 0; evg < this.events.length; evg++)
			{
				evgPtr = this.events[evg];

				for (evt = 0; evt < evgPtr.evgNAct + evgPtr.evgNCond; evt++)
				{
					evtPtr = evgPtr.evgEvents[evt];

					evtPtr.evtFlags &= ~CEvent.EVFLAGS_BADOBJECT;

					if (CEventProgram.EVTTYPE(evtPtr.evtCode) >= 0)
					{
						evtPtr.evtOiList = this.get_OiListOffset(evtPtr.evtOi, CEventProgram.EVTTYPE(evtPtr.evtCode));
					}

					if (evtPtr.evtCode == CAct.ACT_STARTLOOP)
	                {
	                    var expression = evtPtr.evtParams[0];
	                    expression.fastFastLoop = 0;
						if (expression.tokens[0].code == CExp.EXP_STRING && expression.tokens[1].code == 0)
						{
							var posStart = {};
							posStart.address = evtPtr.evtParams[0];
							posStart.name = expression.tokens[0].string;
							posStartLoop.push(posStart);

							this.rhPtr.addFastLoop(expression.tokens[0].string);
						}
					}
					else if (evtPtr.evtCode == CAct.ACT_STOPLOOP || evtPtr.evtCode == CAct.ACT_SETLOOPINDEX )
					{
						var expression = evtPtr.evtParams[0];
						if (expression.tokens[0].code == CExp.EXP_STRING && expression.tokens[1].code == 0)
						{
							expression.tokens[0] = new EXP_LONG();
							expression.tokens[0].code = CExp.EXP_LONG;
							expression.tokens[0].value = this.rhPtr.addFastLoop(expression.tokens[0].string);
						}
					}

					if (evtPtr.evtNParams > 0)
					{
						for (evp = 0; evp < evtPtr.evtNParams; evp++)
						{
							evpPtr = evtPtr.evtParams[evp];
							switch (evpPtr.code)
							{
								// Met un parametre buffer 4 a zero
								case 25:        // PARAM_BUFFER4:
									evpPtr.value = 0;
									break;

								// Trouve le levobj de creation
								case 21:        // PARAM_SYSCREATE:
									if ((evtPtr.evtOi & COI.OIFLAG_QUALIFIER) == 0)
									{
										var loPtr;
										for (loPtr = this.rhPtr.rhFrame.LOList.first_LevObj(); loPtr != null; loPtr = this.rhPtr.rhFrame.LOList.next_LevObj())
										{
											if (evtPtr.evtOi == loPtr.loOiHandle)
											{
												evpPtr.cdpHFII = loPtr.loHandle;
												break;
											}
										}
									}
									else
									{
										evpPtr.cdpHFII = -1;
									}
									oi = evpPtr.posOINUMParent;
									if (oi != -1)
									{
										evpPtr.posOiList = this.get_OiListOffset(oi, evpPtr.posTypeParent);
									}
									break;

								// Met l'adresse du levObj pour create object
								case 9:         // PARAM_CREATE:
								case 18:        // PARAM_SHOOT:
								case 16:        // PARAM_POSITION:
									oi = evpPtr.posOINUMParent;
									if (oi != -1)
									{
										evpPtr.posOiList = this.get_OiListOffset(oi, evpPtr.posTypeParent);
									}
									break;

								// Poke l'adresse de l'objet dans l'curFrame.m_oiList
								case 1:         // PARAM_OBJECT:
									evpPtr.oiList = this.get_OiListOffset(evpPtr.oi, evpPtr.type);
									break;

							    case 69:         // PARAM_CHILDEVENT:
							        for (var n = 0; n < evpPtr.ois.length; n += 2) {
							            evpPtr.ois[n + 1] = this.get_OiListOffset(evpPtr.ois[n], 0);
							        }
							        break;

							        // Expression : poke l'adresse de l'curFrame.m_oiList dans les parametres objets
								case 15:        // PARAM_SPEED:
								case 27:        // PARAM_SAMLOOP:
								case 28:        // PARAM_MUSLOOP:
								case 45:        // PARAM_EXPSTRING:
								case 46:        // PARAM_CMPSTRING:
								case 22:        // PARAM_EXPRESSION:
								case 23:        // PARAM_COMPARAISON:
								case 52:        // PARAM_VARGLOBAL_EXP:
								case 59:        // PARAM_STRINGGLOBAL_EXP:
								case 53:        // PARAM_ALTVALUE_EXP:
								case 62:        // PARAM_ALTSTRING_EXP:
								case 54:        // PARAM_FLAG_EXP:
									var expPtr = evpPtr;
									for (n = 0; n < expPtr.tokens.length; n++)
									{
										// Un objet avec OI?
										if (CEventProgram.EVTTYPE(expPtr.tokens[n].code) > 0)
										{
											var expOi = expPtr.tokens[n];
											expOi.oiList = this.get_OiListOffset(expOi.oi, CEventProgram.EVTTYPE(expOi.code));
										}
									}
									;
									break;
							}
						}
					}
				}

				// Flags par defaut / Listes de limitation
				// ---------------------------------------
				evgF = 0;
				evgM = CEventGroup.EVGFLAGS_ONCE | CEventGroup.EVGFLAGS_LIMITED | CEventGroup.EVGFLAGS_STOPINGROUP;
				for (evt = 0; evt < evgPtr.evgNCond + evgPtr.evgNAct; evt++)
				{
					evtPtr = evgPtr.evgEvents[evt];

					type = CEventProgram.EVTTYPE(evtPtr.evtCode);
					code = evtPtr.evtCode;
					n = 0;
					d1 = 0;
					d2 = 0;
					evpPtr = null;
					if (type >= COI.OBJ_SPR)
					{
						switch (CEventProgram.getEventCode(code))
						{
							case (4 << 16):      // ACTL_EXTSTOP:
							case (9 << 16):      // ACTL_EXTBOUNCE:

								evgF |= CEventGroup.EVGFLAGS_STOPINGROUP;

								// Recherche dans le groupe, la cause du STOP. limitList
								// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
								oi = evtPtr.evtOi;
								if ((oi & COI.OIFLAG_QUALIFIER) != 0)
								{
									for (o = this.qual_GetFirstOiList2(evtPtr.evtOiList); o != -1; o = this.qual_GetNextOiList2())
									{
										colList = this.make_ColList1(evgPtr, colList, this.rhPtr.rhOiList[o].oilOi);
									}
								}
								else
								{
									colList = this.make_ColList1(evgPtr, colList, oi);
								}
								break;
							case (25 << 16):      // ACTL_EXTSHUFFLE:
								evgF |= CEventGroup.EVGFLAGS_SHUFFLE;
								break;
							case (-14 << 16):     // CNDL_EXTCOLLISION:
								evpPtr = evtPtr.evtParams[0];
								var pEvpObject = evtPtr.evtParams[0];
								this.addColList(evtPtr.evtOiList, evtPtr.evtOi, pEvpObject.oiList, pEvpObject.oi);
								this.addColList(pEvpObject.oiList, pEvpObject.oi, evtPtr.evtOiList, evtPtr.evtOi);
								// L'objet 1 est-il un sprite?
								type1 = CEventProgram.EVTTYPE(evtPtr.evtCode);
								if (this.isTypeRealSprite(type1))
								{
									d2 = CObjInfo.OILIMITFLAGS_QUICKCOL | CObjInfo.OILIMITFLAGS_ONCOLLIDE;
								}
								else
								{
									d2 = CObjInfo.OILIMITFLAGS_QUICKCOL | CObjInfo.OILIMITFLAGS_QUICKEXT | CObjInfo.OILIMITFLAGS_ONCOLLIDE;
								}

								// L'objet 2 est-il un sprite?
								type2 = pEvpObject.type;
								if (this.isTypeRealSprite(type2))
								{
									d1 = CObjInfo.OILIMITFLAGS_QUICKCOL | CObjInfo.OILIMITFLAGS_ONCOLLIDE;
								}
								else
								{
									d1 = CObjInfo.OILIMITFLAGS_QUICKCOL | CObjInfo.OILIMITFLAGS_QUICKEXT | CObjInfo.OILIMITFLAGS_ONCOLLIDE;
								}
								n = 3;
								break;
							case (-4 << 16):     // CNDL_EXTISCOLLIDING:
								// L'objet 1 est-il un sprite?
								type1 = CEventProgram.EVTTYPE(evtPtr.evtCode);
								if (this.isTypeRealSprite(type1))
								{
									d2 = CObjInfo.OILIMITFLAGS_QUICKCOL;
								}
								else
								{
									d2 = CObjInfo.OILIMITFLAGS_QUICKCOL | CObjInfo.OILIMITFLAGS_QUICKEXT;
								}

								// L'objet 2 est-il un sprite?
								evpPtr = evtPtr.evtParams[0];
								type2 = evtPtr.evtParams[0].type;
								if (this.isTypeRealSprite(type2))
								{
									d1 = CObjInfo.OILIMITFLAGS_QUICKCOL;
								}
								else
								{
									d1 = CObjInfo.OILIMITFLAGS_QUICKCOL | CObjInfo.OILIMITFLAGS_QUICKEXT;
								}
								n = 3;
								break;
							case (-11 << 16):     // CNDL_EXTINPLAYFIELD:
							case (-12 << 16):     // CNDL_EXTOUTPLAYFIELD:
								d1 = CObjInfo.OILIMITFLAGS_QUICKBORDER;
								n = 1;
								break;
							case (-13 << 16):     // CNDL_EXTCOLBACK:
								d1 = CObjInfo.OILIMITFLAGS_QUICKBACK;
								n = 1;
								break;
						}
					}
					else
					{
						switch (code)
						{
							case ((-6 << 16) | 65535):      // CNDL_ONCE
								evgM &= ~CEventGroup.EVGFLAGS_ONCE;
								break;
							case ((-7 << 16) | 65535):      // CNDL_NOTALWAYS:
								evgM |= CEventGroup.EVGFLAGS_NOMORE;
								break;
							case ((-5 << 16) | 65535):      // CNDL_REPEAT:
								evgM |= CEventGroup.EVGFLAGS_NOMORE;
								break;
							case ((-4 << 16) | 65535):      // CNDL_NOMORE:
								evgM |= CEventGroup.EVGFLAGS_NOTALWAYS + CEventGroup.EVGFLAGS_REPEAT;
								break;
							case ((-4 << 16) | 0xFFFA):     // CNDL_MONOBJECT:
								d2 = CObjInfo.OILIMITFLAGS_QUICKCOL;
								evpPtr = evtPtr.evtParams[0];
								n = 2;
								break;
							case ((-7 << 16) | 0xFFFA):     // CNDL_MCLICKONOBJECT:
								d2 = CObjInfo.OILIMITFLAGS_QUICKCOL;
								evpPtr = evtPtr.evtParams[1];
								n = 2;
								break;
						}
					}
					// Poke les flags collision
					if ((n & 1) != 0)
					{
						for (o = this.qual_GetFirstOiList(evtPtr.evtOiList); o != -1; o = this.qual_GetNextOiList())
						{
							this.rhPtr.rhOiList[o].oilLimitFlags |= d1;
						}
					}
					if ((n & 2) != 0)
					{
						for (o = this.qual_GetFirstOiList(evpPtr.oiList); o != -1; o = this.qual_GetNextOiList())
						{
							this.rhPtr.rhOiList[o].oilLimitFlags |= d2;
						}
					}
				}
				// Inhibe les anciens flags
				evgPtr.evgFlags &= ~evgM;
				evgPtr.evgFlags |= evgF;
			}
			this.colBuffer[colList] = -1;

			// Reserve le buffer des pointeurs sur listes d'events
			// ---------------------------------------------------
			var aListPointers = new Array(COI.NUMBEROF_SYSTEMTYPES + oiMax + 1);

			// Rempli cette table avec les offsets en fonction des types
			ss = 0;
			var alp;
			for (alp = 0  , type = -COI.NUMBEROF_SYSTEMTYPES; type < 0; type++, alp++)
			{
				aListPointers[alp] = ss;
				ss += this.nConditions[COI.NUMBEROF_SYSTEMTYPES + type];
			}
			// Continue avec les OI, la taille juste pour le type de l'oi
			for (oil = 0; oil < this.rhPtr.rhMaxOI; oil++, alp++)
			{
				aListPointers[alp] = ss;
				if (this.rhPtr.rhOiList[oil].oilType < COI.KPX_BASE)
				{
					ss += this.nConditions[COI.NUMBEROF_SYSTEMTYPES + this.rhPtr.rhOiList[oil].oilType] + CEventProgram.EVENTS_EXTBASE + 1;
				}
				else
				{
					ss += this.application.extLoader.getNumberOfConditions(this.rhPtr.rhOiList[oil].oilType) + CEventProgram.EVENTS_EXTBASE + 1;
				}
			}

			// Reserve le buffer des pointeurs
			var sListPointers = ss;
			this.listPointers = new Array(sListPointers);
			for (n = 0; n < sListPointers; n++)
			{
				this.listPointers[n] = 0;
			}
			evtAlways = 0;
			evtAlwaysRoot = 0;

			// Explore le programme et repere les evenements
			var wBufNear = new Array(this.rhPtr.rhFrame.maxObjects);
			var wPtrNear;
			for (evg = 0; evg < this.nEvents; evg++)
			{
				evgPtr = this.events[evg];
				evgPtr.evgFlags &= ~CEventGroup.EVGFLAGS_ORINGROUP;
				bOrBefore = true;
				cndOR = 0;
				for (evt = 0; evt < evgPtr.evgNCond; evt++)
				{
					evtPtr = evgPtr.evgEvents[evt];
					type = CEventProgram.EVTTYPE(evtPtr.evtCode);
					code = evtPtr.evtCode;
					num = -CEventProgram.EVTNUM(code);

					if (bOrBefore && evtPtr.evtCode != ((-42 << 16) | 0xFFFF))  // CNDL_ENDCHILDEVENT
					{
						// Dans la liste des evenements ALWAYS
						if ((evtPtr.evtFlags & CEvent.EVFLAGS_ALWAYS) != 0)
						{
							evtAlways++;
							if ((evgPtr.evgFlags & CEventGroup.EVGFLAGS_HASPARENT) == 0)
							    evtAlwaysRoot++;
	                    }

						// Dans la liste des evenements generaux si objet systeme
						if (type < 0)
						{
							this.listPointers[aListPointers[7 + type] + num]++;
						}
						else
						// Un objet normal / qualifier : relie aux objets
						{
							wPtrNear = 0;
							for (o = this.qual_GetFirstOiList(evtPtr.evtOiList); o != -1; o = this.qual_GetNextOiList())
							{
								this.listPointers[aListPointers[COI.NUMBEROF_SYSTEMTYPES + o] + num]++;
								wBufNear[wPtrNear++] = o;
							}
							wBufNear[wPtrNear] = -1;
							// Cas special pour les collisions de sprites : branche aux deux sprites (sauf si meme!)
							if (CEventProgram.getEventCode(code) == (-14 << 16))      // CNDL_EXTCOLLISION
							{
								evpPtr = evtPtr.evtParams[0];
								for (oo = this.qual_GetFirstOiList(evpPtr.oiList); oo != -1; oo = this.qual_GetNextOiList())
								{
									for (wPtrNear = 0; wBufNear[wPtrNear] != oo && wBufNear[wPtrNear] != -1;)
										wPtrNear++;
									if (wBufNear[wPtrNear] == -1)
									{
										this.listPointers[aListPointers[COI.NUMBEROF_SYSTEMTYPES + oo] + num]++;
									}
								}
							}
						}
					}
					bOrBefore = false;
					if (evtPtr.evtCode == ((-24 << 16) | 65535) || evtPtr.evtCode == ((-25 << 16) | 65535))     // CNDL_OR - CNDL_ORLOGICAL
					{
						bOrBefore = true;
						evgPtr.evgFlags |= CEventGroup.EVGFLAGS_ORINGROUP;
						// Un seul type de OR dans un groupe
						if (cndOR == 0)
						{
							cndOR = evtPtr.evtCode;
						}
						else
						{
							evtPtr.evtCode = cndOR;
						}
						// Marque les OR Logical
						if (cndOR == ((-25 << 16) | 65535))       // CNDL_ORLOGICAL)
						{
							evgPtr.evgFlags |= CEventGroup.EVGFLAGS_ORLOGICAL;
						}
					}
					if (evtPtr.evtCode == ((-42 << 16) | 0xFFFF))  // CNDL_ENDCHILDEVENT
					{
					    evtAlways++;				// for ending evgOffset (-1)
					    evgPtr.evgFlags |= CEventGroup.EVGFLAGS_INACTIVE;		// set line as inactive
					}
				}
			}

			// Calcule les tailles necessaires, poke les pointeurs dans les listes
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			var sEventPointers = evtAlways + 1;
			var uil;
			for (uil = 0; uil < sListPointers; uil++)
			{
				if (this.listPointers[uil] != 0)
				{
					ss = this.listPointers[uil];
					this.listPointers[uil] = sEventPointers;
					sEventPointers += ss + 1;
				}
			}
			this.eventPointersGroup = new Array(sEventPointers);
			this.eventPointersCnd = new Array(sEventPointers);
			for (n = 0; n < sEventPointers; n++)
			{
				this.eventPointersGroup[n] = null;
				this.eventPointersCnd[n] = 0;
			}

			var lposBuffer = new Array(sListPointers);
			for (n = 0; n < sListPointers; n++)
			{
				lposBuffer[n] = this.listPointers[n];
			}

		    // 288.2 - fast loops were doubled if there was a frame fade-in transition
			this.rhPtr.rh4PosOnLoop = null;

			evtAlwaysPos = 0;
			evtAlways = 0;
			var lposPtr;
			var nestedEventOffsetStack = new Array();
			var nestedEventActionParamStack = new Array();
			var evtAlwaysChildrenPos = (evtAlwaysRoot + 1);
			this.complexOnLoop = false;
			for (evg = 0; evg < this.nEvents; evg++)
			{
				evgPtr = this.events[evg];
				bOrBefore = true;
				for (evt = 0; evt < evgPtr.evgNCond; evt++)
				{
					evtPtr = evgPtr.evgEvents[evt];
					type = CEventProgram.EVTTYPE(evtPtr.evtCode);
					code = evtPtr.evtCode;
					num = -CEventProgram.EVTNUM(code);

					if (bOrBefore && evtPtr.evtCode != ((-42 << 16) | 0xFFFF))  // CNDL_ENDCHILDEVENT
					{
						// Dans la liste des evenements ALWAYS
						if ((evtPtr.evtFlags & CEvent.EVFLAGS_ALWAYS) != 0)
						{
						    if ((evgPtr.evgFlags & CEventGroup.EVGFLAGS_HASPARENT) != 0) {
						        if (nestedEventOffsetStack.length > 0) {
						            var curOffsets = nestedEventOffsetStack[nestedEventOffsetStack.length - 1];
						            curOffsets.push(evgPtr);
						            curOffsets.push(evt);
						        }
						    }
						    else {
						        this.eventPointersGroup[evtAlwaysPos] = evgPtr;
						        this.eventPointersCnd[evtAlwaysPos] = evt;
						        evtAlwaysPos++;
						    }
						}

						// Dans la liste des evenements generaux si objet systeme
						if (type < 0)
						{
							lposPtr = aListPointers[COI.NUMBEROF_SYSTEMTYPES + type] + num;
							this.eventPointersGroup[lposBuffer[lposPtr]] = evgPtr;
							this.eventPointersCnd[lposBuffer[lposPtr]] = evt;
							lposBuffer[lposPtr]++;

							if (evtPtr.evtCode == CCnd.CND_ONLOOP)
							{
								var n;
								var bOR = false;
								for (n = 0; n < evgPtr.evgNCond; n++)
								{
									if (evgPtr.evgEvents[n].evtCode == CCnd.CND_OR || evgPtr.evgEvents[n].evtCode == CCnd.CND_ORLOGICAL)
										break;
								}
								if (n < evgPtr.evgNCond)
									bOR = true;

								var expression = evtPtr.evtParams[0];
								if (expression.tokens[0].code == CExp.EXP_STRING && expression.tokens[1].code == 0)
								{
	                                var posOnLoop = null;
	                                var nOnLoop;
									var pName = expression.tokens[0].string;
	                                var fastLoopIndex = this.rhPtr.addFastLoop(pName);
	                                var nStartLoop;
	                                for (nStartLoop = 0; nStartLoop < posStartLoop.length; nStartLoop++)
									{
	                                    var pPos = posStartLoop[nStartLoop];
										if (CServices.compareStringsIgnoreCase(pPos.name, pName))
										{
											if (!this.rhPtr.rh4PosOnLoop)
												this.rhPtr.rh4PosOnLoop = new Array();

	                                        if (posOnLoop == null)
	                                        {
	                                            for (nOnLoop = 0; nOnLoop < this.rhPtr.rh4PosOnLoop.length; nOnLoop++)
	                                            {
	                                                posOnLoop = this.rhPtr.rh4PosOnLoop[nOnLoop];
	                                                if (CServices.compareStringsIgnoreCase(pName, posOnLoop.name))
	                                                    break;
	                                            }
	                                            if (nOnLoop == this.rhPtr.rh4PosOnLoop.length)
	                                            {
	                                                posOnLoop = new CPosOnLoop(pName, fastLoopIndex);
	                                                this.rhPtr.rh4PosOnLoop.push(posOnLoop);
	                                            }
	                                            posOnLoop.AddOnLoop(evgPtr);
	                                            posOnLoop.m_bOR |= bOR;
	                                        }
	                                        pPos.address.fastFastLoop = nOnLoop + 1;
										}
									}

	                                if (posOnLoop == null)
	                                {
	                                    if (!this.rhPtr.rh4PosOnLoop)
	                                        this.rhPtr.rh4PosOnLoop = new Array();
	                                    for (nOnLoop = 0; nOnLoop < this.rhPtr.rh4PosOnLoop.length; nOnLoop++)
	                                    {
	                                        posOnLoop = this.rhPtr.rh4PosOnLoop[nOnLoop];
	                                        if (CServices.compareStringsIgnoreCase(pName, posOnLoop.name))
	                                            break;
	                                    }
	                                    if (nOnLoop == this.rhPtr.rh4PosOnLoop.length)
	                                    {
	                                        posOnLoop = new CPosOnLoop(pName, fastLoopIndex);
	                                        this.rhPtr.rh4PosOnLoop.push(posOnLoop);
	                                    }
	                                    posOnLoop.AddOnLoop(evgPtr);
	                                    posOnLoop.m_bOR |= bOR;
	                                }
	                            }
								else
								{
									this.complexOnLoop = true;
								}
							}

						}
						else
						// Un objet normal : relie a l'objet
						{
							wPtrNear = 0;
							for (o = this.qual_GetFirstOiList(evtPtr.evtOiList); o != -1; o = this.qual_GetNextOiList())
							{
								lposPtr = aListPointers[COI.NUMBEROF_SYSTEMTYPES + o] + num;
								this.eventPointersGroup[lposBuffer[lposPtr]] = evgPtr;
								this.eventPointersCnd[lposBuffer[lposPtr]] = evt;
								lposBuffer[lposPtr]++;
								wBufNear[wPtrNear++] = o;
							}
							wBufNear[wPtrNear] = -1;
							// Cas special pour les collisions de sprites : branche aux deux sprites (sauf si meme!)
							if (CEventProgram.getEventCode(code) == (-14 << 16))      // CNDL_EXTCOLLISION
							{
								evpPtr = evtPtr.evtParams[0];
								for (oo = this.qual_GetFirstOiList(evpPtr.oiList); oo != -1; oo = this.qual_GetNextOiList())
								{
									for (wPtrNear = 0; wBufNear[wPtrNear] != oo && wBufNear[wPtrNear] != -1;)
										wPtrNear++;
									if (wBufNear[wPtrNear] == -1)
									{
										lposPtr = aListPointers[COI.NUMBEROF_SYSTEMTYPES + oo] + num;
										this.eventPointersGroup[lposBuffer[lposPtr]] = evgPtr;
										this.eventPointersCnd[lposBuffer[lposPtr]] = evt;
										lposBuffer[lposPtr]++;
									}
								}
							}
						}
					}
					bOrBefore = false;
					if (evtPtr.evtCode == ((-24 << 16) | 65535) || evtPtr.evtCode == ((-25 << 16) | 65535))     // CNDL_OR - CNDL_ORLOGICAL
					{
						bOrBefore = true;
					}

					if (evtPtr.evtCode == ((-42 << 16) | 0xFFFF))  // CNDL_ENDCHILDEVENT
					{
					    // Copy events
					    if (nestedEventOffsetStack.length > 0) {
					        var param = nestedEventActionParamStack.pop();
					        param.evgOffsetList = evtAlwaysChildrenPos;

					        var curOffsets = nestedEventOffsetStack.pop();
					        for (var v = 0; v < curOffsets.length; v+=2) {
					            this.eventPointersGroup[evtAlwaysChildrenPos] = curOffsets[v];
					            this.eventPointersCnd[evtAlwaysChildrenPos] = curOffsets[v+1];
					            evtAlwaysChildrenPos++;
					        }
					        this.eventPointersGroup[evtAlwaysChildrenPos] = null;
					        this.eventPointersCnd[evtAlwaysChildrenPos] = null;
					        evtAlwaysChildrenPos++;
					    }
					}
				}

				if ((evgPtr.evgFlags & CEventGroup.EVGFLAGS_HASCHILDREN) != 0) {
				    // Add new eventGroup offset list
				    var curOffsets = new Array();
				    nestedEventOffsetStack.push(curOffsets);

				    // Look for action "Start child events"
				    for (var n = 0; n < evgPtr.evgNAct; n++) {
				        var evtPtr = evgPtr.evgEvents[evgPtr.evgNCond + n];
				        if (evtPtr.evtCode == ((43 << 16) | 0xFFFF))    // ACTL_EXECUTECHILDEVENTS )
				        {
				            if (evtPtr.evtNParams > 0) {
				                var evpPtr = evtPtr.evtParams[0];
				                nestedEventActionParamStack.push(evpPtr);
				            }
				            break;
				        }
				    }
				}
	        }

			// Adresse des conditions timer
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			uil = aListPointers[COI.NUMBEROF_SYSTEMTYPES + COI.OBJ_TIMER];
			aTimers = this.listPointers[uil - CEventProgram.EVTNUM(((-3 << 16) | 0xFFFC))];     // CNDL_TIMER

			// Poke les adresses et les autres flags des pointeurs dans tous OI
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			this.limitBuffer = new Array(oiMax + 1 + colList / 2);
			var limitListStart = 0;
			var limitPos, limitCur;
			for (oil = 0; oil < this.rhPtr.rhMaxOI; oil++)
			{
				oilPtr = this.rhPtr.rhOiList[oil];

				// Poke l'offset dans les events
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				uil = aListPointers[COI.NUMBEROF_SYSTEMTYPES + oil];
				oilPtr.oilEvents = uil;

				// Traitement des flags particuliers
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				var act;
				if ((oilPtr.oilOEFlags & CObjectCommon.OEFLAG_MOVEMENTS) != 0)
				{
					// Recherche les flags WRAP dans les messages OUT OF PLAYFIELD
					fWrap = 0;
					ss = this.listPointers[uil - CEventProgram.EVTNUM(-12 << 16)];     // CNDL_EXTOUTPLAYFIELD
					if (ss != 0)
					{
						while (this.eventPointersGroup[ss] != null)
						{
							evgPtr = this.eventPointersGroup[ss];
							evtPtr = evgPtr.evgEvents[this.eventPointersCnd[ss]];
							d = evtPtr.evtParams[0].value;	// Prend la direction
							for (act = CEventProgram.evg_FindAction(evgPtr, 0), n = evgPtr.evgNAct; n > 0; n--, act++)
							{
								evtPtr = evgPtr.evgEvents[act];
								if (evtPtr.evtCode == ((8 << 16) | (oilPtr.oilType & 0xFFFF))) // ACT_EXTWRAP
								{
									fWrap |= d;
								}
							}
							ss++;
						}
					}
					oilPtr.oilWrap = fWrap;

					// Fabrique la table de limitations des mouvements
					// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					oi1 = oilPtr.oilOi;
					for (colList = 0  , limitPos = 0; this.colBuffer[colList] != -1; colList += 2)
					{
						if (this.colBuffer[colList] == oi1)
						{
							oi2 = this.colBuffer[colList + 1];
							if ((oi2 & 0x8000) != 0)
							{
								oilPtr.oilLimitFlags |= oi2;
								continue;
							}
							for (limitCur = 0; limitCur < limitPos && this.limitBuffer[limitListStart + limitCur] != oi2;)
								limitCur++;
							if (limitCur == limitPos)
							{
								this.limitBuffer[limitListStart + limitPos++] = oi2;
							}
						}
					}
					// Marque la fin...
					if (limitPos > 0)
					{
						oilPtr.oilLimitList = limitListStart;
						this.limitBuffer[limitListStart + limitPos++] = -1;
						limitListStart += limitPos;
					}
				}
			}

			// Met les adresses des tables de pointeur systeme
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			this.rhEvents[0] = 0;
			for (n = 1; n <= COI.NUMBEROF_SYSTEMTYPES; n++)
			{
				this.rhEvents[n] = aListPointers[COI.NUMBEROF_SYSTEMTYPES - n];
			}

			// Poke les adresses et les autres flags des pointeurs dans tous les objets definis
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			for (oil = 0; oil < this.rhPtr.rhMaxOI; oil++)
			{
				oilPtr = this.rhPtr.rhOiList[oil];

				// Explore tous les objets de meme OI dans le programme
				o = oilPtr.oilObject;
				if ((o & 0x80000000) == 0)
				{
					do
					{
						// Met les oi dans les ro
						hoPtr = this.rhPtr.rhObjectList[o];
						hoPtr.hoEvents = oilPtr.oilEvents;
						hoPtr.hoOiList = oilPtr;
						hoPtr.hoLimitFlags = oilPtr.oilLimitFlags;
						// Flags Wrap pour les objets avec movement
						if ((hoPtr.hoOEFlags & CObjectCommon.OEFLAG_MOVEMENTS) != 0)
						{
							hoPtr.rom.rmWrapping = oilPtr.oilWrap;
						}
						// Si le sprite n'est pas implique dans les collisions . le passe en neutre
						if ((hoPtr.hoOEFlags & CObjectCommon.OEFLAG_SPRITES) != 0 && (hoPtr.hoLimitFlags & (CObjInfo.OILIMITFLAGS_QUICKCOL)) == 0)
						{
							hoPtr.ros.setColFlag(false);
						}
						// Sprite en mode inbitate?
						if ((hoPtr.hoOEFlags & CObjectCommon.OEFLAG_MANUALSLEEP) == 0)
						{
							// On detruit... sauf si...
							hoPtr.hoOEFlags &= ~CObjectCommon.OEFLAG_NEVERSLEEP;

							// On teste des collisions avec le decor?
							if ((hoPtr.hoLimitFlags & CObjInfo.OILIMITFLAGS_QUICKBACK) != 0)
							{
								// Si masque des collisions general
								if ((this.rhPtr.rhFrame.leFlags & CRunFrame.LEF_TOTALCOLMASK) != 0)
								{
									hoPtr.hoOEFlags |= CObjectCommon.OEFLAG_NEVERSLEEP;
								}
							}
							// Ou test des collisions normal
							if ((hoPtr.hoLimitFlags & (CObjInfo.OILIMITFLAGS_QUICKCOL | CObjInfo.OILIMITFLAGS_QUICKBORDER)) != 0)
							{
								hoPtr.hoOEFlags |= CObjectCommon.OEFLAG_NEVERSLEEP;
							}
						}
						o = hoPtr.hoNumNext;
					} while ((o & 0x80000000) == 0);
				}
			}
			// Les messages speciaux
			// ~~~~~~~~~~~~~~~~~~~~~
			if (evtAlwaysRoot != 0)
			{
				this.rhEventAlways = true;
			}
			else
			{
				this.rhEventAlways = false;
			}
			// Messages Timer (a bulle!)
			if (aTimers != 0)
			{
				this.rh4TimerEventsBase = aTimers;
			}
			else
			{
				this.rh4TimerEventsBase = 0;
			}

			// Liberation
			this.colBuffer = null;
			this.bReady = true;

		},

		unBranchPrograms: function ()
		{
			this.bReady = false;
			this.qualToOiList = null;
			this.limitBuffer = null;
			this.listPointers = null;
			this.eventPointersGroup = null;
			this.eventPointersCnd = null;
		},

		get_OiListOffset: function (oi, type)
		{
			if ((oi & COI.OIFLAG_QUALIFIER) != 0)
			{
				var q;
				for (q = 0; oi != this.qualifiers[q].qOi || type != this.qualifiers[q].qType;)
					q++;
				return (q | 0x8000);
			}
			else
			{
				var n;
				for (n = 0; n < this.rhPtr.rhMaxOI && this.rhPtr.rhOiList[n].oilOi != oi;)
					n++;
				return n;
			}
		},

		isTypeRealSprite: function (type)
		{
			var oil;
			for (oil = 0; oil < this.rhPtr.rhMaxOI; oil++)
			{
				if (this.rhPtr.rhOiList[oil].oilOi != -1)
				{
					if (this.rhPtr.rhOiList[oil].oilType == type)
					{
						if ((this.rhPtr.rhOiList[oil].oilOEFlags & CObjectCommon.OEFLAG_SPRITES) != 0 && (this.rhPtr.rhOiList[oil].oilOEFlags & CObjectCommon.OEFLAG_QUICKDISPLAY) == 0)
						{
							return true;
						}
						else
						{
							return false;
						}
					}
				}
			}
			return true;
		},

		qual_GetFirstOiList: function (o)
		{
			if ((o & 0x8000) == 0)
			{
				this.qualOilPtr = -1;
				return (o);
			}
			if (o == -1)
			{
				return -1;
			}

			o &= 0x7FFF;
			this.qualOilPtr = o;
			this.qualOilPos = 0;
			return this.qual_GetNextOiList();
		},

		qual_GetNextOiList: function ()
		{
			var o;

			if (this.qualOilPtr == -1)
			{
				return -1;
			}
			if (this.qualOilPos >= this.qualToOiList[this.qualOilPtr].qoiList.length)
			{
				return -1;
			}
			o = this.qualToOiList[this.qualOilPtr].qoiList[this.qualOilPos + 1];
			this.qualOilPos += 2;
			return (o);
		},

		qual_GetFirstOiList2: function (o)
		{
			if ((o & 0x8000) == 0)
			{
				this.qualOilPtr2 = -1;
				return (o);
			}
			if (o == -1)
			{
				return -1;
			}

			o &= 0x7FFF;
			this.qualOilPtr2 = o;
			this.qualOilPos2 = 0;
			return this.qual_GetNextOiList2();
		},

		qual_GetNextOiList2: function ()
		{
			var o;

			if (this.qualOilPtr2 == -1)
			{
				return -1;
			}
			if (this.qualOilPos2 >= this.qualToOiList[this.qualOilPtr2].qoiList.length)
			{
				return -1;
			}
			o = this.qualToOiList[this.qualOilPtr2].qoiList[this.qualOilPos2 + 1];
			this.qualOilPos2 += 2;
			return (o);
		},

		addColList: function (oiList, oiNum, oiList2, oiNum2)
		{
			var qoil;
			var pOinOil;
			if (oiNum < 0)
			{
				if (this.qualToOiList != null)
				{
					qoil = this.qualToOiList[oiList & 0x7FFF];
					pOinOil = 0;
					while (pOinOil < qoil.qoiList.length)
					{
						this.addColList(qoil.qoiList[pOinOil + 1], qoil.qoiList[pOinOil], oiList2, oiNum2);
						pOinOil += 2;
					}
				}
				return;
			}

			if (oiNum2 < 0)
			{
				if (this.qualToOiList != null)
				{
					qoil = this.qualToOiList[oiList2 & 0x7FFF];
					pOinOil = 0;
					while (pOinOil < qoil.qoiList.length)
					{
						this.addColList(oiList, oiNum, qoil.qoiList[pOinOil + 1], qoil.qoiList[pOinOil]);
						pOinOil += 2;
					}
				}
				return;
			}

			var colList;
			var oilPtr = this.rhPtr.rhOiList[oiList];
			if (oilPtr.oilColList == null)
			{
				oilPtr.oilColList = new Array();
				colList = oilPtr.oilColList;
			}
			else
			{
				colList = oilPtr.oilColList;

				var n;
				for (n = 0; n < colList.length; n += 2)
				{
					if (oiNum2 == colList[n])
					{
						return;
					}
				}
			}
			colList.push(oiNum2);
			colList.push(oiList2);
		},

		make_ColList1: function (evgPtr, colList, oi1)
		{
			var oi2;
			var flag;
			var code;
			var o;
			var evtPtr;
			var evpPtr;
			var evt;

			for (evt = 0; evt < evgPtr.evgNCond; evt++)
			{
				evtPtr = evgPtr.evgEvents[evt];
				if (CEventProgram.EVTTYPE(evtPtr.evtCode) >= 2)
				{
					flag = (0x8000 + CObjInfo.OILIMITFLAGS_BACKDROPS);
					code = CEventProgram.getEventCode(evtPtr.evtCode);
					switch (code)
					{
						case (-14 << 16):
							evpPtr = evtPtr.evtParams[0];
							for (o = this.qual_GetFirstOiList(evtPtr.evtOiList); o != -1; o = this.qual_GetNextOiList())
							{
								oi2 = this.rhPtr.rhOiList[o].oilOi;
								if (oi1 == oi2)
								{
									flag = 0;
									colList = this.make_ColList2(colList, oi1, evpPtr.oiList);
								}
							}
							if (flag == 0)
							{
								break;
							}
							for (o = this.qual_GetFirstOiList(evpPtr.oiList); o != -1; o = this.qual_GetNextOiList())
							{
								oi2 = this.rhPtr.rhOiList[o].oilOi;
								if (oi1 == oi2)
								{
									colList = this.make_ColList2(colList, oi1, evtPtr.evtOiList);
								}
							}
							break;
						case (-12 << 16):
							evpPtr = evtPtr.evtParams[0];
							flag = (0x8000 + evpPtr.value);
						case (-13 << 16):
							for (o = this.qual_GetFirstOiList(evtPtr.evtOiList); o != -1; o = this.qual_GetNextOiList())
							{
								oi2 = this.rhPtr.rhOiList[o].oilOi;
								if (oi1 == oi2)
								{
									this.colBuffer[colList++] = oi1;
									this.colBuffer[colList++] = flag;
								}
							}
							break;
					}
				}
			}
			return (colList);
		},

		make_ColList2: function (colList, oi1, ol)
		{
			var oi2;
			var o;
			for (o = this.qual_GetFirstOiList(ol); o != -1; o = this.qual_GetNextOiList())
			{
				oi2 = this.rhPtr.rhOiList[o].oilOi;

				var pos;
				for (pos = 0; pos < colList; pos += 2)
				{
					if (this.colBuffer[pos] == oi1 && this.colBuffer[pos + 1] == oi2)
					{
						break;
					}
				}
				if (pos == colList)
				{
					this.colBuffer[colList++] = oi1;
					this.colBuffer[colList++] = oi2;
				}
			}
			return colList;
		},

		getCollisionFlags: function ()
		{
			var evgPtr;
			var evtPtr;
			var evpPtr;
			var evg, evt, evp;
			var flag;
			for (evg = 0; evg < this.events.length; evg++)
			{
				evgPtr = this.events[evg];

				for (evt = 0; evt < evgPtr.evgNAct + evgPtr.evgNCond; evt++)
				{
					evtPtr = evgPtr.evgEvents[evt];

					if (evtPtr.evtNParams > 0)
					{
						for (evp = 0; evp < evtPtr.evtNParams; evp++)
						{
							evpPtr = evtPtr.evtParams[evp];
							if (evpPtr.code == 43)
							{
								var p = evpPtr;
								switch (p.value)
								{
									case 1:
										flag |= CColMask.CM_OBSTACLE;
										break;
									case 2:
										flag |= CColMask.CM_PLATFORM;
										break;
								}
							}
						}
					}
				}
			}
			return flag;
		},

		enumSounds: function (sounds)
		{
			var evgPtr;
			var evtPtr;
			var evg, evt, p;
			var pSample;

			for (evg = 0; evg < this.nEvents; evg++)
			{
				evgPtr = this.events[evg];
				for (evt = 0; evt < evgPtr.evgNCond + evgPtr.evgNAct; evt++)
				{
					evtPtr = evgPtr.evgEvents[evt];
					for (p = 0; p < evtPtr.evtNParams; p++)
					{
						switch (evtPtr.evtParams[p].code)
						{
							case 6:
							case 35:
								pSample = evtPtr.evtParams[p];
								sounds.enumerate(pSample.sndHandle);
								break;
						}
					}
				}
			}
		},

		HandleKeyRepeat: function ()
		{
			var evgPtr;
			var evtPtr;
			var evg, evt, p;

			for (evg = 0; evg < this.nEvents; evg++)
			{
				evgPtr = this.events[evg];
				for (evt = 0; evt < evgPtr.evgNCond; evt++)
				{
					evtPtr = evgPtr.evgEvents[evt];
					if (evtPtr.evtCode == ((-1 << 16) | 0xFFFA))
					{
						evgPtr.evgInhibit = this.rhPtr.rhLoopCount;
						break;
					}
				}
			}
		}
	}


	// CEventGroup object
	// ----------------------------------------------------------
	CEventGroup.EVGFLAGS_ONCE = 0x0001;
	CEventGroup.EVGFLAGS_NOTALWAYS = 0x0002;
	CEventGroup.EVGFLAGS_REPEAT = 0x0004;
	CEventGroup.EVGFLAGS_NOMORE = 0x0008;
	CEventGroup.EVGFLAGS_SHUFFLE = 0x0010;
	CEventGroup.EVGFLAGS_HASCHILDREN = 0x0040;
	CEventGroup.EVGFLAGS_BREAK = 0x0080;
	CEventGroup.EVGFLAGS_BREAKPOINT = 0x0100;
	CEventGroup.EVGFLAGS_ALWAYSCLEAN = 0x0200;
	CEventGroup.EVGFLAGS_ORINGROUP = 0x0400;
	CEventGroup.EVGFLAGS_STOPINGROUP = 0x0800;
	CEventGroup.EVGFLAGS_ORLOGICAL = 0x1000;
	CEventGroup.EVGFLAGS_GROUPED = 0x2000;
	CEventGroup.EVGFLAGS_INACTIVE = 0x4000;
	CEventGroup.EVGFLAGS_HASPARENT = 0x8000;
	CEventGroup.EVGFLAGS_LIMITED = CEventGroup.EVGFLAGS_SHUFFLE + CEventGroup.EVGFLAGS_NOTALWAYS + CEventGroup.EVGFLAGS_REPEAT + CEventGroup.EVGFLAGS_NOMORE;
	CEventGroup.EVGFLAGS_DEFAULTMASK = CEventGroup.EVGFLAGS_BREAKPOINT + CEventGroup.EVGFLAGS_GROUPED + CEventGroup.EVGFLAGS_HASCHILDREN + CEventGroup.EVGFLAGS_HASPARENT;

	function CEventGroup()
	{
		this.evgNCond = 0;
		this.evgNAct = 0;
		this.evgFlags = 0;
		this.evgInhibit = 0;
		this.evgInhibitCpt = 0;
	    this.evgEvents = null;
	    this.evgLine = 0;
	}
	CEventGroup.create = function (app)
	{
		var debut = app.file.getFilePointer();

		var size = app.file.readShort();
		var evg = new CEventGroup();
		evg.evgNCond = app.file.readAByte();
		evg.evgNAct = app.file.readAByte();
		evg.evgFlags = app.file.readAShort();
		evg.evgLine = app.file.readAShort();
		//app.file.skipBytes(2);
		evg.evgInhibit = app.file.readAInt();
		evg.evgInhibitCpt = app.file.readAInt();

		evg.evgEvents = new Array(evg.evgNCond + evg.evgNAct);
		var n;
		var count = 0;
		for (n = 0; n < evg.evgNCond; n++)
		{
			evg.evgEvents[count++] = CCnd.create(app);
		}
		for (n = 0; n < evg.evgNAct; n++)
		{
			evg.evgEvents[count++] = CAct.create(app);
		}
		app.file.seek(debut - size);
		return evg;
	}

	// CEvent
	// ------------------------------------------------------------
	CEvent.EVFLAGS_REPEAT = 0x01;
	CEvent.EVFLAGS_DONE = 0x02;
	CEvent.EVFLAGS_DEFAULT = 0x04;
	CEvent.EVFLAGS_DONEBEFOREFADEIN = 0x08;
	CEvent.EVFLAGS_NOTDONEINSTART = 0x10;
	CEvent.EVFLAGS_ALWAYS = 0x20;
	CEvent.EVFLAGS_BAD = 0x40;
	CEvent.EVFLAGS_BADOBJECT = 0x80;
	CEvent.EVFLAGS_DEFAULTMASK = CEvent.EVFLAGS_ALWAYS + CEvent.EVFLAGS_REPEAT + CEvent.EVFLAGS_DEFAULT + CEvent.EVFLAGS_DONEBEFOREFADEIN + CEvent.EVFLAGS_NOTDONEINSTART;
	CEvent.EVFLAG2_NOT = 0x01;
	function CEvent()
	{
	}

	// Various objects
	// ------------------------------------------------------------
	function CGroupFind()
	{
		this.id = 0;
		this.evg = 0;
	}
	function CLoadQualifiers()
	{
		this.qOi = 0;
		this.qType = 0;
	}
	function CPushedEvent(r, c, p, hoPtr, o)
	{
		this.routine = r;
		this.code = c;
		this.param = p;
		this.pHo = hoPtr;
		this.oi = o;
	}
	function CQualToOiList()
	{
		this.qoiCurrentOi = 0
		this.qoiNext = 0;
		this.qoiActionPos = 0;
		this.qoiCurrentRoutine = 0;
		this.qoiActionCount = 0;
		this.qoiActionLoopCount = 0;
		this.qoiNextFlag = false;
		this.qoiSelectedFlag = false;
		this.qoiList = null;
	}

	// ForEach
	// -------------------------------------------------------------------------
	function ForEach()
	{
		this.next = null;
		this.oi = 0;
		this.index = 0;
		this.name = null;
		this.number = 0;
		this.stop = false;
		this.objects = new Array();
	}

	// TimerEvents
	// -------------------------------------------------------------------------
	TimerEvents.TIMEREVENTTYPE_ONESHOT = 0;
	TimerEvents.TIMEREVENTTYPE_REPEAT = 1;
	function TimerEvents()
	{
		this.next = null;
		this.type = 0;
		this.name = null;
		this.timer = 0;
		this.timerNext = 0;
		this.timerPosition = 0;
		this.loops = 0;
		this.index = 0;
		this.bDelete = false;
	}	// CLO Object
	// -------------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CLO.PARENT_NONE = 0;
	CLO.PARENT_FRAME = 1;
	CLO.PARENT_FRAMEITEM = 2;
	CLO.PARENT_QUALIFIER = 3;
	function CLO()
	{
		this.loHandle = 0;
		this.loOiHandle = 0;
		this.loX = 0;
		this.loY = 0;
		this.loParentType = 0;
		this.loOiParentHandle = 0;
		this.loLayer = 0;
		this.loType = 0;
		this.loInstances = null;

		this.loInstances = new Array(4);
		var i;
		for (i = 0; i < 4; i++)
			this.loInstances[i] = null;
	}
	CLO.prototype =
	{
		load:        function (file)
		{
			this.loHandle = file.readAShort();
			this.loOiHandle = file.readAShort();
			this.loX = file.readAInt();
			this.loY = file.readAInt();
			this.loParentType = file.readAShort();
			this.loOiParentHandle = file.readAShort();
			this.loLayer = file.readAShort();
			file.skipBytes(2);
		},
		addInstance: function (num, bi)
		{
			this.loInstances[num] = bi;
		}
	}

	// CLOList object
	// --------------------------------------------------------------
	function CLOList()
	{
		this.list = null;
		this.handleToIndex = null;
		this.nIndex = 0;
		this.loFranIndex = 0;
	}
	CLOList.prototype =
	{
		load:            function (app)
		{
			this.nIndex = app.file.readAInt();
			this.list = new Array(this.nIndex);
			var n;
			var maxHandles = 0;
			for (n = 0; n < this.nIndex; n++)
			{
				this.list[n] = new CLO();
				this.list[n].load(app.file);
				if (this.list[n].loHandle + 1 > maxHandles)
				{
					maxHandles = this.list[n].loHandle + 1;
				}
				var pOI = app.OIList.getOIFromHandle(this.list[n].loOiHandle);
				this.list[n].loType = pOI.oiType;
			}
			this.handleToIndex = new Array(maxHandles);
			for (n = 0; n < this.nIndex; n++)
			{
				this.handleToIndex[this.list[n].loHandle] = n;
			}
		},
		getLOFromIndex:  function (index)
		{
			return this.list[index];
		},
		getLOFromHandle: function (handle)
		{
			if (handle < this.handleToIndex.length)
			{
				return this.list[this.handleToIndex[handle]];
			}
			return null;
		},

		next_LevObj: function ()
		{
			var plo;
			if (this.loFranIndex < this.nIndex)
			{
				do
				{
					plo = this.list[this.loFranIndex++];
					if (plo.loType >= 2)		// OBJ_SPR
					{
						return plo;
					}
				} while (this.loFranIndex < this.nIndex);
			}
			return null;
		},

		first_LevObj: function ()
		{
			this.loFranIndex = 0;
			return this.next_LevObj();
		}
	}

	// CLayer object
	// --------------------------------------------------------------------------
	CLayer.FLOPT_XCOEF = 0x0001;
	CLayer.FLOPT_YCOEF = 0x0002;
	CLayer.FLOPT_NOSAVEBKD = 0x0004;
	CLayer.FLOPT_VISIBLE = 0x0010;
	CLayer.FLOPT_WRAP_HORZ = 0x0020;
	CLayer.FLOPT_WRAP_VERT = 0x0040;
	CLayer.FLOPT_REDRAW = 0x000010000;
	CLayer.FLOPT_TOHIDE = 0x000020000;
	CLayer.FLOPT_TOSHOW = 0x000040000;
	function CLayer(a)
	{
		this.app = a;
		this.pName = null;
		this.x = 0;
		this.y = 0;
		this.realX = 0;
		this.realY = 0;
		this.dx = 0;
		this.dy = 0;
		this.pObstacles = null;
		this.pPlatforms = null;
		this.addedBackdrops = null;
		this.bVisible = false;
		this.pLadders = null;
		this.nZOrderMax = 0;
		this.dwOptions = 0;
		this.xCoef = 0;
		this.yCoef = 0;
		this.nBkdLOs = 0;
		this.nFirstLOIndex = 0;
		this.effect = 0;
		this.effectParam = 0;
		this.backUp_dwOptions = 0;
		this.backUp_xCoef = 0;
		this.backUp_yCoef = 0;
		this.backUp_nBkdLOs = 0;
		this.backUp_nFirstLOIndex = 0;
		this.planeBack = null;
		this.planeQuickDisplay = null;
		this.planeSprites = null;
		this.angle = 0;
		this.scale = this.scaleX = this.scaleY = 1;
		this.xSpot = this.xDest = 320;
		this.ySpot = this.yDest = 240;
	}
	CLayer.prototype =
	{
		load:                 function (file)
		{
			this.dwOptions = file.readAInt();
			this.xCoef = file.readAFloat();
			this.yCoef = file.readAFloat();
			this.nBkdLOs = file.readAInt();
			this.nFirstLOIndex = file.readAInt();
			this.pName = file.readAString();

			this.backUp_dwOptions = this.dwOptions;
			this.backUp_xCoef = this.xCoef;
			this.backUp_yCoef = this.yCoef;
			this.backUp_nBkdLOs = this.nBkdLOs;
			this.backUp_nFirstLOIndex = this.nFirstLOIndex;
		},
		reset:                function ()
		{
			this.dwOptions = this.backUp_dwOptions;
			this.xCoef = this.backUp_xCoef;
			this.yCoef = this.backUp_yCoef;
			this.nBkdLOs = this.backUp_nBkdLOs;
			this.nFirstLOIndex = this.backUp_nFirstLOIndex;
			this.x = this.y = this.dx = this.dy = this.realX = this.realY = 0;

			this.pObstacles = null;
			this.pPlatforms = null;
			this.pLadders = null;
			this.addedBackdrops = null;

			this.setAngle(0);
			this.scale = 1;
			this.setScaleX(1);
			this.setScaleY(1);
			this.setXSpot(this.app.gaCxWin / 2);
			this.setYSpot(this.app.gaCyWin / 2);
			this.setXDest(this.app.gaCxWin / 2);
			this.setYDest(this.app.gaCyWin / 2);
			this.setZoom(false);

			if (this.dwOptions & CLayer.FLOPT_TOHIDE)
			{
				this.bVisible = true;
				this.hide();
			}
			else
			{
				this.bVisible = false;
				this.show();
			}
		},
		deleteBackObjects:    function ()
		{
			this.planeBack.removeAll();
		},
		addObstacle:          function (bi)
		{
			if (this.pObstacles == null)
				this.pObstacles = new CArrayList();
			this.pObstacles.add(bi);
		},
		delObstacle:          function (bi)
		{
			if (this.pObstacles != null)
				this.pObstacles.removeObject(bi);
		},
		addPlatform:          function (bi)
		{
			if (this.pPlatforms == null)
				this.pPlatforms = new CArrayList();
			this.pPlatforms.add(bi);
		},
		delPlatform:          function (bi)
		{
			if (this.pPlatforms != null)
				this.pPlatforms.removeObject(bi);
		},
		addBackdrop:          function (bi)
		{
			if (this.addedBackdrops == null)
				this.addedBackdrops = new CArrayList();
			this.addedBackdrops.add(bi);
		},
		resetLevelBackground: function ()
		{
			this.pPlatforms = null;
			this.pObstacles = null;
			this.pLadders = null;
			this.addedBackdrops = null;
			this.planeBack.removeAll();
		},
		createPlanes:         function (xOffset, yOffset)
		{
			this.planeBack = new Sprite();
			this.planeBack.x = xOffset;
			this.planeBack.y = yOffset;
			this.planeQuickDisplay = new Sprite();
			this.planeQuickDisplay.x = xOffset;
			this.planeQuickDisplay.y = yOffset;
			this.planeSprites = new Sprite();
			this.planeSprites.x = xOffset;
			this.planeSprites.y = yOffset;

			this.setAngle(0);
			this.scale = 1;
			this.setScaleX(1);
			this.setScaleY(1);
			this.setXSpot(this.app.gaCxWin / 2);
			this.setYSpot(this.app.gaCyWin / 2);
			this.setXDest(this.app.gaCxWin / 2);
			this.setYDest(this.app.gaCyWin / 2);
			this.setZoom(false);

			this.app.mainSprite.addChild(this.planeBack);
			this.app.mainSprite.addChild(this.planeQuickDisplay);
			this.app.mainSprite.addChild(this.planeSprites);
			this.showHide();
		},

		setAngle:  function (angle)
		{
			this.angle = angle;
			this.planeBack.angle = angle;
			this.planeQuickDisplay.angle = angle;
			this.planeSprites.angle = angle;
		},
		setScaleX: function (scale)
		{
			this.scaleX = scale;
			this.planeBack.scaleX = scale;
			this.planeQuickDisplay.scaleX = scale;
			this.planeSprites.scaleX = scale;
		},
		setScaleY: function (scale)
		{
			this.scaleY = scale;
			this.planeBack.scaleY = scale;
			this.planeQuickDisplay.scaleY = scale;
			this.planeSprites.scaleY = scale;
		},
		setXSpot:  function (spot)
		{
			this.xSpot = spot;
			this.planeBack.xSpot = spot;
			this.planeQuickDisplay.xSpot = spot;
			this.planeSprites.xSpot = spot;
		},
		setYSpot:  function (spot)
		{
			this.ySpot = spot;
			this.planeBack.ySpot = spot;
			this.planeQuickDisplay.ySpot = spot;
			this.planeSprites.ySpot = spot;
		},
		setXDest:  function (spot)
		{
			spot = this.app.gaCxWin - spot;
			this.xDest = spot;
			this.planeBack.xDest = spot;
			this.planeQuickDisplay.xDest = spot;
			this.planeSprites.xDest = spot;
		},
		setYDest:  function (spot)
		{
			spot = this.app.gaCyWin - spot;
			this.yDest = spot;
			this.planeBack.yDest = spot;
			this.planeQuickDisplay.yDest = spot;
			this.planeSprites.yDest = spot;
		},
		setZoom:   function (zoom)
		{
			this.bZoom = zoom;
			this.planeBack.bZoom = zoom;
			this.planeQuickDisplay.bZoom = zoom;
			this.planeSprites.bZoom = zoom;
		},

		resetPlanes: function (xOffset, yOffset)
		{
			this.planeBack.x = xOffset;
			this.planeBack.y = yOffset;
			this.planeQuickDisplay.x = xOffset;
			this.planeQuickDisplay.y = yOffset;
			this.planeSprites.x = xOffset;
			this.planeSprites.y = yOffset;
			this.show();
		},

		fillBack: function (sx, sy, color)
		{
			// TODO!
		},

		showHide:               function ()
		{
			if (this.dwOptions & CLayer.FLOPT_VISIBLE)
				this.show();
			else
				this.hide();
		},
		hide:                   function ()
		{
			this.dwOptions &= ~CLayer.FLOPT_TOHIDE;
			if (this.bVisible)
			{
				this.planeBack.visible = false;
				this.planeQuickDisplay.visible = false;
				this.planeSprites.visible = false;
				this.bVisible = false;
			}
		},
		show:                   function ()
		{
			if (this.bVisible == false)
			{
				this.planeBack.visible = true;
				this.planeQuickDisplay.visible = true;
				this.planeSprites.visible = true;
				this.bVisible = true;
			}
		},
		deletePlanes:           function ()
		{
			if (this.planeBack != null)
			{
				this.app.mainSprite.removeChild(this.planeBack);
				this.planeBack = null;
			}
			if (this.planeQuickDisplay != null)
			{
				this.app.mainSprite.removeChild(this.planeQuickDisplay);
				this.planeQuickDisplay = null;
			}
			if (this.planeSprites != null)
			{
				this.app.mainSprite.removeChild(this.planeSprites);
				this.planeSprites = null;
			}
		},
		deleteAddedBackdrops:   function ()
		{
			var n;
			if (this.addedBackdrops != null)
			{
				for (n = 0; n < this.addedBackdrops.size(); n++)
				{
					var bi = this.addedBackdrops.get(n);
					bi.delInstance(this);
					if (bi.body != null)
					{
						this.app.run.rh4Box2DBase.rSubABackdrop(bi.body);
					}
				}
			}
			this.addedBackdrops = null;
		},
		deleteAddedBackdropsAt: function (xx, yy, fine)
		{
			xx += this.x;
			yy += this.y;

			var n;
			if (this.addedBackdrops != null)
			{
				for (n = 0; n < this.addedBackdrops.size(); n++)
				{
					var bi = this.addedBackdrops.get(n);
					if (xx >= bi.x && xx < bi.x + bi.width)
					{
						if (yy >= bi.y && yy < bi.y + bi.height)
						{
							var flag = true;
							if (fine)
							{
								flag = bi.testPoint(xx, yy);
							}
							if (flag)
							{
								bi.delInstance(this);
								this.addedBackdrops.removeObject(bi);
								if (bi.body != null)
								{
									this.app.run.rh4Box2DBase.rSubABackdrop(bi.body);
								}
								return;
							}
						}
					}
				}
			}
		},

		addLadder: function (x1, y1, x2, y2)
		{
			var rc = new CRect();
			rc.left = x1;
			rc.top = y1;
			rc.right = x2;
			rc.bottom = y2;
			if (this.pLadders == null)
				this.pLadders = new CArrayList();
			this.pLadders.add(rc);
		},

		ladderSub:   function (x1, y1, x2, y2)
		{
			if (pLadders != null)
			{
				var rc = new CRect();
				rc.left = Math.min(x1, x2);
				rc.top = Math.min(y1, y2);
				rc.right = Math.max(x1, x2);
				rc.bottom = Math.max(y1, y2);

				var i;
				var rcDst;
				for (i = 0; i < pLadders.size(); i++)
				{
					rcDst = this.pLadders.get(i);
					if (rcDst.intersectRect(rc) == true)
					{
						this.pLadders.removeIndex(i);
						i--;
					}
				}
			}
		},
		getLadderAt: function (xx, yy)
		{
			var nl, nLayers;
			xx += this.x;
			yy += this.y;

			if (this.pLadders != null)
			{
				var i;
				var rc;
				for (i = 0; i < this.pLadders.size(); i++)
				{
					rc = this.pLadders.get(i);
					if (xx >= rc.left)
					{
						if (yy >= rc.top)
						{
							if (xx < rc.right)
							{
								if (yy < rc.bottom)
								{
									return rc;
								}
							}
						}
					}
				}
			}
			return null;
		},
		testMask:    function (mask, xx, yy, htFoot, plan)
		{
			var xLeft = xx + this.x - mask.xSpot;
			var yTop = yy + this.y - mask.ySpot;
			var xRight = xLeft + mask.width;
			var yBottom = yTop + mask.height;
			var yFoot = yTop;
			if (htFoot != 0)
				yFoot = yBottom - htFoot;

			var o;
			var bi;
			var list;
			if (plan == CColMask.CM_TEST_OBSTACLE)
				list = this.pObstacles;
			else
				list = this.pPlatforms;
			if (list == null)
				return null;

			for (o = 0; o < list.size(); o++)
			{
				bi = list.get(o);
				if (bi.x < xRight && bi.x + bi.width > xLeft)
				{
					if (bi.y < yBottom && bi.y + bi.height > yFoot)
					{
						if (bi.testMask(mask, xLeft, yTop, htFoot))
						{
							return bi;
						}
					}
				}
			}
			return null;
		},
		testRect:    function (x1, y1, x2, y2, htFoot, plan)
		{
			var list;
			if (plan == CColMask.CM_TEST_OBSTACLE)
				list = this.pObstacles;
			else
				list = this.pPlatforms;
			if (list == null)
				return null;

			x1 += this.x;
			y1 += this.y;
			x2 += this.x;
			y2 += this.y;
			if (htFoot != 0)
				y1 = y2 - htFoot;

			var o;
			for (o = 0; o < list.size(); o++)
			{
				var bi = list.get(o);
				if (bi.x < x2 && bi.x + bi.width > x1)
				{
					if (bi.y < y2 && bi.y + bi.height > y1)
					{
						if (bi.testRect(x1, y1, x2, y2))
						{
							return bi;
						}
					}
				}
			}
			return null;
		},
		testPoint:   function (x1, y1, plan)
		{
			var list;
			if (plan == CColMask.CM_TEST_OBSTACLE)
				list = this.pObstacles;
			else
				list = this.pPlatforms;
			if (list == null)
				return null;

			x1 += this.x;
			y1 += this.y;

			var o;
			for (o = 0; o < list.size(); o++)
			{
				var bi = list.get(o);
				if (x1 >= bi.x && x1 < bi.x + bi.width)
				{
					if (y1 >= bi.y && y1 < bi.y + bi.height)
					{
						if (bi.testPoint(x1, y1))
						{
							return bi;
						}
					}
				}
			}
			return null;
		}
	}

	// CBackInstance object
	// ------------------------------------------------------------------
	function CBackInstance(a, xx, yy, plo, sprImage, colType)
	{
		this.app = a;
		this.levelObject = plo;
		this.type = 0;
		this.obstacleType = 0;
		this.x = xx;
		this.y = yy;
		this.width = 0;
		this.height = 0;
		this.poi = null;
		this.colBox = false;
		this.imageUsed = null;
		this.borderWidth = 0;
		this.color1 = null;
		this.color2 = null;
		this.borderColor = null;
		this.effect = 0;
		this.effectParam = 0;
		this.body = null;
		this.ho = null;

		if (plo)
		{
			this.poi = this.app.OIList.getOIFromHandle(plo.loOiHandle);
			this.type = this.poi.oiType;
			this.obstacleType = this.poi.oiOC.ocObstacleType;
			this.borderWidth = this.poi.oiOC.ocBorderSize;
			this.gradientFlags = this.poi.oiOC.ocGradientFlags;
			this.effect = this.poi.oiInkEffect;
			this.effectParam = this.poi.oiInkEffectParam;
			this.width = this.poi.oiOC.ocCx;
			this.height = this.poi.oiOC.ocCy;
			this.colBox = this.poi.oiOC.ocColMode != 0;
			this.color1 = this.poi.oiOC.ocColor1;
			this.color2 = this.poi.oiOC.ocColor2;
			this.borderColor = this.poi.oiOC.ocBorderColor;
			if (this.type == 1)
			{
				this.imageUsed = this.app.imageBank.getImageFromHandle(this.poi.oiOC.ocImage);
				this.width = this.imageUsed.width;
				this.height = this.imageUsed.height;
			}
			else if (this.type >= 32)
			{
				var rhPtr = this.app.run;
				var hoPtr = null;
				var count = 0;
				for (var nObject = 0; nObject < rhPtr.rhNObjects; nObject++)
				{
					while (rhPtr.rhObjectList[count] == null)
						count++;
					hoPtr = rhPtr.rhObjectList[count];
					count++;
					if (hoPtr.lo == plo)
					{
						break;
					}
				}
				this.ho = hoPtr;
			}
		}
		else
		{
			this.type = COI.OBJ_PASTED;
			this.imageUsed = sprImage;
			this.width = this.imageUsed.width;
			this.height = this.imageUsed.height;
			this.x -= this.imageUsed.xSpot;
			this.y -= this.imageUsed.ySpot;
			switch (colType)
			{
				case 0:
					this.obstacleType = COC.OBSTACLE_NONE;
					break;
				case 1:
					this.obstacleType = COC.OBSTACLE_SOLID;
					break;
				case 2:
					this.obstacleType = COC.OBSTACLE_PLATFORM;
					break;
				case 3:
					this.obstacleType = COC.OBSTACLE_LADDER;
					break;
			}
			this.colBox = false;
		}
	}
	CBackInstance.prototype =
	{
		draw:        function (context, xx, yy)
		{
			if (this.levelObject != null)
			{
				if (this.type == COI.OBJ_BOX)
				{
					var pCOCQB = this.poi.oiOC;
					var image;

					switch (pCOCQB.ocFillType)
					{
						case 0: /* no fill */
							break;

						case 1: /* solid */

							switch (pCOCQB.ocShape)
							{
								case 1: /* line */

									context.renderLine(xx + this.x, yy + this.y, this.width,
										this.height, this.color1, this.effect,
										this.effectParam);

									break;

								case 2: /* rectangle */

									context.renderSolidColor(xx + this.x, yy + this.y, this.width,
										this.height, this.color1, this.effect,
										this.effectParam);

									break;

								case 3: /* ellipse */
									context.renderSolidColorEllipse(xx + this.x, yy + this.y, this.width,
										this.height, this.color1, this.effect,
										this.effectParam);
									break;
							}
							;

							break;

						case 2: /* gradient */

							switch (pCOCQB.ocShape)
							{
								case 1: /* line */

									context.renderLine(xx + this.x, yy + this.y, this.width,
										this.height, this.color1, this.effect,
										this.effectParam);

									break;

								case 2: /* rectangle */

									context.renderGradient(xx + this.x, yy + this.y, this.width,
										this.height, this.color1, this.color2, this.gradientFlags != 0,
										this.effect, this.effectParam);

									break;

								case 3: /* ellipse */

									context.renderGradientEllipse(xx + this.x, yy + this.y, this.width,
										this.height, this.color1, this.color2, this.gradientFlags != 0,
										this.effect, this.effectParam);

									break;
							}
							;

							break;

						case 3: /* motif */

							switch (pCOCQB.ocShape)
							{
								case 1: /* line */
									break;

								case 2: /* rectangle */
									image = this.app.imageBank.getImageFromHandle(pCOCQB.ocImage);
									context.renderPattern(image, xx + this.x, yy + this.y, this.width,
										this.height, this.effect, this.effectParam);
									break;

								case 3: /* ellipse */
									image = this.app.imageBank.getImageFromHandle(pCOCQB.ocImage);
									context.renderPatternEllipse(image, xx + this.x, yy + this.y, this.width,
										this.height, this.effect, this.effectParam);
									break;
							}
							break;
					}

					if (this.borderWidth > 0)
					{
						switch (pCOCQB.ocShape)
						{
							case 1: /* line */

								var xLine = 0;
								var yLine = 0;
								var cxLine = this.width;
								var cyLine = this.height;
								if ((pCOCQB.ocLineFlags & COCQBackdrop.LINEF_INVX) != 0)
								{
									xLine += cxLine;
									cxLine = -cxLine;
								}
								if ((pCOCQB.ocLineFlags & COCQBackdrop.LINEF_INVY) != 0)
								{
									yLine += cyLine;
									cyLine = -cyLine;
								}

								context.renderLine(xx + this.x + xLine, yy + this.y + yLine,
									xx + this.x + xLine + cxLine, yy + this.y + yLine + cyLine,
									this.borderColor, this.borderWidth);

								break;

							case 2: /* rectangle */

								context.renderRect(xx + this.x, yy + this.y, this.width, this.height,
									this.borderColor, this.borderWidth);

								break;

							case 3: /* ellipse */

								context.renderEllipse(xx + this.x, yy + this.y, this.width,
									this.height, 1, this.borderColor, this.borderWidth);
								break;
						}
					}
				}
				else if (this.type == COI.OBJ_BKD)
				{
				    context.renderImage(this.imageUsed, xx + this.x + this.imageUsed.xSpot, yy + this.y + this.imageUsed.ySpot, 0, 1.0, 1.0, this.effect, this.effectParam);
				}
				else
				{
				    if ( this.ho != null )
					    this.ho.draw(context, xx, yy);
				}
			}
			else
			{
			    context.renderImage(this.imageUsed, xx + this.x + this.imageUsed.xSpot, yy + this.y + this.imageUsed.ySpot, 0, 1.0, 1.0, this.effect, this.effectParam);
			}
		},
		setEffect:   function (e, ep)
		{
			this.effect = e;
			this.effectParam = ep;
		},
		addInstance: function (num, pLayer)
		{
			pLayer.planeBack.addChild(this);
			if (this.type == COI.OBJ_PASTED)
				pLayer.addBackdrop(this);

			switch (this.obstacleType)
			{
				case COC.OBSTACLE_SOLID:
					pLayer.addObstacle(this);
					pLayer.addPlatform(this);
					break;
				case COC.OBSTACLE_PLATFORM:
					pLayer.addPlatform(this);
					break;
				case COC.OBSTACLE_LADDER:
					pLayer.addLadder(this.x, this.y, this.x + this.width, this.y + this.height);
					break;
			}
		},
		delInstance: function (pLayer)
		{
			pLayer.planeBack.removeChild(this);
			switch (this.obstacleType)
			{
				case COC.OBSTACLE_SOLID:
					pLayer.delObstacle(this);
					pLayer.delPlatform(this);
					break;
				case COC.OBSTACLE_PLATFORM:
					pLayer.delPlatform(this);
					break;
				case COC.OBSTACLE_LADDER:
					pLayer.ladderSub(x, y, x + width, y + height);
					break;
			}
		},

		testMask:  function (mask, xx, yy, htFoot)
		{
			var flags;
			var mask2;

			switch (this.type)
			{
				case 0:
					var h = this.height;
					if (this.obstacleType == COC.OBSTACLE_PLATFORM)
					{
						h = CRunFrame.HEIGHT_PLATFORM;
					}
					return mask.testRect2(xx, yy, htFoot, this.x, this.y, this.width, h, 0);
				case 1:
					if (this.colBox != 0)
					{
						return true;
					}
					flags = CMask.GCMF_OBSTACLE;
					if (this.obstacleType == COC.OBSTACLE_PLATFORM)
					{
						flags = CMask.GCMF_PLATFORM;
					}
					mask2 = this.imageUsed.getMask(flags, 0, 1.0, 1.0);
					return mask.testMask(xx, yy, htFoot, mask2, this.x, this.y, 0);
				case 11:
					if (this.colBox != 0)
					{
						return true;
					}
					flags = CMask.GCMF_OBSTACLE;
					if (this.obstacleType == COC.OBSTACLE_PLATFORM)
					{
						flags = CMask.GCMF_PLATFORM;
					}
					mask2 = this.imageUsed.getMask(flags, 0, 1.0, 1.0);
					return mask.testMask(xx, yy, htFoot, mask2, this.x, this.y, 0);
			}
			return false;
		},
		testRect:  function (x1, y1, x2, y2)
		{
			var flags;
			var mask;

			switch (this.type)
			{
				case 0:
					if (this.obstacleType == COC.OBSTACLE_PLATFORM)
					{
						var yTop = this.y;
						var yBottom = this.y + Math.min(this.height, CRunFrame.HEIGHT_PLATFORM);
						if (yTop < y2 && yBottom > y1)
						{
							return true;
						}
						return false;
					}
					return true;
				case 1:
					if (this.colBox != 0)
					{
						return true;
					}
					flags = CMask.GCMF_OBSTACLE;
					if (this.obstacleType == COC.OBSTACLE_PLATFORM)
					{
						flags = CMask.GCMF_PLATFORM;
					}
					mask = this.imageUsed.getMask(flags, 0, 1.0, 1.0);
					return mask.testRect2(this.x, this.y, 0, x1, y1, x2, y2, 0);
				case 11:
					if (this.colBox != 0)
					{
						return true;
					}
					flags = CMask.GCMF_OBSTACLE;
					if (this.obstacleType == COC.OBSTACLE_PLATFORM)
					{
						flags = CMask.GCMF_PLATFORM;
					}
					mask = this.imageUsed.getMask(flags, 0, 1.0, 1.0);
					return mask.testRect2(this.x, this.y, 0, x1, y1, x2, y2, 0);
			}
			return false;
		},
		testPoint: function (x1, y1)
		{
			var flags;
			var mask;

			switch (this.type)
			{
				case 0:
					if (this.obstacleType == COC.OBSTACLE_PLATFORM)
					{
						var yTop = y + this.height - CRunFrame.HEIGHT_PLATFORM;
						var yBottom = this.y + this.height;
						if (y1 >= yTop && y1 < yBottom)
						{
							return true;
						}
						return false;
					}
					return true;
				case 1:
					if (this.colBox != 0)
					{
						return true;
					}
					flags = CMask.GCMF_OBSTACLE;
					if (this.obstacleType == COC.OBSTACLE_PLATFORM)
					{
						flags = CMask.GCMF_PLATFORM;
					}
					mask = this.imageUsed.getMask(flags, 0, 1.0, 1.0);
					return mask.testPoint(this.x, this.y, x1, y1);
				case 11:
					if (this.colBox != 0)
					{
						return true;
					}
					flags = CMask.GCMF_OBSTACLE;
					if (this.obstacleType == COC.OBSTACLE_PLATFORM)
					{
						flags = CMask.GCMF_PLATFORM;
					}
					mask = this.imageUsed.getMask(flags, 0, 1.0, 1.0);
					return mask.testPoint(this.x, this.y, x1, y1);
			}
			return false;
		}
	}


	// COI Object
	// -------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */

	COI.OILF_OCLOADED = 0x0001;
	COI.OILF_ELTLOADED = 0x0002;
	COI.OILF_TOLOAD = 0x0004;
	COI.OILF_TODELETE = 0x0008;
	COI.OILF_CURFRAME = 0x0010;
	COI.OILF_TORELOAD = 0x0020;
	COI.OILF_IGNORELOADONCALL = 0x0040;
	COI.OIF_LOADONCALL = 0x0001;
	COI.OIF_DISCARDABLE = 0x0002;
	COI.OIF_GLOBAL = 0x0004;
	COI.NUMBEROF_SYSTEMTYPES = 7;
	COI.OBJ_PLAYER = -7;
	COI.OBJ_KEYBOARD = -6;
	COI.OBJ_CREATE = -5;
	COI.OBJ_TIMER = -4;
	COI.OBJ_GAME = -3;
	COI.OBJ_SPEAKER = -2;
	COI.OBJ_SYSTEM = -1;
	COI.OBJ_BOX = 0;
	COI.OBJ_BKD = 1;
	COI.OBJ_SPR = 2;
	COI.OBJ_TEXT = 3;
	COI.OBJ_QUEST = 4;
	COI.OBJ_SCORE = 5;
	COI.OBJ_LIVES = 6;
	COI.OBJ_COUNTER = 7;
	COI.OBJ_RTF = 8;
	COI.OBJ_CCA = 9;
	COI.NB_SYSOBJ = 10;
	COI.OBJ_PASTED = 11;
	COI.OBJ_LAST = 10;
	COI.KPX_BASE = 32;
	COI.OIFLAG_QUALIFIER = 0x8000;

	function COI()
	{
		this.oiHandle = 0;
		this.oiType = 0;
		this.oiFlags = 0;
		this.oiInkEffect = 0;
		this.oiInkEffectParam = 0;
		this.oiName = null;
		this.oiOC = null;
		this.oiFileOffset = 0;
		this.oiLoadFlags = 0;
		this.oiLoadCount = 0;
		this.oiCount = 0;
	}
	COI.prototype =
	{
		loadHeader:   function (file)
		{
			this.oiHandle = file.readAShort();
			this.oiType = file.readAShort();
			this.oiFlags = file.readAShort();
			file.skipBytes(2);
			this.oiInkEffect = file.readAInt();
			this.oiInkEffectParam = file.readAInt();
		},
		load:         function (file)
		{
			file.seek(this.oiFileOffset);

			switch (this.oiType)
			{
				case 0:
					this.oiOC = new COCQBackdrop();
					break;
				case 1:
					this.oiOC = new COCBackground();
					break;
				default:
					this.oiOC = new CObjectCommon();
					break;
			}
			this.oiOC.load(file, this.oiType);
			this.oiLoadFlags = 0;
		},
		unLoad:       function ()
		{
			this.oiOC = null;
		},
		enumElements: function (enumImages, enumFonts)
		{
			this.oiOC.enumElements(enumImages, enumFonts);
		}
	}

	// COIList object
	// ----------------------------------------------------------------------
	function COIList()
	{
		this.oiMaxIndex = 0;
		this.ois = 0;
		this.oiMaxHandle = 0;
		this.oiHandleToIndex = null;
		this.oiToLoad = null;
		this.oiLoaded = null;
		this.currentOI = 0;
	}
	COIList.prototype =
	{
		preLoad:         function (file)
		{
			// Alloue la table de OI
			this.oiMaxIndex = file.readAInt();
			this.ois = new Array(this.oiMaxIndex);

			// Explore les chunks
			var index;
			this.oiMaxHandle = 0;
			for (index = 0; index < this.oiMaxIndex; index++)
			{
				var chID = 0;
				var chFlags;
				var chSize;
				var posEnd;
				while (chID != 0x7F7F)
				{
					chID = file.readAShort();
					chFlags = file.readAShort();
					chSize = file.readAInt();
					if (chSize == 0)
						continue;
					posEnd = file.getFilePointer() + chSize;

					switch (chID)
					{
						case 0x4444:
							this.ois[index] = new COI();
							this.ois[index].loadHeader(file);
							if (this.ois[index].oiHandle >= this.oiMaxHandle)
								this.oiMaxHandle = (this.ois[index].oiHandle + 1);
							break;
						case 0x4445:
							this.ois[index].oiName = file.readAString();
							break;
						case 0x4446:
							this.ois[index].oiFileOffset = file.getFilePointer();
							break;
					}
					file.seek(posEnd);
				}
			}

			this.oiHandleToIndex = new Array(this.oiMaxHandle);
			for (index = 0; index < this.oiMaxIndex; index++)
			{
				this.oiHandleToIndex[this.ois[index].oiHandle] = index;
			}

			this.oiToLoad = new Array(this.oiMaxHandle);
			this.oiLoaded = new Array(this.oiMaxHandle);
			var n;
			for (n = 0; n < this.oiMaxHandle; n++)
			{
				this.oiToLoad[n] = 0;
				this.oiLoaded[n] = 0;
			}
		},
		getOIFromHandle: function (handle)
		{
			return this.ois[this.oiHandleToIndex[handle]];
		},
		getOIFromIndex:  function (index)
		{
			return this.ois[index];
		},
		resetOICurrent:  function ()
		{
			var n;
			for (n = 0; n < this.oiMaxIndex; n++)
			{
				this.ois[n].oiFlags &= ~COI.OILF_CURFRAME;
			}
		},
		setOICurrent:    function (handle)
		{
			this.ois[this.oiHandleToIndex[handle]].oiFlags |= COI.OILF_CURFRAME;
		},
		getFirstOI:      function ()
		{
			var n;
			for (n = 0; n < this.oiMaxIndex; n++)
			{
				if ((this.ois[n].oiFlags & COI.OILF_CURFRAME) != 0)
				{
					this.currentOI = n;
					return this.ois[n];
				}
			}
			return null;
		},
		getNextOI:       function ()
		{
			if (this.currentOI < this.oiMaxIndex)
			{
				var n;
				for (n = this.currentOI + 1; n < this.oiMaxIndex; n++)
				{
					if ((this.ois[n].oiFlags & COI.OILF_CURFRAME) != 0)
					{
						this.currentOI = n;
						return this.ois[n];
					}
				}
			}
			return null;
		},

		resetToLoad:  function ()
		{
			var n;
			for (n = 0; n < this.oiMaxHandle; n++)
			{
				this.oiToLoad[n] = 0;
			}
		},
		setToLoad:    function (n)
		{
			this.oiToLoad[n] = 1;
		},
		load:         function (file)
		{
			var h;
			for (h = 0; h < this.oiMaxHandle; h++)
			{
				if (this.oiToLoad[h] != 0)
				{
					if (this.oiLoaded[h] == 0 || (this.oiLoaded[h] != 0 && (this.ois[this.oiHandleToIndex[h]].oiLoadFlags & COI.OILF_TORELOAD) != 0))
					{
						this.ois[this.oiHandleToIndex[h]].load(file);
						this.oiLoaded[h] = 1;
					}
				}
				else
				{
					if (this.oiLoaded[h] != 0)
					{
						this.ois[this.oiHandleToIndex[h]].unLoad();
						this.oiLoaded[h] = 0;
					}
				}
			}
			this.resetToLoad();
		},
		enumElements: function (enumImages, enumFonts)
		{
			var h;
			for (h = 0; h < this.oiMaxHandle; h++)
			{
				if (this.oiLoaded[h] != 0)
				{
					this.ois[this.oiHandleToIndex[h]].enumElements(enumImages, enumFonts);
				}
			}
		}
	}

	// COC object
	// -------------------------------------------------------------------
	COC.OBSTACLE_NONE = 0;
	COC.OBSTACLE_SOLID = 1;
	COC.OBSTACLE_PLATFORM = 2;
	COC.OBSTACLE_LADDER = 3;
	COC.OBSTACLE_TRANSPARENT = 4;
	function COC()
	{
	}

	// COCBackground object
	// -------------------------------------------------------------------
	function COCBackground()
	{
		this.ocImage = 0;
	}
	COCBackground.prototype =
	{
		load: function (file, type)
		{
			file.skipBytes(4);		// ocDWSize
			this.ocObstacleType = file.readAShort();
			this.ocColMode = file.readAShort();
			this.ocCx = file.readAInt();
			this.ocCy = file.readAInt();
			this.ocImage = file.readAShort();
		},

		enumElements: function (enumImages, enumFonts)
		{
			if (enumImages != null)
			{
				var num = enumImages.enumerate(this.ocImage);
				if (num != -1)
				{
					this.ocImage = num;
				}
			}
		}
	}

	// COCQBackdrop object
	// ------------------------------------------------------------------
	COCQBackdrop.LINEF_INVX = 0x0001;
	COCQBackdrop.LINEF_INVY = 0x0002;
	function COCQBackdrop()
	{
		this.ocBorderSize = 0;
		this.ocBorderColor = 0;
		this.ocShape = 0;
		this.ocFillType = 0;
		this.ocLineFlags = 0;
		this.ocColor1 = 0;
		this.ocColor2 = 0;
		this.ocGradientFlags = 0;
		this.ocImage = 0;
	}
	COCQBackdrop.prototype =
	{
		load: function (file, type)
		{
			file.skipBytes(4);
			this.ocObstacleType = file.readAShort();
			this.ocColMode = file.readAShort();
			this.ocCx = file.readAInt();
			this.ocCy = file.readAInt();
			this.ocBorderSize = file.readAShort();
			this.ocBorderColor = file.readAColor();
			this.ocShape = file.readAShort();

			this.ocFillType = file.readAShort();
			if (this.ocShape == 1)
			{
				this.ocLineFlags = file.readAShort();
			}
			else
			{
				switch (this.ocFillType)
				{
					case 1:
						this.ocColor1 = this.ocColor2 = file.readAColor();
						break;
					case 2:
						this.ocColor1 = file.readAColor();
						this.ocColor2 = file.readAColor();
						this.ocGradientFlags = file.readAInt();
						break;
					case 3:
						this.ocImage = file.readAShort();
						break;
				}
			}
		},

		enumElements: function (enumImages, enumFonts)
		{
			if (this.ocFillType == 3)
			{
				if (enumImages != null)
				{
					var num = enumImages.enumerate(this.ocImage);
					if (num != -1)
					{
						ocImage = num;
					}
				}
			}
		}
	}

	// CObjectCommon object
	// -------------------------------------------------------------------
	CObjectCommon.OEFLAG_DISPLAYINFRONT = 0x0001;
	CObjectCommon.OEFLAG_BACKGROUND = 0x0002;
	CObjectCommon.OEFLAG_BACKSAVE = 0x0004;
	CObjectCommon.OEFLAG_RUNBEFOREFADEIN = 0x0008;
	CObjectCommon.OEFLAG_MOVEMENTS = 0x0010;
	CObjectCommon.OEFLAG_ANIMATIONS = 0x0020;
	CObjectCommon.OEFLAG_TABSTOP = 0x0040;
	CObjectCommon.OEFLAG_WINDOWPROC = 0x0080;
	CObjectCommon.OEFLAG_VALUES = 0x0100;
	CObjectCommon.OEFLAG_SPRITES = 0x0200;
	CObjectCommon.OEFLAG_INTERNALBACKSAVE = 0x0400;
	CObjectCommon.OEFLAG_SCROLLINGINDEPENDANT = 0x0800;
	CObjectCommon.OEFLAG_QUICKDISPLAY = 0x1000;
	CObjectCommon.OEFLAG_NEVERKILL = 0x2000;
	CObjectCommon.OEFLAG_NEVERSLEEP = 0x4000;
	CObjectCommon.OEFLAG_MANUALSLEEP = 0x8000;
	CObjectCommon.OEFLAG_TEXT = 0x10000;
	CObjectCommon.OEFLAG_DONTCREATEATSTART = 0x20000;
	CObjectCommon.OEFLAG_DONTRESETANIMCOUNTER = 0x100000;
	CObjectCommon.OCFLAGS2_DONTSAVEBKD = 0x0001;
	CObjectCommon.OCFLAGS2_SOLIDBKD = 0x0002;
	CObjectCommon.OCFLAGS2_COLBOX = 0x0004;
	CObjectCommon.OCFLAGS2_VISIBLEATSTART = 0x0008;
	CObjectCommon.OCFLAGS2_OBSTACLESHIFT = 4;
	CObjectCommon.OCFLAGS2_OBSTACLEMASK = 0x0030;
	CObjectCommon.OCFLAGS2_OBSTACLE_SOLID = 0x0010;
	CObjectCommon.OCFLAGS2_OBSTACLE_PLATFORM = 0x0020;
	CObjectCommon.OCFLAGS2_OBSTACLE_LADDER = 0x0030;
	CObjectCommon.OCFLAGS2_AUTOMATICROTATION = 0x0040;
	CObjectCommon.OCFLAGS2_INITFLAGS = 0x0080;
	CObjectCommon.OEPREFS_BACKSAVE = 0x0001;
	CObjectCommon.OEPREFS_SCROLLINGINDEPENDANT = 0x0002;
	CObjectCommon.OEPREFS_QUICKDISPLAY = 0x0004;
	CObjectCommon.OEPREFS_SLEEP = 0x0008;
	CObjectCommon.OEPREFS_LOADONCALL = 0x0010;
	CObjectCommon.OEPREFS_GLOBAL = 0x0020;
	CObjectCommon.OEPREFS_BACKEFFECTS = 0x0040;
	CObjectCommon.OEPREFS_KILL = 0x0080;
	CObjectCommon.OEPREFS_INKEFFECTS = 0x0100;
	CObjectCommon.OEPREFS_TRANSITIONS = 0x0200;
	CObjectCommon.OEPREFS_FINECOLLISIONS = 0x0400;
	CObjectCommon.prototype = COC;

	function CObjectCommon()
	{
		this.ocOEFlags = 0;
		this.ocQualifiers = null;
		this.ocFlags2 = 0;
		this.ocOEPrefs = 0;
		this.ocIdentifier = 0;
		this.ocBackColor = 0;
		this.ocMovements = null;
		this.ocValues = null;
		this.ocStrings = null;
		this.ocAnimations = null;
		this.ocCounters = null;
		this.ocObject = null;
		this.ocExtension = 0;
		this.ocVersion = 0;
		this.ocID = 0;
		this.ocPrivate = 0;
		this.ocFadeIn = null;
		this.ocFadeOut = null;
	}
	CObjectCommon.prototype =
	{
		load:         function (file, type)
		{
			// Position de debut
			var debut = file.getFilePointer();
			this.ocQualifiers = new Array(8);

			// Lis le header
			var n;
			file.skipBytes(4);
			file.skipBytes(2);      // var oMovements = file.readAShort();
			var oData = file.readAShort();  // var oAnimations = file.readAShort();
			file.skipBytes(2);
			var oCounter = file.readAShort();
			var oAnimations = file.readAShort(); // var oData = file.readAShort();
			var oMovements = file.readAShort();    // file.skipBytes(2);
			this.ocOEFlags = file.readAInt();
			for (n = 0; n < 8; n++)
			{
				this.ocQualifiers[n] = file.readShort();
			}
			this.ocOEPrefs = file.readAShort(); // var oExtension = file.readAShort();
			var oValues = file.readAShort();
			var oStrings = file.readAShort();
			this.ocFlags2 = file.readAShort();
			var oExtension = file.readAShort(); // this.ocOEPrefs = file.readAShort();
			this.ocIdentifier = file.readAInt();
			this.ocBackColor = file.readAColor();
			var oFadeIn = file.readAInt();
			var oFadeOut = file.readAInt();
			this.ocFadeIn = null;
			this.ocFadeOut = null;

			if (oMovements != 0)
			{
				file.seek(debut + oMovements);
				this.ocMovements = new CMoveDefList();
				this.ocMovements.load(file);
			}
			if (oValues != 0)
			{
				file.seek(debut + oValues);
				this.ocValues = new CDefValues();
				this.ocValues.load(file, (this.ocFlags2 & CObjectCommon.OCFLAGS2_INITFLAGS) != 0);
	        }
			if (oStrings != 0)
			{
				file.seek(debut + oStrings);
				this.ocStrings = new CDefStrings();
				this.ocStrings.load(file);
			}
			if (oAnimations != 0)
			{
				file.seek(debut + oAnimations);
				this.ocAnimations = new CAnimHeader();
				this.ocAnimations.load(file);
			}
			if (oCounter != 0)
			{
				file.seek(debut + oCounter);
				this.ocObject = new CDefCounter();
				this.ocObject.load(file);
			}
			if (oExtension != 0)
			{
				file.seek(debut + oExtension);
				var size = file.readAInt();
				file.skipBytes(4);
				this.ocVersion = file.readAInt();
				this.ocID = file.readAInt();
				this.ocPrivate = file.readAInt();
				size -= 20;
				if (size != 0)
				{
					this.ocExtension = file.getFilePointer();
				}
			}
			if (oFadeIn != 0)
			{
				file.seek(debut + oFadeIn);
				this.ocFadeIn = new CTransitionData();
				this.ocFadeIn.load(file);
			}
			if (oFadeOut != 0)
			{
				file.seek(debut + oFadeOut);
				this.ocFadeOut = new CTransitionData();
				this.ocFadeOut.load(file);
			}

			if (oData != 0)
			{
				file.seek(debut + oData);
				switch (type)
				{
					case 3:
					case 4:
						this.ocObject = new CDefTexts();
						this.ocObject.load(file);
						break;

					case 5:
					case 6:
					case 7:
						this.ocCounters = new CDefCounters();
						this.ocCounters.load(file);
						break;

					case 8:
						this.ocObject = new CDefRtf();
						this.ocObject.load(file);
						this.ocOEFlags &= ~(CObjectCommon.OEFLAG_SPRITES | CObjectCommon.OEFLAG_QUICKDISPLAY | CObjectCommon.OEFLAG_BACKSAVE);
						break;
					case 9:         // OBJ_CCA
						this.ocObject = new CDefCCA();
						this.ocObject.load(file);
						break;
				}
			}
		},
		enumElements: function (enumImages, enumFonts)
		{
			if (this.ocAnimations != null)
			{
				this.ocAnimations.enumElements(enumImages);
			}
			if (this.ocObject != null)
			{
				this.ocObject.enumElements(enumImages, enumFonts);
			}
			if (this.ocCounters != null)
			{
				this.ocCounters.enumElements(enumImages, enumFonts);
			}
		}
	}

	// CDefCCA object
	// ---------------------------------------------------------
	function CDefCCA()
	{
		this.odCx = 0;
		this.odCy = 0;
		this.odVersion = 0;
		this.odNStartFrame = 0;
		this.odOptions = 0;
		this.odName = null;
	}
	CDefCCA.prototype =
	{
		load:         function (file)
		{
			file.skipBytes(4);
			this.odCx = file.readAInt();
			this.odCy = file.readAInt();
			this.odVersion = file.readAShort();
			this.odNStartFrame = file.readAShort();
			this.odOptions = file.readAInt();
			file.skipBytes(4 + 4);                  // odFree+pad bytes
			this.odName = file.readAString();
		},
		enumElements: function (enumImages, enumFonts)
		{
		}
	}

	// CDefCounter object 
	// ----------------------------------------------------------
	function CDefCounter()
	{
		this.ctInit = 0;
		this.ctMini = 0;
		this.ctMaxi = 0;
	}
	CDefCounter.prototype =
	{
		load:         function (file)
		{
			file.skipBytes(2);
			this.ctInit = file.readAInt();
			this.ctMini = file.readAInt();
			this.ctMaxi = file.readAInt();
		},
		enumElements: function (enumImages, enumFonts)
		{
		}
	}

	// CDefCounters object
	// --------------------------------------------------------------
	CDefCounters.CTA_HIDDEN = 0;
	CDefCounters.CTA_DIGITS = 1;
	CDefCounters.CTA_VBAR = 2;
	CDefCounters.CTA_HBAR = 3;
	CDefCounters.CTA_ANIM = 4;
	CDefCounters.CTA_TEXT = 5;
	CDefCounters.BARFLAG_INVERSE = 0x0100;

	function CDefCounters()
	{
		this.odCx = 0;
		this.odCy = 0;
		this.odPlayer = 0;
		this.odDisplayType = 0;
		this.odDisplayFlags = 0;
		this.odFont = 0;
		this.ocBorderSize = 0;
		this.ocBorderColor = 0;
		this.ocShape = 0;
		this.ocFillType = 0;
		this.ocLineFlags = 0;
		this.ocColor1 = 0;
		this.ocColor2 = 0;
		this.ocGradientFlags = 0;
		this.nFrames = 0;
		this.frames = null;
	}
	CDefCounters.prototype =
	{
		load: function (file)
		{
			file.skipBytes(4);
			this.odCx = file.readAInt();
			this.odCy = file.readAInt();
			this.odPlayer = file.readAShort();
			this.odDisplayType = file.readAShort();
			this.odDisplayFlags = file.readAShort();
			this.odFont = file.readAShort();

			switch (this.odDisplayType)
			{
				case 0:
					break;
				case 1:
				case 4:
					this.nFrames = file.readAShort();
					this.frames = new Array(this.nFrames);
					var n;
					for (n = 0; n < this.nFrames; n++)
					{
						this.frames[n] = file.readAShort();
					}
					break;
				case 2:
				case 3:
				case 5:
					this.ocBorderSize = file.readAShort();
					this.ocBorderColor = file.readAColor();
					this.ocShape = file.readAShort();
					this.ocFillType = file.readAShort();
					if (this.ocShape == 1)
						this.ocLineFlags = file.readAShort();
					else
					{
						switch (this.ocFillType)
						{
							case 1:
								this.ocColor1 = file.readAColor();
								break;
							case 2:
								this.ocColor1 = file.readAColor();
								this.ocColor2 = file.readAColor();
								this.ocGradientFlags = file.readAInt();
								break;
							case 3:
								break;
						}
					}
					break;
			}
		},

		enumElements: function (enumImages, enumFonts)
		{
			var num;
			switch (this.odDisplayType)
			{
				case 1:
				case 4:
					var n;
					for (n = 0; n < this.nFrames; n++)
					{
						if (enumImages != null)
						{
							num = enumImages.enumerate(this.frames[n]);
							/*						if (num!=-1)
							 {
							 this.frames[n]=num;
							 }
							 */
						}
					}
					break;
				case 5:
					if (enumFonts != null)
					{
						num = enumFonts.enumerate(this.odFont);
						/*			    	if (num!=-1)
						 {
						 this.odFont=num;
						 }
						 */
					}
					break;
			}
		}
	}

	// CDefRtf object
	// ----------------------------------------------------------
	function CDefRtf()
	{
		this.odDWSize = 0;
		this.odVersion = 0;
		this.odOptions = 0;
		this.odBackColor = 0;
		this.odCx = 0;
		this.odCy = 0;
		this.text = null;
	}
	CDefRtf.prototype =
	{
		load:         function (file)
		{
			this.odDWSize = file.readAInt();
			this.odVersion = file.readAInt();
			this.odOptions = file.readAInt();
			this.odBackColor = file.readAColor();
			this.odCx = file.readAInt();
			this.odCy = file.readAInt();

			file.skipBytes(4);
			var size = file.readAInt();
			this.text = file.readAString(size);
		},
		enumElements: function (enumImages, enumFonts)
		{
		}
	}

	// CDefText object
	// -------------------------------------------------------------------
	CDefText.TSF_LEFT = 0x0000;
	CDefText.TSF_HCENTER = 0x0001;
	CDefText.TSF_RIGHT = 0x0002;
	CDefText.TSF_VCENTER = 0x0004;
	CDefText.TSF_HALIGN = 0x000F;
	CDefText.TSF_CORRECT = 0x0100;
	CDefText.TSF_RELIEF = 0x0200;
	function CDefText()
	{
		this.tsFont = 0;
		this.tsFlags = 0;
		this.tsColor = 0;
		this.tsText = null;
	}
	CDefText.prototype =
	{
		load:         function (file)
		{
			this.tsFont = file.readShort();
			this.tsFlags = file.readAShort();
			this.tsColor = file.readAColor();
			this.tsText = file.readAString();
		},
		enumElements: function (enumImages, enumFonts)
		{
			if (enumFonts != null)
			{
				var num = enumFonts.enumerate(this.tsFont);
				/*		    if (num!=-1)
				 {
				 this.tsFont=num;
				 }
				 */
			}
		}
	}

	// CDefTexts object
	// -------------------------------------------------------------------
	function CDefTexts()
	{
		this.otCx = 0;
		this.otCy = 0;
		this.otNumberOfText = 0;
		this.otTexts = null;
	}
	CDefTexts.prototype =
	{
		load:         function (file)
		{
			var debut = file.getFilePointer();
			file.skipBytes(4);          // Size
			this.otCx = file.readAInt();
			this.otCy = file.readAInt();
			this.otNumberOfText = file.readAInt();

			this.otTexts = new Array(this.otNumberOfText);
			var offsets = new Array(this.otNumberOfText);
			var n;
			for (n = 0; n < this.otNumberOfText; n++)
			{
				offsets[n] = file.readAInt();
			}
			for (n = 0; n < this.otNumberOfText; n++)
			{
				this.otTexts[n] = new CDefText();
				file.seek(debut + offsets[n]);
				this.otTexts[n].load(file);
			}
		},
		enumElements: function (enumImages, enumFonts)
		{
			var n;
			for (n = 0; n < this.otNumberOfText; n++)
			{
				this.otTexts[n].enumElements(enumImages, enumFonts);
			}
		}
	}

	// CObject
	// ----------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */

	CObject.HOF_DESTROYED = 0x0001;
	CObject.HOF_TRUEEVENT = 0x0002;
	CObject.HOF_REALSPRITE = 0x0004;
	CObject.HOF_FADEIN = 0x0008;
	CObject.HOF_FADEOUT = 0x0010;
	CObject.HOF_OWNERDRAW = 0x0020;
	CObject.HOF_SHOOTER = 0x0040;
	CObject.HOF_NOCOLLISION = 0x2000;
	CObject.HOF_FLOAT = 0x4000;
	CObject.HOF_STRING = 0x8000;
	function CObject()
	{
		this.hoNumber = 0;
		this.hoNextSelected = 0;
		this.hoAdRunHeader = null;
		this.hoHFII = 0;
		this.hoOi = 0;
		this.hoNumPrev = 0;
		this.hoNumNext = 0;
		this.hoType = 0;
		this.hoCreationId = 0;
		this.hoOiList = null;
		this.hoEvents = 0;
		this.hoPrevNoRepeat = null;
		this.hoBaseNoRepeat = null;
		this.hoMark1 = 0;
		this.hoMark2 = 0;
		this.hoMT_NodeName = null;
		this.hoEventNumber = 0;
		this.hoCommon = null;
		this.hoCalculX = 0;
		this.hoX = 0;
		this.hoCalculY = 0;
		this.hoY = 0;
		this.hoImgXSpot = 0;
		this.hoImgYSpot = 0;
		this.hoImgWidth = 0;
		this.hoImgHeight = 0;
		this.hoOEFlags = 0;
		this.hoFlags = 0;
		this.hoSelectedInOR = 0;
		this.hoOffsetValue = 0;
		this.hoLayer = 0;
		this.hoLimitFlags = 0;
		this.hoNextQuickDisplay = 0;
		this.hoCurrentParam = 0;
		this.hoIdentifier = 0;
		this.hoCallRoutine = false;
		this.roc = null;
		this.rom = null;
		this.roa = null;
		this.rov = null;
		this.ros = null;
	}
	CObject.prototype =
	{
		setScale:  function (fScaleX, fScaleY)
		{
			if (this.roc.rcScaleX != fScaleX || this.roc.rcScaleY != fScaleY)
			{
				if (fScaleX >= 0)
				{
					this.roc.rcScaleX = fScaleX;
				}
				if (fScaleY >= 0)
				{
					this.roc.rcScaleY = fScaleY;
				}
				this.roc.rcChanged = true;

				var ifo = this.hoAdRunHeader.rhApp.imageBank.getImageInfoEx(this.roc.rcImage, this.roc.rcAngle, this.roc.rcScaleX, this.roc.rcScaleY);
				if (ifo != null)
				{
				    this.hoImgWidth = ifo.width;
				    this.hoImgHeight = ifo.height;
				    this.hoImgXSpot = ifo.xSpot;
				    this.hoImgYSpot = ifo.ySpot;
				}
			}
		},
		shtCreate: function (p, x, y, dir)
		{
			var nLayer = this.hoLayer;
			var num = this.hoAdRunHeader.f_CreateObject(p.cdpHFII, p.cdpOi, x, y, dir, CRun.COF_NOMOVEMENT | CRun.COF_HIDDEN, nLayer, -1);
			if (num >= 0)
			{
				var pHo = this.hoAdRunHeader.rhObjectList[num];
				if (pHo.rom != null)
				{
					pHo.roc.rcDir = dir;
					pHo.rom.initSimple(pHo, CMoveDef.MVTYPE_BULLET, false);
					pHo.roc.rcSpeed = p.shtSpeed;
					pHo.rom.rmMovement.init2(this);

					if (nLayer != -1)
					{
						if ((pHo.hoOEFlags & CObjectCommon.OEFLAG_SPRITES) != 0)
						{
							var layer = this.hoAdRunHeader.rhFrame.layers[nLayer];
							if ((layer.dwOptions & (CLayer.FLOPT_TOHIDE | CLayer.FLOPT_VISIBLE)) != CLayer.FLOPT_VISIBLE)
							{
								pHo.ros.obHide();
							}
						}
					}

					// Met l'objet dans la liste des objets selectionnes
					// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					this.hoAdRunHeader.rhEvtProg.evt_AddCurrentObject(pHo);

					// Force l'animation SHOOT si definie
					// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					if ((this.hoOEFlags & CObjectCommon.OEFLAG_ANIMATIONS) != 0)
					{
						if (this.roa.anim_Exist(CAnim.ANIMID_SHOOT))
						{
							this.roa.animation_Force(CAnim.ANIMID_SHOOT);
							this.roa.animation_OneLoop();
						}
					}
				}
				else
				{
					this.hoAdRunHeader.destroy_Add(pHo.hoNumber);
				}
			}
		},

		fixedValue: function ()
		{
			return (this.hoCreationId << 16) | (this.hoNumber & 0xFFFF);
		},

		init: function (ocPtr, cob)
		{
		},

		handle: function ()
		{
		},

		callComputeNewDisplay: function ()
		{

		},

		createFont: function ()
		{
		},

		display: function ()
		{
		},


		kill: function (bFast)
		{
		},

		getSurface: function (context)
		{
			return false;
		},

		getCollisionMask: function (flags)
		{
			return null;
		},

		setEffect: function (effect, effectParam)
		{
		},

		addSprite: function (x, y, i, layer, bShow)
		{
		},

		addOwnerDrawSprite: function (x, y, layer, bQD, bShow, index)
		{
		},

		delSprite: function ()
		{
			return 0;
		},

		showSprite: function ()
		{
		},

		hideSprite: function ()
		{
		},

		setTransparency: function (t)
		{
		},

		getChildIndex: function ()
		{
			return -1;
		},

		getChildMaxIndex: function ()
		{
			return 0;
		},

		setChildIndex: function (index)
		{
		},

		autoResize: function ()
		{
		},

		forcePosition: function ()
		{
		}
	}

	// CActive class
	// ----------------------------------------------------------------
	function CActive()
	{
		this.smoothing = false;
		this.image = null;
		this.bShown = false;
		this.nLayer = 0;
		this.pLayer = null;
		this.startFade = 0;
		this.sprite = null;
		this.bHandCursor = false;
		this.rcRotate = null;
		this.ptRotate = null;
		this.bVisible = true;
		this.scaleX = 1.0;
		this.scaleY = 1.0;
		this.angle = 0;
		this.x = 0;
		this.y = 0;
		this.transitionImage = null;
	}
	CActive.prototype = CServices.extend(new CObject(),
		{
			handle:           function ()
			{
				this.ros.handle();
				if (this.roc.rcChanged)
				{
					this.roc.rcChanged = false;
				}
			},
			addSprite:        function (xx, yy, ii, layer, bShow)
			{
				this.nLayer = layer;
				this.pLayer = this.hoAdRunHeader.rhFrame.layers[layer];
				this.bShown = bShow;
				this.pLayer.planeSprites.addChild(this);
			},
			draw:             function (context, xx, yy)
			{
				if (this.bShown)
				{
					if ((this.hoFlags & CObject.HOF_FADEIN) != 0 && !this.ros.rsTrans)
					{
						return;
					}

					var effect = this.ros.rsEffect;
					if (this.ros.rsFlags & CRSpr.RSFLAG_ROTATE_ANTIA)
						effect |= CRSpr.BOP_SMOOTHING;
					var image = this.hoAdRunHeader.rhApp.imageBank.getImageFromHandle(this.roc.rcImage);
					if (image)
					{
						if (!this.transitionImage)
						{
							context.renderImage(image, xx + this.hoX - this.hoAdRunHeader.rhWindowX + this.pLayer.x,
								yy + this.hoY - this.hoAdRunHeader.rhWindowY + this.pLayer.y,
								this.roc.rcAngle, this.roc.rcScaleX, this.roc.rcScaleY,
								effect, this.ros.rsEffectParam);
						}
						else
						{
							context.renderSimpleImage(this.transitionImage, xx + this.hoX - this.hoAdRunHeader.rhWindowX + this.pLayer.x - image.xSpot,
								yy + this.hoY - this.hoAdRunHeader.rhWindowY + this.pLayer.y - image.ySpot,
								this.transitionImage.width * this.roc.rcScaleX, this.transitionImage.height * this.roc.rcScaleY,
								effect, this.ros.rsEffectParam);
						}
					}
				}
			},
			delSprite:        function ()
			{
				return this.pLayer.planeSprites.removeChild(this);
			},
			showSprite:       function ()
			{
				this.bShown = true;
			},
			hideSprite:       function ()
			{
				this.bShown = false;
			},
			getChildIndex:    function ()
			{
				return this.pLayer.planeSprites.getChildIndex(this);
			},
			getChildMaxIndex: function ()
			{
				return this.pLayer.planeSprites.children.length;
			},
			setChildIndex:    function (index)
			{
				if (index >= this.pLayer.planeSprites.children.length)
				{
					index = this.pLayer.planeSprites.children.length;
				}
				if (index < 0)
				{
					index = 0;
				}
				this.pLayer.planeSprites.setChildIndex(this, index);
			},

			setTransparency: function (t)
			{
				this.ros.rsEffect = CRSpr.BOP_BLEND;
				this.ros.rsEffectParam = t;
			}


		});

	// Sub application object
	// ----------------------------------------------------------------
	CCCA.CCAF_SHARE_GLOBALVALUES = 0x00000001;
	CCCA.CCAF_SHARE_LIVES = 0x00000002;
	CCCA.CCAF_SHARE_SCORES = 0x00000004;
	CCCA.CCAF_SHARE_WINATTRIB = 0x00000008;
	CCCA.CCAF_STRETCH = 0x00000010;
	CCCA.CCAF_POPUP = 0x00000020;
	CCCA.CCAF_CAPTION = 0x00000040;
	CCCA.CCAF_TOOLCAPTION = 0x00000080;
	CCCA.CCAF_BORDER = 0x00000100;
	CCCA.CCAF_WINRESIZE = 0x00000200;
	CCCA.CCAF_SYSMENU = 0x00000400;
	CCCA.CCAF_DISABLECLOSE = 0x00000800;
	CCCA.CCAF_MODAL = 0x00001000;
	CCCA.CCAF_DIALOGFRAME = 0x00002000;
	CCCA.CCAF_INTERNAL = 0x00004000;
	CCCA.CCAF_HIDEONCLOSE = 0x00008000;
	CCCA.CCAF_CUSTOMSIZE = 0x00010000;
	CCCA.CCAF_INTERNALABOUTBOX = 0x00020000;
	CCCA.CCAF_CLIPSIBLINGS = 0x00040000;
	CCCA.CCAF_SHARE_PLAYERCTRLS = 0x00080000;
	CCCA.CCAF_MDICHILD = 0x00100000;
	CCCA.CCAF_DOCKED = 0x00200000;
	CCCA.CCAF_DOCKING_AREA = 0x00C00000;
	CCCA.CCAF_DOCKED_LEFT = 0x00000000;
	CCCA.CCAF_DOCKED_TOP = 0x00400000;
	CCCA.CCAF_DOCKED_RIGHT = 0x00800000;
	CCCA.CCAF_DOCKED_BOTTOM = 0x00C00000;
	CCCA.CCAF_REOPEN = 0x01000000;
	CCCA.CCAF_MDIRUNEVENIFNOTACTIVE = 0x02000000;

	function CCCA()
	{
		this.flags = 0;
		this.odOptions = 0;
		this.subApp = null;
		this.oldX = 0;
		this.oldY = 0;
		this.level = -1;
		this.oldLevel = -1;
		this.layer = null;
		this.bVisible = true;
	}
	CCCA.prototype = CServices.extend(new CObject(),
		{
			//    init:function(ocPtr, cob)
			startCCA: function (ocPtr, bInit, nStartFrame)
			{
				var defCCA = ocPtr.ocObject;

				this.hoImgWidth = defCCA.odCx;
				this.hoImgHeight = defCCA.odCy;
				this.odOptions = defCCA.odOptions;

				if ((this.odOptions & CCCA.CCAF_STRETCH) != 0)
				{
					this.odOptions |= CCCA.CCAF_CUSTOMSIZE;
				}

				if (nStartFrame == -1)
				{
					nStartFrame = 0;
					if ((this.odOptions & CCCA.CCAF_INTERNAL) != 0)
					{
						nStartFrame = defCCA.odNStartFrame;
					}
				}

				// Change l'extension
				if (defCCA.odName == null || defCCA.odName.length != 0)
					return;
				if ((this.odOptions & CCCA.CCAF_INTERNAL) == 0)
					return;
				if (nStartFrame >= this.hoAdRunHeader.rhApp.gaNbFrames)
					return;
				if (nStartFrame == this.hoAdRunHeader.rhApp.currentFrame)
					return;

				if ((ocPtr.ocFlags2 & CObjectCommon.OCFLAGS2_VISIBLEATSTART) != 0)
					this.bVisible = true;
				else
					this.bVisible = false;
				this.appSprite = new Sprite();
				this.appSprite.x = this.hoX - this.hoAdRunHeader.rhWindowX;
				this.appSprite.y = this.hoY - this.hoAdRunHeader.rhWindowY;
				this.hoAdRunHeader.rhApp.mainSprite.addChild(this);
				this.oldX = this.hoX;
				this.oldY = this.hoY;

				this.subApp = new CRunApp(this.hoAdRunHeader.rhApp, this.hoAdRunHeader.rhApp.file, this.hoAdRunHeader.rhApp.path, true);
				this.subApp.setParentApp(this.hoAdRunHeader.rhApp, nStartFrame, this.odOptions, this.appSprite, this.hoImgWidth, this.hoImgHeight);

				this.subApp.digest();

			    //Register itself as the modal subapp
				if ((this.odOptions & CCCA.CCAF_MODAL) != 0) {
				    if (this.hoAdRunHeader.rhApp.modalSubappObject == null) {
				        this.hoAdRunHeader.rhApp.modalSubappObject = this;
				        this.hoAdRunHeader.rhApp.run.pause();
				    }
				}

				this.subApp.startApplication();
				this.subApp.setMouseOffsets((this.hoAdRunHeader.rhApp.xMouseOffset + this.appSprite.x) * this.hoAdRunHeader.rhApp.scaleX,
					(this.hoAdRunHeader.rhApp.yMouseOffset + this.appSprite.y) * this.hoAdRunHeader.rhApp.scaleY);
				this.subApp.stepApplication();
				this.hoAdRunHeader.rhApp.subApps.push(this.subApp);
			},

			init: function (ocPtr, cob)
			{
				this.startCCA(ocPtr, true, -1);
			},

			handle: function ()
			{
				this.rom.move();
				if (this.subApp != null)
				{
					if (this.oldX != this.hoX || this.oldY != this.hoY)
					{
						this.appSprite.x = this.hoX - this.hoAdRunHeader.rhWindowX;
						this.appSprite.y = this.hoY - this.hoAdRunHeader.rhWindowY;
						this.oldX = this.hoX;
						this.oldY = this.hoY;
						this.subApp.setMouseOffsets(this.appSprite.x * this.hoAdRunHeader.rhApp.scaleX, this.appSprite.y * this.hoAdRunHeader.rhApp.scaleY);
						this.updateChildControlPos();
					}
					if (this.subApp.stepApplication() == false)
					{
						this.destroyObject();
						if ((this.odOptions & CCCA.CCAF_MODAL) != 0 && this.subApp.parentApp != null) {
						    if (this.subApp.parentApp.modalSubappObject == this) {
						        this.subApp.parentApp.modalSubappObject = null;
						        this.subApp.parentApp.run.resume();
						    }
						}
						this.subApp = null;
						return;
					}
					this.oldLevel = this.level;
					this.level = this.subApp.currentFrame;
				}
			},

			draw: function (context, xx, yy)
			{
				if (!this.bVisible) return;
				if (this.subApp != null)
				{
					this.subApp.drawSubApplication(context, this.appSprite.x, this.appSprite.y);
				}
			},

			kill: function (bFast)
			{
				if (this.subApp != null)    
				{
					switch (this.subApp.appRunningState)
					{
						case 3:	    // SL_FRAMELOOP:
							this.subApp.endFrame();
							break;
					}
					this.destroyObject();
					this.subApp.endApplication();
					if ((this.odOptions & CCCA.CCAF_MODAL) != 0 && this.subApp.parentApp != null) {
					    if (this.subApp.parentApp.modalSubappObject == this) {
					        this.subApp.parentApp.modalSubappObject = null;
					        this.subApp.parentApp.run.resume();
					    }
					}
					this.subApp = null;
				}
			},

			destroyObject: function ()
			{
				var n;
				for (n = 0; n < this.hoAdRunHeader.rhApp.subApps.length; n++)
				{
					if (this.hoAdRunHeader.rhApp.subApps[n] == this.subApp)
					{
						this.hoAdRunHeader.rhApp.subApps.splice(n, 1);
						break;
					}
				}
				this.hoAdRunHeader.rhApp.mainSprite.removeChild(this.appSprite);
			},

			restartApp: function ()
			{
				if (this.subApp != null)
				{
					if (this.subApp.run != null)
					{
						this.subApp.run.rhQuit = CRun.LOOPEXIT_NEWGAME;
						return;
					}
					this.kill(true);
				}
				this.startCCA(this.hoCommon, false, -1);
			},

			endApp: function ()
			{
				if (this.subApp != null)
				{
					if (this.subApp.run != null)
					{
						this.subApp.run.rhQuit = CRun.LOOPEXIT_ENDGAME;
					}
					if ((this.odOptions & CCCA.CCAF_MODAL) != 0 && this.subApp.parentApp != null) {
					    if (this.subApp.parentApp.modalSubappObject == this) {
					        this.subApp.parentApp.modalSubappObject = null;
					        this.subApp.parentApp.run.resume();
					    }
					}
	            }
			},

			hide: function ()
			{
				this.bVisible = false;
			},

			show: function ()
			{
				this.bVisible = true;
			},

			jumpFrame: function (frame)
			{
				if (this.subApp != null)
				{
					if (this.subApp.run != null)
					{
						if (frame >= 0 && frame < 4096)
						{
							this.subApp.run.rhQuit = CRun.LOOPEXIT_GOTOLEVEL;
							this.subApp.run.rhQuitParam = 0x8000 | frame;
						}
					}
				}
			},

			nextFrame: function ()
			{
				if (this.subApp != null)
				{
					if (this.subApp.run != null)
					{
						this.subApp.run.rhQuit = CRun.LOOPEXIT_NEXTLEVEL;
					}
				}
			},

			previousFrame: function ()
			{
				if (this.subApp != null)
				{
					if (this.subApp.run != null)
					{
						this.subApp.run.rhQuit = CRun.LOOPEXIT_PREVLEVEL;
					}
				}
			},

			restartFrame: function ()
			{
				if (this.subApp != null)
				{
					if (this.subApp.run != null)
					{
						this.subApp.run.rhQuit = CRun.LOOPEXIT_RESTART;
					}
				}
			},

			pause: function ()
			{
				if (this.subApp != null)
				{
					if (this.subApp.run != null)
					{
						this.subApp.run.pause();
					}
				}
			},

			resume: function ()
			{
				if (this.subApp != null)
				{
					if (this.subApp.run != null)
					{
						this.subApp.run.resume();
					}
				}
			},

			setGlobalValue: function (number, value)
			{
				if (this.subApp != null)
				{
					this.subApp.setGlobalValueAt(number, value);
				}
			},

			setGlobalString: function (number, value)
			{
				if (this.subApp != null)
				{
					this.subApp.setGlobalStringAt(number, value);
				}
			},

			isPaused: function ()
			{
				if (this.subApp != null)
				{
					if (this.subApp.run != null)
					{
						return this.subApp.run.rh2PauseCompteur != 0;
					}
				}
				return false;
			},

			appFinished: function ()
			{
				return this.subApp == null;
			},

			isVisible: function ()
			{
				return this.bVisible;
			},

			frameChanged: function ()
			{
				return this.level != this.oldLevel;
			},

			getGlobalString: function (num)
			{
				if (this.subApp != null)
				{
					return this.subApp.getGlobalStringAt(num);
				}
				return "";
			},

			getGlobalValue: function (num)
			{
				if (this.subApp != null)
				{
					return this.subApp.getGlobalValueAt(num);
				}
				return 0;
			},

			getFrameNumber: function ()
			{
				return this.level + 1;
			},

			setWidth: function (width)
			{
			},

			setHeight: function (height)
			{
			},

			bringToFront: function ()
			{
				if (this.subApp != null)
				{
					if (this.bVisible)
					{
						hoAdRunHeader.rhApp.planeControls.removeChild(this);
						hoAdRunHeader.rhApp.planeControls.addChild(this);
					}
				}
			},

			updateChildControlPos: function () {
			    if (this.subApp != null && this.subApp.run != null) {
			        var rh = this.subApp.run;
			        var count = 0;
			        var no;
			        for (no = 0; no < rh.rhNObjects; no++) {
			            while (rh.rhObjectList[count] == null)
			                count++;
			            var hoPtr = rh.rhObjectList[count];
			            count++;
			            hoPtr.forcePosition();
			        }
			    }
			},

			autoResize: function () {
			    if (this.subApp != null) {
			        this.subApp.setMouseOffsets((this.hoAdRunHeader.rhApp.xMouseOffset + this.appSprite.x) * this.hoAdRunHeader.rhApp.scaleX,
	                    (this.hoAdRunHeader.rhApp.yMouseOffset + this.appSprite.y) * this.hoAdRunHeader.rhApp.scaleY);
			        this.subApp.resizeCanvas();
			    }
			}

		});

	// CRCom object
	// --------------------------------------------------------------------
	function CRCom()
	{
		this.rcPlayer = 0;
		this.rcMovementType = 0;
		this.rcAnim = 0;
		this.rcImage = -1;
		this.rcScaleX = 1.0;
		this.rcScaleY = 1.0;
		this.rcAngle = 0;
		this.rcDir = 0;
		this.rcSpeed = 0;
		this.rcMinSpeed = 0;
		this.rcMaxSpeed = 0;
		this.rcChanged = false;
		this.rcCheckCollides = false;

		this.rcOldX = 0;
		this.rcOldY = 0;
		this.rcOldImage = -1;
		this.rcOldAngle = 0;
		this.rcOldDir = 0;
		this.rcOldX1 = 0;
		this.rcOldY1 = 0;
		this.rcOldX2 = 0;
		this.rcOldY2 = 0;
	}
	CRCom.prototype =
	{
		init: function ()
		{
		    this.rcScaleX = 1.0;
		    this.rcScaleY = 1.0;
		    this.rcAngle = 0;
		    this.rcMovementType = -1;
		},
		kill: function (bFast)
		{
		}
	}

	// CCounter object
	// ---------------------------------------------------------------
	CCounter.CPTDISPFLAG_INTNDIGITS = 0x000F;
	CCounter.CPTDISPFLAG_FLOATNDIGITS = 0x00F0;
	CCounter.CPTDISPFLAG_FLOATNDIGITS_SHIFT = 4
	CCounter.CPTDISPFLAG_FLOATNDECIMALS = 0xF000;
	CCounter.CPTDISPFLAG_FLOATNDECIMALS_SHIFT = 12;
	CCounter.CPTDISPFLAG_FLOAT_FORMAT = 0x0200;
	CCounter.CPTDISPFLAG_FLOAT_USENDECIMALS = 0x0400;
	CCounter.CPTDISPFLAG_FLOAT_PADD = 0x0800;
	function CCounter()
	{
		this.type = 0;
		this.rsValue = 0;
		this.rsMini = 0;
		this.rsMaxi = 0;
		this.rsBoxCx = 0;
		this.rsBoxCy = 0;
		this.bShown = false;
		this.bQuickDisplay = false;
		this.rsColor1 = 0;
		this.rsColor2 = 0
		this.rsOldFrame = 0;
		this.nIndex = 0;
		this.displayFlags = 0;
		this.bDeleted = false;
		this.bFloat = false;
		this.plane = null;
		this.pLayer = null;
		this.fontHeight = 0;
		this.font = null;
		this.bAddedToPlane = false;
		this.computed = false;
	}

	CCounter.prototype = CServices.extend(new CObject(),
		{
			init: function (ocPtr, cob)
			{
				this.rsFont = -1;
				this.rsColor1 = 0;
				this.rsColor2 = 0;
				this.hoImgWidth = this.hoImgHeight = 1;

				if (this.hoCommon.ocCounters == null)
				{
					this.hoImgWidth = this.rsBoxCx = 1;
					this.hoImgHeight = this.rsBoxCy = 1;
				}
				else
				{
					var ctPtr = this.hoCommon.ocCounters;
					this.hoImgWidth = this.rsBoxCx = ctPtr.odCx;
					this.hoImgHeight = this.rsBoxCy = ctPtr.odCy;
					this.displayFlags = ctPtr.odDisplayFlags;
					this.type = ctPtr.odDisplayType;
					switch (this.type)
					{
						case 5:
							var nFont = this.rsFont;
							if (nFont == -1)
								nFont = ctPtr.odFont;
							this.font = this.hoAdRunHeader.rhApp.fontBank.getFontFromHandle(nFont);
							this.fontHeight = this.font.getHeight();
							this.rsColor1 = ctPtr.ocColor1;
							break;
						case 2:
						case 3:
							this.rsColor1 = ctPtr.ocColor1;
							this.rsColor2 = ctPtr.ocColor2;
							break;
						case 1:
							break;
						case 4:
							break;
					}
				}

				var cPtr = this.hoCommon.ocObject;
				this.rsMini = cPtr.ctMini;
				this.rsMaxi = cPtr.ctMaxi;
				this.rsValue = cPtr.ctInit;
				this.bFloat = false;
			},

			kill: function ()
			{
			},

			handle: function ()
			{
				this.ros.handle();
				if (this.roc.rcChanged)
				{
					this.roc.rcChanged = false;
				}
			},

			getFont: function ()
			{
				var adCta = this.hoCommon.ocCounters;
				if (this.type == 5)
				{
					var nFont = rsFont;
					if (nFont == -1)
						nFont = adCta.odFont;
					return this.hoAdRunHeader.rhApp.fontBank.getFontInfoFromHandle(nFont);
				}
				return null;
			},

			setFont: function (font, size)
			{
				if (this.type == 5)
				{
					this.rsFont = this.hoAdRunHeader.rhApp.fontBank.addFont(font);
					this.font = this.hoAdRunHeader.rhApp.fontBank.getFontFromHandle(this.rsFont);
					this.fontHeight = this.font.getHeight();
					if (size != null)
					{
						this.hoImgWidth = this.rsBoxCx = size.right - size.left;
						this.hoImgHeight = this.rsBoxCy = size.bottom - size.top;
					}
					this.computeNewDisplay();
				}
			},

			getFontColor: function ()
			{
				return this.rsColor1;
			},

			setFontColor: function (rgb)
			{
				this.rsColor1 = rgb;
				this.computeNewDisplay();
			},

			cpt_ToFloat: function (pValue)
			{
				if (this.bFloat == false)
				{
					if (CServices.isInt(pValue))
						return;
					this.bFloat = true;
				}
			},

			cpt_Change: function (pValue)
			{
				if (this.bFloat == false)
				{
					var value = CServices.floatToInt(pValue);
					if (value < this.rsMini)
						value = this.rsMini;
					if (value > this.rsMaxi)
						value = this.rsMaxi;
					if (value != Math.round(this.rsValue))
					{
						this.rsValue = value;
						this.roc.rcChanged = true;
						this.computeNewDisplay();
					}
				}
				else
				{
					if (pValue < this.rsMini)
						pValue = this.rsMini;
					if (pValue > this.rsMaxi)
						pValue = this.rsMaxi;
					if (pValue != this.rsValue)
					{
						this.rsValue = pValue;
						this.roc.rcChanged = true;
						this.computeNewDisplay();
					}
				}
			},

			cpt_Add: function (pValue)
			{
				this.cpt_ToFloat(pValue);
				this.cpt_Change(this.rsValue + pValue);
			},

			cpt_Sub: function (pValue)
			{
				this.cpt_ToFloat(pValue);
				this.cpt_Change(this.rsValue - pValue);
			},

			cpt_SetMin: function (value)
			{
				this.rsMini = value;
				this.cpt_Change(this.rsValue);
			},

			cpt_SetMax: function (value)
			{
				this.rsMaxi = value;
				this.cpt_Change(this.rsValue);
			},

			cpt_SetColor1: function (rgb)
			{
				this.rsColor1 = rgb;
				this.computeNewDisplay();
			},

			cpt_SetColor2: function (rgb)
			{
				this.rsColor2 = rgb;
				this.computeNewDisplay();
			},

			cpt_GetValue: function ()
			{
				return this.rsValue;
			},

			cpt_GetMin: function ()
			{
				return this.rsMini;
			},

			cpt_GetMax: function ()
			{
				return this.rsMaxi;
			},

			cpt_GetColor1: function ()
			{
				return this.rsColor1;
			},

			cpt_GetColor2: function ()
			{
				return this.rsColor2;
			},

			addOwnerDrawSprite: function (xx, yy, layer, quickDisplay, shown, index)
			{
				if (this.hoCommon.ocCounters == null)
					return;
				if (this.bAddedToPlane == true)
					return;

				this.bAddedToPlane = true;
				this.bQuickDisplay = quickDisplay;
				this.bShown = shown;

				this.pLayer = this.hoAdRunHeader.rhFrame.layers[layer];
				if (this.bQuickDisplay)
					this.plane = this.pLayer.planeQuickDisplay;
				else
					this.plane = this.pLayer.planeSprites;

				if (index < 0)
					this.plane.addChild(this);
				else
					this.plane.addChildIndex(this, index);

				if (this.type != 5)
					this.computeNewDisplay();
			},

			delSprite: function ()
			{
				if (this.hoCommon.ocCounters == null)
					return -1;
				if (this.bAddedToPlane == false)
					return -1;

				this.bAddedToPlane = false;
				var index = this.plane.getChildIndex(this);
				this.plane.removeChild(this);
				return index;
			},

			getChildIndex: function ()
			{
				if (this.bAddedToPlane)
				{
					return this.plane.getChildIndex(this);
				}
				return -1;
			},

			getChildMaxIndex: function ()
			{
				if (this.bAddedToPlane)
					return this.plane.getNumChildren();
				return -1;
			},

			setChildIndex: function (index)
			{
				if (this.bAddedToPlane)
					this.plane.setChildIndex(this, index);
			},

			showSprite: function ()
			{
				if (this.hoCommon.ocCounters == null)
					return;

				if (this.bShown == false)
				{
					this.bShown = true;
					this.computeNewDisplay();
				}
			},

			hideSprite: function ()
			{
				if (this.hoCommon.ocCounters == null)
					return;

				if (this.bShown == true)
				{
					this.bShown = false;
				}
			},

			callComputeNewDisplay: function ()
			{
				if (!this.computed)
					this.computeNewDisplay();
			},

			computeNewDisplay: function ()
			{
				var image;
				var s;
				var nbl;

				var adCta = this.hoCommon.ocCounters;
				switch (this.type)
				{
					case 4:
						if (this.rsMaxi <= this.rsMini)
							this.rsOldFrame = 0;
						else
							this.rsOldFrame = Math.floor(((this.rsValue - this.rsMini) * adCta.nFrames) / (this.rsMaxi - this.rsMini));
						this.rsOldFrame = Math.min(this.rsOldFrame, adCta.nFrames - 1);
						image = this.hoAdRunHeader.rhApp.imageBank.getImageFromHandle(adCta.frames[Math.max(this.rsOldFrame, 0)]);
						this.hoImgWidth = image.width;
						this.hoImgHeight = image.height;
						this.hoImgXSpot = image.xSpot;
						this.hoImgYSpot = image.ySpot;
						break;
					case 2:
					case 3:
						nbl = this.rsBoxCx;
						if (adCta.odDisplayType == CDefCounters.CTA_VBAR)
							nbl = this.rsBoxCy;
						if (this.rsMaxi <= this.rsMini)
							this.rsOldFrame = 0;
						else
							this.rsOldFrame = (((this.rsValue - this.rsMini) * nbl) / (this.rsMaxi - this.rsMini));
						if (adCta.odDisplayType == CDefCounters.CTA_HBAR)
						{
							this.hoImgYSpot = 0;
							this.hoImgHeight = this.rsBoxCy;
							this.hoImgWidth = this.rsOldFrame;
							if ((adCta.odDisplayFlags & CDefCounters.BARFLAG_INVERSE) != 0)
								this.hoImgXSpot = this.rsOldFrame - this.rsBoxCx;
							else
								this.hoImgXSpot = 0;
						}
						else
						{
							this.hoImgXSpot = 0;
							this.hoImgWidth = this.rsBoxCx;
							this.hoImgHeight = this.rsOldFrame;
							if ((adCta.odDisplayFlags & CDefCounters.BARFLAG_INVERSE) != 0)
								this.hoImgYSpot = this.rsOldFrame - this.rsBoxCy;
							else
								this.hoImgYSpot = 0;
						}
						break;
					case 1:
						if (this.bFloat == false)
							s = CServices.intToString(this.rsValue, this.displayFlags);
						else
							s = CServices.doubleToString(this.rsValue, this.displayFlags);
						var i;
						var c;
						var img;
						var ifo;
						var dx = 0, dy = 0;

						for (i = s.length - 1; i >= 0; i--)
						{
							c = s.charCodeAt(i);
							img = 0;
							if (c == 45)
								img = adCta.frames[10];
							else if (c == 46)
								img = adCta.frames[12];
							else if (c == 43)
								img = adCta.frames[11];
							else if (c == 101 || c == 69)
								img = adCta.frames[13];
							else if (c >= 48 && c <= 57)
								img = adCta.frames[c - 48];
							if (img >= 0)
							{
								ifo = this.hoAdRunHeader.rhApp.imageBank.getImageFromHandle(img);
								if (ifo != null)
								{
									dx += ifo.width;
									dy = Math.max(dy, ifo.height);
								}
								else
								{
									toto = 2;
								}
							}
						}
						this.hoImgXSpot = dx;
						this.hoImgYSpot = dy;
						this.hoImgWidth = dx;
						this.hoImgHeight = dy;
						break;
					case 5:
						if (this.bFloat == false)
							s = CServices.intToString(this.rsValue, this.displayFlags);
						else
							s = CServices.doubleToString(this.rsValue, this.displayFlags);
						var w;
						if (this.textSurface != null)
							w = this.textSurface.measureText(s, this.font);
						else
						{
							var ts = new CTextSurface(this.hoAdRunHeader.rhApp, 16, 16);
							w = ts.measureText(s, this.font);
						}
						this.hoImgXSpot = w;
						this.hoImgYSpot = this.rsBoxCy / 2 + this.fontHeight / 2;
						this.hoImgWidth = w;
						this.hoImgHeight = this.fontHeight;
						if (this.textSurface == null)
							this.textSurface = new CTextSurface(this.hoAdRunHeader.rhApp, this.hoImgWidth, this.hoImgHeight);
						else
						{
							if (this.hoImgWidth > this.textSurface.width || this.hoImgHeight > this.textSurface.height)
								this.textSurface.resize(this.hoImgWidth, this.hoImgHeight);
						}
						var rect = new CRect(0, 0, 1000, 1000);
						this.textSurface.setText(s, CServices.DT_LEFT | CServices.DT_TOP, rect, this.font, this.rsColor1);
						break;
				}
				this.computed = true;
			},

			draw:            function (context, xx, yy)
			{
				if (!this.bShown || !this.computed) return;


				var image;
				var color1, color2;
				var s;

				var adCta = this.hoCommon.ocCounters;
				var x = xx + this.hoX - this.hoImgXSpot - this.hoAdRunHeader.rhWindowX + this.pLayer.x;
				var y = yy + this.hoY - this.hoImgYSpot - this.hoAdRunHeader.rhWindowY + this.pLayer.y;
				var cx = this.hoImgWidth;
				var cy = this.hoImgHeight;
				switch (this.type)
				{
					case 4:
						image = this.hoAdRunHeader.rhApp.imageBank.getImageFromHandle(adCta.frames[Math.max(this.rsOldFrame, 0)]);
						context.renderImage(image, x + image.xSpot, y + image.ySpot, 0, 1.0, 1.0, this.ros.rsEffect, this.ros.rsEffectParam);
						break;
					case 2:
					case 3:
						var color1 = this.rsColor1;
						var color2 = this.rsColor2;
						switch (adCta.ocFillType)
						{
							case 1:
								context.renderSolidColor(x, y, cx, cy, color1, this.ros.rsEffect, this.ros.rsEffectParam);
								break;
							case 2:
								if ((adCta.odDisplayFlags & CDefCounters.BARFLAG_INVERSE) != 0)
								{
									dl = color1;
									color1 = color2;
									color2 = dl;
								}
								var bVertical = adCta.ocGradientFlags != 0;
								context.renderGradient(x, y, cx, cy, color1, color2, bVertical, this.ros.rsEffect, this.ros.rsEffectParam);
								break;
						}
						break;
					case 1:
						if (this.bFloat == false)
							s = CServices.intToString(this.rsValue, this.displayFlags);
						else
							s = CServices.doubleToString(this.rsValue, this.displayFlags);
						var i, img, ifo;
						for (i = 0; i < s.length; i++)
						{
							var c = s.charCodeAt(i);
							img = 0;
							if (c == 45)
								img = adCta.frames[10];
							else if (c == 46 || c == 44)
								img = adCta.frames[12];
							else if (c == 43)
								img = adCta.frames[11];
							else if (c == 69 || c == 101)
								img = adCta.frames[13];
							else if (c >= 48 && c <= 57)
								img = adCta.frames[c - 48];
							ifo = this.hoAdRunHeader.rhApp.imageBank.getImageFromHandle(img);
							if (ifo != null)
							{
								context.renderImage(ifo, x + ifo.xSpot, y + ifo.ySpot, 0, 1.0, 1.0, this.ros.rsEffect, this.ros.rsEffectParam);
								x += ifo.width;
							}
						}
						break;
					case 5:
						this.textSurface.draw(context, x, y, this.ros.rsEffect, this.ros.rsEffectParam);
						break;
				}
			},
			setTransparency: function (t)
			{
				this.ros.rsEffect = CRSpr.BOP_BLEND;
				this.ros.rsEffectParam = t;
			}
		});

	// CScore object
	// ------------------------------------------------------------
	function CScore()
	{
		this.rsPlayer = 0;
		this.rsValue = 0;
		this.rsBoxCx = 0;
		this.rsBoxCy = 0;
		this.rsFont = 0;
		this.rsColor1 = 0;
		this.type = 0;
		this.bShown = true;
		this.nLayer = 0;
		this.nIndex = 0;
		this.plane = null;
		this.displayFlags = 0;
		this.pLayer = null;
		this.bAddedToFrame = false;
		this.fontHeight = 0;
		this.alpha = 1.0;
		this.composite = "source-over";
		this.computed = false;
	}

	CScore.prototype = CServices.extend(new CObject(),
		{
			init: function (ocPtr, cob)
			{
				this.rsFont = -1;
				this.rsColor1 = 0;
				this.hoImgWidth = this.hoImgHeight = 1;

				var adCta = this.hoCommon.ocCounters;
				this.hoImgWidth = this.rsBoxCx = adCta.odCx;
				this.hoImgHeight = this.rsBoxCy = adCta.odCy;
				this.type = adCta.odDisplayType;
				this.rsColor1 = adCta.ocColor1;
				this.rsPlayer = adCta.odPlayer;
				this.rsValue = this.hoAdRunHeader.rhApp.getScores()[this.rsPlayer - 1];
				this.displayFlags = adCta.odDisplayFlags;

				if (this.type == 5)
				{
					var nFont = this.rsFont;
					if (nFont == -1)
						nFont = adCta.odFont;
					this.font = this.hoAdRunHeader.rhApp.fontBank.getFontFromHandle(nFont);
					this.fontHeight = this.font.getHeight();
				}
			},

			kill: function ()
			{
			},

			handle: function ()
			{
				var value = this.hoAdRunHeader.rhApp.getScores()[this.rsPlayer - 1];
				if (value != this.rsValue)
				{
					this.rsValue = value;
					this.computeNewDisplay();
				}
				this.ros.handle();
				if (this.roc.rcChanged)
				{
					this.roc.rcChanged = false;
				}
			},

			getFont: function ()
			{
				var adCta = this.hoCommon.ocCounters;
				if (adCta.odDisplayType == 5)
				{
					var nFont = this.rsFont;
					if (nFont == -1)
						nFont = adCta.odFont;
					return this.hoAdRunHeader.rhApp.fontBank.getFontInfoFromHandle(nFont);
				}
				return null;
			},

			setFont: function (font, size)
			{
				if (type == 5)
				{
					this.rsFont = hoAdRunHeader.rhApp.fontBank.addFont(font);
					var font = this.hoAdRunHeader.rhApp.fontBank.getFontFromHandle(this.rsFont);
					this.fontHeight = font.getHeight();
					if (size != null)
					{
						this.hoImgWidth = this.rsBoxCx = size.right - size.left;
						this.hoImgHeight = this.rsBoxCy = size.bottom - size.top;
					}
					this.computeNewDisplay();
				}
			},

			getFontColor: function ()
			{
				return this.rsColor1;
			},

			setFontColor: function (rgb)
			{
				this.rsColor1 = rgb;
				this.computeNewDisplay();
			},

			addOwnerDrawSprite: function (xx, yy, layer, quickDisplay, shown, index)
			{
				if (this.hoCommon.ocCounters == null)
					return;
				if (this.bAddedToPlane == true)
					return;

				this.bAddedToPlane = true;
				this.bShown = shown;

				this.pLayer = this.hoAdRunHeader.rhFrame.layers[layer];
				if (quickDisplay)
					this.plane = this.pLayer.planeQuickDisplay;
				else
					this.plane = this.pLayer.planeSprites;

				if (index < 0)
					this.plane.addChild(this);
				else
					this.plane.addChildIndex(this, index);

				if (this.type != 5)
					this.computeNewDisplay();
			},

			delSprite: function ()
			{
				if (this.hoCommon.ocCounters == null)
					return -1;
				if (this.bAddedToPlane == false)
					return -1;

				this.bAddedToPlane = false;
				var index = this.plane.getChildIndex(this);
				this.plane.removeChild(this);
				return index;
			},

			getChildIndex: function ()
			{
				if (this.bAddedToPlane)
				{
					return this.plane.getChildIndex(this);
				}
				return -1;
			},

			getChildMaxIndex: function ()
			{
				if (this.bAddedToPlane)
					return this.plane.getNumChildren();
				return -1;
			},

			setChildIndex: function (index)
			{
				if (this.bAddedToPlane)
					this.plane.setChildIndex(this, index);
			},

			showSprite: function ()
			{
				if (this.hoCommon.ocCounters == null)
					return;

				if (this.bShown == false)
				{
					this.bShown = true;
					this.computeNewDisplay();
				}
			},

			hideSprite: function ()
			{
				if (this.hoCommon.ocCounters == null)
					return;

				if (this.bShown == true)
				{
					this.bShown = false;
				}
			},

			setValue: function (value)
			{
				if (value != this.rsValue)
				{
					this.rsValue = value;
					this.computeNewDisplay();
				}
			},

			callComputeNewDisplay: function ()
			{
				if (!this.computed)
					this.computeNewDisplay();
			},

			computeNewDisplay: function ()
			{
				this.computed = true;
				this.hoImgWidth = this.hoImgHeight = 1;
				if (this.hoCommon.ocCounters == null)
					return;
				var adCta = this.hoCommon.ocCounters;

				var img;
				var s = CServices.intToString(this.rsValue, this.displayFlags);
				switch (adCta.odDisplayType)
				{
					case 1:
						var i;
						var c;
						var img;
						var ifo;
						var dx = 0, dy = 0;

						for (i = s.length - 1; i >= 0; i--)
						{
							c = s.charCodeAt(i);
							img = 0;
							if (c == 45)
								img = adCta.frames[10];
							else if (c == 46)
								img = adCta.frames[12];
							else if (c == 43)
								img = adCta.frames[11];
							else if (c == 101 || c == 69)
								img = adCta.frames[13];
							else if (c >= 48 && c <= 57)
								img = adCta.frames[c - 48];
							if (img >= 0)
							{
								ifo = this.hoAdRunHeader.rhApp.imageBank.getImageFromHandle(img);
								dx += ifo.width;
								dy = Math.max(dy, ifo.height);
							}
						}
						this.hoImgXSpot = dx;
						this.hoImgYSpot = dy;
						this.hoImgWidth = dx;
						this.hoImgHeight = dy;
						break;

					case 5:
						var w;
						if (this.textSurface != null)
							w = this.textSurface.measureText(s, this.font);
						else
						{
							var ts = new CTextSurface(this.hoAdRunHeader.rhApp, 8, 8);
							w = ts.measureText(s, this.font);
						}
						this.hoImgXSpot = w;
						this.hoImgYSpot = this.rsBoxCy / 2 + this.fontHeight / 2;
						this.hoImgWidth = w;
						this.hoImgHeight = this.fontHeight;
						if (this.textSurface == null)
							this.textSurface = new CTextSurface(this.hoAdRunHeader.rhApp, this.hoImgWidth, this.hoImgHeight);
						else
						{
							if (this.hoImgWidth > this.textSurface.width || this.hoImgHeight > this.textSurface.height)
								this.textSurface.resize(this.hoImgWidth, this.hoImgHeight);
						}
						var rect = new CRect(0, 0, 1000, 1000);
						this.textSurface.setText(s, CServices.DT_LEFT | CServices.DT_TOP, rect, this.font, this.rsColor1);
						break;
				}
			},

			draw:            function (context, xx, yy)
			{
				if (!this.bShown || !this.computed) return;

				this.globalAlpha = this.alpha;
				this.globalCompositeOperation = this.composite;

				var image;
				var color1, color2;
				var s;

				var adCta = this.hoCommon.ocCounters;
				var x = xx + this.hoX - this.hoImgXSpot - this.hoAdRunHeader.rhWindowX + this.pLayer.x;
				var y = yy + this.hoY - this.hoImgYSpot - this.hoAdRunHeader.rhWindowY + this.pLayer.y;
				s = CServices.intToString(this.rsValue, this.displayFlags);
				switch (this.type)
				{
					case 1:
						var i, img, ifo;
						for (i = 0; i < s.length; i++)
						{
							var c = s.charCodeAt(i);
							img = 0;
							if (c == 45)
								img = adCta.frames[10];
							else if (c == 46 || c == 44)
								img = adCta.frames[12];
							else if (c == 43)
								img = adCta.frames[11];
							else if (c == 69 || c == 101)
								img = adCta.frames[13];
							else if (c >= 48 && c <= 57)
								img = adCta.frames[c - 48];
							ifo = this.hoAdRunHeader.rhApp.imageBank.getImageFromHandle(img);
							context.renderImage(ifo, x + ifo.xSpot, y + ifo.ySpot, 0, 1.0, 1.0, this.ros.rsEffect, this.ros.rsEffectParam);
							x += ifo.width;
						}
						break;
					case 5:
						this.textSurface.draw(context, x, y, this.ros.rsEffect, this.ros.rsEffectParam);
						break;
				}
			},
			setTransparency: function (t)
			{
				this.ros.rsEffect = CRSpr.BOP_BLEND;
				this.ros.rsEffectParam = t;
			}
		});

	// CLives object
	// ------------------------------------------------------------
	function CLives()
	{
		this.rsPlayer = 0;
		this.rsValue = 0;
		this.rsBoxCx = 0;
		this.rsBoxCy = 0;
		this.rsFont = 0;
		this.rsColor1 = 0;
		this.type = 0;
		this.bShown = true;
		this.nLayer = 0;
		this.nIndex = 0;
		this.plane = null;
		this.displayFlags = 0;
		this.pLayer = null;
		this.bAddedToFrame = false;
		this.fontHeight = 0;
		this.alpha = 1.0;
		this.composite = "source-over";
		this.computed = false;
	}

	CLives.prototype = CServices.extend(new CObject(),
		{
			init: function (ocPtr, cob)
			{
				this.rsFont = -1;
				this.rsColor1 = 0;
				this.hoImgWidth = this.hoImgHeight = 1;

				var adCta = this.hoCommon.ocCounters;
				this.hoImgWidth = this.rsBoxCx = adCta.odCx;
				this.hoImgHeight = this.rsBoxCy = adCta.odCy;
				this.type = adCta.odDisplayType;
				this.rsColor1 = adCta.ocColor1;
				this.rsPlayer = adCta.odPlayer;
				this.rsValue = this.hoAdRunHeader.rhApp.getLives()[this.rsPlayer - 1];
				this.displayFlags = adCta.odDisplayFlags;

				if (this.type == 5)
				{
					var nFont = this.rsFont;
					if (nFont == -1)
						nFont = adCta.odFont;
					this.font = this.hoAdRunHeader.rhApp.fontBank.getFontFromHandle(nFont);
					this.fontHeight = this.font.getHeight();
				}
			},

			kill: function ()
			{
			},

			handle: function ()
			{
				var value = this.hoAdRunHeader.rhApp.getLives()[this.rsPlayer - 1];
				if (value != this.rsValue)
				{
					this.rsValue = value;
					this.computeNewDisplay();
				}
				this.ros.handle();
				if (this.roc.rcChanged)
				{
					this.roc.rcChanged = false;
				}
			},

			getFont: function ()
			{
				var adCta = this.hoCommon.ocCounters;
				if (adCta.odDisplayType == 5)
				{
					var nFont = this.rsFont;
					if (nFont == -1)
						nFont = adCta.odFont;
					return this.hoAdRunHeader.rhApp.fontBank.getFontInfoFromHandle(nFont);
				}
				return null;
			},

			setFont: function (font, size)
			{
				if (type == 5)
				{
					this.rsFont = hoAdRunHeader.rhApp.fontBank.addFont(font);
					var font = this.hoAdRunHeader.rhApp.fontBank.getFontFromHandle(this.rsFont);
					this.fontHeight = font.getHeight();
					if (size != null)
					{
						this.hoImgWidth = this.rsBoxCx = size.right - size.left;
						this.hoImgHeight = this.rsBoxCy = size.bottom - size.top;
					}
					this.computeNewDisplay();
				}
			},

			getFontColor: function ()
			{
				return this.rsColor1;
			},

			setFontColor: function (rgb)
			{
				this.rsColor1 = rgb;
				this.computeNewDisplay();
			},

			addOwnerDrawSprite: function (xx, yy, layer, quickDisplay, shown, index)
			{
				if (this.hoCommon.ocCounters == null)
					return;
				if (this.bAddedToPlane == true)
					return;

				this.bAddedToPlane = true;
				this.bShown = shown;

				this.pLayer = this.hoAdRunHeader.rhFrame.layers[layer];
				if (quickDisplay)
					this.plane = this.pLayer.planeQuickDisplay;
				else
					this.plane = this.pLayer.planeSprites;

				if (index < 0)
					this.plane.addChild(this);
				else
					this.plane.addChildIndex(this, index);

				if (this.type != 5)
					this.computeNewDisplay();
			},

			delSprite: function ()
			{
				if (this.hoCommon.ocCounters == null)
					return -1;
				if (this.bAddedToPlane == false)
					return -1;

				this.bAddedToPlane = false;
				var index = this.plane.getChildIndex(this);
				this.plane.removeChild(this);
				return index;
			},

			getChildIndex: function ()
			{
				if (this.bAddedToPlane)
				{
					return this.plane.getChildIndex(this);
				}
				return -1;
			},

			getChildMaxIndex: function ()
			{
				if (this.bAddedToPlane)
					return this.plane.getNumChildren();
				return -1;
			},

			setChildIndex: function (index)
			{
				if (this.bAddedToPlane)
					this.plane.setChildIndex(this, index);
			},

			showSprite: function ()
			{
				if (this.hoCommon.ocCounters == null)
					return;

				if (this.bShown == false)
				{
					this.bShown = true;
					this.computeNewDisplay();
				}
			},

			hideSprite: function ()
			{
				if (this.hoCommon.ocCounters == null)
					return;

				if (this.bShown == true)
				{
					this.bShown = false;
				}
			},

			setValue: function (value)
			{
				if (value != this.rsValue)
				{
					this.rsValue = value;
					this.computeNewDisplay();
				}
			},

			callComputeNewDisplay: function ()
			{
				if (!this.computed)
					this.computeNewDisplay();
			},

			computeNewDisplay: function ()
			{
				this.computed = true;
				this.hoImgWidth = this.hoImgHeight = 1;
				if (this.hoCommon.ocCounters == null)
					return;
				var adCta = this.hoCommon.ocCounters;

				switch (adCta.odDisplayType)
				{
					case 4:
						if (this.rsValue != 0)
						{
							ifo = this.hoAdRunHeader.rhApp.imageBank.getImageFromHandle(adCta.frames[0]);
							var lg = this.rsValue * ifo.width;
							if (lg <= this.rsBoxCx)
							{
								this.hoImgWidth = lg;
								this.hoImgHeight = ifo.height;
							}
							else
							{
								this.hoImgWidth = this.rsBoxCx;
								this.hoImgHeight = ((this.rsBoxCx / ifo.width) + this.rsValue - 1) * ifo.height;
							}
							break;
						}
						this.hoImgWidth = this.hoImgHeight = 1;
						break;
					case 1:
						var i;
						var c;
						var img;
						var ifo;
						var dx = 0, dy = 0;
						var s = CServices.intToString(this.rsValue, this.displayFlags);
						for (i = s.length - 1; i >= 0; i--)
						{
							c = s.charCodeAt(i);
							img = 0;
							if (c == 45)
								img = adCta.frames[10];
							else if (c == 46)
								img = adCta.frames[12];
							else if (c == 43)
								img = adCta.frames[11];
							else if (c == 101 || c == 69)
								img = adCta.frames[13];
							else if (c >= 48 && c <= 57)
								img = adCta.frames[c - 48];
							if (img >= 0)
							{
								ifo = this.hoAdRunHeader.rhApp.imageBank.getImageFromHandle(img);
								dx += ifo.width;
								dy = Math.max(dy, ifo.height);
							}
						}
						this.hoImgXSpot = dx;
						this.hoImgYSpot = dy;
						this.hoImgWidth = dx;
						this.hoImgHeight = dy;
						break;

					case 5:
						var s = CServices.intToString(this.rsValue, this.displayFlags);
						var w;
						if (this.textSurface != null)
							w = this.textSurface.measureText(s, this.font);
						else
						{
							var ts = new CTextSurface(this.hoAdRunHeader.rhApp, 8, 8);
							w = ts.measureText(s, this.font);
						}
						this.hoImgXSpot = w;
						this.hoImgYSpot = this.rsBoxCy / 2 + this.fontHeight / 2;
						this.hoImgWidth = w;
						this.hoImgHeight = this.fontHeight;
						if (this.textSurface == null)
							this.textSurface = new CTextSurface(this.hoAdRunHeader.rhApp, this.hoImgWidth, this.hoImgHeight);
						else
						{
							if (this.hoImgWidth > this.textSurface.width || this.hoImgHeight > this.textSurface.height)
								this.textSurface.resize(this.hoImgWidth, this.hoImgHeight);
						}
						var rect = new CRect(0, 0, 1000, 1000);
						this.textSurface.setText(s, CServices.DT_LEFT | CServices.DT_TOP, rect, this.font, this.rsColor1);
						break;
				}
			},

			draw:            function (context, xx, yy)
			{
				if (!this.bShown || !this.computed) return;

				this.globalAlpha = this.alpha;
				this.globalCompositeOperation = this.composite;

				var image;
				var color1, color2;
				var s;

				var adCta = this.hoCommon.ocCounters;
				var x = xx + this.hoX - this.hoImgXSpot - this.hoAdRunHeader.rhWindowX + this.pLayer.x;
				var y = yy + this.hoY - this.hoImgYSpot - this.hoAdRunHeader.rhWindowY + this.pLayer.y;
				switch (this.type)
				{
					case 1:
						var i, img, ifo;
						s = CServices.intToString(this.rsValue, this.displayFlags);
						for (i = 0; i < s.length; i++)
						{
							var c = s.charCodeAt(i);
							img = 0;
							if (c == 45)
								img = adCta.frames[10];
							else if (c == 46 || c == 44)
								img = adCta.frames[12];
							else if (c == 43)
								img = adCta.frames[11];
							else if (c == 69 || c == 101)
								img = adCta.frames[13];
							else if (c >= 48 && c <= 57)
								img = adCta.frames[c - 48];
							ifo = this.hoAdRunHeader.rhApp.imageBank.getImageFromHandle(img);
							context.renderImage(ifo, x + ifo.xSpot, y + ifo.ySpot, 0, 1.0, 1.0, this.ros.rsEffect, this.ros.rsEffectParam);
							x += ifo.width;
						}
						break;
					case 4:
						if (this.rsValue != 0)
						{
							var x2 = x + this.hoImgWidth;
							var y2 = y + this.hoImgHeight;
							var x1 = x;
							var y1 = y;
							var vInt = this.rsValue;
							var ifo = this.hoAdRunHeader.rhApp.imageBank.getImageFromHandle(adCta.frames[0]);
							for (y = y1; y < y2 && vInt > 0; y += ifo.height)
							{
								for (x = x1; x < x2 && vInt > 0; x += ifo.width, vInt -= 1)
								{
									context.renderImage(ifo, x + ifo.xSpot, y + ifo.ySpot, 0, 1.0, 1.0, this.ros.rsEffect, this.ros.rsEffectParam);
								}
							}
						}
						break;
					case 5:
						this.textSurface.draw(context, x, y, this.ros.rsEffect, this.ros.rsEffectParam);
						break;
				}
			},
			setTransparency: function (t)
			{
				this.ros.rsEffect = CRSpr.BOP_BLEND;
				this.ros.rsEffectParam = t;
			}
		});

	// CText object
	// ------------------------------------------------------------
	function CText()
	{
		this.rsTextBuffer = null;
		this.currentText = null;
		this.rsMaxi = 0;
		this.rsMini = 0;
		this.rsFont = 0;
		this.rsTextColor = 0;
		this.nLayer = 0;
		this.font = null;
		this.bShown = true;
		this.flags = 0;
		this.rsHidden = 0;
		this.pLayer = null;
		this.plane = null;
		this.bAddedToPlane = false;
		this.rect = new CRect();
		this.deltaY = 0;
		this.rsBoxCx = 0;
		this.rsBoxCy = 0;
		this.textSurface = null;
		this.computed = false;
	}

	CText.prototype = CServices.extend(new CObject(),
		{
			init: function (ocPtr, cob)
			{
				var txt = ocPtr.ocObject;
				this.hoImgWidth = txt.otCx;
				this.hoImgHeight = txt.otCy;
				this.rsBoxCx = txt.otCx;
				this.rsBoxCy = txt.otCy;

				this.rsMaxi = txt.otNumberOfText;
				this.rsTextColor = 0;
				if (txt.otTexts.length > 0)
					this.rsTextColor = txt.otTexts[0].tsColor;

				this.rsTextBuffer = null;
				this.rsFont = -1;
				this.rsMini = 0;
				this.bShown = true;
				this.rsHidden = cob.cobFlags;
				if (txt.otTexts.length > 0)
				{
					this.rsTextBuffer = txt.otTexts[0].tsText;
				}
				var nFont = this.rsFont;
				if (nFont == -1)
				{
					if (txt.otTexts.length > 0)
						nFont = txt.otTexts[0].tsFont;
				}
				this.font = this.hoAdRunHeader.rhApp.fontBank.getFontFromHandle(nFont);
				this.textSurface = new CTextSurface(this.hoAdRunHeader.rhApp, this.hoImgWidth, this.hoImgHeight);
			},

			kill: function ()
			{
			},

			handle: function ()
			{
				this.ros.handle();
				if (this.roc.rcChanged)
				{
					this.roc.rcChanged = false;
				}
			},

			getFont: function ()
			{
				var nFont = this.rsFont;
				if (nFont == -1)
				{
					var txt = this.hoCommon.ocObject;
					nFont = txt.otTexts[0].tsFont;
				}
				return this.hoAdRunHeader.rhApp.fontBank.getFontInfoFromHandle(nFont);
			},

			setFont: function (f, size)
			{
				this.rsFont = this.hoAdRunHeader.rhApp.fontBank.addFont(f);
				this.font = this.hoAdRunHeader.rhApp.fontBank.getFontFromHandle(this.rsFont);
				if (size != null)
				{
					this.hoImgWidth = size.right - size.left;
					this.hoImgHeight = size.bottom - size.top;
					this.textSurface.resize(this.hoImgWidth, this.hoImgHeight);
				}
				this.roc.rcChanged = true;
				this.computeNewDisplay();
			},

			getFontColor: function ()
			{
				return this.rsTextColor;
			},

			setFontColor: function (rgb)
			{
				this.rsTextColor = rgb;
				this.computeNewDisplay();
			},

			addOwnerDrawSprite: function (xx, yy, layer, quickDisplay, shown, index)
			{
				if (this.bAddedToPlane == true)
					return;

				this.bAddedToPlane = true;
				this.bShown = shown;

				this.pLayer = this.hoAdRunHeader.rhFrame.layers[layer];
				if (quickDisplay)
					this.plane = this.pLayer.planeQuickDisplay;
				else
					this.plane = this.pLayer.planeSprites;

				if (index < 0)
					this.plane.addChild(this);
				else
					this.plane.addChildIndex(this, index);
			},

			delSprite: function ()
			{
				if (this.bAddedToPlane == false)
					return -1;

				this.bAddedToPlane = false;
				var index = this.plane.getChildIndex(this);
				this.plane.removeChild(this);
				return index;
			},

			getChildIndex: function ()
			{
				if (this.bAddedToPlane)
				{
					return this.plane.getChildIndex(this);
				}
				return -1;
			},

			getChildMaxIndex: function ()
			{
				if (this.bAddedToPlane)
					return this.plane.getNumChildren();
				return -1;
			},

			setChildIndex: function (index)
			{
				if (this.bAddedToPlane)
					this.plane.setChildIndex(this, index);
			},

			showSprite: function ()
			{
				if (this.bShown == false)
				{
					this.bShown = true;
				}
			},

			hideSprite: function ()
			{
				if (this.bShown == true)
				{
					this.bShown = false;
				}
			},

			txtChange: function (num)
			{
				if (num < -1)
					num = -1;
				if (num >= this.rsMaxi)
					num = this.rsMaxi - 1;
				if (num == this.rsMini)
					return false;

				this.rsMini = num;

				if (num >= 0)
				{
					var txt = this.hoCommon.ocObject;
					this.txtSetString(txt.otTexts[this.rsMini].tsText);
				}
				this.computeNewDisplay();

				if ((this.ros.rsFlags & CRSpr.RSFLAG_HIDDEN) != 0)
					return false;

				return true;
			},

			txtSetString: function (s)
			{
				this.rsTextBuffer = s;
				this.computeNewDisplay();
			},

			callComputeNewDisplay: function ()
			{
				if (!this.computed)
					this.computeNewDisplay();
			},

			computeNewDisplay: function ()
			{
				this.computed = true;

				var txt = this.hoCommon.ocObject;
				var flags = txt.otTexts[0].tsFlags;

				this.hoImgXSpot = 0;
				this.hoImgYSpot = 0;
				this.rect.left = 0;
				this.rect.top = 0;
				this.rect.right = this.hoImgWidth;
				this.rect.bottom = this.hoImgHeight;

				var s;
				if (this.rsMini >= 0)
					s = txt.otTexts[this.rsMini].tsText;
				else
				{
					s = this.rsTextBuffer;
					if (s == null)
						s = "";
				}

				var dtflags = (flags & (CServices.DT_LEFT | CServices.DT_CENTER | CServices.DT_RIGHT |
					CServices.DT_TOP | CServices.DT_BOTTOM | CServices.DT_VCENTER |
					CServices.DT_SINGLELINE));
				var ht = this.textSurface.setText(s, dtflags, this.rect, this.font, this.rsTextColor);
				if ((dtflags & (CServices.DT_BOTTOM | CServices.DT_VCENTER)) == 0)
				    this.hoImgHeight = ht;
			},
			setTransparency:   function (t)
			{
				this.ros.rsEffect = CRSpr.BOP_BLEND;
				this.ros.rsEffectParam = t;
			},
			draw:              function (context, xx, yy)
			{
				if (!this.bShown || !this.computed) return;
				var x = xx + this.hoX - this.hoAdRunHeader.rhWindowX + this.pLayer.x;
				var y = yy + this.hoY - this.hoAdRunHeader.rhWindowY + this.pLayer.y;
				this.textSurface.draw(context, x, y, this.ros.rsEffect, this.ros.rsEffectParam);
			}
		});

	// CQuestion object
	// -------------------------------------------------------------
	function CQuestion()
	{
		this.rsBoxCx = 0;
		this.rsBoxCy = 0;
		this.rcA = null;
		this.currentDown = 0;
		this.xMouse = 0;
		this.yMouse = 0;
		this.textSurfaces = new Array();
	}
	CQuestion.prototype = CServices.extend(new CObject(),
		{
			init: function (ocPtr, cob)
			{
			},

			kill: function ()
			{
			},

			handle:         function ()
			{
				this.hoAdRunHeader.pause();
				this.hoAdRunHeader.questionObjectOn = this;
				var layer = this.hoAdRunHeader.rhFrame.layers[this.hoAdRunHeader.rhFrame.nLayers - 1];
				layer.planeSprites.addChild(this);
				this.computeTexts();
			},
			destroyObject:  function ()
			{
				var layer = this.hoAdRunHeader.rhFrame.layers[this.hoAdRunHeader.rhFrame.nLayers - 1];
				layer.planeSprites.removeChild(this);
			},
			handleQuestion: function ()
			{
				var current;
				var xMouse = this.hoAdRunHeader.rhApp.mouseX - this.hoAdRunHeader.rhApp.xOffset;
				var yMouse = this.hoAdRunHeader.rhApp.mouseY - this.hoAdRunHeader.rhApp.yOffset;

				if (this.currentDown == 0)
				{
					if (this.hoAdRunHeader.rhApp.keyBuffer[CRunApp.VK_LBUTTON])
					{
						current = this.getQuestion(xMouse, yMouse);
						if (current != 0)
						{
							this.currentDown = current;
						}
					}
				}
				else
				{
					if (!this.hoAdRunHeader.rhApp.keyBuffer[CRunApp.VK_LBUTTON])
					{
						if (this.getQuestion(xMouse, yMouse) == this.currentDown)
						{
							this.hoAdRunHeader.rhEvtProg.rhCurParam0 = this.currentDown;
							this.hoAdRunHeader.rhEvtProg.handle_Event(this, (((-80 - 3) << 16) | 4));

							var defTexts = this.hoCommon.ocObject;
							var ptts = defTexts.otTexts[this.currentDown];
							var bCorrect = (ptts.tsFlags & CDefText.TSF_CORRECT) != 0;
							if (bCorrect)
							{
								this.hoAdRunHeader.rhEvtProg.handle_Event(this, (((-80 - 1) << 16) | 4));
							}
							else
							{
								this.hoAdRunHeader.rhEvtProg.handle_Event(this, (((-80 - 2) << 16) | 4));
							}
							this.destroyObject();
							this.hoAdRunHeader.questionObjectOn = null;
							this.hoAdRunHeader.resume();
							this.hoAdRunHeader.f_KillObject(this.hoNumber, true);
							return;
						}
						this.currentDown = 0;
					}
				}
			},

			getQuestion: function (xMouse, yMouse)
			{
				var i;
				if (this.rcA != null)
				{
					for (i = 1; i < this.rcA.length; i++)
					{
						if (xMouse >= this.rcA[i].left && xMouse < this.rcA[i].right)
						{
							if (yMouse > this.rcA[i].top && yMouse < this.rcA[i].bottom)
							{
								return i;
							}
						}
					}
				}
				return 0;
			},

			border3D: function (context, rc, state)
			{
				var color1, color2;

				if (state)
				{
					color1 = 0x808080;
					color2 = 0xFFFFFF;
				}
				else
				{
					color2 = 0x808080;
					color1 = 0xFFFFFF;
				}

				context.renderRect(rc.left, rc.top, rc.right - rc.left,
					rc.bottom - rc.top, 0x000000, 1);

				var pt = new Array(3);
				var n;
				for (n = 0; n < 3; n++)
				{
					pt[n] = new CPoint();
				}
				pt[0].x = rc.right - 1;
				if (state == false)
					pt[0].x -= 1;
				pt[0].y = rc.top + 1;
				pt[1].y = rc.top + 1;
				pt[1].x = rc.left + 1;
				pt[2].x = rc.left + 1;
				pt[2].y = rc.bottom;
				if (state == false)
					pt[2].y -= 1;
				context.renderLine(pt[0].x, pt[0].y, pt[1].x, pt[1].y, color1, 1);
				context.renderLine(pt[1].x, pt[1].y, pt[2].x, pt[2].y, color1, 1);

				if (state == false)
					pt[0].x -= 1;
				pt[0].y += 1;
				pt[1].x += 1;
				pt[1].y += 1;
				pt[2].x += 1;
				if (state == false)
					pt[2].y -= 1;
				context.renderLine(pt[0].x, pt[0].y, pt[1].x, pt[1].y, color1, 1);
				context.renderLine(pt[1].x, pt[1].y, pt[2].x, pt[2].y, color1, 1);

				if (state == false)
				{
					pt[0].x += 2;
					pt[1].x = rc.right - 1;
					pt[1].y = rc.bottom - 1;
					pt[2].y = rc.bottom - 1;
					pt[2].x -= 1;
					context.renderLine(pt[0].x, pt[0].y, pt[1].x, pt[1].y, color2, 1);
					context.renderLine(pt[1].x, pt[1].y, pt[2].x, pt[2].y, color2, 1);

					pt[0].x -= 1;
					pt[0].y += 1;
					pt[1].x -= 1;
					pt[1].y -= 1;
					pt[2].x += 1;
					pt[2].y -= 1;
					context.renderLine(pt[0].x, pt[0].y, pt[1].x, pt[1].y, color2, 1);
					context.renderLine(pt[1].x, pt[1].y, pt[2].x, pt[2].y, color2, 1);
				}
			},

			redraw_Answer: function (context, number, state)
			{
				var rc = new CRect();

				rc.copyRect(this.rcA[number]);
				this.border3D(context, this.rcA[number], state);
				rc.left += 2;
				rc.top += 2;
				rc.right -= 4;
				rc.bottom -= 4;
				if (state)
				{
					rc.left += 2;
					rc.top += 2;
				}
				this.textSurfaces[number].draw(context,
					(rc.left + rc.right) / 2 - this.textSurfaces[number].width / 2,
					(rc.top + rc.bottom) / 2 - this.textSurfaces[number].height / 2,
					0, 0);
			},

			computeTexts: function ()
			{
				this.measureTextSurface = new CTextSurface(this.hoAdRunHeader.rhApp, 8, 8);

				var defTexts = this.hoCommon.ocObject;
				var prh = this.hoAdRunHeader;

				var ptta = defTexts.otTexts[1];
				var colorA = ptta.tsColor;
				var flgRelief = (ptta.tsFlags & CDefText.TSF_RELIEF) != 0;
				var fontAnswers = prh.rhApp.fontBank.getFontFromHandle(ptta.tsFont);
				this.xa_margin = Math.floor((this.measureTextSurface.measureText("X", fontAnswers) * 3) / 2);
				this.hta = 4;
				this.lgBox = 64;
				var i, tm;
				for (i = 1; i < defTexts.otTexts.length; i++)
				{
					ptta = defTexts.otTexts[i];
					if (ptta.tsText.length > 0)
					{
						tm = this.measureTextSurface.measureText(ptta.tsText, fontAnswers);
						this.lgBox = Math.max(this.lgBox, tm + this.xa_margin * 2 + 4);
						this.hta = Math.max(this.hta, Math.floor((fontAnswers.getHeight() * 3) / 2));
					}
				}
				this.hte = Math.max(Math.floor(this.hta / 4), 2);
				this.lgBox += this.xa_margin * 2 + 4;
				var rc = new CRect();
				for (i = 1; i < defTexts.otTexts.length; i++)
				{
					ptta = defTexts.otTexts[i];
					this.textSurfaces[i] = new CTextSurface(prh.rhApp, this.lgBox, this.hta);
					rc.right = this.lgBox;
					rc.bottom = this.hta;
					this.textSurfaces[i].manualDrawText(ptta.tsText, CServices.DT_CENTER | CServices.DT_VCENTER, rc, colorA, fontAnswers, flgRelief ? 1 : 0, 0xFFFFFF);
				}

				var ptts = defTexts.otTexts[0];
				flgRelief = (ptts.tsFlags & CDefText.TSF_RELIEF) != 0;
				var fontQuestion = prh.rhApp.fontBank.getFontFromHandle(ptts.tsFont);
				var xq_margin = Math.floor((this.measureTextSurface.measureText("X", fontQuestion) * 3) / 2);
				tm = this.measureTextSurface.measureText(ptts.tsText, fontQuestion);
				this.htq = Math.floor(fontQuestion.getHeight() * 3 / 2);
				this.lgBox = Math.max(this.lgBox, tm + xq_margin * 2 + 4);
				if (this.lgBox > prh.rhApp.gaCxWin)
					this.lgBox = prh.rhApp.gaCxWin;
				else if (this.lgBox > prh.rhFrame.leWidth)
					this.lgBox = prh.rhFrame.leWidth;
				rc.right = this.lgBox;
				rc.bottom = this.htq;
				this.textSurfaces[0] = new CTextSurface(prh.rhApp, this.lgBox, this.htq);
				this.textSurfaces[0].manualDrawText(ptts.tsText, CServices.DT_CENTER | CServices.DT_VCENTER,
					rc, colorA, fontQuestion, flgRelief ? 1 : 0, 0xFFFFFF);
			},
			draw:         function (context, xDraw, yDraw)
			{
				var defTexts = this.hoCommon.ocObject;
				var prh = this.hoAdRunHeader;
				var x = this.hoX - prh.rhWindowX;
				var y = this.hoY - prh.rhWindowY;

				var rcQ = new CRect();
				rcQ.left = x;
				rcQ.top = y;
				var boxCx = this.lgBox;
				var boxCy = this.htq + 1 + (this.hta + this.hte) * (defTexts.otTexts.length - 1) + this.hte + 4;
				rcQ.right = x + boxCx;
				rcQ.bottom = y + boxCy;

				context.renderSolidColor(rcQ.left, rcQ.top, rcQ.right - rcQ.left, rcQ.bottom - rcQ.top, 0xC0C0C0, 0, 0);
				this.border3D(context, rcQ, false);

				rcQ.left += 2;
				rcQ.top += 2;
				rcQ.right -= 2;
				rcQ.bottom = rcQ.top + this.htq;
				this.textSurfaces[0].draw(context,
					(rcQ.left + rcQ.right) / 2 - this.textSurfaces[0].width / 2,
					(rcQ.top + rcQ.bottom) / 2 - this.textSurfaces[0].height / 2,
					0, 0);
				rcQ.top = rcQ.bottom;
				context.renderLine(rcQ.left, rcQ.top, rcQ.right, rcQ.bottom, 0x808080, 1, 0, 0);
				rcQ.top += 1;
				rcQ.bottom += 1;
				context.renderLine(rcQ.left, rcQ.top, rcQ.right, rcQ.bottom, 0xFFFFFF, 1, 0, 0);

				if (this.rcA == null)
				{
					this.rcA = Array(defTexts.otTexts.length);
					for (i = 1; i < defTexts.otTexts.length; i++)
					{
						this.rcA[i] = new CRect();
						this.rcA[i].left = x + 2 + this.xa_margin;
						this.rcA[i].right = x + this.lgBox - 2 - this.xa_margin;
						this.rcA[i].top = y + 2 + this.htq + 1 + this.hte + (this.hta + this.hte) * (i - 1);
						this.rcA[i].bottom = this.rcA[i].top + this.hta;
					}
				}
				for (i = 1; i < defTexts.otTexts.length; i++)
				{
					var bFlag = (this.currentDown == i);
					this.redraw_Answer(context, i, bFlag);
				}
			}
		});

	// CExtension object
	// -------------------------------------------------------------
	function CExtension(type, rhPtr)
	{
		this.ext = rhPtr.rhApp.extLoader.loadRunObject(type);
		this.noHandle = false;
		this.privateData = 0;
		this.objectCount = 0;
		this.objectNumber = 0;
		this.bAddedToPlane = false;
		this.bShown = true;
		this.nLayer = 0;
		this.pLayer = null;
		this.plane = null;
	}
	CExtension.prototype = CServices.extend(new CObject(),
		{
			init: function (ocPtr, cob)
			{
				this.ext.init(this);

				var file = this.hoAdRunHeader.rhApp.file.createFromFile(ocPtr.ocExtension);
				this.privateData = ocPtr.ocPrivate;
				this.ext.createRunObject(file, cob, ocPtr.ocVersion);
			},

			addSprite: function (xx, yy, image, layer, bShown)
			{
				this.nLayer = layer;
				this.pLayer = this.hoAdRunHeader.rhFrame.layers[layer];
				this.bShown = bShown;
				if (this.bAddedToPlane == true)
					return;
				this.bAddedToPlane = true;
				this.plane = this.pLayer.planeSprites;
				this.plane.addChild(this);
			},

			addOwnerDrawSprite: function (xx, yy, layer, bQuickDisplay, bShown)
			{
				this.nLayer = layer;
				this.pLayer = this.hoAdRunHeader.rhFrame.layers[layer];
				this.bShown = bShown;

				if (this.bAddedToPlane == true)
					return;
				this.bAddedToPlane = true;

				if (bQuickDisplay)
					this.plane = this.pLayer.planeQuickDisplay;
				else
					this.plane = this.pLayer.planeSprites;

				this.plane.addChild(this);
			},

			delSprite: function ()
			{
			    //return this.plane.removeChild(this);

				if (this.bAddedToPlane == false)
				    return -1;
				this.bAddedToPlane = false;
				var index = this.plane.getChildIndex(this);
				this.plane.removeChild(this);
				return index;
			},

			handle: function ()
			{
				if ((this.hoOEFlags & 0x0200) != 0)
					this.ros.handle();
				else if ((this.hoOEFlags & 0x0030) == 0x0010 || (this.hoOEFlags & 0x0030) == 0x0030)
					this.rom.move();
				else if ((this.hoOEFlags & 0x0030) == 0x0020)
					this.roa.animate();

				var ret = 0;
				if (this.noHandle == false)
					ret = this.ext.handleRunObject();

				if ((ret & CRunExtension.REFLAG_ONESHOT) != 0)
					this.noHandle = true;
				if (this.roc != null)
				{
					if (this.roc.rcChanged)
					{
						ret |= CRunExtension.REFLAG_DISPLAY;
						this.roc.rcChanged = false;
					}
				}
			},

			autoResize: function ()
			{
				this.ext.autoResize();
			},
			createFont: function ()
			{
				this.ext.createFont();
			},
			draw:       function (context, xDraw, yDraw)
			{
				if (this.bShown)
				{
					this.ext.displayRunObject(context, xDraw, yDraw);
				}
			},

			kill: function (bFast)
			{
				this.ext.destroyRunObject(bFast);
			},

			getCollisionMask: function (flags)
			{
				return this.ext.getRunObjectCollisionMask(flags);
			},

			condition: function (num, cnd)
			{
				return this.ext.condition(num, cnd);
			},

			action: function (num, act)
			{
				this.ext.action(num, act);
			},

			expression: function (num)
			{
				return this.ext.expression(num);
			},

			setTransparency: function (t)
			{
				this.ros.rsEffect = CRSpr.BOP_BLEND;
				this.ros.rsEffectParam = t;
			},

			setFocus: function (bFlag)
			{
				this.ext.setFocus(bFlag);
			},

			showSprite: function ()
			{
				this.bShown = true;
			},

			hideSprite: function ()
			{
				this.bShown = false;
			},

			//setChildIndex: function (index)
			//{
			//	this.ext.setChildIndex(index);
			//},

			getChildIndex: function ()
			{
				return this.plane.getChildIndex(this);
			},

			getChildMaxIndex: function ()
			{
				return this.plane.children.length;
			},

			setChildIndex: function (index)
			{
				if (index >= this.plane.children.length)
					index = this.plane.children.length;
				if (index < 0)
					index = 0;
				this.plane.setChildIndex(this, index);
			},

			pauseRunObject: function ()
			{
				this.ext.pauseRunObject();
			},

			continueRunObject: function ()
			{
				this.ext.continueRunObject();
			},

			forcePosition: function ()
			{
				this.ext.forcePosition();
			},

			loadImageList: function (list)
			{
				this.hoAdRunHeader.rhApp.imageBank.loadImageList(list);
			},

			getImage: function (handle)
			{
				return this.hoAdRunHeader.rhApp.imageBank.getImageFromHandle(handle);
			},

			getApplication: function ()
			{
				return this.hoAdRunHeader.rhApp;
			},

			getX: function ()
			{
				return this.hoX;
			},

			getY: function ()
			{
				return this.hoY;
			},

			getWidth: function ()
			{
				return this.hoImgWidth;
			},

			getHeight: function ()
			{
				return this.hoImgHeight;
			},

			setX: function (x)
			{
				if (this.rom != null)
				{
					this.rom.rmMovement.setXPosition(x);
				}
				else
				{
					this.hoX = x;
					if (this.roc != null)
					{
						this.roc.rcChanged = true;
						this.roc.rcCheckCollides = true;
					}
				}
			},

			setY: function (y)
			{
				if (this.rom != null)
				{
					this.rom.rmMovement.setYPosition(y);
				}
				else
				{
					this.hoY = y;
					if (this.roc != null)
					{
						this.roc.rcChanged = true;
						this.roc.rcCheckCollides = true;
					}
				}
			},

			setWidth: function (width)
			{
				this.hoImgWidth = width;
			},

			setHeight: function (height)
			{
				this.hoImgHeight = height;
			},
			setSize:   function (width, height)
			{
				this.hoImgWidth = width;
				this.hoImgHeight = height;
			},
			reHandle:  function ()
			{
				this.noHandle = false;
			},

			generateEvent: function (code, param)
			{
				if (this.hoAdRunHeader.rh2PauseCompteur == 0)
				{
					var p0 = this.hoAdRunHeader.rhEvtProg.rhCurParam0;
					this.hoAdRunHeader.rhEvtProg.rhCurParam0 = param;

					code = (-(code + CEventProgram.EVENTS_EXTBASE + 1) << 16);
					code |= (this.hoType & 0xFFFF);
					this.hoAdRunHeader.rhEvtProg.handle_Event(this, code);

					this.hoAdRunHeader.rhEvtProg.rhCurParam0 = p0;
				}
			},

			pushEvent: function (code, param)
			{
				if (this.hoAdRunHeader.rh2PauseCompteur == 0)
				{
					code = (-(code + CEventProgram.EVENTS_EXTBASE + 1) << 16);
					code |= (this.hoType & 0xFFFF);
					this.hoAdRunHeader.rhEvtProg.push_Event(1, code, param, this, this.hoOi);
				}
			},

			pause: function ()
			{
				this.hoAdRunHeader.pause();
			},

			resume: function ()
			{
				this.hoAdRunHeader.resume();
			},

			redraw: function ()
			{
			},

			destroy: function ()
			{
				this.hoAdRunHeader.destroy_Add(this.hoNumber);
			},

			setPosition: function (x, y)
			{
				if (this.rom != null)
				{
					this.rom.rmMovement.setXPosition(x);
					this.rom.rmMovement.setYPosition(y);
				}
				else
				{
					this.hoX = x;
					this.hoY = y;
					if (this.roc != null)
					{
						this.roc.rcChanged = true;
						this.roc.rcCheckCollides = true;
					}
				}
			},

			getExtUserData: function ()
			{
				return this.privateData;
			},

			setExtUserData: function (data)
			{
				this.privateData = data;
			},

			addBackdrop: function (img, x, y, typeObst, nLayer)
			{
				this.hoAdRunHeader.addBackdrop(img, x, y, nLayer, typeObst, true);
			},

			getEventCount: function ()
			{
				return this.hoAdRunHeader.rh4EventCount;
			},

			getExpParam: function ()
			{
				this.hoAdRunHeader.rh4CurToken++;
				return this.hoAdRunHeader.getExpression();
			},

			getEventParam: function ()
			{
				return this.hoAdRunHeader.rhEvtProg.rhCurParam0;
			},

			callMovement: function (hoPtr, action, param)
			{
				if ((hoPtr.hoOEFlags & CObjectCommon.OEFLAG_MOVEMENTS) != 0)
				{
					if (hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
					{
						var mvPtr = hoPtr.rom.rmMovement;
						return mvPtr.callMovement(action, param);
					}
				}
				return 0;
			},

			getFirstObject: function ()
			{
				this.objectCount = 0;
				this.objectNumber = 0;
				return this.getNextObject();
			},

			getNextObject: function ()
			{
				if (this.objectNumber < this.hoAdRunHeader.rhNObjects)
				{
					while (this.hoAdRunHeader.rhObjectList[this.objectCount] == null)
						this.objectCount++;
					var hoPtr = this.hoAdRunHeader.rhObjectList[this.objectCount];
					this.objectNumber++;
					this.objectCount++;
					return hoPtr;
				}
				return null;
			},

			getObjectFromFixed: function (fixed)
			{
				var count = 0;
				var number;
				for (number = 0; number < this.hoAdRunHeader.rhNObjects; number++)
				{
					while (this.hoAdRunHeader.rhObjectList[count] == null)
						count++;
					var hoPtr = this.hoAdRunHeader.rhObjectList[count];
					count++;
					var id = (hoPtr.hoCreationId << 16) | (hoPtr.hoNumber & 0xFFFF);
					if (id == fixed)
						return hoPtr;
				}
				return null;
			},

			findFirstObject:function(name)
			{
				return this.hoAdRunHeader.findFirstObject(name);
			},

			findNextObject:function(object)
			{
				return this.hoAdRunHeader.findNextObject(object);
			},

			openHFile: function (path)
			{
				return hoAdRunHeader.rhApp.openHFile(path);
			},

			closeHFile: function (path)
			{
				hoAdRunHeader.rhApp.closeHFile(path);
			}
		});
	// CParam object
	// ------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */

	CParam.PARAM_EXPRESSIONNUM = 22;
	CParam.create = function (app)
	{
		var debut = app.file.getFilePointer();

		var param = null;
		var size = app.file.readAShort();
		var c = app.file.readAShort();

		switch (c)
		{
			case 1:
				param = new PARAM_OBJECT(app);
				break;
			case 2:
				param = new PARAM_TIME(app);
				break;
			case 3:
				param = new PARAM_SHORT(app);
				break;
			case 4:
				param = new PARAM_SHORT(app);
				break;
			case 5:
				param = new PARAM_INT(app);
				break;
			case 6:
				param = new PARAM_SAMPLE(app);
				break;
			case 9:
				param = new PARAM_CREATE(app);
				break;
			case 10:
				param = new PARAM_SHORT(app);
				break;
			case 11:
				param = new PARAM_SHORT(app);
				break;
			case 12:
				param = new PARAM_SHORT(app);
				break;
			case 13:
				param = new PARAM_EVERY(app);
				break;
			case 14:
				param = new PARAM_KEY(app);
				break;
			case 15:
				param = new PARAM_EXPRESSION(app);
				break;
			case 16:
				param = new PARAM_POSITION(app);
				break;
			case 17:
				param = new PARAM_SHORT(app);
				break;
			case 18:
				param = new PARAM_SHOOT(app);
				break;
			case 19:
				param = new PARAM_ZONE(app);
				break;
			case 21:
				param = new PARAM_CREATE(app);
				break;
			case 22:
				param = new PARAM_EXPRESSION(app);
				break;
			case 23:
				param = new PARAM_EXPRESSION(app);
				break;
			case 24:
				param = new PARAM_COLOUR(app);
				break;
			case 25:
				param = new PARAM_INT(app);
				break;
			case 26:
				param = new PARAM_SHORT(app);
				break;
			case 27:
				param = new PARAM_EXPRESSION(app);
				break;
			case 28:
				param = new PARAM_EXPRESSION(app);
				break;
			case 29:
				param = new PARAM_INT(app);
				break;
			case 31:
				param = new PARAM_SHORT(app);
				break;
			case 32:
				param = new PARAM_SHORT(app);
				break;
			case 34:
				param = new PARAM_INT(app);
				break;
			case 35:
				param = new PARAM_SAMPLE(app);
				break;
			case 36:
				param = new PARAM_SAMPLE(app);
				break;
			case 37:
				param = new PARAM_SHORT(app);
				break;
			case 38:
				param = new PARAM_GROUP(app);
				break;
			case 39:
				param = new PARAM_GROUPOINTER(app);
				break;
			case 40:
				param = new PARAM_STRING(app);
				break;
			case 41:
				param = new PARAM_STRING(app);
				break;
			case 42:
				param = new PARAM_CMPTIME(app);
				break;
			case 43:
				param = new PARAM_SHORT(app);
				break;
			case 44:
				param = new PARAM_KEY(app);
				break;
			case 45:
				param = new PARAM_EXPRESSION(app);
				break;
			case 46:
				param = new PARAM_EXPRESSION(app);
				break;
			case 47:
				param = new PARAM_2SHORTS(app);
				break;
			case 48:
				param = new PARAM_INT(app);
				break;
			case 49:
				param = new PARAM_SHORT(app);
				break;
			case 50:
				param = new PARAM_SHORT(app);
				break;
			case 51:
				param = new PARAM_2SHORTS(app);
				break;
			case 52:
				param = new PARAM_EXPRESSION(app);
				break;
			case 53:
				param = new PARAM_EXPRESSION(app);
				break;
			case 54:
				param = new PARAM_EXPRESSION(app);
				break;
			case 55:
				param = new PARAM_EXTENSION(app);
				break;
			case 56:
				param = new PARAM_INT(app);
				break;
			case 57:
				param = new PARAM_SHORT(app);
				break;
			case 58:
				param = new PARAM_SHORT(app);
				break;
			case 59:
				param = new PARAM_EXPRESSION(app);
				break;
			case 60:
				param = new PARAM_SHORT(app);
				break;
			case 61:
				param = new PARAM_SHORT(app);
				break;
			case 62:
				param = new PARAM_EXPRESSION(app);
				break;
			case 63:
				param = new PARAM_STRING(app);
				break;
			case 64:
				param = new PARAM_STRING(app);
				break;
		    case 67:
		        param = new PARAM_SHORT(app);
		        break;
		    case 68:
		        param = new PARAM_MULTIPLEVAR(app);
		        break;
		    case 69:
		        param = new PARAM_CHILDEVENT(app);
		        break;
		}
		param.code = c;
		app.file.seek(debut + size);
		return param;
	}
	function CParam()
	{
	}

	// CPositionInfo object
	// ------------------------------------------------------------------------
	function CPositionInfo()
	{
		this.x = 0;
		this.y = 0;
		this.dir = 0;
		this.layer = 0;
		this.bRepeat = false;
	}
	// Parameter objects
	// ------------------------------------------------------------------------
	function PARAM_2SHORTS(app)
	{
		this.value1 = app.file.readAShort();
		this.value2 = app.file.readAShort();
	}
	function PARAM_CMPTIME(app)
	{
		this.timer = app.file.readAInt();
		this.loops = app.file.readAInt();
		this.comparaison = app.file.readAShort();
	}
	function PARAM_COLOUR(app)
	{
		this.color = app.file.readAColor();
	}
	function PARAM_EVERY(app)
	{
		this.delay = app.file.readAInt();
		this.compteur = app.file.readAInt();
	}
	function PARAM_EXPRESSION(app)
	{
		this.comparaison = app.file.readAShort();

		var debut = app.file.getFilePointer();
		var count = 0;
		var size;
		var code;
		while (true)
		{
			count++;
			code = app.file.readAInt();
			if (code == 0)
				break;
			size = app.file.readAShort();
			if (size > 6)
				app.file.skipBytes(size - 6);
		}

		app.file.seek(debut);
		this.tokens = new Array(count);
		var n;
		for (n = 0; n < count; n++)
			this.tokens[n] = CExp.create(app.file);
	}
	function PARAM_EXTENSION(app)
	{
		var size = app.file.readAShort();
		app.file.skipBytes(4);
		this.data = 0;
		if (size > 6)
		{
			this.data = app.file.getFilePointer();
			app.file.skipBytes(size - 6);
		}
	}
	PARAM_GROUP.GRPFLAGS_INACTIVE = 0x0001;
	PARAM_GROUP.GRPFLAGS_CLOSED = 0x0002;
	PARAM_GROUP.GRPFLAGS_PARENTINACTIVE = 0x0004;
	PARAM_GROUP.GRPFLAGS_GROUPINACTIVE = 0x0008;
	PARAM_GROUP.GRPFLAGS_GLOBAL = 0x0010;
	function PARAM_GROUP(app)
	{
		this.grpFlags = app.file.readAShort();
		this.grpId = app.file.readAShort();
	}
	function PARAM_GROUPOINTER(app)
	{
		app.file.skipBytes(4);
		this.pointer = 0;
		this.id = app.file.readAShort();
	}
	function PARAM_INT(app)
	{
		this.value = app.file.readAInt();
		this.value2 = 0;
	}
	function PARAM_KEY(app)
	{
		this.key = app.file.readAShort();
	}
	function PARAM_OBJECT(app)
	{
		this.oiList = app.file.readShort();
		this.oi = app.file.readShort();
		this.type = app.file.readShort();
	}
	function PARAM_CHILDEVENT(app) {
	    app.file.skipBytes(4);
	    this.evgOffsetList = 0;
	    this.ois = new Array();
	    while (true) {
	        var oi = app.file.readShort();
	        var oil = app.file.readShort();
	        if (oi == -1)
	            break;
	        this.ois.push(oi);
	        this.ois.push(oil);
	    }
	}
	CPosition.CPF_DIRECTION = 0x0001;
	CPosition.CPF_ACTION = 0x0002;
	CPosition.CPF_INITIALDIR = 0x0004;
	CPosition.CPF_DEFAULTDIR = 0x0008;
	function CPosition()
	{
	}
	CPosition.prototype =
	{
		read_Position: function (rhPtr, getDir, pInfo)
		{
			pInfo.layer = -1;

			if (this.posOINUMParent == -1)
			{
				if (getDir != 0)
				{
					pInfo.dir = -1;
					if ((this.posFlags & CPosition.CPF_DEFAULTDIR) == 0)
					{
						pInfo.dir = rhPtr.get_Direction(this.posDir);
					}
				}
				pInfo.x = this.posX;
				pInfo.y = this.posY;
				var nLayer = this.posLayer;
				if (nLayer > rhPtr.rhFrame.nLayers - 1)
					nLayer = rhPtr.rhFrame.nLayers - 1;
				pInfo.layer = nLayer;
				pInfo.bRepeat = false;
			}
			else
			{
				rhPtr.rhEvtProg.rh2EnablePick = false;
				var pHo;
				pHo = rhPtr.rhEvtProg.get_CurrentObjects(this.posOiList);
				pInfo.bRepeat = rhPtr.rhEvtProg.repeatFlag;
				if (pHo == null)
					return false;
				pInfo.x = pHo.hoX;
				pInfo.y = pHo.hoY;
				pInfo.layer = pHo.hoLayer;

				if ((this.posFlags & CPosition.CPF_ACTION) != 0)
				{
					if ((pHo.hoOEFlags & CObjectCommon.OEFLAG_ANIMATIONS) != 0)
					{
						if (pHo.roc.rcImage >= 0)
						{
							var ifo;
							var angle = pHo.roc.rcAngle;
							var pMBase = rhPtr.GetMBase(pHo);
							if (pMBase != null)
								angle = pMBase.getAngle();
							ifo = rhPtr.rhApp.imageBank.getImageInfoEx(pHo.roc.rcImage, angle, pHo.roc.rcScaleX, pHo.roc.rcScaleY);
							pInfo.x += ifo.xAP - ifo.xSpot;
							pInfo.y += ifo.yAP - ifo.ySpot;
						}
					}
				}

				if ((this.posFlags & CPosition.CPF_DIRECTION) != 0)
				{
					var dir = this.posAngle + pHo.hoAdRunHeader.getDir(pHo) & 0x1F;
					var px = CMove.getDeltaX(this.posSlope, dir);
					var py = CMove.getDeltaY(this.posSlope, dir);
					pInfo.x += px;
					pInfo.y += py;
				}
				else
				{
					pInfo.x += this.posX;
					pInfo.y += this.posY;
				}

				if ((getDir & 0x01) != 0)
				{
					if ((this.posFlags & CPosition.CPF_DEFAULTDIR) != 0)
						pInfo.dir = -1;
					else if ((this.posFlags & CPosition.CPF_INITIALDIR) != 0)
						pInfo.dir = pHo.hoAdRunHeader.getDir(pHo);
					else
						pInfo.dir = rhPtr.get_Direction(this.posDir);
				}
			}

			if ((getDir & 0x02) != 0)
			{
				if (pInfo.x < rhPtr.rh3XMinimumKill || pInfo.x > rhPtr.rh3XMaximumKill)
					return false;
				if (pInfo.y < rhPtr.rh3YMinimumKill || pInfo.y > rhPtr.rh3YMaximumKill)
					return false;
			}
			return true;
		}
	}
	function PARAM_POSITION(app)
	{
		this.posOINUMParent = app.file.readShort();
		this.posFlags = app.file.readShort();
		this.posX = app.file.readShort();
		this.posY = app.file.readShort();
		this.posSlope = app.file.readShort();
		this.posAngle = app.file.readShort();
		this.posDir = app.file.readAInt();
		this.posTypeParent = app.file.readShort();
		this.posOiList = app.file.readShort();
		this.posLayer = app.file.readShort();
	}
	PARAM_POSITION.prototype = CServices.extend(new CPosition(),
		{
		});
	function PARAM_CREATE(app)
	{
		this.posOINUMParent = app.file.readShort();
		this.posFlags = app.file.readShort();
		this.posX = app.file.readShort();
		this.posY = app.file.readShort();
		this.posSlope = app.file.readShort();
		this.posAngle = app.file.readShort();
		this.posDir = app.file.readAInt();
		this.posTypeParent = app.file.readShort();
		this.posOiList = app.file.readShort();
		this.posLayer = app.file.readShort();
		this.cdpHFII = app.file.readAShort();
		this.cdpOi = app.file.readAShort();
	}
	PARAM_CREATE.prototype = CServices.extend(new CPosition(),
		{
		});
	function PARAM_SHOOT(app)
	{
		this.posOINUMParent = app.file.readShort();
		this.posFlags = app.file.readShort();
		this.posX = app.file.readShort();
		this.posY = app.file.readShort();
		this.posSlope = app.file.readShort();
		this.posAngle = app.file.readShort();
		this.posDir = app.file.readAInt();
		this.posTypeParent = app.file.readShort();
		this.posOiList = app.file.readShort();
		this.posLayer = app.file.readShort();
		this.cdpHFII = app.file.readShort();
		this.cdpOi = app.file.readShort();
		app.file.skipBytes(4);		//cdpFree
		this.shtSpeed = app.file.readAShort();
	}
	PARAM_SHOOT.prototype = CServices.extend(new CPosition(),
		{
		});

	function PARAM_SAMPLE(app)
	{
		this.sndHandle = app.file.readAShort();
		this.sndFlags = app.file.readAShort();
	}
	function PARAM_SHORT(app)
	{
		this.value = app.file.readAShort();
	}
	function PARAM_STRING(app)
	{
		this.string = app.file.readAString();
	}
	function PARAM_TIME(app)
	{
		this.timer = app.file.readAInt();
		this.loops = app.file.readAInt();
	}
	function PARAM_ZONE(app)
	{
		this.x1 = app.file.readShort();
		this.y1 = app.file.readShort();
		this.x2 = app.file.readShort();
		this.y2 = app.file.readShort();
	}
	function multiVar(app, _global, _double)
	{
	    this.index = app.file.readAInt();
	    this.op = app.file.readAInt();
	    this.global = _global;
	    if (_double) {
	        this.val = app.file.readADouble();
	    } else {
	        this.val = app.file.readAInt();
	        app.file.skipBytes(4);
	    }
	}
	function PARAM_MULTIPLEVAR(app) {
	    this.flags = app.file.readAInt();
	    this.flagMasks = app.file.readAInt();
	    this.flagValues = app.file.readAInt();
	    this.values = new Array();
	    var mask = 1;
	    var maskGlobal = 2;
	    var maskDouble = 4;
	    for (var i = 0; i < 4; i++) {
	        if ((this.flags & mask) == 0)
	            break;
	        var value = new multiVar(app, (this.flags & maskGlobal) != 0, (this.flags & maskDouble) != 0);
	        mask <<= 4;
	        maskGlobal <<= 4;
	        maskDouble <<= 4;
	        this.values.push(value);
	    }
	}
	PARAM_MULTIPLEVAR.prototype =
	{
	    evaluate: function (pHo) {

	        if ( pHo.rov == null )
	            return false;

	        // Test multiple flags
	        if ( this.flagMasks != 0 )
	        {
	            if ( (pHo.rov.rvValueFlags & this.flagMasks) != this.flagValues )
	                return false;
	        }

	        // Test values
	        for (var i = 0; i < this.values.length; i++) {
	            var value = this.values[i];
	            var v;
	            if (value.global) {
	                v = pHo.hoAdRunHeader.rhApp.getGlobalValueAt(value.index);
	            }
	            else {
	                v = pHo.rov.getValue(value.index);
	            }
	            if (!CRun.compareTo(v, value.val, value.op))
	                return false;
	        }
	        return true;
	    },

	    evaluateNoGlobal: function (pHo) {

	        if ( pHo.rov == null )
	            return false;

	        // Test multiple flags
	        if ( this.flagMasks != 0 )
	        {
	            if ( (pHo.rov.rvValueFlags & this.flagMasks) != this.flagValues )
	                return false;
	        }

	        // Test values
	        for (var i = 0; i < this.values.length; i++) {
	            var value = this.values[i];
	            var v = pHo.rov.getValue(value.index);
	            if (!CRun.compareTo(v, value.val, value.op))
	                return false;
	        }
	        return true;
	    }
	}
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	function Renderer()
	{
		this.clips = [];
	};

	Renderer.prototype =
	{
		renderSolidColor: function (x, y, w, h, color, inkEffect, inkEffectParam)
		{
		},

		renderSolidColorEllipse: function (x, y, w, h, color, inkEffect, inkEffectParam)
		{
		},

		renderGradient: function (x, y, w, h, color1, color2, vertical, inkEffect, inkEffectParam)
		{
		},

		renderGradientEllipse: function (x, y, w, h, color1, color2, vertical, inkEffect, inkEffectParam)
		{
		},

		renderImage: function (image, x, y, angle, scaleX, scaleY, inkEffect, inkEffectParam)
		{
		},

		renderSimpleImage: function (image, x, y, w, h, inkEffect, inkEffectParam)
		{
		},

		renderPattern: function (image, x, y, w, h, inkEffect, inkEffectParam)
		{
		},

		renderPatternEllipse: function (image, x, y, w, h, inkEffect, inkEffectParam)
		{
		},

		renderLine: function (xA, yA, xB, yB, color, thickness, inkEffect, inkEffectParam)
		{
		},

		renderRect: function (x, y, w, h, color, thickness, inkEffect, inkEffectParam)
		{
		},

		renderEllipse: function (x, y, w, h, color, inkEffect, inkEffectParam)
		{
		},

		renderTriangle: function (x, y, b, h, color, orientation)		// x, y is the triangle's left-bottom/top vertice, base and height are reference from this point also.
		{
		},
		
		pushClip: function (x, y, w, h)
		{
			var curClip = this.clips[this.clips.length - 1];

			if (curClip)
			{
				if (x < curClip.x)
					x = curClip.x;

				if (y < curClip.y)
					y = curClip.y;

				if ((x + w) > (curClip.x + curClip.w))
					w = (curClip.x + curClip.w) - x;

				if ((y + h) > (curClip.y + curClip.h))
					h = (curClip.y + curClip.h) - y;
			}

			var clip = { x: x, y: y, w: w, h: h };

			this.clips.push(clip);

			return clip;
		},

		popClip: function ()
		{
			this.clips.pop();
		}
	};

	/* Renderer implementation using 2D canvas context
	 */
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	function StandardRenderer(element)
	{
	    this.xScale = 1.0;
	    this.yScale = 1.0;
	    this.oldEffect = -1;
		this.smoothing = false;
		this.oldSmoothing = false;
		this.dxw = 0.0;               // sub-pixel margin size for destination rectangle
		this.dyw = 0.0;               // sub-pixel margin size for destination rectangle

		if (!(this._context = element.getContext('2d')))
			throw new Error("Failed to init standard renderer");
	};

	StandardRenderer.prototype = CServices.extend(new Renderer(),
		{
			resetEffect: function (smooth)
			{
				this.smoothing = smooth;
				this.oldSmoothing = smooth;
				this._context["imageSmoothingEnabled"] = smooth;
				this._context["webkitImageSmoothingEnabled"] = smooth;
				this._context["mozImageSmoothingEnabled"] = smooth;
				this._context["msImageSmoothingEnabled"] = smooth;

				this.oldEffect = -1;
				this.setInkEffect(0, 0);
			},

			setScale: function (sx, sy)
			{
				this._context.scale(sx, sy);

			    // Adjust subpixel correction according to scale, to avoid seams between backdrop objects
	            // todo: should it depend on the browser?
				this.xScale = sx;
				this.yScale = sy;
				this.dxw = 0.0;             // no sub-pixel correction if no scaling
				this.dyw = 0.0;

				if (this.xScale > 1.0)
				    this.dxw = 1.0;         // 1 pixel correction if zoom > 1.0
			    else if (this.xScale > 0.0 && this.xScale < 1.0)
			        this.dxw = 1.0 / this.xScale;   // 1/scale pixel correction if zoom < 1.0
				if (this.yScale > 1.0)
				    this.dyw = 1.0;
				if (this.yScale > 0.0 && this.yScale < 1.0)
				    this.dyw = 1.0 / this.yScale;
			},

			clearBackground: function (x, y, w, h)
			{
				var context = this._context;
				context.clearRect(x, y, w, h);
			},

			renderSolidColor: function (x, y, w, h, color, inkEffect, inkEffectParam)
			{
				var context = this._context;

				this.setInkEffect(inkEffect, inkEffectParam);

				context.fillStyle = CServices.getColorString(color);
				context.fillRect(x, y, w, h);
			},

			renderSolidColorEllipse: function (x, y, w, h, color, inkEffect, inkEffectParam)
			{
				var context = this._context;

				this.setInkEffect(inkEffect, inkEffectParam);

				context.fillStyle = CServices.getColorString(color);

				CServices.createEllipse(context, x, y, w, h);
				context.fill();
			},

			renderGradient: function (x, y, w, h, color1, color2, vertical, inkEffect, inkEffectParam)
			{
				if (color1 == color2)
					return this.renderSolidColor(x, y, w, h, color1, inkEffect, inkEffectParam);

				var context = this._context;

				this.setInkEffect(inkEffect, inkEffectParam);

				this.configureGradient(x, y, w, h, vertical, color1, color2);

				context.fillRect(x, y, w, h);
			},

			renderGradientEllipse: function (x, y, w, h, color1, color2, vertical, inkEffect, inkEffectParam)
			{
				if (color1 == color2)
					return this.renderSolidColorEllipse(x, y, w, h, color1, inkEffect, inkEffectParam);

				var context = this._context;

				this.setInkEffect(inkEffect, inkEffectParam);

				this.configureGradient(x, y, w, h, vertical, color1, color2);

				CServices.createEllipse(context, x, y, w, h);
				this._context.fill();
			},

			renderImage: function (image, x, y, angle, scaleX, scaleY, inkEffect, inkEffectParam)
			{
				//        if(! (image instanceof CImage))
				//            throw new Error("renderImage: bad image type: " + (typeof image));
				var context = this._context;
				var xi = x - image.xSpot;
				var yi = y - image.ySpot;
				//        if (xi+image.width<0 || xi>context.width || yi+image.height<0 || yi>context.height)
				//        	return;

				this.setInkEffect(inkEffect, inkEffectParam);

				if (angle == 0 && scaleX == 1 && scaleY == 1)
				{
					if (image.mosaic == 0)
					{
						if (image.img != null)
						{
						    context.drawImage(image.img, xi, yi);
	                    }
					}
					else
					{
					    context.drawImage(image.app.imageBank.mosaics[image.mosaic],
							image.mosaicX, image.mosaicY,
							image.width, image.height,
	                        xi, yi,
							image.width, image.height);
	                }
				}
				else
				{
					context.save();

					context.translate(x, y);

					if (angle != 0)
						context.rotate(-angle * 0.0174532925);

					context.scale(Math.max(0.001, scaleX), Math.max(0.001, scaleY));
					context.translate(-image.xSpot, -image.ySpot);

					if (image.mosaic == 0)
					{
					    if (image.img != null && image.width != 0 && image.height != 0)
						{
							context.drawImage(image.img, 0, 0, image.width, image.height,
								0, 0, image.width, image.height);
						}
					}
					else
					{
						context.drawImage(image.app.imageBank.mosaics[image.mosaic],
							image.mosaicX, image.mosaicY,
							image.width, image.height, 0, 0,
							image.width, image.height);
					}

					context.restore();
				}
			},

		    // This function is used by backdrop objects only, to avoid seams between objects
	        // Limited to backdrop objects as it can affect rendering of small objects
			renderImageWithSubPixelCorrection: function (image, x, y, angle, scaleX, scaleY, inkEffect, inkEffectParam) {
			    //        if(! (image instanceof CImage))
			    //            throw new Error("renderImage: bad image type: " + (typeof image));
			    var context = this._context;
			    var xi = x - image.xSpot;
			    var yi = y - image.ySpot;
			    //        if (xi+image.width<0 || xi>context.width || yi+image.height<0 || yi>context.height)
			    //        	return;

			    this.setInkEffect(inkEffect, inkEffectParam);

			    if (angle == 0 && scaleX == 1 && scaleY == 1)
			    {
			        if (image.mosaic == 0)
			        {
			            if (image.img != null)
			            {
			                context.drawImage(image.img,
	                            0, 0,
	                            image.width, image.height,
	                            xi, yi,
	                            image.width + this.dxw, image.height + this.dyw);
			            }
			        }
			        else
			        {
			            context.drawImage(image.app.imageBank.mosaics[image.mosaic],
							image.mosaicX, image.mosaicY,
							image.width, image.height,
	                        xi, yi,
							image.width + this.dxw, image.height + this.dyw);
			        }
			    }
			    else
			    {
			        context.save();

			        context.translate(x, y);

			        if (angle != 0)
			            context.rotate(-angle * 0.0174532925);

			        context.scale(Math.max(0.001, scaleX), Math.max(0.001, scaleY));
			        context.translate(-image.xSpot, -image.ySpot);

			        if (image.mosaic == 0)
			        {
			            if (image.img != null)
			            {
			                context.drawImage(image.img, 0, 0, image.width, image.height,
								0, 0, image.width, image.height);
			            }
			        }
			        else
			        {
			            context.drawImage(image.app.imageBank.mosaics[image.mosaic],
							image.mosaicX, image.mosaicY,
							image.width, image.height, 0, 0,
							image.width, image.height);
			        }

			        context.restore();
			    }
			},

			renderSimpleImage: function (image, x, y, width, height, inkEffect, inkEffectParam)
			{
				this.setInkEffect(inkEffect, inkEffectParam);
				this._context.drawImage(image, x, y, width, height);

			    // Not sure if we should add sub-pixel margin to this routine as it's not used by backdrops
	            // Do it later if necessary only
				//this._context.drawImage(image, x, y, width + this.dxw, height + this.dyw);
			},

			renderPattern: function (image, x, y, w, h, inkEffect, inkEffectParam)
			{
				var context = this._context;

				this.setInkEffect(inkEffect, inkEffectParam);

				context.save();
				context.beginPath();
				context.moveTo(x, y);
				context.lineTo(x + w, y);
				context.lineTo(x + w, y + h);
				context.lineTo(x, y + h);
				context.lineTo(x, y);
				context.clip();

				var iSx = image.width;
				var iSy = image.height;
				var widthX = Math.floor(w / iSx) + 1;
				var heightY = Math.floor(h / iSy) + 1;
				var nX, nY;
				for (nX = 0; nX < widthX; nX++)
				{
					for (nY = 0; nY < heightY; nY++)
					{
						if (image.mosaic == 0)
						{
							if (image.img != null)
							{
	//							context.drawImage(image.img, x + nX * iSx, y + nY * iSy);

							    context.drawImage(image.img,
	                                0, 0,
	                                image.width, image.height,
	                                x + nX * iSx, y + nY * iSy,
	                                image.width + this.dxw, image.height + this.dyw);
							}
						}
						else
						{
						    context.drawImage(image.app.imageBank.mosaics[image.mosaic],
								image.mosaicX, image.mosaicY,
								image.width, image.height,
	                            x + nX * iSx, y + nY * iSy,
								image.width + this.dxw, image.height + this.dyw);
	                    }
					}
				}
				context.restore();
			},

			renderPatternEllipse: function (image, x, y, w, h, inkEffect, inkEffectParam)
			{
				if (!(image instanceof CImage))
					throw new Error("renderPatternEllipse: bad image type: " + (typeof image));

				var context = this._context;

				this.setInkEffect(inkEffect, inkEffectParam);

				if (image.mosaic == 0)
				{
					if (image.img != null)
					{
						context.fillStyle = context.createPattern(image.img, 'repeat');
					}
				}
				else
				{
					if (!image.pattern)
					{
						image.pattern = document.createElement("canvas");
						image.pattern.width = image.width;
						image.pattern.height = image.height;
						var context = image.pattern.getContext("2d");
						context.drawImage(image.app.imageBank.mosaics[image.mosaic],
							image.mosaicX, image.mosaicY,
							image.width, image.height, 0, 0,
							image.width, image.height);
					}
					context.fillStyle = context.createPattern(image.pattern, 'repeat');
				}
				CServices.createEllipse(context, x, y, w, h);
				this._context.fill();
			},

			renderLine: function (xA, yA, xB, yB, color, thickness, inkEffect, inkEffectParam)
			{
				var context = this._context;

				this.setInkEffect(inkEffect, inkEffectParam);

				context.strokeStyle = CServices.getColorString(color);
				context.lineCap = 'round';
				context.lineWidth = thickness;

				context.beginPath();
				context.moveTo(xA, yA);
				context.lineTo(xB, yB);
				context.closePath();

				context.stroke();
			},

			renderTriangle: 	function(x, y, b, h, color, orientation)
			{
				var context = this._context;
				var l_color = CServices.getColorString(color);
				
				if(orientation == 1)	//Vertical
				{
					context.beginPath();			
					context.moveTo(x,y);
					context.lineTo(x+b,y);
					context.lineTo(x+b/2,y-h);
					context.closePath();
					context.lineWidth = 1;
					context.strokeStyle = l_color;
					context.stroke();
					context.fillStyle = l_color;
					context.fill();

				}
				else 
				{
					context.beginPath();			
					context.moveTo(x,y);
					context.lineTo(x,y-b);
					context.lineTo(x-h,y-b/2);
					context.closePath();		
					context.lineWidth = 1;
					context.strokeStyle = l_color;
					context.stroke();
					context.fillStyle = l_color;
					context.fill();
				}
			},
			
			renderRect: function (x, y, w, h, color, thickness, inkEffect, inkEffectParam)
			{
				var context = this._context;

				this.setInkEffect(inkEffect, inkEffectParam);

				context.strokeStyle = CServices.getColorString(color);
				context.lineWidth = thickness;
				context.strokeRect(x, y, w, h);
			},

			renderEllipse: function (x, y, w, h, thickness, color, inkEffect, inkEffectParam)
			{
				var context = this._context;

				this.setInkEffect(inkEffect, inkEffectParam);
				context.lineWidth = thickness;
				context.strokeStyle = CServices.getColorString(color);

				CServices.createEllipse(context, x, y, w, h);
				this._context.stroke();
			},

			clip: function (x, y, w, h)
			{
				var context = this._context;
				context.save();
				context.beginPath();
				context.rect(x, y, w, h);
				context.clip();
			},

			unClip: function ()
			{
				this._context.restore();
			},

			pushClip: function ()
			{
				var context = this._context;

				var clip = Renderer.prototype.pushClip.apply(this, arguments);

				context.beginPath();
				context.rect(clip.x, clip.y, clip.w, clip.h);
				context.clip();
			},

			popClip: function ()
			{
				var context = this._context;

				Renderer.prototype.popClip.apply(this, arguments);

				if (this.clips.length > 0)
				{
					var clip = this.clips[this.clips.length - 1];

					context.beginPath();
					context.rect(clip.x, clip.y, clip.w, clip.h);
					context.clip();
				}
				else
				{
					context.resetClip();
				}
			},

			setInkEffect: function (effect, effectParam)
			{
				var context = this._context;
				if (typeof effect == 'undefined')
				{
					context.globalAlpha = 1.0;
					context.composite = 'source-over';
					return;
				}

				if (effect == this.oldEffect && effectParam == this.oldEffectParam)
					return;
				this.oldEffect = effect;
				this.oldEffectParam = effectParam;


				var effectMasked = effect & CRSpr.BOP_MASK;
				var smoothing = ((effect & CRSpr.BOP_SMOOTHING) != 0) | this.smoothing;
				if (smoothing != this.oldSmoothing)
				{
					this.oldSmoothing = smoothing;
					context["imageSmoothingEnabled"] = smoothing;
					context["webkitImageSmoothingEnabled"] = smoothing;
					context["mozImageSmoothingEnabled"] = smoothing;
					context["msImageSmoothingEnabled"] = smoothing;
	            }

				if ((effect & CRSpr.BOP_RGBAFILTER) != 0)
					context.globalAlpha = (((effectParam >>> 24) & 0xFF) / 255.0);
				else if (effectMasked == CRSpr.BOP_BLEND)
					context.globalAlpha = ((128 - effectParam) / 128.0);
				else
					context.globalAlpha = 1.0;

				switch (effectMasked)
				{
					case CRSpr.BOP_ADD:
						context.composite = "lighter";
						break;
					case CRSpr.BOP_XOR:
						context.composite = "xor";
						break;
					default:
						context.composite = "source-over";
						break;
				}
			},

			configureGradient: function (x, y, w, h, vertical, color1, color2)
			{
				var gradient = vertical ?
					this._context.createLinearGradient(x, y, x, y + h)
					: this._context.createLinearGradient(x, y, x + w, y);

				gradient.addColorStop(0, CServices.getColorString(color1));
				gradient.addColorStop(1, CServices.getColorString(color2));

				this._context.fillStyle = gradient;
			}
		});




	// CTRANSITIONDATA : données transitions
	//----------------------------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */

	CTransitionData.TRFLAG_COLOR = 0x0001;
	function CTransitionData()
	{
		this.dllName = "";
		this.transID = 0;
		this.transDuration = 0;
		this.transFlags = 0;
		this.transColor = 0;
		this.dataOffset = 0;
	}
	CTransitionData.prototype =
	{
		load: function (file)
		{
			var debut = file.getFilePointer();

			file.skipBytes(4);
			this.transID = file.readAInt();
			this.transDuration = file.readAInt();
			this.transFlags = file.readAInt();
			this.transColor = file.readAColor();

			var nameOffset = file.readAInt();
			var paramOffset = file.readAInt();
			file.seek(debut + nameOffset);
			this.dllName = file.readAString();
			this.dllName = this.dllName.substr(0, this.dllName.indexOf('.'));
			this.dataOffset = (debut + paramOffset);
		}
	}

	// CTRANSITIONS : interface avec la dll
	//----------------------------------------------------------------------------------
	function CTransition()
	{
	}
	CTransition.prototype =
	{
		getTrans: function (data)
		{
			return null;
		}
	}

	// CTRANS : interface avec un effet de transition
	//----------------------------------------------------------------------------------
	CTrans.LEFT_RIGHT = 0;
	CTrans.RIGHT_LEFT = 1;
	CTrans.TOP_BOTTOM = 2;
	CTrans.BOTTOM_TOP = 3;
	CTrans.CENTER_LEFTRIGHT = 0;
	CTrans.LEFTRIGHT_CENTER = 1;
	CTrans.CENTER_TOPBOTTOM = 2;
	CTrans.TOPBOTTOM_CENTER = 3;
	CTrans.TOP_LEFT = 0;
	CTrans.TOP_RIGHT = 1;
	CTrans.BOTTOM_LEFT = 2;
	CTrans.BOTTOM_RIGHT = 3;
	CTrans.CENTER = 4;
	CTrans.DIR_HORZ = 0;
	CTrans.DIR_VERT = 1;
	CTrans.TRFLAG_FADEIN = 0x0001;
	CTrans.TRFLAG_FADEOUT = 0x0002;
	function CTrans()
	{
		this.m_initTime = 0;
		this.m_currentTime = 0;
		this.m_endTime = 0;
		this.m_duration = 0;
		this.m_overflow = false;
		this.m_running = false;
		this.m_starting = false;
		this.source1 = null;
		this.source2 = null;
		this.dest = null;
		this.destContext = null;
	}
	CTrans.prototype =
	{
		start: function (data, display, debut, fin)
		{
			this.dest = display;
			this.destContext = this.dest.getContext("2d");
			this.source1 = debut;
			this.source2 = fin;

			var date = new Date();
			this.m_initTime = date.getTime();
			this.m_duration = data.transDuration;
			if (this.m_duration == 0)
				this.m_duration = 1;
			this.m_currentTime = this.m_initTime;
			this.m_endTime = this.m_initTime + this.m_duration;
			this.m_running = true;
			this.m_starting = true;
		},

		finish: function ()
		{
		},

		isCompleted: function ()
		{
			if (this.m_running)
			{
				var date = new Date();
				if (date.getTime() >= this.m_endTime)
					return true;
				return (date.getTime() >= this.m_endTime);
			}
			return true;
		},

		getDeltaTime: function ()
		{
			var date = new Date();
			this.m_currentTime = date.getTime();
			if (this.m_currentTime > this.m_endTime)
				this.m_currentTime = this.m_endTime;
			return (this.m_currentTime - this.m_initTime);
		},

		getTimePos: function ()
		{
			return this.m_currentTime - this.m_initTime;
		},

		setTimePos: function (msTimePos)
		{
			this.m_initTime = (this.m_currentTime - this.msTimePos);
			this.m_endTime = this.m_initTime + this.m_duration;
		},

		blit: function (source, xDest, yDest, xSrce, ySrce, width, height)
		{
			if (this.m_objectFadeOut)
				this.destContext.globalCompositeOperation = "source-atop";
			if (arguments.length == 1)
				this.destContext.drawImage(source, 0, 0);
			else if (width > 0 && height > 0)
				this.destContext.drawImage(source, xSrce, ySrce, width, height, xDest, yDest, width, height);
		},

		stretch: function (source, xDest, yDest, wDest, hDest, xSrce, ySrce, wSrce, hSrce)
		{
			if (this.m_objectFadeOut)
				this.destContext.globalCompositeOperation = "source-atop";
			if (wDest > 0 && hDest > 0 && wSrce > 0 && hSrce > 0)
				this.destContext.drawImage(source, xSrce, ySrce, wSrce, hSrce, xDest, yDest, wDest, hDest);
		},

		stepDraw: function (flag)
		{
		},

		end: function ()
		{
		},

		init: function (data, file, display, source, dest)
		{
		}

	}

	// CTRANSITIONMANAGER
	//----------------------------------------------------------------------------------
	function CTransitionManager(a)
	{
		this.app = a;
	}
	CTransitionManager.prototype =
	{
		startObjectFade:  function (hoPtr, bFadeOut)
		{
			var pData = hoPtr.hoCommon.ocFadeIn;
			if (bFadeOut)
			{
				pData = hoPtr.hoCommon.ocFadeOut;
			}
			var img = null;
			var context;
			if ((hoPtr.hoOEFlags & CObjectCommon.OEFLAG_ANIMATIONS) != 0)
			{
				var image = this.app.imageBank.getImageFromHandle(hoPtr.roc.rcImage);
				img = document.createElement("canvas");
				img.width = image.width;
				img.height = image.height;
				var context = img.getContext("2d");
				if (image.mosaic == 0)
					context.drawImage(image.img, 0, 0);
				else
				{
					context.drawImage(this.app.imageBank.mosaics[image.mosaic],
						image.mosaicX, image.mosaicY,
						image.width, image.height, 0, 0,
						image.width, image.height);
				}
			}
			else if (hoPtr.hoType >= 32)
			{
				img = document.createElement("canvas");
				img.width = hoPtr.hoImgWidth;
				img.height = hoPtr.hoImgHeight;
				var renderer = new StandardRendered(img);
				if (!hoPtr.getSurface(renderer))
					img = null;
			}
			if (img == null)
			{
				return null;
			}

			var width = img.width;
			var height = img.height;

			// L'image de fond
			var display = document.createElement("canvas");
			display.width = width;
			display.height = height;

			// Les images de debut et de fin
			var surface1 = document.createElement("canvas");
			surface1.width = width;
			surface1.height = height;
			var surface2 = document.createElement("canvas");
			surface2.width = width;
			surface2.height = height;
			var context;
			if (bFadeOut)
			{
				// Source = image
				context = surface1.getContext("2d");
				context.drawImage(img, 0, 0);
				context = display.getContext("2d");
				context.drawImage(img, 0, 0);
				if ((pData.transFlags & CTransitionData.TRFLAG_COLOR) != 0)
				{
					this.copyColorMask(surface2, img, pData.transColor);
				}
			}
			// Fade in
			else
			{
				// Destination = image
				context = surface2.getContext("2d");
				context.drawImage(img, 0, 0);
				if ((pData.transFlags & CTransitionData.TRFLAG_COLOR) != 0)
				{
					this.copyColorMask(surface1, img, pData.transColor);
				}
			}

			// Charge la transition
			var pTrans = this.createTransition(pData, display, surface1, surface2);
			if (pTrans != null)
			{
				var trFlags = 0;
				if ((hoPtr.hoFlags & CObject.HOF_FADEOUT) != 0)
				{
					pTrans.m_objectFadeOut = true;
					trFlags |= CTrans.TRFLAG_FADEOUT;
				}
				else
				{
					pTrans.m_objectFadeOut = false;
					trFlags |= CTrans.TRFLAG_FADEIN;
				}
				hoPtr.transitionImage = display;
				pTrans.stepDraw(trFlags);
			}
			return pTrans;
		},
		copyColorMask:    function (dest, source, couleur)
		{
			var context = dest.getContext("2d");
			context.drawImage(source, 0, 0);
			var width = source.width;
			var height = source.height;
			var pixels = context.getImageData(0, 0, width, height);
			var x, y, alpha;
			var color = couleur & 0x00FFFFFF;
			var r = (couleur & 0x00FF0000) >> 16;
			var g = (couleur & 0x0000FF00) >> 8;
			var b = couleur & 0x000000FF;
			for (y = 0; y < height; y++)
			{
				for (x = 0; x < width; x++)
				{
					if (pixels.data[(y * width + x) * 4 + 3] != 0)
					{
						pixels.data[(y * width + x) * 4] = r;
						pixels.data[(y * width + x) * 4 + 1] = g;
						pixels.data[(y * width + x) * 4 + 2] = b;
					}
				}
			}
			context.putImageData(pixels, 0, 0);
		},
		createTransition: function (pData, display, surfaceStart, surfaceEnd)
		{
			var dllName = pData.dllName;

			var dll = null;

			// STARTCUT
			if (dllName.toLowerCase() == "cctrans")
				dll = new CTransitionCCTrans();
			// ENDCUT

			if (dll != null)
			{
				var trans = dll.getTrans(pData);
				this.app.file.seek(pData.dataOffset);
				trans.m_objectFadeOut = false;
				trans.init(pData, this.app.file, display, surfaceStart, surfaceEnd);
				return trans;
			}
			return null;
		}
	}

	// CTransitioncctrans : point d'entree des transitions standard
	//----------------------------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 * 
	 * Permission is hereby granted to any person obtaining a legal copy 
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for 
	 * debugging, optimizing, or customizing applications created with 
	 * Clickteam Multimedia Fusion 2. 
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */

	CTransitionCCTrans.identifiers =
		[
			"BAND",
			"SE00",
			"SE10",
			"SE12",
			"DOOR",
			"SE03",
			"MOSA",
			"SE05",
			"SE06",
			"SCRL",
			"SE01",
			"SE07",
			"SE09",
			"SE13",
			"SE08",
			"SE02",
			"ZIGZ",
			"SE04",
			"ZOOM",
			"SE11",
			"FADE"
		];
	function CTransitionCCTrans()
	{
	}
	CTransitionCCTrans.prototype = CServices.extend(new CTransition(),
		{
			getTrans: function (data)
			{
				// Extrait l'identifier
				var id = data.transID;
				var idChars = "";
				idChars += String.fromCharCode(id & 0xFF);
				id >>= 8;
				idChars += String.fromCharCode(id & 0xFF);
				id >>= 8;
				idChars += String.fromCharCode(id & 0xFF);
				id >>= 8;
				idChars += String.fromCharCode(id & 0xFF);

				// Recherche dans la liste
				var n;
				for (n = 0; n < CTransitionCCTrans.identifiers.length; n++)
				{
					if (idChars == CTransitionCCTrans.identifiers[n])
					{
						break;
					}
				}

				// Cree la transition
				var trans = null;
				switch (n)
				{
					case 0:
						trans = new CTransBand();
						break;
					case 1:
						trans = new CTransAdvancedScrolling();
						break;
					case 2:
						trans = new CTransBack();
						break;
					case 3:
						trans = new CTransCell();
						break;
					case 4:
						trans = new CTransDoor();
						break;
					case 5:
						trans = new CTransLine();
						break;
					case 6:
						trans = new CTransMosaic();
						break;
					case 7:
						trans = new CTransOpen();
						break;
					case 8:
						trans = new CTransPush();
						break;
					case 9:
						trans = new CTransScroll();
						break;
					case 10:
						trans = new CTransSquare();
						break;
					case 11:
						trans = new CTransStretch();
						break;
					case 12:
						trans = new CTransStretch2();
						break;
					case 13:
						trans = new CTransTrame();
						break;
					case 14:
						trans = new CTransTurn();
						break;
					case 15:
						trans = new CTransTurn2();
						break;
					case 16:
						trans = new CTransZigZag();
						break;
					case 17:
						trans = new CTransZigZag2();
						break;
					case 18:
						trans = new CTransZoom();
						break;
					case 19:
						trans = new CTransZoom2();
						break;
					case 20:
						trans = new CTransFade();
						break;
				}
				return trans;
			}
		});

	// CTransAdvancedScrolling
	//----------------------------------------------------------------------------------
	function CTransAdvancedScrolling()
	{
		this.dwStyle = 0;
		this.m_source2Width = 0;
		this.m_source2Height = 0;
		this.m_style = 0;
	}
	CTransAdvancedScrolling.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.dwStyle = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time?
				if (this.m_starting)
				{
					this.m_starting = false;
					this.m_source2Width = this.source2.width;
					this.m_source2Height = this.source2.height;

					if (this.dwStyle != 8)
						this.m_style = this.dwStyle;
					else
						this.m_style = Math.floor(Math.random() * 8);
				}

				var elapsedTime = this.getDeltaTime();

				if ((elapsedTime / this.m_duration) > 1.0)
				{
					this.blit(this.source2);													// completed
				}
				else
				{
					var w, h;

					switch (this.m_style)
					{
						case 0:
							// Scrolling (To right, to left and to down)
							/////////////////////////////////////////////

							w = this.m_source2Width / 3 * elapsedTime / this.m_duration;
							h = this.m_source2Height;
							this.blit(this.source2, 0, 0, this.m_source2Width / 3 - w, 0, w, h);					// Left Side
							this.blit(this.source2, this.m_source2Width - w, 0, 2 * this.m_source2Width / 3, 0, w, h);	// Right Side

							w = this.m_source2Width / 3;
							h = this.m_source2Height * elapsedTime / this.m_duration;
							this.blit(this.source2, w, 0, w, this.m_source2Height - h, w, h);					// Top side
							break;
						case 1:
							// Scrolling (To right, to left and to up)
							/////////////////////////////////////////////

							w = this.m_source2Width / 3 * elapsedTime / this.m_duration;
							h = this.m_source2Height;
							this.blit(this.source2, 0, 0, this.m_source2Width / 3 - w, 0, w, h);					// Left Side
							this.blit(this.source2, this.m_source2Width - w, 0, 2 * this.m_source2Width / 3, 0, w, h);	// Right Side

							w = this.m_source2Width / 3;
							h = this.m_source2Height * elapsedTime / this.m_duration;
							this.blit(this.source2, w, this.m_source2Height - h, w, 0, w, h);					// Bottom side
							break;
						case 2:
							// To right, to left and to up
							////////////////////////////////

							w = this.m_source2Width / 3 * elapsedTime / this.m_duration;
							h = this.m_source2Height;
							this.blit(this.source2, 0, 0, this.m_source2Width / 3 - w, 0, w, h);					// Left Side
							this.blit(this.source2, this.m_source2Width - w, 0, 2 * this.m_source2Width / 3, 0, w, h);	// Right Side

							w = this.m_source2Width / 3;
							h = this.m_source2Height * elapsedTime / this.m_duration;
							this.blit(this.source2, w, 0, w, 0, w, h);									// Top side
							break;
						case 3:
							// To right, to left and to down
							/////////////////////////////////

							w = this.m_source2Width / 3 * elapsedTime / this.m_duration;
							h = this.m_source2Height;
							this.blit(this.source2, 0, 0, this.m_source2Width / 3 - w, 0, w, h);					// Left Side
							this.blit(this.source2, this.m_source2Width - w, 0, 2 * this.m_source2Width / 3, 0, w, h);	// Right Side

							w = this.m_source2Width / 3;
							h = this.m_source2Height * elapsedTime / this.m_duration;
							this.blit(this.source2, w, this.m_source2Height - h, w, this.m_source2Height - h, w, h);	// Bottom side
							break;
						case 4:
							// To right, to left, to down and to up
							////////////////////////////////////////

							w = this.m_source2Width / 3 * elapsedTime / this.m_duration;
							h = this.m_source2Height;
							this.blit(this.source2, 0, 0, this.m_source2Width / 3 - w, 0, w, h);					// Left Side
							this.blit(this.source2, this.m_source2Width - w, 0, 2 * this.m_source2Width / 3, 0, w, h);	// Right Side

							w = this.m_source2Width / 3;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							this.blit(this.source2, w, 0, w, this.m_source2Height / 2 - h, w, h);					// Top side
							this.blit(this.source2, w, this.m_source2Height - h, w, this.m_source2Height / 2, w, h);	// Bottom side
							break;
						case 5:
							// To right, to left, to down and to up
							////////////////////////////////////////

							w = this.m_source2Width / 3 * elapsedTime / this.m_duration;
							h = this.m_source2Height;
							this.blit(this.source2, 0, 0, this.m_source2Width / 3 - w, 0, w, h);					// Left Side
							this.blit(this.source2, this.m_source2Width - w, 0, 2 * this.m_source2Width / 3, 0, w, h);	// Right Side

							w = this.m_source2Width / 3;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							this.blit(this.source2, w, 0, w, 0, w, h);									// Top side
							this.blit(this.source2, w, this.m_source2Height - h, w, this.m_source2Height - h, w, h);	// Bottom side
							break;
						case 6:
							// Scrolling (3 bands)
							///////////////////////

							w = this.m_source2Width / 3;
							h = this.m_source2Height * elapsedTime / this.m_duration;

							this.blit(this.source2, 0, this.m_source2Height - h, 0, 0, w, h);					// Band 1
							this.blit(this.source2, w, 0, w, this.m_source2Height - h, w, h);					// Band 2
							this.blit(this.source2, w * 2, this.m_source2Height - h, w * 2, 0, w, h);				// Band 3
							break;
						case 7:
							// Scrolling (7 bands)
							///////////////////////

							w = this.m_source2Width / 7;
							h = this.m_source2Height * elapsedTime / this.m_duration;

							this.blit(this.source2, 0, this.m_source2Height - h, 0, 0, w, h);					// Band 1
							this.blit(this.source2, w, 0, w, this.m_source2Height - h, w, h);					// Band 2
							this.blit(this.source2, w * 2, this.m_source2Height - h, w * 2, 0, w, h);				// Band 3
							this.blit(this.source2, w * 3, 0, w * 3, this.m_source2Height - h, w, h);				// Band 4
							this.blit(this.source2, w * 4, this.m_source2Height - h, w * 4, 0, w, h);				// Band 5
							this.blit(this.source2, w * 5, 0, w * 5, this.m_source2Height - h, w, h);				// Band 6
							this.blit(this.source2, w * 6, this.m_source2Height - h, w * 6, 0, w * 2, h);				// Band 7
							break;
						default:
							this.blit(this.source2);
							break;
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransBack()
	{
		this.dwStyle = 0;
		this.m_source2Width = 0;
		this.m_source2Height = 0;
	}
	CTransBack.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.dwStyle = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time?
				if (this.m_starting)
				{
					this.m_starting = false;
					this.m_source2Width = this.source2.width;
					this.m_source2Height = this.source2.height;
				}

				var elapsedTime = this.getDeltaTime();

				if ((elapsedTime / this.m_duration) > 1.0)
				{
					this.blit(this.source2);												// completed
				}
				else
				{
					var w, h;
					this.blit(this.source2);

					switch (this.dwStyle)
					{
						// OPEN
						case 0:
							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							w = this.m_source2Width / 2 - w;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 - h;
							this.stretch(this.source1, 0, 0, w, h, 0, 0, this.m_source2Width / 2, this.m_source2Height / 2);

							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 - h;
							this.stretch(this.source1, this.m_source2Width / 2 + w, 0, this.m_source2Width / 2 - w, h, this.m_source2Width / 2, 0, this.m_source2Width / 2, this.m_source2Height / 2);

							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							w = this.m_source2Width / 2 - w;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							this.stretch(this.source1, 0, this.m_source2Height / 2 + h, w, this.m_source2Height / 2 - h, 0, this.m_source2Height / 2, this.m_source2Width / 2, this.m_source2Height / 2);

							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							this.stretch(this.source1, this.m_source2Width / 2 + w, this.m_source2Height / 2 + h, this.m_source2Width / 2 - w, this.m_source2Height / 2 - h, this.m_source2Width / 2, this.m_source2Height / 2, this.m_source2Width / 2, this.m_source2Height / 2);
							break;
						// SLIDE
						case 1:
							w = this.m_source2Width * elapsedTime / this.m_duration;
							w = this.m_source2Width - w;
							h = this.m_source2Height * elapsedTime / this.m_duration;
							h = this.m_source2Height - h;
							this.blit(this.source1, 0, 0, this.m_source2Width - w, this.m_source2Height - h, w, h);
							break;
						// SLIDE
						case 2:
							w = this.m_source2Width * elapsedTime / this.m_duration;
							h = this.m_source2Height * elapsedTime / this.m_duration;
							h = this.m_source2Height - h;
							this.blit(this.source1, w, 0, 0, this.m_source2Height - h, this.m_source2Width - w, h);
							break;
						// SLIDE
						case 3:
							w = this.m_source2Width * elapsedTime / this.m_duration;
							w = this.m_source2Width - w;
							h = this.m_source2Height * elapsedTime / this.m_duration;
							this.blit(this.source1, 0, h, this.m_source2Width - w, 0, w, this.m_source2Height - h);
							break;
						// SLIDE
						case 4:
							w = this.m_source2Width * elapsedTime / this.m_duration;
							h = this.m_source2Height * elapsedTime / this.m_duration;
							this.blit(this.source1, w, h, 0, 0, this.m_source2Width - w, this.m_source2Height - h);
							break;
						// OPEN (SCROLLING)
						case 5:
							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							w = this.m_source2Width / 2 - w;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 - h;
							this.blit(this.source1, w - this.m_source2Width / 2, h - this.m_source2Height / 2, 0, 0, this.m_source2Width / 2, this.m_source2Height / 2);

							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 - h;
							this.blit(this.source1, this.m_source2Width / 2 + w, h - this.m_source2Height / 2, this.m_source2Width / 2, 0, this.m_source2Width / 2, this.m_source2Height / 2);

							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							w = this.m_source2Width / 2 - w;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							this.blit(this.source1, w - this.m_source2Width / 2, this.m_source2Height / 2 + h, 0, this.m_source2Height / 2, this.m_source2Width / 2, this.m_source2Height / 2);

							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							this.blit(this.source1, this.m_source2Width / 2 + w, this.m_source2Height / 2 + h, this.m_source2Width / 2, this.m_source2Height / 2, this.m_source2Width / 2, this.m_source2Height / 2);
							break;
						// SLIDE
						case 6:
							w = this.m_source2Width;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 - h;
							this.blit(this.source1, 0, h - this.m_source2Height / 2, 0, 0, this.m_source2Width, this.m_source2Height / 2);
							this.blit(this.source1, 0, this.m_source2Height - h, 0, this.m_source2Height / 2, this.m_source2Width, this.m_source2Height / 2);
							break;
						// SLIDE
						case 7:
							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							w = this.m_source2Width / 2 - w;
							h = this.m_source2Height;
							this.blit(this.source1, w - this.m_source2Width / 2, 0, 0, 0, this.m_source2Width / 2, this.m_source2Height);
							this.blit(this.source1, this.m_source2Width - w, 0, this.m_source2Width / 2, 0, this.m_source2Width / 2, this.m_source2Height);
							break;
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});

	function CTransBand()
	{
		this.bpNbBands = 0;
		this.bpDirection = 0;
		this.m_wbande = 0;
		this.m_rw = 0;
		this.m_prc = null;
	}
	CTransBand.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.bpNbBands = file.readAShort();
				this.bpDirection = file.readAShort();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				var sw = this.source1.width;
				var sh = this.source1.height;
				var n;

				// 1st time? create surface
				if (this.m_starting)
				{
					// Security...
					if (this.bpNbBands == 0)
						this.bpNbBands = 1;

					switch (this.bpDirection)
					{
						case CTrans.LEFT_RIGHT:
						case CTrans.RIGHT_LEFT:
							this.m_wbande = (sw + this.bpNbBands - 1) / this.bpNbBands;
							if (this.m_wbande == 0)
							{
								this.m_wbande = 1;
								this.bpNbBands = sw;
							}
							break;
						default:
							this.m_wbande = (sh + this.bpNbBands - 1) / this.bpNbBands;
							if (this.m_wbande == 0)
							{
								this.m_wbande = 1;
								this.bpNbBands = sh;
							}
							break;
					}
					this.m_rw = 0;
					this.m_starting = false;
				}

				// Attention, passer la transparence en parametre...
				if (this.bpNbBands <= 0 || this.m_wbande <= 0 || this.m_duration == 0)
					this.blit(this.source2);	// termine
				else
				{
					var rw = this.m_wbande * this.getDeltaTime() / this.m_duration;
					if (rw > this.m_rw)
					{
						var x = 0, y = 0, w = 0, h = 0;
						for (n = 0; n < this.bpNbBands; n++)
						{
							switch (this.bpDirection)
							{
								case CTrans.LEFT_RIGHT:
									x = this.m_rw + n * this.m_wbande;
									y = 0;
									w = rw - this.m_rw;
									h = sh;
									break;
								case CTrans.RIGHT_LEFT:
									x = sw - (this.m_rw + n * this.m_wbande) - (rw - this.m_rw);
									y = 0;
									w = rw - this.m_rw;
									h = sh;
									break;
								case CTrans.TOP_BOTTOM:
									x = 0;
									y = this.m_rw + n * this.m_wbande;
									w = sw;
									h = rw - this.m_rw;
									break;
								case CTrans.BOTTOM_TOP:
									x = 0;
									y = sh - (this.m_rw + n * this.m_wbande) - (rw - this.m_rw);
									w = sw;
									h = rw - this.m_rw;
									break;
							}
							this.blit(this.source2, x, y, x, y, w, h);
						}
					}
					this.m_rw = rw;
				}
				return this.m_prc;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransCell()
	{
		this.dwPos = 0;
		this.dwPos2 = 0;
		this.m_source2Width = 0;
		this.m_source2Height = 0;
	}
	CTransCell.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.dwPos = file.readAInt();
				this.dwPos2 = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				if (this.m_starting)
				{
					this.m_starting = false;
					this.m_source2Width = this.source2.width;
					this.m_source2Height = this.source2.height;
				}

				var elapsedTime = this.getDeltaTime();

				if ((elapsedTime / this.m_duration) > 1.0)
				{
					this.blit(this.source2);					// completed
				}
				else
				{
					var x, y, w, h, i, j, w2, h2;
					var width, height;

					width = this.m_source2Width / this.dwPos;
					height = this.m_source2Height / this.dwPos2;
					w = this.m_source2Width / this.dwPos;
					h = this.m_source2Height / this.dwPos2;

					for (i = 0; i < this.dwPos; i++)
					{
						for (j = 0; j < this.dwPos2; j++)
						{
							x = ( i * width );
							y = ( j * height );

							w2 = w * elapsedTime / this.m_duration;
							h2 = h * elapsedTime / this.m_duration;
							this.stretch(this.source2, x + (w - w2) / 2, y + (h - h2) / 2, w2, h2, x + (w - w2) / 2, y + (h - h2) / 2, w2, h2);
						}
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});

	function CTransDoor()
	{
		this.m_direction = 0;
		this.m_wbande = 0;
		this.m_rw = 0;
	}
	CTransDoor.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.m_direction = file.readAShort();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time? create surface
				if (this.m_starting)
				{
					switch (this.m_direction)
					{
						case CTrans.CENTER_LEFTRIGHT:
						case CTrans.LEFTRIGHT_CENTER:
							this.m_wbande = this.source1.width / 2;
							break;
						default:
							this.m_wbande = this.source1.height / 2;
							break;
					}
					this.m_rw = 0;
					this.m_starting = false;
				}

				// Attention, passer la transparence en parametre...
				if (this.m_wbande == 0)
					this.blit(this.source2);	// termine
				else
				{
					var x = 0, y = 0, w = 0, h = 0;
					var rw = this.m_wbande * this.getDeltaTime() / this.m_duration;
					if (rw > this.m_rw)
					{
						// 1st band
						switch (this.m_direction)
						{
							case CTrans.CENTER_LEFTRIGHT:
								x = this.source1.width / 2 - rw;
								y = 0;
								w = rw - this.m_rw;
								h = this.source2.height;
								break;
							case CTrans.LEFTRIGHT_CENTER:
								x = this.m_rw;
								y = 0;
								w = rw - this.m_rw;
								h = this.source2.height;
								break;
							case CTrans.CENTER_TOPBOTTOM:
								x = 0;
								y = this.source1.height / 2 - rw;
								w = this.source2.width;
								h = rw - this.m_rw;
								break;
							case CTrans.TOPBOTTOM_CENTER:
								x = 0;
								y = this.m_rw;
								w = this.source2.width;
								h = rw - this.m_rw;
								break;
						}
						this.blit(this.source2, x, y, x, y, w, h);

						// 2nd band
						switch (this.m_direction)
						{
							case CTrans.CENTER_LEFTRIGHT:
								x = this.source1.width / 2 + this.m_rw;
								break;
							case CTrans.LEFTRIGHT_CENTER:
								x = this.source1.width - rw;
								break;
							case CTrans.CENTER_TOPBOTTOM:
								y = this.source1.height / 2 + this.m_rw;
								break;
							case CTrans.TOPBOTTOM_CENTER:
								y = this.source1.height - rw;
								break;
						}
						this.blit(this.source2, x, y, x, y, w, h);
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransFade()
	{
	}
	CTransFade.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time? create surface
				if (this.m_starting)
				{
					this.m_starting = false;
				}

				var fadeCoef;

				// Fade in
				if ((flag & CTrans.TRFLAG_FADEIN) != 0)
				{
					this.destContext.globalAlpha = 1.0;
					this.blit(this.source1);
					fadeCoef = this.getDeltaTime() / this.m_duration;
					this.destContext.globalAlpha = fadeCoef;
					this.blit(this.source2);
				}
				// Fade out
				else
				{
					this.destContext.globalAlpha = 1.0;
					this.blit(this.source1);
					fadeCoef = this.getDeltaTime() / this.m_duration;
					this.destContext.globalAlpha = fadeCoef;
					this.blit(this.source2);
				}
				return null;
			},
			end:      function ()
			{
				this.destContext.globalAlpha = 1.0;
				this.finish();
			}
		});


	function CTransLine()
	{
		this.dwPos = 0;
		this.dwStyle = 0;
		this.dwScrolling = 0;
		this.m_source2Width = 0;
		this.m_source2Height = 0;
	}
	CTransLine.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.dwPos = file.readAInt();
				this.dwStyle = file.readAInt();
				this.dwScrolling = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time?
				if (this.m_starting)
				{
					this.m_starting = false;
					this.m_source2Width = this.source2.width;
					this.m_source2Height = this.source2.height;
				}

				var elapsedTime = this.getDeltaTime();

				if ((elapsedTime / this.m_duration) > 1.0)
				{
					this.blit(this.source2);      // completed
				}
				else
				{
					var x, y, w, h;
					var i = 0;		// Loop
					var j = 0;		// Loop
					var linesize = 0;

					// Horizontal
					if (this.dwStyle == 0)
					{
						linesize = this.m_source2Height / this.dwPos;
						for (i = 0; i < this.dwPos; i++)
						{
							if (j == 0)
							{
								x = 0;
								y = (i * linesize);
								w = this.m_source2Width * elapsedTime / this.m_duration;

								// Last
								if (i == this.dwPos - 1)
									h = this.m_source2Height;
								else
									h = (linesize + 1.0);

								// Without scrolling or with scrolling
								if (this.dwScrolling == 0)
									this.blit(this.source2, x, y, x, y, w, h);
								else
									this.blit(this.source2, x, y, this.m_source2Width - w, y, w, h);

								j = 1;
							}
							else
							{
								y = (i * linesize);//h;
								w = this.m_source2Width * elapsedTime / this.m_duration;
								x = this.m_source2Width - w;

								// Last
								if (i == this.dwPos - 1)
									h = this.m_source2Height;
								else
									h = (linesize + 1.0);

								// Without scrolling or with scrolling
								if (this.dwScrolling == 0)
									this.blit(this.source2, x, y, x, y, w, h);
								else
									this.blit(this.source2, x, y, 0, y, w, h);

								j = 0;
							}
						}
					}
					// Vertical
					else
					{
						linesize = this.m_source2Width / this.dwPos;
						for (i = 0; i < this.dwPos; i++)
						{
							if (j == 0)
							{
								x = (i * linesize);
								y = 0;
								h = this.m_source2Height * elapsedTime / this.m_duration;

								// Last
								if (i == this.dwPos - 1)
									w = this.m_source2Width;
								else
									w = (linesize + 1);

								// Without scrolling or with scrolling
								if (this.dwScrolling == 0)
									this.blit(this.source2, x, y, x, y, w, h);
								else
									this.blit(this.source2, x, y, x, this.m_source2Height - h, w, h);

								j = 1;
							}
							else
							{
								x = (i * linesize);
								h = this.m_source2Height * elapsedTime / this.m_duration;
								y = this.m_source2Height - h;

								// Last
								if (i == this.dwPos - 1)
									w = this.m_source2Width;
								else
									w = (linesize + 1);

								// Without scrolling or with scrolling
								if (this.dwScrolling == 0)
									this.blit(this.source2, x, y, x, y, w, h);
								else
									this.blit(this.source2, x, y, x, 0, w, h);
								j = 0;
							}
						}
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransMosaic()
	{
		// Parameters
		this.m_spotPercent;

		// Runtime
		this.m_spotSize = 0;
		this.m_nbBlockPerLine = 0;
		this.m_nbBlockPerCol = 0;
		this.m_nbBlocks = 0;
		this.m_lastNbBlocks = 0;
		this.m_bitbuf = null;
	}
	CTransMosaic.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.m_spotPercent = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time? create surface
				if (this.m_starting)
				{
					var sw = this.source1.width;
					var sh = this.source1.height;

					// Spot size: voir si ca rend bien
					this.m_spotSize = Math.floor(((sw * this.m_spotPercent / 100) + (sh * this.m_spotPercent / 100)) / 2);
					if (this.m_spotSize == 0)
						this.m_spotSize = 1;

					// Calcul buffer bits
					var bufSize;
					this.m_nbBlockPerLine = ((sw + this.m_spotSize - 1) / this.m_spotSize);
					this.m_nbBlockPerCol = ((sh + this.m_spotSize - 1) / this.m_spotSize);
					this.m_nbBlocks = this.m_nbBlockPerLine * this.m_nbBlockPerCol;
					bufSize = Math.floor((this.m_nbBlocks + 7) / 8 + 2);	// 2 = security
					this.m_lastNbBlocks = 0;
					this.m_bitbuf = new Array(bufSize);
					var n;
					for (n = 0; n < bufSize; n++)
						this.m_bitbuf[n] = 0;
					this.m_starting = false;
				}

				if (this.m_bitbuf == null || this.m_nbBlockPerLine < 2 || this.m_nbBlockPerCol < 2 || this.m_duration == 0)
					this.blit(this.source2);	// termine
				else
				{
					var NB_TRIES = 1;
					var i;
					var l, xb = 0, yb = 0;
					var nbBlocks = Math.floor(this.m_nbBlocks * this.getDeltaTime() / this.m_duration);
					var nbCurrentBlocks = nbBlocks - this.m_lastNbBlocks;
					if (nbCurrentBlocks != 0)
					{
						this.m_lastNbBlocks = nbBlocks;
						for (l = 0; l < nbCurrentBlocks; l++)
						{
							// Get random block coordinates
							for (i = 0; i < NB_TRIES; i++)
							{
								xb = Math.floor(this.m_nbBlockPerLine * Math.random());
								yb = Math.floor(this.m_nbBlockPerCol * Math.random());

								var nb, off;
								var mask;

								nb = yb * this.m_nbBlockPerLine + xb;
								off = Math.floor(nb / 8);
								mask = (1 << (nb & 7));
								if ((this.m_bitbuf[off] & mask) == 0)
								{
									this.m_bitbuf[off] |= mask;
									break;
								}

								var pBuf = off;
								var nbb = (this.m_nbBlocks + 7) / 8;
								var b;
								var r = false;
								for (b = off; b < nbb; b++, pBuf++)
								{
									if (this.m_bitbuf[pBuf] != -1)
									{
										yb = Math.floor((b * 8) / this.m_nbBlockPerLine);
										xb = Math.floor((b * 8) % this.m_nbBlockPerLine);
										for (mask = 1; mask != 0; mask <<= 1)
										{
											if ((this.m_bitbuf[pBuf] & mask) == 0)
											{
												this.m_bitbuf[pBuf] |= mask;
												r = true;
												break;
											}
											if (++xb >= this.m_nbBlockPerLine)
											{
												xb = 0;
												if (++yb >= this.m_nbBlockPerCol)
													break;
											}
										}
										if (r)
											break;
									}
								}
								if (r)
									break;

								pBuf = 0;
								for (b = 0; b < off; b++, pBuf++)
								{
									if (this.m_bitbuf[pBuf] != 255)
									{
										yb = Math.floor((b * 8) / m_nbBlockPerLine);
										xb = Math.floor((b * 8) % m_nbBlockPerLine);
										for (mask = 1; mask != 0; mask <<= 1)
										{
											if ((this.m_bitbuf[pBuf] & mask) == 0)
											{
												this.m_bitbuf[pBuf] |= mask;
												r = true;
												break;
											}
											if (++xb >= this.m_nbBlockPerLine)
											{
												xb = 0;
												if (++yb >= this.m_nbBlockPerCol)
													break;
											}
										}
										if (r)
											break;
									}
									if (r)
										break;

									r = false;
								}
							}
							if (i < NB_TRIES)
							{
								this.blit(this.source2, Math.floor(xb * this.m_spotSize), Math.floor(yb * this.m_spotSize), Math.floor(xb * this.m_spotSize), Math.floor(yb * this.m_spotSize), this.m_spotSize, this.m_spotSize);
							}
						}
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransOpen()
	{
		this.dwStyle = 0;
		this.m_source2Width = 0;
		this.m_source2Height = 0;
	}
	CTransOpen.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.dwStyle = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time?
				if (this.m_starting)
				{
					this.m_starting = false;
					this.m_source2Width = this.source2.width;
					this.m_source2Height = this.source2.height;
				}

				var elapsedTime = this.getDeltaTime();

				var pourcentage = elapsedTime / this.m_duration;

				if (pourcentage > 1.0)
				{
					this.blit(this.source2);					// completed
				}
				else
				{
					var x, y, w, h;
					if (pourcentage < 0.25)
					{
						w = this.m_source2Width * 2 * elapsedTime / this.m_duration;
						w *= 2;
						h = this.m_source2Height / 7;
						x = this.m_source2Width / 2 - w / 2;
						y = this.m_source2Height / 2 - h / 2;
						this.blit(this.source2, x, y, x, y, w, h);

						w = this.m_source2Width / 7;
						h = this.m_source2Height * 2 * elapsedTime / this.m_duration;
						h *= 2;
						x = this.m_source2Width / 2 - w / 2;
						y = this.m_source2Height / 2 - h / 2;
						this.blit(this.source2, x, y, x, y, w, h);
					}
					else
					{
						x = this.m_source2Width / 2;
						w = this.m_source2Width * elapsedTime / this.m_duration - x;
						h = this.m_source2Height / 2;
						y = 0;
						this.blit(this.source2, x, y, x, y, w, h);

						y = this.m_source2Height / 2;
						h = this.m_source2Height * elapsedTime / this.m_duration - y;
						w = this.m_source2Width / 2;
						x = w;
						this.blit(this.source2, x, y, x, y, w, h);

						w = this.m_source2Width * elapsedTime / this.m_duration - this.m_source2Width / 2;
						x = this.m_source2Width / 2 - w;
						h = this.m_source2Height / 2;
						y = h;
						this.blit(this.source2, x, y, x, y, w, h);

						h = this.m_source2Height * elapsedTime / this.m_duration - this.m_source2Height / 2;
						y = this.m_source2Height / 2 - h;
						w = this.m_source2Width / 2;
						x = 0;
						this.blit(this.source2, x, y, x, y, w, h);
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransPush()
	{
		this.dwStyle = 0;
		this.m_source2Width = 0;
		this.m_source2Height = 0;
		this.m_refresh = 0;
	}
	CTransPush.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.dwStyle = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time?
				if (this.m_starting)
				{
					this.m_starting = false;
					this.m_source2Width = this.source2.width;
					this.m_source2Height = this.source2.height;
					this.m_refresh = false;
				}

				var elapsedTime = this.getDeltaTime();

				var pourcentage = elapsedTime / this.m_duration;
				if (pourcentage > 1.0)
				{
					this.blit(this.source2);
				}
				else
				{
					var x, y, w, h;

					// First Scrolling
					if (pourcentage <= 0.5)
					{
						switch (this.dwStyle)
						{
							case 0:
								w = this.m_source2Width * elapsedTime / this.m_duration * 2;
								h = this.m_source2Height / 2;
								x = this.m_source2Width - w;
								y = this.m_source2Height / 2;
								this.blit(this.source2, 0, 0, x, y, w, h);
								break;
							case 1:
								w = this.m_source2Width * elapsedTime / this.m_duration * 2;
								h = this.m_source2Height / 2;
								x = this.m_source2Width - w;
								y = this.m_source2Height / 2;
								this.blit(this.source2, x, 0, 0, y, w, h);
								break;
							case 2:
								w = this.m_source2Width * elapsedTime / this.m_duration * 2;
								h = this.m_source2Height / 2;
								x = this.m_source2Width - w;
								y = this.m_source2Height / 2;
								this.blit(this.source2, 0, y, x, 0, w, h);
								break;
							case 3:
								w = this.m_source2Width * elapsedTime / this.m_duration * 2;
								h = this.m_source2Height / 2;
								x = this.m_source2Width - w;
								y = this.m_source2Height / 2;
								this.blit(this.source2, x, y, 0, 0, w, h);
								break;
						}
					}

					// Second Scrolling
					if (pourcentage > 0.5)
					{
						if (this.m_refresh == false)
						{
							if (this.dwStyle <= 1)
								this.blit(this.source2, 0, 0, 0, this.m_source2Height / 2, this.m_source2Width, this.m_source2Height / 2);
							else
								this.blit(this.source2, 0, this.m_source2Height / 2, 0, 0, this.m_source2Width, this.m_source2Height / 2);
							this.m_refresh = true;
						}

						pourcentage = elapsedTime - this.m_duration / 2.0;
						pourcentage /= this.m_duration / 2.0;
						pourcentage *= 1000;
						h = this.m_source2Height / 2 * pourcentage / 1000; // Math.floor()?

						switch (this.dwStyle)
						{
							case 0:
							case 1:
								this.stretch(this.source2, 0, h, this.m_source2Width, this.m_source2Height / 2, 0, this.m_source2Height / 2, this.m_source2Width, this.m_source2Height / 2);
								this.stretch(this.source2, 0, 0, this.m_source2Width, h, 0, this.m_source2Height / 2 - h, this.m_source2Width, h);
								break;
							case 2:
							case 3:
								this.stretch(this.source2, 0, this.m_source2Height / 2 - h, this.m_source2Width, this.m_source2Height / 2, 0, 0, this.m_source2Width, this.m_source2Height / 2);
								this.stretch(this.source2, 0, this.m_source2Height - h, this.m_source2Width, h, 0, this.m_source2Height / 2, this.m_source2Width, h);
								break;
						}
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransScroll()
	{
		this.m_direction;
		this.m_wbande;
		this.m_rw;
	}
	CTransScroll.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.m_direction = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				var sw = this.source1.width;
				var sh = this.source1.height;

				// 1st time? create surface
				if (this.m_starting)
				{
					switch (this.m_direction)
					{
						case CTrans.LEFT_RIGHT:
						case CTrans.RIGHT_LEFT:
							this.m_wbande = sw;
							break;
						default:
							this.m_wbande = sh;
							break;
					}
					this.m_rw = 0;
					this.m_starting = false;
				}

				if (this.m_duration == 0)
					this.blit(this.source2);  // termine
				else
				{
					var rw = this.m_wbande * this.getDeltaTime() / this.m_duration;
					if (rw > this.m_rw)
					{
						var x = 0, y = 0;

						switch (this.m_direction)
						{
							case CTrans.LEFT_RIGHT:
								x = rw - sw;
								y = 0;
								break;
							case CTrans.RIGHT_LEFT:
								x = sw - rw;
								y = 0;
								break;
							case CTrans.TOP_BOTTOM:
								x = 0;
								y = rw - sh;
								break;
							case CTrans.BOTTOM_TOP:
								x = 0;
								y = sh - rw;
								break;
						}
						this.blit(this.source2, x, y, 0, 0, sw, sh);
						this.m_rw = rw;
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransSquare()
	{
		this.dwStyle = 0;
		this.dwPos = 0;
		this.dwStretch = 0;
		this.m_source2Width = 0;
		this.m_source2Height = 0;
	}
	CTransSquare.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.dwStyle = file.readAInt();
				this.dwPos = file.readAInt();
				this.dwStretch = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time?
				if (this.m_starting)
				{
					this.m_starting = false;
					this.m_source2Width = this.source2.width;
					this.m_source2Height = this.source2.height;
				}

				var elapsedTime = this.getDeltaTime();

				if (elapsedTime / this.m_duration > 1.0)
				{
					this.blit(this.source2);													// completed
				}
				else
				{
					var x, y, w, h;
					var width, height;

					// Inside Square
					/////////////////

					width = this.m_source2Width * this.dwPos / 100;
					height = this.m_source2Height * this.dwPos / 100;

					w = width * elapsedTime / this.m_duration;
					h = height * elapsedTime / this.m_duration;
					x = this.m_source2Width / 2 - w / 2;
					y = this.m_source2Height / 2 - h / 2;

					// No Stretch
					if (this.dwStretch == 0)
						this.blit(this.source2, x, y, x, y, w, h);
					else
						this.stretch(this.source2, x, y, w, h, this.m_source2Width / 2 - width / 2, this.m_source2Height / 2 - height / 2, width, height);

					// Outside Square
					//////////////////

					var pos = 100 - this.dwPos;
					width = this.m_source2Width * pos / 100;
					height = this.m_source2Height * pos / 100;

					w = width / 2 * elapsedTime / this.m_duration;
					h = height / 2 * elapsedTime / this.m_duration;
					this.blit(this.source2, 0, 0, 0, 0, this.m_source2Width, h);									// Up To Down
					this.blit(this.source2, 0, 0, 0, 0, w, this.m_source2Height);									// Left to Right
					this.blit(this.source2, 0, this.m_source2Height - h, 0, this.m_source2Height - h, this.m_source2Width, h);	// Down To Up
					this.blit(this.source2, this.m_source2Width - w, 0, this.m_source2Width - w, 0, w, this.m_source2Height);	// Right To Left
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransStretch()
	{
		this.dwStyle = 0;
		this.m_source2Width = 0;
		this.m_source2Height = 0;
	}
	CTransStretch.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.dwStyle = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time?
				if (this.m_starting)
				{
					this.m_starting = false;
					this.m_source2Width = this.source2.width;
					this.m_source2Height = this.source2.height;
				}

				var elapsedTime = this.getDeltaTime();

				if ((elapsedTime / this.m_duration) > 1.0)
				{
					this.blit(this.source2);					// completed
				}
				else
				{
					var w, h;

					switch (this.dwStyle)
					{
						// Top Left
						case 0:
							w = this.m_source2Width * elapsedTime / this.m_duration;
							h = this.m_source2Height * elapsedTime / this.m_duration;
							this.stretch(this.source2, 0, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							break;
						// Top Right
						case 1:
							w = this.m_source2Width * elapsedTime / this.m_duration;
							h = this.m_source2Height * elapsedTime / this.m_duration;
							this.stretch(this.source2, this.m_source2Width - w, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							break;
						// Bottom Left
						case 2:
							w = this.m_source2Width * elapsedTime / this.m_duration;
							h = this.m_source2Height * elapsedTime / this.m_duration;
							this.stretch(this.source2, 0, this.m_source2Height - h, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							break;
						// Bottom Right
						case 3:
							w = this.m_source2Width * elapsedTime / this.m_duration;
							h = this.m_source2Height * elapsedTime / this.m_duration;
							this.stretch(this.source2, this.m_source2Width - w, this.m_source2Height - h, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							break;
						// 4 corners
						case 4:
							// Top Left
							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							if (h < 5)
								h = 5;
							this.stretch(this.source2, 0, 0, w, h, 0, 0, this.source1.width / 2, this.source1.height / 2);
							// Top Right
							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							if (h < 5)
								h = 5;
							this.stretch(this.source2, this.m_source2Width - w, 0, w, h, this.m_source2Width / 2, 0, this.m_source2Width / 2, this.m_source2Height / 2);
							// Bottom Left
							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							this.stretch(this.source2, 0, this.m_source2Height - h, w, h, 0, this.m_source2Height / 2, this.m_source2Width / 2, this.m_source2Height / 2);
							// Bottom Right
							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							this.stretch(this.source2, this.m_source2Width - w, this.m_source2Height - h, w, h, this.m_source2Width / 2, this.m_source2Height / 2, this.m_source2Width / 2, this.m_source2Height / 2);
							break;
						// Center
						case 5:
							// Top Left
							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							if (h < 5)
								h = 5;
							this.stretch(this.source2, this.m_source2Width / 2 - w, this.m_source2Height / 2 - h, w, h, 0, 0, this.source1.width / 2, this.source1.height / 2);
							// Top Right
							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							if (h < 5)
								h = 5;
							this.stretch(this.source2, this.m_source2Width / 2, this.m_source2Height / 2 - h, w, h, this.m_source2Width / 2, 0, this.m_source2Width / 2, this.m_source2Height / 2);
							// Bottom Left
							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							this.stretch(this.source2, this.m_source2Width / 2 - w, this.m_source2Height / 2, w, h, 0, this.m_source2Height / 2, this.m_source2Width / 2, this.m_source2Height / 2);
							// Bottom Right
							w = this.m_source2Width / 2 * elapsedTime / this.m_duration;
							h = this.m_source2Height / 2 * elapsedTime / this.m_duration;
							this.stretch(this.source2, this.m_source2Width / 2, this.m_source2Height / 2, w, h, this.m_source2Width / 2, this.m_source2Height / 2, this.m_source2Width / 2, this.m_source2Height / 2);
							break;
						// Top Middle
						case 6:
							w = this.m_source2Width;
							h = this.m_source2Height * elapsedTime / this.m_duration;
							this.stretch(this.source2, 0, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							break;
						// Middle Left
						case 7:
							w = this.m_source2Width * elapsedTime / this.m_duration;
							h = this.m_source2Height;
							this.stretch(this.source2, 0, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							break;
						// Middle Right
						case 8:
							w = this.m_source2Width * elapsedTime / this.m_duration;
							h = this.m_source2Height;
							this.stretch(this.source2, this.m_source2Width - w, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							break;
						// Bottom Middle
						case 9:
							w = this.m_source2Width;
							h = this.m_source2Height * elapsedTime / this.m_duration;
							this.stretch(this.source2, 0, this.m_source2Height - h, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							break;
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransStretch2()
	{
		this.dwStyle = 0;
		this.m_source2Width = 0;
		this.m_source2Height = 0;
		this.m_phase = 0;
	}
	CTransStretch2.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.dwStyle = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time?
				if (this.m_starting)
				{
					this.m_starting = false;
					this.m_source2Width = this.source2.width;
					this.m_source2Height = this.source2.height;
					this.m_phase = 0;
				}

				var elapsedTime = this.getDeltaTime();

				if ((elapsedTime / this.m_duration) > 1.0)
				{
					this.blit(this.source2);					// completed
				}
				else
				{
					var w, h;

					switch (this.dwStyle)
					{
						// Top Left
						case 0:
							if (this.m_phase == 0)
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w = this.m_source2Width - w;
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h = this.m_source2Height - h;

								this.stretch(this.source1, 0, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);

								if (elapsedTime >= this.m_duration / 2)
									this.m_phase = 1;
							}
							else
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w -= this.m_source2Width;
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h -= this.m_source2Height;
								this.stretch(this.source2, 0, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							}
							break;
						// Top Middle
						case 1:
							if (this.m_phase == 0)
							{
								w = this.m_source2Width;
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h = this.m_source2Height - h;

								this.stretch(this.source1, 0, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);

								if (elapsedTime >= this.m_duration / 2)
									this.m_phase = 1;
							}
							else
							{
								w = this.m_source2Width;
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h -= this.m_source2Height;
								this.stretch(this.source2, 0, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							}
							break;
						// Top Right
						case 2:
							if (this.m_phase == 0)
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w = this.m_source2Width - w;
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h = this.m_source2Height - h;

								this.stretch(this.source1, this.m_source2Width - w, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);

								if (elapsedTime >= this.m_duration / 2)
									this.m_phase = 1;
							}
							else
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w -= this.m_source2Width;
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h -= this.m_source2Height;
								this.stretch(this.source2, this.m_source2Width - w, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							}
							break;
						// Middle Left
						case 3:
							if (this.m_phase == 0)
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w = this.m_source2Width - w;
								h = this.m_source2Height;

								this.stretch(this.source1, 0, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);

								if (elapsedTime >= this.m_duration / 2)
									this.m_phase = 1;
							}
							else
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w -= this.m_source2Width;
								h = this.m_source2Height;
								this.stretch(this.source2, 0, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							}
							break;
						// Center H
						case 4:
							if (this.m_phase == 0)
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w = this.m_source2Width - w;
								h = this.m_source2Height;

								this.stretch(this.source1, this.m_source2Width / 2 - w / 2, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);

								if (elapsedTime >= this.m_duration / 2)
									this.m_phase = 1;
							}
							else
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w -= this.m_source2Width;
								h = this.m_source2Height;
								this.stretch(this.source2, this.m_source2Width / 2 - w / 2, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							}
							break;
						// Center V
						case 5:
							if (this.m_phase == 0)
							{
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h = this.m_source2Height - h;
								w = this.m_source2Width;

								this.stretch(this.source1, 0, this.m_source2Height / 2 - h / 2, w, h, 0, 0, this.m_source2Width, this.m_source2Height);

								if (elapsedTime >= this.m_duration / 2)
									this.m_phase = 1;
							}
							else
							{
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h -= this.m_source2Height;
								w = this.m_source2Width;
								this.stretch(this.source2, 0, this.m_source2Height / 2 - h / 2, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							}
							break;
						// Center H+V
						case 6:
							if (this.m_phase == 0)
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w = this.m_source2Width - w;
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h = this.m_source2Height - h;

								this.stretch(this.source1, this.m_source2Width / 2 - w / 2, this.m_source2Height / 2 - h / 2, w, h, 0, 0, this.m_source2Width, this.m_source2Height);

								if (elapsedTime >= this.m_duration / 2)
									this.m_phase = 1;
							}
							else
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w -= this.m_source2Width;
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h -= this.m_source2Height;
								this.stretch(this.source2, this.m_source2Width / 2 - w / 2, this.m_source2Height / 2 - h / 2, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							}
							break;
						// Middle Right
						case 7:
							if (this.m_phase == 0)
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w = this.m_source2Width - w;
								h = this.m_source2Height;

								this.stretch(this.source1, this.m_source2Width - w, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);

								if (elapsedTime >= this.m_duration / 2)
									this.m_phase = 1;
							}
							else
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w -= this.m_source2Width;
								h = this.m_source2Height;
								this.stretch(this.source2, this.m_source2Height - w, 0, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							}
							break;
						// Bottom Left
						case 8:
							if (this.m_phase == 0)
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w = this.m_source2Width - w;
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h = this.m_source2Height - h;

								this.stretch(this.source1, 0, this.m_source2Height - h, w, h, 0, 0, this.m_source2Width, this.m_source2Height);

								if (elapsedTime >= this.m_duration / 2)
									this.m_phase = 1;
							}
							else
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w -= this.m_source2Width;
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h -= this.m_source2Height;
								this.stretch(this.source2, 0, this.m_source2Height - h, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							}
							break;
						// Bottom Middle
						case 9:
							if (this.m_phase == 0)
							{
								w = this.m_source2Width;
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h = this.m_source2Height - h;

								this.stretch(this.source1, 0, this.m_source2Height - h, w, h, 0, 0, this.m_source2Width, this.m_source2Height);

								if (elapsedTime >= this.m_duration / 2)
									this.m_phase = 1;
							}
							else
							{
								w = this.m_source2Width;
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h -= this.m_source2Height;
								this.stretch(this.source2, 0, this.m_source2Height - h, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							}
							break;
						// Bottom Right
						case 10:
							if (this.m_phase == 0)
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w = this.m_source2Width - w;
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h = this.m_source2Height - h;

								this.stretch(this.source1, this.m_source2Width - w, this.m_source2Height - h, w, h, 0, 0, this.m_source2Width, this.m_source2Height);

								if (elapsedTime >= this.m_duration / 2)
									this.m_phase = 1;
							}
							else
							{
								w = 2 * this.m_source2Width * elapsedTime / this.m_duration;
								w -= this.m_source2Width;
								h = 2 * this.m_source2Height * elapsedTime / this.m_duration;
								h -= this.m_source2Height;
								this.stretch(this.source2, this.m_source2Width - w, this.m_source2Height - h, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
							}
							break;
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransTrame()
	{
		this.dwStyle = 0;
		this.m_source2Width = 0;
		this.m_source2Height = 0;
		this.m_index = 0;
		this.m_index2 = 0;
	}
	CTransTrame.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.dwStyle = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time?
				if (this.m_starting)
				{
					this.m_starting = false;
					this.m_source2Width = this.source2.width;
					this.m_source2Height = this.source2.height;
					this.m_index = 0;
					this.m_index2 = 0;
				}

				var elapsedTime = this.getDeltaTime();

				if ((elapsedTime / this.m_duration) > 1.0)
				{
					this.blit(this.source2);					// completed
				}
				else
				{
					var w, h, i, j, k;

					h = this.m_source2Height * elapsedTime / this.m_duration;
					w = this.m_source2Width * elapsedTime / this.m_duration;

					if (this.dwStyle == 0)
					{
						k = h % 2;
						for (i = 0; i < this.m_source2Width; i += 2)
						{
							for (j = this.m_index; j < h; j++)
							{
								this.blit(this.source2, i, j, i, j, 1, 1);
							}
							for (j = this.m_source2Height - h - k; j < this.m_source2Height - this.m_index; j++)
							{
								this.blit(this.source2, i + 1, j + 1, i + 1, j + 1, 1, 1);
							}
						}
						if (h % 2 == 0)
							this.m_index = h;
						else
							this.m_index = h - 1;
					}

					if (this.dwStyle == 1)
					{
						k = w % 2;
						for (j = 0; j < this.m_source2Height; j++)
						{
							for (i = this.m_index2; i < w; i += 2)
							{
								this.blit(this.source2, i + 1, j, i + 1, j, 1, 1);
							}
							for (i = this.m_source2Width - w - k; i < this.m_source2Width - this.m_index2; i += 2)
							{
								this.blit(this.source2, i, j + 1, i, j + 1, 1, 1);
							}
						}
						if (w % 2 == 0)
							this.m_index2 = w;
						else
							this.m_index2 = w - 1;
					}

					if (this.dwStyle == 2)
					{
						k = h % 2;
						for (i = 0; i < this.m_source2Width; i += 2)
						{
							for (j = this.m_index; j < h; j += 2)
							{
								this.blit(this.source2, i, j, i, j, 1, 1);
							}
							for (j = this.m_source2Height - h - k; j < this.m_source2Height - this.m_index; j += 2)
							{
								this.blit(this.source2, i + 1, j + 1, i + 1, j + 1, 1, 1);
							}
						}

						k = w % 2;
						for (j = 0; j < this.m_source2Height; j += 2)
						{
							for (i = this.m_index2; i < w; i += 2)
							{
								this.blit(this.source2, i + 1, j, i + 1, j, 1, 1);
							}
							for (i = this.m_source2Width - w - k; i < this.m_source2Width - this.m_index2; i += 2)
							{
								this.blit(this.source2, i, j + 1, i, j + 1, 1, 1);
							}
						}
						if (h % 2 == 0)
							this.m_index = h;
						else
							this.m_index = h - 1;
						if (w % 2 == 0)
							this.m_index2 = w;
						else
							this.m_index2 = w - 1;
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransTurn()
	{
		this.dwPos = 0;
		this.dwCheck1 = 0;
		this.dwCheck2 = 0;
		this.m_source2Width = 0;
		this.m_source2Height = 0;
		this.m_angle = 0;
	}
	CTransTurn.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.dwPos = file.readAInt();
				this.dwCheck1 = file.readAInt();
				this.dwCheck2 = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time?
				if (this.m_starting)
				{
					this.m_starting = false;
					this.m_source2Width = this.source2.width;
					this.m_source2Height = this.source2.height;
					this.m_angle = 0.0;
				}

				var elapsedTime = this.getDeltaTime();

				if ((elapsedTime / this.m_duration) > 1.0)
				{
					this.blit(this.source2);			// completed
				}
				else
				{
					var x, y, w, h;
					var dist, xcenter, ycenter;

					xcenter = this.m_source2Width / 2;
					ycenter = this.m_source2Height / 2;

					this.m_angle = this.dwPos * 6.28318 * elapsedTime / this.m_duration;

					// Inverse ?
					if (this.dwCheck2 == 1)
					{
						this.m_angle = 6.28318 - this.m_angle;
					}

					dist = this.m_source2Width / 2 - this.m_source2Width / 2 * elapsedTime / this.m_duration;
					x = Math.floor(xcenter + Math.cos(this.m_angle) * dist);
					y = Math.floor(ycenter + Math.sin(this.m_angle) * dist);

					w = this.m_source2Width * elapsedTime / this.m_duration;
					h = this.m_source2Height * elapsedTime / this.m_duration;

					this.stretch(this.source1, 0, 0, this.m_source2Width, this.m_source2Height, 0, 0, this.source1.width, this.source1.height);

					// Full Image ?
					if (this.wCheck1 == 1)
						this.stretch(this.source2, x - w / 2, y - h / 2, w, h, 0, 0, this.m_source2Width, this.m_source2Height);
					else
						this.stretch(this.source2, x - w / 2, y - h / 2, w, h, this.m_source2Width - w, this.m_source2Height - h, w, h);
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransTurn2()
	{
		this.dwPos = 0;
		this.dwCheck1 = 0;
		this.m_source2Width = 0;
		this.m_source2Height = 0;
		this.m_curcircle = 0;
	}
	CTransTurn2.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.dwPos = file.readAInt();
				this.dwCheck1 = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time?
				if (this.m_starting)
				{
					this.m_starting = false;
					this.m_source2Width = this.source2.width;
					this.m_source2Height = this.source2.height;
					this.m_curcircle = 0;
				}

				var elapsedTime = this.getDeltaTime();

				if ((elapsedTime / this.m_duration) > 1.0)
				{
					this.blit(this.source2);				// completed
				}
				else
				{
					var x, y, xcenter, ycenter, dist;
					var angle = 0.0;

					xcenter = this.m_source2Width / 2;
					ycenter = this.m_source2Height / 2;

					angle = this.dwPos * 6.28318 * elapsedTime / this.m_duration;
					angle -= this.m_curcircle * 6.28318;
					if (this.dwCheck1 == 1)
						angle = 6.28318 - angle;

					dist = this.m_source2Width * elapsedTime / this.m_duration;
					x = Math.floor(xcenter + Math.cos(angle) * dist);
					y = Math.floor(ycenter + Math.sin(angle) * dist);

					this.blit(this.source2);
					this.blit(this.source1, x - this.m_source2Width / 2, y - this.m_source2Height / 2, 0, 0, this.m_source2Width, this.m_source2Height);

					if (this.dwCheck1 == 0)
					{
						if (angle >= 6.28318)
							this.m_curcircle++;
					}
					else
					{
						if (angle <= 0)
							this.m_curcircle++;
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransZigZag()
	{
		this.zpSpotPercent = 0;
		this.zpStartPoint = 0;
		this.zpDirection = 0;
		this.m_spotSize = 0;
		this.m_nbBlockPerLine = 0;
		this.m_nbBlockPerCol = 0;
		this.m_nbBlocks = 0;
		this.m_lastNbBlocks = 0;
		this.m_curx = 0;
		this.m_cury = 0;
		this.m_currentDirection = 0;
		this.m_currentStartPoint = 0;
		this.m_left = 0;
		this.m_top = 0;
		this.m_right = 0;
		this.m_bottom = 0;
	}
	CTransZigZag.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.zpSpotPercent = file.readAInt();
				this.zpStartPoint = file.readAShort();
				this.zpDirection = file.readAShort();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				var sw = this.source1.width;
				var sh = this.source1.height;

				// 1st time? create surface
				if (this.m_starting)
				{
					// Spot size: voir si ca rend bien
					this.m_spotSize = Math.floor(((sw * this.zpSpotPercent / 100) + (sh * this.zpSpotPercent / 100)) / 2);
					if (this.m_spotSize == 0)
						this.m_spotSize = 1;

					this.m_nbBlockPerLine = ((sw + this.m_spotSize - 1) / this.m_spotSize);
					this.m_nbBlockPerCol = ((sh + this.m_spotSize - 1) / this.m_spotSize);

					// Start point
					this.m_currentDirection = this.zpDirection;
					this.m_currentStartPoint = this.zpStartPoint;

					switch (this.zpStartPoint)
					{
						case CTrans.TOP_LEFT:
							this.m_curx = this.m_cury = 0;
							break;
						case CTrans.TOP_RIGHT:
							this.m_curx = sw - this.m_spotSize;
							this.m_cury = 0;
							break;
						case CTrans.BOTTOM_LEFT:
							this.m_curx = 0;
							this.m_cury = sh - this.m_spotSize;
							break;
						case CTrans.BOTTOM_RIGHT:
							this.m_curx = sw - this.m_spotSize;
							this.m_cury = sh - this.m_spotSize;
							break;
						case CTrans.CENTER:
							this.m_curx = sw / 2 - this.m_spotSize;
							this.m_cury = sh / 2 - this.m_spotSize;
							if (this.m_currentDirection == CTrans.DIR_HORZ)
								this.m_currentStartPoint = CTrans.TOP_LEFT;
							else
								this.m_currentStartPoint = CTrans.TOP_RIGHT;
							this.m_left = this.m_curx - this.m_spotSize;
							this.m_top = this.m_cury - this.m_spotSize;
							this.m_bottom = this.m_cury + this.m_spotSize * 2;
							this.m_right = this.m_curx + this.m_spotSize * 2;

							this.m_nbBlockPerLine = 2 + 2 * (this.m_curx + this.m_spotSize - 1) / this.m_spotSize;
							this.m_nbBlockPerCol = 2 + 2 * (this.m_cury + this.m_spotSize - 1) / this.m_spotSize;
							break;
					}
					this.m_nbBlocks = Math.floor(this.m_nbBlockPerLine * this.m_nbBlockPerCol);
					this.m_lastNbBlocks = 0;
					this.m_starting = false;
				}

				if (this.m_spotSize >= sw || this.m_spotSize >= sh)
					this.blit(this.source2);	// termine
				else
				{
					// Compute number of spots to display in 1 step
					var l;
					var nbBlocks = Math.floor(this.m_nbBlocks * this.getDeltaTime() / this.m_duration);
					var nbCurrentBlocks = nbBlocks - this.m_lastNbBlocks;
					if (nbCurrentBlocks != 0)
					{
						this.m_lastNbBlocks = nbBlocks;
						for (l = 0; l < nbCurrentBlocks; l++)
						{
							// Blit current spot
							this.blit(this.source2, this.m_curx, this.m_cury, this.m_curx, this.m_cury, this.m_spotSize, this.m_spotSize);

							// Increment spot coordinates
							if (this.zpStartPoint == CTrans.CENTER)
							{
								switch (this.m_currentStartPoint)
								{
									case CTrans.TOP_LEFT:
										this.m_curx += this.m_spotSize;
										if (this.m_curx >= this.m_right)
										{
											this.m_curx -= this.m_spotSize;
											this.m_cury += this.m_spotSize;
											this.m_currentStartPoint = CTrans.TOP_RIGHT;
											this.m_right += this.m_spotSize;
										}
										break;
									case CTrans.TOP_RIGHT:
										this.m_cury += this.m_spotSize;
										if (this.m_cury >= this.m_bottom)
										{
											this.m_cury -= this.m_spotSize;
											this.m_curx -= this.m_spotSize;
											this.m_currentStartPoint = CTrans.BOTTOM_RIGHT;
											this.m_bottom += this.m_spotSize;
										}
										break;
									case CTrans.BOTTOM_RIGHT:
										this.m_curx -= this.m_spotSize;
										if ((this.m_curx + this.m_spotSize) <= this.m_left)
										{
											this.m_curx += this.m_spotSize;
											this.m_cury -= this.m_spotSize;
											this.m_currentStartPoint = CTrans.BOTTOM_LEFT;
											this.m_left -= this.m_spotSize;
										}
										break;
									case CTrans.BOTTOM_LEFT:
										this.m_cury -= this.m_spotSize;
										if ((this.m_cury + this.m_spotSize) <= this.m_top)
										{
											this.m_cury += this.m_spotSize;
											this.m_curx += this.m_spotSize;
											this.m_currentStartPoint = CTrans.TOP_LEFT;
											this.m_top -= this.m_spotSize;
										}
										break;
								}
							}
							else
							{
								switch (this.m_currentDirection)
								{
									// Horizontal
									case CTrans.DIR_HORZ:
										switch (this.m_currentStartPoint)
										{
											case CTrans.TOP_LEFT:
												this.m_curx += this.m_spotSize;
												if (this.m_curx >= sw)
												{
													this.m_curx -= this.m_spotSize;
													this.m_cury += this.m_spotSize;
													this.m_currentStartPoint = CTrans.TOP_RIGHT;
												}
												break;
											case CTrans.TOP_RIGHT:
												this.m_curx -= this.m_spotSize;
												if ((this.m_curx + this.m_spotSize) <= 0)
												{
													this.m_curx += this.m_spotSize;
													this.m_cury += this.m_spotSize;
													this.m_currentStartPoint = CTrans.TOP_LEFT;
												}
												break;
											case CTrans.BOTTOM_LEFT:
												this.m_curx += this.m_spotSize;
												if (this.m_curx >= sw)
												{
													this.m_curx -= this.m_spotSize;
													this.m_cury -= this.m_spotSize;
													this.m_currentStartPoint = CTrans.BOTTOM_RIGHT;
												}
												break;
											case CTrans.BOTTOM_RIGHT:
												this.m_curx -= this.m_spotSize;
												if ((this.m_curx + this.m_spotSize) <= 0)
												{
													this.m_curx += this.m_spotSize;
													this.m_cury -= this.m_spotSize;
													this.m_currentStartPoint = CTrans.BOTTOM_LEFT;
												}
												break;
										}
										break;

									// Vertical
									case CTrans.DIR_VERT:
										switch (this.m_currentStartPoint)
										{
											case CTrans.TOP_LEFT:
												this.m_cury += this.m_spotSize;
												if (this.m_cury >= sh)
												{
													this.m_cury -= this.m_spotSize;
													this.m_curx += this.m_spotSize;
													this.m_currentStartPoint = CTrans.BOTTOM_LEFT;
												}
												break;
											case CTrans.TOP_RIGHT:
												this.m_cury += this.m_spotSize;
												if (this.m_cury >= sh)
												{
													this.m_cury -= this.m_spotSize;
													this.m_curx -= this.m_spotSize;
													this.m_currentStartPoint = CTrans.BOTTOM_RIGHT;
												}
												break;
											case CTrans.BOTTOM_LEFT:
												this.m_cury -= this.m_spotSize;
												if ((this.m_cury + this.m_spotSize) <= 0)
												{
													this.m_cury += this.m_spotSize;
													this.m_curx += this.m_spotSize;
													this.m_currentStartPoint = CTrans.TOP_LEFT;
												}
												break;
											case CTrans.BOTTOM_RIGHT:
												this.m_cury -= this.m_spotSize;
												if ((this.m_cury + this.m_spotSize) <= 0)
												{
													this.m_cury += this.m_spotSize;
													this.m_curx -= this.m_spotSize;
													this.m_currentStartPoint = CTrans.TOP_RIGHT;
												}
												break;
										}
										break;
								}
							}
						}
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransZigZag2()
	{
		this.dwStyle = 0;
		this.dwPos = 0;
		this.m_source2Width = 0;
		this.m_source2Height = 0;
		this.m_linepos = 0;
		this.m_dir = 0;
	}
	CTransZigZag2.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.dwStyle = file.readAInt();
				this.dwPos = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time?
				if (this.m_starting)
				{
					this.m_starting = false;
					this.m_source2Width = this.source2.width;
					this.m_source2Height = this.source2.height;
					this.m_linepos = 0;
					this.m_dir = 0;
				}

				var elapsedTime = this.getDeltaTime();

				if ((elapsedTime / this.m_duration) > 1.0)
				{
					this.blit(this.source2);					// completed
				}
				else
				{
					var x, y, w, h;
					var nb = 0.0;

					if (this.dwStyle == 0)
					{
						nb = this.m_source2Height / this.dwPos;

						// TOP
						h = Math.floor(this.m_linepos * nb) + Math.floor(nb);
						y = 0;
						w = this.m_source2Width * elapsedTime / this.m_duration;
						w = w * this.dwPos / 2;
						w -= this.m_source2Width * this.m_linepos;
						if (this.m_dir == 0)
							x = 0;
						else
							x = this.m_source2Width - w;
						this.blit(this.source2, x, y, x, y, w, h);

						// BOTTOM
						y = this.m_source2Height - h;
						if (this.m_dir == 1)
							x = 0;
						else
							x = this.m_source2Width - w;
						this.blit(this.source2, x, y, x, y, w, h);

						// End of line
						if (w >= this.m_source2Width)
						{
							this.m_linepos++;
							this.m_dir++;
							if (this.m_dir == 2)
								this.m_dir = 0;
						}
					}
					else
					{
						nb = this.m_source2Width / this.dwPos;

						// LEFT
						w = Math.floor(this.m_linepos * nb) + Math.floor(nb);
						x = 0;
						h = this.m_source2Height * elapsedTime / this.m_duration;
						h = h * this.dwPos / 2;
						h -= this.m_source2Height * this.m_linepos;
						if (this.m_dir == 0)
							y = 0;
						else
							y = this.m_source2Height - h;
						this.blit(this.source2, x, y, x, y, w, h);

						// RIGHT
						x = this.m_source2Width - w;
						if (this.m_dir == 1)
							y = 0;
						else
							y = this.m_source2Height - h;
						this.blit(this.source2, x, y, x, y, w, h);

						// End of line
						if (h >= this.m_source2Height)
						{
							this.m_linepos++;
							this.m_dir++;
							if (this.m_dir == 2)
								this.m_dir = 0;
						}
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransZoom()
	{
	}
	CTransZoom.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{

				var sw = this.source1.width;
				var sh = this.source1.height;

				// 1st time? 
				if (this.m_starting)
				{
					// Reset m_starting
					this.m_starting = false;
				}

				// Securites
				if (this.m_duration == 0)	// || etc... )
					this.blit(this.source2);
				else
				{
					var nw, nh;
					var deltaTime = this.getDeltaTime();

					// Fade out
					if ((flag & CTrans.TRFLAG_FADEOUT) != 0)
					{
						nw = Math.floor(sw - sw * deltaTime / this.m_duration);
						nh = Math.floor(sh - sh * deltaTime / this.m_duration);

						// Fill background
						this.blit(this.source2);

						// Stretch new image
						this.stretch(this.source1, (sw - nw) / 2, (sh - nh) / 2, nw, nh, 0, 0, sw, sh);
					}

					// Fade in
					else
					{
						nw = Math.floor(sw * deltaTime / this.m_duration);
						nh = Math.floor(sh * deltaTime / this.m_duration);

						// Fill background
						this.blit(this.source1);

						// Stretch new image
						this.stretch(this.source2, (sw - nw) / 2, (sh - nh) / 2, nw, nh, 0, 0, sw, sh);
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});


	function CTransZoom2()
	{
		this.dwPos = 0;
		this.m_source2Width = 0;
		this.m_source2Height = 0;
	}
	CTransZoom2.prototype = CServices.extend(new CTrans(),
		{
			init:     function (data, file, display, source, dest)
			{
				this.dwPos = file.readAInt();
				this.start(data, display, source, dest);
			},
			stepDraw: function (flag)
			{
				// 1st time?
				if (this.m_starting)
				{
					this.m_starting = false;
					this.m_source2Width = this.source2.width;
					this.m_source2Height = this.source2.height;
				}

				var elapsedTime = this.getDeltaTime();

				if ((elapsedTime / this.m_duration) > 1.0)
				{
					this.blit(this.source2);		// completed
				}
				else
				{
					var x, y, w, h;

					if (this.dwPos == 0)
					{
						w = this.m_source2Width * elapsedTime / this.m_duration;
						h = this.m_source2Height * elapsedTime / this.m_duration;
						x = this.m_source2Width / 2 - w / 2;
						y = this.m_source2Height / 2 - h / 2;

						this.stretch(this.source2, 0, 0, this.m_source2Width, this.m_source2Height, x, y, w, h);
					}
					else
					{
						w = this.m_source2Width * elapsedTime / this.m_duration;
						w = this.m_source2Width - w;
						h = this.m_source2Height * elapsedTime / this.m_duration;
						h = this.m_source2Height - h;
						x = this.m_source2Width / 2 - w / 2;
						y = this.m_source2Height / 2 - h / 2;

						this.stretch(this.source1, 0, 0, this.m_source2Width, this.m_source2Height, x, y, w, h);
					}
				}
				return null;
			},
			end:      function ()
			{
				this.finish();
			}
		});
	/**

	 JSZip - A Javascript class for generating and reading zip files
	 <http://stuartk.com/jszip>

	 (c) 2009-2012 Stuart Knightley <stuart [at] stuartk.com>
	 Dual licenced under the MIT license or GPLv3. See LICENSE.markdown.

	 Usage:
	 zip = new JSZip();
	 zip.file("hello.txt", "Hello, World!").file("tempfile", "nothing");
	 zip.folder("images").file("smile.gif", base64Data, {base64: true});
	 zip.file("Xmas.txt", "Ho ho ho !", {date : new Date("December 25, 2007 00:00:01")});
	 zip.remove("tempfile");

	 base64zip = zip.generate();

	 **/

	/**
	 * Representation a of zip file in js
	 * @constructor
	 * @param {String=|ArrayBuffer=|Uint8Array=} data the data to load, if any (optional).
	 * @param {Object=} options the options for creating this objects (optional).
	 */
	var JSZip = function (data, options)
	{
		// object containing the files :
		// {
		//   "folder/" : {...},
		//   "folder/data.txt" : {...}
		// }
		this.files = {};

		// Where we are in the hierarchy
		this.root = "";

		if (data)
		{
			this.load(data, options);
		}
	};

	JSZip.signature = {
		LOCAL_FILE_HEADER:               "\x50\x4b\x03\x04",
		CENTRAL_FILE_HEADER:             "\x50\x4b\x01\x02",
		CENTRAL_DIRECTORY_END:           "\x50\x4b\x05\x06",
		ZIP64_CENTRAL_DIRECTORY_LOCATOR: "\x50\x4b\x06\x07",
		ZIP64_CENTRAL_DIRECTORY_END:     "\x50\x4b\x06\x06",
		DATA_DESCRIPTOR:                 "\x50\x4b\x07\x08"
	};

	// Default properties for a new file
	JSZip.defaults = {
		base64:      false,
		binary:      false,
		dir:         false,
		date:        null,
		compression: null
	};


	JSZip.prototype = (function ()
	{
		/**
		 * A simple object representing a file in the zip file.
		 * @constructor
		 * @param {string} name the name of the file
		 * @param {string} data the data
		 * @param {Object} options the options of the file
		 */
		var ZipObject = function (name, data, options)
		{
			this.name = name;
			this.data = data;
			this.options = options;
		};

		ZipObject.prototype = {
			/**
			 * Return the content as UTF8 string.
			 * @return {string} the UTF8 string.
			 */
			asText:        function ()
			{
				var result = this.data;
				if (result === null || typeof result === "undefined")
				{
					return "";
				}
				if (this.options.base64)
				{
					result = JSZipBase64.decode(result);
				}
				if (this.options.binary)
				{
					result = JSZip.prototype.utf8decode(result);
				}
				return result;
			},
			/**
			 * Returns the binary content.
			 * @return {string} the content as binary.
			 */
			asBinary:      function ()
			{
				var result = this.data;
				if (result === null || typeof result === "undefined")
				{
					return "";
				}
				if (this.options.base64)
				{
					result = JSZipBase64.decode(result);
				}
				if (!this.options.binary)
				{
					result = JSZip.prototype.utf8encode(result);
				}
				return result;
			},
			/**
			 * Returns the content as an Uint8Array.
			 * @return {Uint8Array} the content as an Uint8Array.
			 */
			asUint8Array:  function ()
			{
				return JSZip.utils.string2Uint8Array(this.asBinary());
			},
			/**
			 * Returns the content as an ArrayBuffer.
			 * @return {ArrayBuffer} the content as an ArrayBufer.
			 */
			asArrayBuffer: function ()
			{
				return JSZip.utils.string2Uint8Array(this.asBinary()).buffer;
			}
		};

		/**
		 * Transform an integer into a string in hexadecimal.
		 * @private
		 * @param {number} dec the number to convert.
		 * @param {number} bytes the number of bytes to generate.
		 * @returns {string} the result.
		 */
		var decToHex = function (dec, bytes)
		{
			var hex = "", i;
			for (i = 0; i < bytes; i++)
			{
				hex += String.fromCharCode(dec & 0xff);
				dec = dec >>> 8;
			}
			return hex;
		};

		/**
		 * Merge the objects passed as parameters into a new one.
		 * @private
		 * @param {...Object} var_args All objects to merge.
		 * @return {Object} a new object with the data of the others.
		 */
		var extend = function ()
		{
			var result = {}, i, attr;
			for (i = 0; i < arguments.length; i++)
			{ // arguments is not enumerable in some browsers
				for (attr in arguments[i])
				{
					if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined")
					{
						result[attr] = arguments[i][attr];
					}
				}
			}
			return result;
		};

		/**
		 * Transforms the (incomplete) options from the user into the complete
		 * set of options to create a file.
		 * @private
		 * @param {Object} o the options from the user.
		 * @return {Object} the complete set of options.
		 */
		var prepareFileAttrs = function (o)
		{
			o = o || {};
			if (o.base64 === true && o.binary == null)
			{
				o.binary = true;
			}
			o = extend(o, JSZip.defaults);
			o.date = o.date || new Date();
			if (o.compression !== null) o.compression = o.compression.toUpperCase();

			return o;
		};

		/**
		 * Add a file in the current folder.
		 * @private
		 * @param {string} name the name of the file
		 * @param {String|ArrayBuffer|Uint8Array} data the data of the file
		 * @param {Object} o the options of the file
		 * @return {Object} the new file.
		 */
		var fileAdd = function (name, data, o)
		{
			// be sure sub folders exist
			var parent = parentFolder(name);
			if (parent)
			{
				folderAdd.call(this, parent);
			}

			o = prepareFileAttrs(o);

			if (o.dir || data === null || typeof data === "undefined")
			{
				o.base64 = false;
				o.binary = false;
				data = null;
			}
			else if (JSZip.support.uint8array && data instanceof Uint8Array)
			{
				o.base64 = false;
				o.binary = true;
				data = JSZip.utils.uint8Array2String(data);
			}
			else if (JSZip.support.arraybuffer && data instanceof ArrayBuffer)
			{
				o.base64 = false;
				o.binary = true;
				var bufferView = new Uint8Array(data);
				data = JSZip.utils.uint8Array2String(bufferView);
			}
			else if (o.binary && !o.base64)
			{
				// optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask
				if (o.optimizedBinaryString !== true)
				{
					// this is a string, not in a base64 format.
					// Be sure that this is a correct "binary string"
					data = JSZip.utils.string2binary(data);
				}
				// we remove this option since it's only relevant here
				delete o.optimizedBinaryString;
			}

			return this.files[name] = new ZipObject(name, data, o);
		};


		/**
		 * Find the parent folder of the path.
		 * @private
		 * @param {string} path the path to use
		 * @return {string} the parent folder, or ""
		 */
		var parentFolder = function (path)
		{
			if (path.slice(-1) == '/')
			{
				path = path.substring(0, path.length - 1);
			}
			var lastSlash = path.lastIndexOf('/');
			return (lastSlash > 0) ? path.substring(0, lastSlash) : "";
		};

		/**
		 * Add a (sub) folder in the current folder.
		 * @private
		 * @param {string} name the folder's name
		 * @return {Object} the new folder.
		 */
		var folderAdd = function (name)
		{
			// Check the name ends with a /
			if (name.slice(-1) != "/")
			{
				name += "/"; // IE doesn't like substr(-1)
			}

			// Does this folder already exist?
			if (!this.files[name])
			{
				// be sure sub folders exist
				var parent = parentFolder(name);
				if (parent)
				{
					folderAdd.call(this, parent);
				}

				fileAdd.call(this, name, null, {dir: true});
			}
			return this.files[name];
		};

		/**
		 * Generate the data found in the local header of a zip file.
		 * Do not create it now, as some parts are re-used later.
		 * @private
		 * @param {Object} file the file to use.
		 * @param {string} utfEncodedFileName the file name, utf8 encoded.
		 * @param {string} compressionType the compression to use.
		 * @return {Object} an object containing header and compressedData.
		 */
		var prepareLocalHeaderData = function (file, utfEncodedFileName, compressionType)
		{
			var useUTF8 = utfEncodedFileName !== file.name,
				data = file.asBinary(),
				o = file.options,
				dosTime,
				dosDate;

			// date
			// @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
			// @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
			// @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

			dosTime = o.date.getHours();
			dosTime = dosTime << 6;
			dosTime = dosTime | o.date.getMinutes();
			dosTime = dosTime << 5;
			dosTime = dosTime | o.date.getSeconds() / 2;

			dosDate = o.date.getFullYear() - 1980;
			dosDate = dosDate << 4;
			dosDate = dosDate | (o.date.getMonth() + 1);
			dosDate = dosDate << 5;
			dosDate = dosDate | o.date.getDate();

			var hasData = data !== null && data.length !== 0;

			compressionType = o.compression || compressionType;
			if (!JSZip.compressions[compressionType])
			{
				throw compressionType + " is not a valid compression method !";
			}

			var compression = JSZip.compressions[compressionType];
			var compressedData = hasData ? compression.compress(data) : '';

			var header = "";

			// version needed to extract
			header += "\x0A\x00";
			// general purpose bit flag
			// set bit 11 if utf8
			header += useUTF8 ? "\x00\x08" : "\x00\x00";
			// compression method
			header += hasData ? compression.magic : JSZip.compressions['STORE'].magic;
			// last mod file time
			header += decToHex(dosTime, 2);
			// last mod file date
			header += decToHex(dosDate, 2);
			// crc-32
			header += hasData ? decToHex(this.crc32(data), 4) : '\x00\x00\x00\x00';
			// compressed size
			header += hasData ? decToHex(compressedData.length, 4) : '\x00\x00\x00\x00';
			// uncompressed size
			header += hasData ? decToHex(data.length, 4) : '\x00\x00\x00\x00';
			// file name length
			header += decToHex(utfEncodedFileName.length, 2);
			// extra field length
			header += "\x00\x00";

			return {
				header:         header,
				compressedData: compressedData
			};
		};


		// return the actual prototype of JSZip
		return {
			/**
			 * Read an existing zip and merge the data in the current JSZip object.
			 * The implementation is in jszip-load.js, don't forget to include it.
			 * @param {String|ArrayBuffer|Uint8Array} stream  The stream to load
			 * @param {Object} options Options for loading the stream.
			 *  options.base64 : is the stream in base64 ? default : false
			 * @return {JSZip} the current JSZip object
			 */
			load: function (stream, options)
			{
				throw new Error("Load method is not defined. Is the file jszip-load.js included ?");
			},

			/**
			 * Filter nested files/folders with the specified function.
			 * @param {Function} search the predicate to use :
			 * function (relativePath, file) {...}
			 * It takes 2 arguments : the relative path and the file.
			 * @return {Array} An array of matching elements.
			 */
			filter: function (search)
			{
				var result = [], filename, relativePath, file, fileClone;
				for (filename in this.files)
				{
					if (!this.files.hasOwnProperty(filename))
					{
						continue;
					}
					file = this.files[filename];
					// return a new object, don't let the user mess with our internal objects :)
					fileClone = new ZipObject(file.name, file.data, extend(file.options));
					relativePath = filename.slice(this.root.length, filename.length);
					if (filename.slice(0, this.root.length) === this.root && // the file is in the current root
						search(relativePath, fileClone))
					{ // and the file matches the function
						result.push(fileClone);
					}
				}
				return result;
			},

			/**
			 * Add a file to the zip file, or search a file.
			 * @param   {string|RegExp} name The name of the file to add (if data is defined),
			 * the name of the file to find (if no data) or a regex to match files.
			 * @param   {String|ArrayBuffer|Uint8Array} data  The file data, either raw or base64 encoded
			 * @param   {Object} o     File options
			 * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
			 * a file (when searching by string) or an array of files (when searching by regex).
			 */
			file: function (name, data, o)
			{
				if (arguments.length === 1)
				{
					if (name instanceof RegExp)
					{
						var regexp = name;
						return this.filter(function (relativePath, file)
						{
							return !file.options.dir && regexp.test(relativePath);
						});
					}
					else
					{ // text
						return this.filter(function (relativePath, file)
						{
							return !file.options.dir && relativePath === name;
						})[0] || null;
					}
				}
				else
				{ // more than one argument : we have data !
					name = this.root + name;
					fileAdd.call(this, name, data, o);
				}
				return this;
			},

			/**
			 * Add a directory to the zip file, or search.
			 * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
			 * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
			 */
			folder: function (arg)
			{
				if (!arg)
				{
					return this;
				}

				if (arg instanceof RegExp)
				{
					return this.filter(function (relativePath, file)
					{
						return file.options.dir && arg.test(relativePath);
					});
				}

				// else, name is a new folder
				var name = this.root + arg;
				var newFolder = folderAdd.call(this, name);

				// Allow chaining by returning a new object with this folder as the root
				var ret = this.clone();
				ret.root = newFolder.name;
				return ret;
			},

			/**
			 * Delete a file, or a directory and all sub-files, from the zip
			 * @param {string} name the name of the file to delete
			 * @return {JSZip} this JSZip object
			 */
			remove: function (name)
			{
				name = this.root + name;
				var file = this.files[name];
				if (!file)
				{
					// Look for any folders
					if (name.slice(-1) != "/")
					{
						name += "/";
					}
					file = this.files[name];
				}

				if (file)
				{
					if (!file.options.dir)
					{
						// file
						delete this.files[name];
					}
					else
					{
						// folder
						var kids = this.filter(function (relativePath, file)
						{
							return file.name.slice(0, name.length) === name;
						});
						for (var i = 0; i < kids.length; i++)
						{
							delete this.files[kids[i].name];
						}
					}
				}

				return this;
			},

			/**
			 * Generate the complete zip file
			 * @param {Object} options the options to generate the zip file :
			 * - base64, (deprecated, use type instead) true to generate base64.
			 * - compression, "STORE" by default.
			 * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
			 * @return {String|Uint8Array|ArrayBuffer|Blob} the zip file
			 */
			generate: function (options)
			{
				options = extend(options || {}, {
					base64:      true,
					compression: "STORE",
					type:        "base64"
				});
				var compression = options.compression.toUpperCase();

				if (!JSZip.compressions[compression])
				{
					throw compression + " is not a valid compression method !";
				}

				// The central directory, and files data
				var directory = [], files = [], fileOffset = 0;

				for (var name in this.files)
				{
					if (!this.files.hasOwnProperty(name))
					{
						continue;
					}

					var file = this.files[name];

					var utfEncodedFileName = this.utf8encode(file.name);

					var fileRecord = "",
						dirRecord = "",
						data = prepareLocalHeaderData.call(this, file, utfEncodedFileName, compression);
					fileRecord = JSZip.signature.LOCAL_FILE_HEADER + data.header + utfEncodedFileName + data.compressedData;

					dirRecord = JSZip.signature.CENTRAL_FILE_HEADER +
						// version made by (00: DOS)
						"\x14\x00" +
						// file header (common to file and central directory)
						data.header +
						// file comment length
						"\x00\x00" +
						// disk number start
						"\x00\x00" +
						// internal file attributes TODO
						"\x00\x00" +
						// external file attributes
						(this.files[name].options.dir === true ? "\x10\x00\x00\x00" : "\x00\x00\x00\x00") +
						// relative offset of local header
						decToHex(fileOffset, 4) +
						// file name
						utfEncodedFileName;

					fileOffset += fileRecord.length;

					files.push(fileRecord);
					directory.push(dirRecord);
				}

				var fileData = files.join("");
				var dirData = directory.join("");

				var dirEnd = "";

				// end of central dir signature
				dirEnd = JSZip.signature.CENTRAL_DIRECTORY_END +
					// number of this disk
					"\x00\x00" +
					// number of the disk with the start of the central directory
					"\x00\x00" +
					// total number of entries in the central directory on this disk
					decToHex(files.length, 2) +
					// total number of entries in the central directory
					decToHex(files.length, 2) +
					// size of the central directory   4 bytes
					decToHex(dirData.length, 4) +
					// offset of start of central directory with respect to the starting disk number
					decToHex(fileData.length, 4) +
					// .ZIP file comment length
					"\x00\x00";

				var zip = fileData + dirData + dirEnd;


				switch (options.type.toLowerCase())
				{
					case "uint8array" :
						return JSZip.utils.string2Uint8Array(zip);
					case "arraybuffer" :
						return JSZip.utils.string2Uint8Array(zip).buffer;
					case "blob" :
						return JSZip.utils.string2Blob(zip);
					case "base64" :
						return (options.base64) ? JSZipBase64.encode(zip) : zip;
					default : // case "string" :
						return zip;
				}
			},

			/**
			 *
			 *  Javascript crc32
			 *  http://www.webtoolkit.info/
			 *
			 */
			crc32: function (str, crc)
			{

				if (str === "" || typeof str === "undefined")
				{
					return 0;
				}

				var table = [
					0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
					0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
					0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
					0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
					0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
					0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
					0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
					0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
					0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
					0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
					0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
					0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
					0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
					0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
					0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
					0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
					0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
					0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
					0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
					0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
					0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
					0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
					0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
					0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
					0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
					0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
					0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
					0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
					0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
					0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
					0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
					0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
					0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
					0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
					0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
					0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
					0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
					0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
					0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
					0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
					0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
					0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
					0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
					0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
					0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
					0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
					0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
					0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
					0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
					0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
					0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
					0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
					0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
					0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
					0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
					0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
					0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
					0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
					0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
					0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
					0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
					0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
					0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
					0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
				];

				if (typeof(crc) == "undefined")
				{
					crc = 0;
				}
				var x = 0;
				var y = 0;

				crc = crc ^ (-1);
				for (var i = 0, iTop = str.length; i < iTop; i++)
				{
					y = ( crc ^ str.charCodeAt(i) ) & 0xFF;
					x = table[y];
					crc = ( crc >>> 8 ) ^ x;
				}

				return crc ^ (-1);
			},

			// Inspired by http://my.opera.com/GreyWyvern/blog/show.dml/1725165
			clone: function ()
			{
				var newObj = new JSZip();
				for (var i in this)
				{
					if (typeof this[i] !== "function")
					{
						newObj[i] = this[i];
					}
				}
				return newObj;
			},


			/**
			 * http://www.webtoolkit.info/javascript-utf8.html
			 */
			utf8encode: function (string)
			{
				var utftext = "";

				for (var n = 0; n < string.length; n++)
				{

					var c = string.charCodeAt(n);

					if (c < 128)
					{
						utftext += String.fromCharCode(c);
					}
					else if ((c > 127) && (c < 2048))
					{
						utftext += String.fromCharCode((c >> 6) | 192);
						utftext += String.fromCharCode((c & 63) | 128);
					}
					else
					{
						utftext += String.fromCharCode((c >> 12) | 224);
						utftext += String.fromCharCode(((c >> 6) & 63) | 128);
						utftext += String.fromCharCode((c & 63) | 128);
					}

				}

				return utftext;
			},

			/**
			 * http://www.webtoolkit.info/javascript-utf8.html
			 */
			utf8decode: function (utftext)
			{
				var string = "";
				var i = 0;
				var c = 0, c1 = 0, c2 = 0, c3 = 0;

				while (i < utftext.length)
				{

					c = utftext.charCodeAt(i);

					if (c < 128)
					{
						string += String.fromCharCode(c);
						i++;
					}
					else if ((c > 191) && (c < 224))
					{
						c2 = utftext.charCodeAt(i + 1);
						string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
						i += 2;
					}
					else
					{
						c2 = utftext.charCodeAt(i + 1);
						c3 = utftext.charCodeAt(i + 2);
						string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
						i += 3;
					}

				}

				return string;
			}
		};
	}());

	/*
	 * Compression methods
	 * This object is filled in as follow :
	 * name : {
	 *    magic // the 2 bytes indentifying the compression method
	 *    compress // function, take the uncompressed content and return it compressed.
	 *    uncompress // function, take the compressed content and return it uncompressed.
	 * }
	 *
	 * STORE is the default compression method, so it's included in this file.
	 * Other methods should go to separated files : the user wants modularity.
	 */
	JSZip.compressions = {
		"STORE": {
			magic:      "\x00\x00",
			compress:   function (content)
			{
				return content; // no compression
			},
			uncompress: function (content)
			{
				return content; // no compression
			}
		}
	};

	/*
	 * List features that require a modern browser, and if the current browser support them.
	 */
	JSZip.support = {
		// contains true if JSZip can read/generate ArrayBuffer, false otherwise.
		arraybuffer: (function ()
		{
			return typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
		})(),
		// contains true if JSZip can read/generate Uint8Array, false otherwise.
		uint8array:  (function ()
		{
			return typeof Uint8Array !== "undefined";
		})(),
		// contains true if JSZip can read/generate Blob, false otherwise.
		blob:        (function ()
		{
			// the spec started with BlobBuilder then replaced it with a construtor for Blob.
			// Result : we have browsers that :
			// * know the BlobBuilder (but with prefix)
			// * know the Blob constructor
			// * know about Blob but not about how to build them
			// About the "=== 0" test : if given the wrong type, it may be converted to a string.
			// Instead of an empty content, we will get "[object Uint8Array]" for example.
			if (typeof ArrayBuffer === "undefined")
			{
				return false;
			}
			var buffer = new ArrayBuffer(0);
			try
			{
				return new Blob([buffer], { type: "application/zip" }).size === 0;
			}
			catch (e)
			{
			}

			try
			{
				var builder = new (window.BlobBuilder || window.WebKitBlobBuilder ||
					window.MozBlobBuilder || window.MSBlobBuilder)();
				builder.append(buffer);
				return builder.getBlob('application/zip').size === 0;
			}
			catch (e)
			{
			}

			return false;
		})()
	};

	JSZip.utils = {
		/**
		 * Convert a string to a "binary string" : a string containing only char codes between 0 and 255.
		 * @param {string} str the string to transform.
		 * @return {String} the binary string.
		 */
		string2binary:     function (str)
		{
			var result = "";
			for (var i = 0; i < str.length; i++)
			{
				result += String.fromCharCode(str.charCodeAt(i) & 0xff);
			}
			return result;
		},
		/**
		 * Create a Uint8Array from the string.
		 * @param {string} str the string to transform.
		 * @return {Uint8Array} the typed array.
		 * @throws {Error} an Error if the browser doesn't support the requested feature.
		 */
		string2Uint8Array: function (str)
		{
			if (!JSZip.support.uint8array)
			{
				throw new Error("Uint8Array is not supported by this browser");
			}
			var buffer = new ArrayBuffer(str.length);
			var bufferView = new Uint8Array(buffer);
			for (var i = 0; i < str.length; i++)
			{
				bufferView[i] = str.charCodeAt(i);
			}

			return bufferView;
		},

		/**
		 * Create a string from the Uint8Array.
		 * @param {Uint8Array} array the array to transform.
		 * @return {string} the string.
		 * @throws {Error} an Error if the browser doesn't support the requested feature.
		 */
		uint8Array2String: function (array)
		{
			if (!JSZip.support.uint8array)
			{
				throw new Error("Uint8Array is not supported by this browser");
			}
			var result = "";
			for (var i = 0; i < array.length; i++)
			{
				result += String.fromCharCode(array[i]);
			}

			return result;
		},
		/**
		 * Create a blob from the given string.
		 * @param {string} str the string to transform.
		 * @return {Blob} the string.
		 * @throws {Error} an Error if the browser doesn't support the requested feature.
		 */
		string2Blob:       function (str)
		{
			if (!JSZip.support.blob)
			{
				throw new Error("Blob is not supported by this browser");
			}

			var buffer = JSZip.utils.string2Uint8Array(str).buffer;
			try
			{
				// Blob constructor
				return new Blob([buffer], { type: "application/zip" });
			}
			catch (e)
			{
			}

			try
			{
				// deprecated, browser only, old way
				var builder = new (window.BlobBuilder || window.WebKitBlobBuilder ||
					window.MozBlobBuilder || window.MSBlobBuilder)();
				builder.append(buffer);
				return builder.getBlob('application/zip');
			}
			catch (e)
			{
			}

			// well, fuck ?!
			throw new Error("Bug : can't construct the Blob.");
		}
	};

	/**
	 *
	 *  Base64 encode / decode
	 *  http://www.webtoolkit.info/
	 *
	 *  Hacked so that it doesn't utf8 en/decode everything
	 **/
	var JSZipBase64 = (function ()
	{
		// private property
		var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

		return {
			// public method for encoding
			encode: function (input, utf8)
			{
				var output = "";
				var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
				var i = 0;

				while (i < input.length)
				{

					chr1 = input.charCodeAt(i++);
					chr2 = input.charCodeAt(i++);
					chr3 = input.charCodeAt(i++);

					enc1 = chr1 >> 2;
					enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
					enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
					enc4 = chr3 & 63;

					if (isNaN(chr2))
					{
						enc3 = enc4 = 64;
					}
					else if (isNaN(chr3))
					{
						enc4 = 64;
					}

					output = output +
						_keyStr.charAt(enc1) + _keyStr.charAt(enc2) +
						_keyStr.charAt(enc3) + _keyStr.charAt(enc4);

				}

				return output;
			},

			// public method for decoding
			decode: function (input, utf8)
			{
				var output = "";
				var chr1, chr2, chr3;
				var enc1, enc2, enc3, enc4;
				var i = 0;

				input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

				while (i < input.length)
				{

					enc1 = _keyStr.indexOf(input.charAt(i++));
					enc2 = _keyStr.indexOf(input.charAt(i++));
					enc3 = _keyStr.indexOf(input.charAt(i++));
					enc4 = _keyStr.indexOf(input.charAt(i++));

					chr1 = (enc1 << 2) | (enc2 >> 4);
					chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
					chr3 = ((enc3 & 3) << 6) | enc4;

					output = output + String.fromCharCode(chr1);

					if (enc3 != 64)
					{
						output = output + String.fromCharCode(chr2);
					}
					if (enc4 != 64)
					{
						output = output + String.fromCharCode(chr3);
					}

				}

				return output;

			}
		};
	}());

	// enforcing Stuk's coding style
	// vim: set shiftwidth=3 softtabstop=3:
	/*
	 * Port of a script by Masanao Izumo.
	 *
	 * Only changes : wrap all the variables in a function and add the 
	 * main function to JSZip (DEFLATE compression method).
	 * Everything else was written by M. Izumo.
	 *
	 * Original code can be found here: http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt
	 */

	if (!JSZip)
	{
		throw "JSZip not defined";
	}

	/*
	 * Original:
	 *   http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt
	 */

	(function ()
	{
		// the original implementation leaks a global variable.
		// Defining the variable here doesn't break anything.
		var zip_fixed_bd;

		/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
		 * Version: 1.0.0.1
		 * LastModified: Dec 25 1999
		 */

		/* Interface:
		 * data = zip_inflate(src);
		 */

		/* constant parameters */
		var zip_WSIZE = 32768;		// Sliding Window size
		var zip_STORED_BLOCK = 0;
		var zip_STATIC_TREES = 1;
		var zip_DYN_TREES = 2;

		/* for inflate */
		var zip_lbits = 9; 		// bits in base literal/length lookup table
		var zip_dbits = 6; 		// bits in base distance lookup table
		var zip_INBUFSIZ = 32768;	// Input buffer size
		var zip_INBUF_EXTRA = 64;	// Extra buffer

		/* variables (inflate) */
		var zip_slide;
		var zip_wp;			// current position in slide
		var zip_fixed_tl = null;	// inflate static
		var zip_fixed_td;		// inflate static
		var zip_fixed_bl, fixed_bd;	// inflate static
		var zip_bit_buf;		// bit buffer
		var zip_bit_len;		// bits in bit buffer
		var zip_method;
		var zip_eof;
		var zip_copy_leng;
		var zip_copy_dist;
		var zip_tl, zip_td;	// literal/length and distance decoder tables
		var zip_bl, zip_bd;	// number of bits decoded by tl and td

		var zip_inflate_data;
		var zip_inflate_pos;


		/* constant tables (inflate) */
		var zip_MASK_BITS = new Array(
			0x0000,
			0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
			0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff);
		// Tables for deflate from PKZIP's appnote.txt.
		var zip_cplens = new Array( // Copy lengths for literal codes 257..285
			3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
			35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0);
		/* note: see note #13 above about the 258 in this list. */
		var zip_cplext = new Array( // Extra bits for literal codes 257..285
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
			3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99); // 99==invalid
		var zip_cpdist = new Array( // Copy offsets for distance codes 0..29
			1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
			257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
			8193, 12289, 16385, 24577);
		var zip_cpdext = new Array( // Extra bits for distance codes
			0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
			7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
			12, 12, 13, 13);
		var zip_border = new Array(  // Order of the bit length code lengths
			16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15);
		/* objects (inflate) */

		function zip_HuftList()
		{
			this.next = null;
			this.list = null;
		}

		function zip_HuftNode()
		{
			this.e = 0; // number of extra bits or operation
			this.b = 0; // number of bits in this code or subcode

			// union
			this.n = 0; // literal, length base, or distance base
			this.t = null; // (zip_HuftNode) pointer to next level of table
		}

		function zip_HuftBuild(b,	// code lengths in bits (all assumed <= BMAX)
			n,	// number of codes (assumed <= N_MAX)
			s,	// number of simple-valued codes (0..s-1)
			d,	// list of base values for non-simple codes
			e,	// list of extra bits for non-simple codes
			mm	// maximum lookup bits
			)
		{
			this.BMAX = 16;   // maximum bit length of any code
			this.N_MAX = 288; // maximum number of codes in any set
			this.status = 0;	// 0: success, 1: incomplete table, 2: bad input
			this.root = null;	// (zip_HuftList) starting table
			this.m = 0;		// maximum lookup bits, returns actual

			/* Given a list of code lengths and a maximum table size, make a set of
			 tables to decode that set of codes.	Return zero on success, one if
			 the given code set is incomplete (the tables are still built in this
			 case), two if the input is invalid (all zero length codes or an
			 oversubscribed set of lengths), and three if not enough memory.
			 The code with value 256 is special, and the tables are constructed
			 so that no bits beyond that code are fetched when that code is
			 decoded. */
			{
				var a;			// counter for codes of length k
				var c = new Array(this.BMAX + 1);	// bit length count table
				var el;			// length of EOB code (value 256)
				var f;			// i repeats in table every f entries
				var g;			// maximum code length
				var h;			// table level
				var i;			// counter, current code
				var j;			// counter
				var k;			// number of bits in current code
				var lx = new Array(this.BMAX + 1);	// stack of bits per table
				var p;			// pointer into c[], b[], or v[]
				var pidx;		// index of p
				var q;			// (zip_HuftNode) points to current table
				var r = new zip_HuftNode(); // table entry for structure assignment
				var u = new Array(this.BMAX); // zip_HuftNode[BMAX][]  table stack
				var v = new Array(this.N_MAX); // values in order of bit length
				var w;
				var x = new Array(this.BMAX + 1);// bit offsets, then code stack
				var xp;			// pointer into x or c
				var y;			// number of dummy codes added
				var z;			// number of entries in current table
				var o;
				var tail;		// (zip_HuftList)

				tail = this.root = null;
				for (i = 0; i < c.length; i++)
					c[i] = 0;
				for (i = 0; i < lx.length; i++)
					lx[i] = 0;
				for (i = 0; i < u.length; i++)
					u[i] = null;
				for (i = 0; i < v.length; i++)
					v[i] = 0;
				for (i = 0; i < x.length; i++)
					x[i] = 0;

				// Generate counts for each bit length
				el = n > 256 ? b[256] : this.BMAX; // set length of EOB code, if any
				p = b;
				pidx = 0;
				i = n;
				do {
					c[p[pidx]]++;	// assume all entries <= BMAX
					pidx++;
				} while (--i > 0);
				if (c[0] == n)
				{	// null input--all zero length codes
					this.root = null;
					this.m = 0;
					this.status = 0;
					return;
				}

				// Find minimum and maximum length, bound *m by those
				for (j = 1; j <= this.BMAX; j++)
					if (c[j] != 0)
						break;
				k = j;			// minimum code length
				if (mm < j)
					mm = j;
				for (i = this.BMAX; i != 0; i--)
					if (c[i] != 0)
						break;
				g = i;			// maximum code length
				if (mm > i)
					mm = i;

				// Adjust last length count to fill out codes, if needed
				for (y = 1 << j; j < i; j++, y <<= 1)
					if ((y -= c[j]) < 0)
					{
						this.status = 2;	// bad input: more codes than bits
						this.m = mm;
						return;
					}
				if ((y -= c[i]) < 0)
				{
					this.status = 2;
					this.m = mm;
					return;
				}
				c[i] += y;

				// Generate starting offsets into the value table for each length
				x[1] = j = 0;
				p = c;
				pidx = 1;
				xp = 2;
				while (--i > 0)		// note that i == g from above
					x[xp++] = (j += p[pidx++]);

				// Make a table of values in order of bit lengths
				p = b;
				pidx = 0;
				i = 0;
				do {
					if ((j = p[pidx++]) != 0)
						v[x[j]++] = i;
				} while (++i < n);
				n = x[g];			// set n to length of v

				// Generate the Huffman codes and for each, make the table entries
				x[0] = i = 0;		// first Huffman code is zero
				p = v;
				pidx = 0;		// grab values in bit order
				h = -1;			// no tables yet--level -1
				w = lx[0] = 0;		// no bits decoded yet
				q = null;			// ditto
				z = 0;			// ditto

				// go through the bit lengths (k already is bits in shortest code)
				for (; k <= g; k++)
				{
					a = c[k];
					while (a-- > 0)
					{
						// here i is the Huffman code of length k bits for value p[pidx]
						// make tables up to required level
						while (k > w + lx[1 + h])
						{
							w += lx[1 + h]; // add bits already decoded
							h++;

							// compute minimum size table less than or equal to *m bits
							z = (z = g - w) > mm ? mm : z; // upper limit
							if ((f = 1 << (j = k - w)) > a + 1)
							{ // try a k-w bit table
								// too few codes for k-w bit table
								f -= a + 1;	// deduct codes from patterns left
								xp = k;
								while (++j < z)
								{ // try smaller tables up to z bits
									if ((f <<= 1) <= c[++xp])
										break;	// enough codes to use up j bits
									f -= c[xp];	// else deduct codes from patterns
								}
							}
							if (w + j > el && w < el)
								j = el - w;	// make EOB code end at table
							z = 1 << j;	// table entries for j-bit table
							lx[1 + h] = j; // set table size in stack

							// allocate and link in new table
							q = new Array(z);
							for (o = 0; o < z; o++)
							{
								q[o] = new zip_HuftNode();
							}

							if (tail == null)
								tail = this.root = new zip_HuftList();
							else
								tail = tail.next = new zip_HuftList();
							tail.next = null;
							tail.list = q;
							u[h] = q;	// table starts after link

							/* connect to last table, if there is one */
							if (h > 0)
							{
								x[h] = i;		// save pattern for backing up
								r.b = lx[h];	// bits to dump before this table
								r.e = 16 + j;	// bits in this table
								r.t = q;		// pointer to this table
								j = (i & ((1 << w) - 1)) >> (w - lx[h]);
								u[h - 1][j].e = r.e;
								u[h - 1][j].b = r.b;
								u[h - 1][j].n = r.n;
								u[h - 1][j].t = r.t;
							}
						}

						// set up table entry in r
						r.b = k - w;
						if (pidx >= n)
							r.e = 99;		// out of values--invalid code
						else if (p[pidx] < s)
						{
							r.e = (p[pidx] < 256 ? 16 : 15); // 256 is end-of-block code
							r.n = p[pidx++];	// simple code is just the value
						}
						else
						{
							r.e = e[p[pidx] - s];	// non-simple--look up in lists
							r.n = d[p[pidx++] - s];
						}

						// fill code-like entries with r //
						f = 1 << (k - w);
						for (j = i >> w; j < z; j += f)
						{
							q[j].e = r.e;
							q[j].b = r.b;
							q[j].n = r.n;
							q[j].t = r.t;
						}

						// backwards increment the k-bit code i
						for (j = 1 << (k - 1); (i & j) != 0; j >>= 1)
							i ^= j;
						i ^= j;

						// backup over finished tables
						while ((i & ((1 << w) - 1)) != x[h])
						{
							w -= lx[h];		// don't need to update q
							h--;
						}
					}
				}

				/* return actual size of base table */
				this.m = lx[1];

				/* Return true (1) if we were given an incomplete table */
				this.status = ((y != 0 && g != 1) ? 1 : 0);
			}
			/* end of constructor */
		}


		/* routines (inflate) */

		function zip_GET_BYTE()
		{
			if (zip_inflate_data.length == zip_inflate_pos)
				return -1;
			return zip_inflate_data.charCodeAt(zip_inflate_pos++) & 0xff;
		}

		function zip_NEEDBITS(n)
		{
			while (zip_bit_len < n)
			{
				zip_bit_buf |= zip_GET_BYTE() << zip_bit_len;
				zip_bit_len += 8;
			}
		}

		function zip_GETBITS(n)
		{
			return zip_bit_buf & zip_MASK_BITS[n];
		}

		function zip_DUMPBITS(n)
		{
			zip_bit_buf >>= n;
			zip_bit_len -= n;
		}

		function zip_inflate_codes(buff, off, size)
		{
			/* inflate (decompress) the codes in a deflated (compressed) block.
			 Return an error code or zero if it all goes ok. */
			var e;		// table entry flag/number of extra bits
			var t;		// (zip_HuftNode) pointer to table entry
			var n;

			if (size == 0)
				return 0;

			// inflate the coded data
			n = 0;
			for (; ;)
			{			// do until end of block
				zip_NEEDBITS(zip_bl);
				t = zip_tl.list[zip_GETBITS(zip_bl)];
				e = t.e;
				while (e > 16)
				{
					if (e == 99)
						return -1;
					zip_DUMPBITS(t.b);
					e -= 16;
					zip_NEEDBITS(e);
					t = t.t[zip_GETBITS(e)];
					e = t.e;
				}
				zip_DUMPBITS(t.b);

				if (e == 16)
				{		// then it's a literal
					zip_wp &= zip_WSIZE - 1;
					buff[off + n++] = zip_slide[zip_wp++] = t.n;
					if (n == size)
						return size;
					continue;
				}

				// exit if end of block
				if (e == 15)
					break;

				// it's an EOB or a length

				// get length of block to copy
				zip_NEEDBITS(e);
				zip_copy_leng = t.n + zip_GETBITS(e);
				zip_DUMPBITS(e);

				// decode distance of block to copy
				zip_NEEDBITS(zip_bd);
				t = zip_td.list[zip_GETBITS(zip_bd)];
				e = t.e;

				while (e > 16)
				{
					if (e == 99)
						return -1;
					zip_DUMPBITS(t.b);
					e -= 16;
					zip_NEEDBITS(e);
					t = t.t[zip_GETBITS(e)];
					e = t.e;
				}
				zip_DUMPBITS(t.b);
				zip_NEEDBITS(e);
				zip_copy_dist = zip_wp - t.n - zip_GETBITS(e);
				zip_DUMPBITS(e);

				// do the copy
				while (zip_copy_leng > 0 && n < size)
				{
					zip_copy_leng--;
					zip_copy_dist &= zip_WSIZE - 1;
					zip_wp &= zip_WSIZE - 1;
					buff[off + n++] = zip_slide[zip_wp++]
						= zip_slide[zip_copy_dist++];
				}

				if (n == size)
					return size;
			}

			zip_method = -1; // done
			return n;
		}

		function zip_inflate_stored(buff, off, size)
		{
			/* "decompress" an inflated type 0 (stored) block. */
			var n;

			// go to byte boundary
			n = zip_bit_len & 7;
			zip_DUMPBITS(n);

			// get the length and its complement
			zip_NEEDBITS(16);
			n = zip_GETBITS(16);
			zip_DUMPBITS(16);
			zip_NEEDBITS(16);
			if (n != ((~zip_bit_buf) & 0xffff))
				return -1;			// error in compressed data
			zip_DUMPBITS(16);

			// read and output the compressed data
			zip_copy_leng = n;

			n = 0;
			while (zip_copy_leng > 0 && n < size)
			{
				zip_copy_leng--;
				zip_wp &= zip_WSIZE - 1;
				zip_NEEDBITS(8);
				buff[off + n++] = zip_slide[zip_wp++] =
					zip_GETBITS(8);
				zip_DUMPBITS(8);
			}

			if (zip_copy_leng == 0)
				zip_method = -1; // done
			return n;
		}

		function zip_inflate_fixed(buff, off, size)
		{
			/* decompress an inflated type 1 (fixed Huffman codes) block.  We should
			 either replace this with a custom decoder, or at least precompute the
			 Huffman tables. */

			// if first time, set up tables for fixed blocks
			if (zip_fixed_tl == null)
			{
				var i;			// temporary variable
				var l = new Array(288);	// length list for huft_build
				var h;	// zip_HuftBuild

				// literal table
				for (i = 0; i < 144; i++)
					l[i] = 8;
				for (; i < 256; i++)
					l[i] = 9;
				for (; i < 280; i++)
					l[i] = 7;
				for (; i < 288; i++)	// make a complete, but wrong code set
					l[i] = 8;
				zip_fixed_bl = 7;

				h = new zip_HuftBuild(l, 288, 257, zip_cplens, zip_cplext,
					zip_fixed_bl);
				if (h.status != 0)
				{
					alert("HufBuild error: " + h.status);
					return -1;
				}
				zip_fixed_tl = h.root;
				zip_fixed_bl = h.m;

				// distance table
				for (i = 0; i < 30; i++)	// make an incomplete code set
					l[i] = 5;
				zip_fixed_bd = 5;

				h = new zip_HuftBuild(l, 30, 0, zip_cpdist, zip_cpdext, zip_fixed_bd);
				if (h.status > 1)
				{
					zip_fixed_tl = null;
					alert("HufBuild error: " + h.status);
					return -1;
				}
				zip_fixed_td = h.root;
				zip_fixed_bd = h.m;
			}

			zip_tl = zip_fixed_tl;
			zip_td = zip_fixed_td;
			zip_bl = zip_fixed_bl;
			zip_bd = zip_fixed_bd;
			return zip_inflate_codes(buff, off, size);
		}

		function zip_inflate_dynamic(buff, off, size)
		{
			// decompress an inflated type 2 (dynamic Huffman codes) block.
			var i;		// temporary variables
			var j;
			var l;		// last length
			var n;		// number of lengths to get
			var t;		// (zip_HuftNode) literal/length code table
			var nb;		// number of bit length codes
			var nl;		// number of literal/length codes
			var nd;		// number of distance codes
			var ll = new Array(286 + 30); // literal/length and distance code lengths
			var h;		// (zip_HuftBuild)

			for (i = 0; i < ll.length; i++)
				ll[i] = 0;

			// read in table lengths
			zip_NEEDBITS(5);
			nl = 257 + zip_GETBITS(5);	// number of literal/length codes
			zip_DUMPBITS(5);
			zip_NEEDBITS(5);
			nd = 1 + zip_GETBITS(5);	// number of distance codes
			zip_DUMPBITS(5);
			zip_NEEDBITS(4);
			nb = 4 + zip_GETBITS(4);	// number of bit length codes
			zip_DUMPBITS(4);
			if (nl > 286 || nd > 30)
				return -1;		// bad lengths

			// read in bit-length-code lengths
			for (j = 0; j < nb; j++)
			{
				zip_NEEDBITS(3);
				ll[zip_border[j]] = zip_GETBITS(3);
				zip_DUMPBITS(3);
			}
			for (; j < 19; j++)
				ll[zip_border[j]] = 0;

			// build decoding table for trees--single level, 7 bit lookup
			zip_bl = 7;
			h = new zip_HuftBuild(ll, 19, 19, null, null, zip_bl);
			if (h.status != 0)
				return -1;	// incomplete code set

			zip_tl = h.root;
			zip_bl = h.m;

			// read in literal and distance code lengths
			n = nl + nd;
			i = l = 0;
			while (i < n)
			{
				zip_NEEDBITS(zip_bl);
				t = zip_tl.list[zip_GETBITS(zip_bl)];
				j = t.b;
				zip_DUMPBITS(j);
				j = t.n;
				if (j < 16)		// length of code in bits (0..15)
					ll[i++] = l = j;	// save last length in l
				else if (j == 16)
				{	// repeat last length 3 to 6 times
					zip_NEEDBITS(2);
					j = 3 + zip_GETBITS(2);
					zip_DUMPBITS(2);
					if (i + j > n)
						return -1;
					while (j-- > 0)
						ll[i++] = l;
				}
				else if (j == 17)
				{	// 3 to 10 zero length codes
					zip_NEEDBITS(3);
					j = 3 + zip_GETBITS(3);
					zip_DUMPBITS(3);
					if (i + j > n)
						return -1;
					while (j-- > 0)
						ll[i++] = 0;
					l = 0;
				}
				else
				{		// j == 18: 11 to 138 zero length codes
					zip_NEEDBITS(7);
					j = 11 + zip_GETBITS(7);
					zip_DUMPBITS(7);
					if (i + j > n)
						return -1;
					while (j-- > 0)
						ll[i++] = 0;
					l = 0;
				}
			}

			// build the decoding tables for literal/length and distance codes
			zip_bl = zip_lbits;
			h = new zip_HuftBuild(ll, nl, 257, zip_cplens, zip_cplext, zip_bl);
			if (zip_bl == 0)	// no literals or lengths
				h.status = 1;
			if (h.status != 0)
			{
				if (h.status == 1)
					;// **incomplete literal tree**
				return -1;		// incomplete code set
			}
			zip_tl = h.root;
			zip_bl = h.m;

			for (i = 0; i < nd; i++)
				ll[i] = ll[i + nl];
			zip_bd = zip_dbits;
			h = new zip_HuftBuild(ll, nd, 0, zip_cpdist, zip_cpdext, zip_bd);
			zip_td = h.root;
			zip_bd = h.m;

			if (zip_bd == 0 && nl > 257)
			{   // lengths but no distances
				// **incomplete distance tree**
				return -1;
			}

			if (h.status == 1)
			{
				;// **incomplete distance tree**
			}
			if (h.status != 0)
				return -1;

			// decompress until an end-of-block code
			return zip_inflate_codes(buff, off, size);
		}

		function zip_inflate_start()
		{
			var i;

			if (zip_slide == null)
				zip_slide = new Array(2 * zip_WSIZE);
			zip_wp = 0;
			zip_bit_buf = 0;
			zip_bit_len = 0;
			zip_method = -1;
			zip_eof = false;
			zip_copy_leng = zip_copy_dist = 0;
			zip_tl = null;
		}

		function zip_inflate_internal(buff, off, size)
		{
			// decompress an inflated entry
			var n, i;

			n = 0;
			while (n < size)
			{
				if (zip_eof && zip_method == -1)
					return n;

				if (zip_copy_leng > 0)
				{
					if (zip_method != zip_STORED_BLOCK)
					{
						// STATIC_TREES or DYN_TREES
						while (zip_copy_leng > 0 && n < size)
						{
							zip_copy_leng--;
							zip_copy_dist &= zip_WSIZE - 1;
							zip_wp &= zip_WSIZE - 1;
							buff[off + n++] = zip_slide[zip_wp++] =
								zip_slide[zip_copy_dist++];
						}
					}
					else
					{
						while (zip_copy_leng > 0 && n < size)
						{
							zip_copy_leng--;
							zip_wp &= zip_WSIZE - 1;
							zip_NEEDBITS(8);
							buff[off + n++] = zip_slide[zip_wp++] = zip_GETBITS(8);
							zip_DUMPBITS(8);
						}
						if (zip_copy_leng == 0)
							zip_method = -1; // done
					}
					if (n == size)
						return n;
				}

				if (zip_method == -1)
				{
					if (zip_eof)
						break;

					// read in last block bit
					zip_NEEDBITS(1);
					if (zip_GETBITS(1) != 0)
						zip_eof = true;
					zip_DUMPBITS(1);

					// read in block type
					zip_NEEDBITS(2);
					zip_method = zip_GETBITS(2);
					zip_DUMPBITS(2);
					zip_tl = null;
					zip_copy_leng = 0;
				}

				switch (zip_method)
				{
					case 0: // zip_STORED_BLOCK
						i = zip_inflate_stored(buff, off + n, size - n);
						break;

					case 1: // zip_STATIC_TREES
						if (zip_tl != null)
							i = zip_inflate_codes(buff, off + n, size - n);
						else
							i = zip_inflate_fixed(buff, off + n, size - n);
						break;

					case 2: // zip_DYN_TREES
						if (zip_tl != null)
							i = zip_inflate_codes(buff, off + n, size - n);
						else
							i = zip_inflate_dynamic(buff, off + n, size - n);
						break;

					default: // error
						i = -1;
						break;
				}

				if (i == -1)
				{
					if (zip_eof)
						return 0;
					return -1;
				}
				n += i;
			}
			return n;
		}

		function zip_inflate(str)
		{
			var out, buff;
			var i, j;

			zip_inflate_start();
			zip_inflate_data = str;
			zip_inflate_pos = 0;

			buff = new Array(1024);
			out = "";
			while ((i = zip_inflate_internal(buff, 0, buff.length)) > 0)
			{
				for (j = 0; j < i; j++)
					out += String.fromCharCode(buff[j]);
			}
			zip_inflate_data = null; // G.C.
			return out;
		}

		//
		// end of the script of Masanao Izumo.
		//

		// we add the compression method for JSZip
		if (!JSZip.compressions["DEFLATE"])
		{
			JSZip.compressions["DEFLATE"] = {
				magic:      "\x08\x00",
				uncompress: zip_inflate
			}
		}
		else
		{
			JSZip.compressions["DEFLATE"].uncompress = zip_inflate;
		}

	})();

	// enforcing Stuk's coding style
	// vim: set shiftwidth=3 softtabstop=3:
	/**

	 JSZip - A Javascript class for generating and reading zip files
	 <http://stuartk.com/jszip>

	 (c) 2011 David Duponchel <d.duponchel@gmail.com>
	 Dual licenced under the MIT license or GPLv3. See LICENSE.markdown.

	 **/
	/*global JSZip,JSZipBase64 */
	(function ()
	{

		var MAX_VALUE_16BITS = 65535;
		var MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

		/**
		 * Prettify a string read as binary.
		 * @param {string} str the string to prettify.
		 * @return {string} a pretty string.
		 */
		var pretty = function (str)
		{
			var res = '', code, i;
			for (i = 0; i < (str || "").length; i++)
			{
				code = str.charCodeAt(i);
				res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
			}
			return res;
		};

		/**
		 * Find a compression registered in JSZip.
		 * @param {string} compressionMethod the method magic to find.
		 * @return {Object|null} the JSZip compression object, null if none found.
		 */
		var findCompression = function (compressionMethod)
		{
			for (var method in JSZip.compressions)
			{
				if (!JSZip.compressions.hasOwnProperty(method))
				{
					continue;
				}
				if (JSZip.compressions[method].magic === compressionMethod)
				{
					return JSZip.compressions[method];
				}
			}
			return null;
		};

		// class StreamReader {{{
		/**
		 * Read bytes from a stream.
		 * Developer tip : when debugging, a watch on pretty(this.reader.stream.slice(this.reader.index))
		 * is very useful :)
		 * @constructor
		 * @param {String|ArrayBuffer|Uint8Array} stream the stream to read.
		 */
		function StreamReader(stream)
		{
			this.stream = "";
			if (JSZip.support.uint8array && stream instanceof Uint8Array)
			{
				this.stream = JSZip.utils.uint8Array2String(stream);
			}
			else if (JSZip.support.arraybuffer && stream instanceof ArrayBuffer)
			{
				var bufferView = new Uint8Array(stream);
				this.stream = JSZip.utils.uint8Array2String(bufferView);
			}
			else
			{
				this.stream = JSZip.utils.string2binary(stream);
			}
			this.index = 0;
		}

		StreamReader.prototype = {
			/**
			 * Check that the offset will not go too far.
			 * @param {string} offset the additional offset to check.
			 * @throws {Error} an Error if the offset is out of bounds.
			 */
			checkOffset: function (offset)
			{
				this.checkIndex(this.index + offset);
			},
			/**
			 * Check that the specifed index will not be too far.
			 * @param {string} newIndex the index to check.
			 * @throws {Error} an Error if the index is out of bounds.
			 */
			checkIndex:  function (newIndex)
			{
				if (this.stream.length < newIndex || newIndex < 0)
				{
					throw new Error("End of stream reached (stream length = " +
						this.stream.length + ", asked index = " +
						(newIndex) + "). Corrupted zip ?");
				}
			},
			/**
			 * Change the index.
			 * @param {number} newIndex The new index.
			 * @throws {Error} if the new index is out of the stream.
			 */
			setIndex:    function (newIndex)
			{
				this.checkIndex(newIndex);
				this.index = newIndex;
			},
			/**
			 * Skip the next n bytes.
			 * @param {number} n the number of bytes to skip.
			 * @throws {Error} if the new index is out of the stream.
			 */
			skip:        function (n)
			{
				this.setIndex(this.index + n);
			},
			/**
			 * Get the byte at the specified index.
			 * @param {number} i the index to use.
			 * @return {number} a byte.
			 */
			byteAt:      function (i)
			{
				return this.stream.charCodeAt(i);
			},
			/**
			 * Get the next number with a given byte size.
			 * @param {number} size the number of bytes to read.
			 * @return {number} the corresponding number.
			 */
			readInt:     function (size)
			{
				var result = 0, i;
				this.checkOffset(size);
				for (i = this.index + size - 1; i >= this.index; i--)
				{
					result = (result << 8) + this.byteAt(i);
				}
				this.index += size;
				return result;
			},
			/**
			 * Get the next string with a given byte size.
			 * @param {number} size the number of bytes to read.
			 * @return {string} the corresponding string.
			 */
			readString:  function (size)
			{
				this.checkOffset(size);
				// this will work because the constructor applied the "& 0xff" mask.
				var result = this.stream.slice(this.index, this.index + size);
				this.index += size;
				return result;
			},
			/**
			 * Get the next date.
			 * @return {Date} the date.
			 */
			readDate:    function ()
			{
				var dostime = this.readInt(4);
				return new Date(
					((dostime >> 25) & 0x7f) + 1980, // year
					((dostime >> 21) & 0x0f) - 1, // month
					(dostime >> 16) & 0x1f, // day
					(dostime >> 11) & 0x1f, // hour
					(dostime >> 5) & 0x3f, // minute
					(dostime & 0x1f) << 1); // second
			}
		};
		// }}} end of StreamReader

		// class ZipEntry {{{
		/**
		 * An entry in the zip file.
		 * @constructor
		 * @param {Object} options Options of the current file.
		 * @param {Object} loadOptions Options for loading the stream.
		 */
		function ZipEntry(options, loadOptions)
		{
			this.options = options;
			this.loadOptions = loadOptions;
		}

		ZipEntry.prototype = {
			/**
			 * say if the file is encrypted.
			 * @return {boolean} true if the file is encrypted, false otherwise.
			 */
			isEncrypted:   function ()
			{
				// bit 1 is set
				return (this.bitFlag & 0x0001) === 0x0001;
			},
			/**
			 * say if the file has utf-8 filename/comment.
			 * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
			 */
			useUTF8:       function ()
			{
				// bit 11 is set
				return (this.bitFlag & 0x0800) === 0x0800;
			},
			/**
			 * Read the local part of a zip file and add the info in this object.
			 * @param {StreamReader} reader the reader to use.
			 */
			readLocalPart: function (reader)
			{
				var compression, localExtraFieldsLength;

				// we already know everything from the central dir !
				// If the central dir data are false, we are doomed.
				// On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
				// The less data we get here, the more reliable this should be.
				// Let's skip the whole header and dash to the data !
				reader.skip(22);
				// in some zip created on windows, the filename stored in the central dir contains \ instead of /.
				// Strangely, the filename here is OK.
				// I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
				// or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
				// Search "unzip mismatching "local" filename continuing with "central" filename version" on
				// the internet.
				//
				// I think I see the logic here : the central directory is used to display
				// content and the local directory is used to extract the files. Mixing / and \
				// may be used to display \ to windows users and use / when extracting the files.
				// Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
				this.fileNameLength = reader.readInt(2);
				localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
				this.fileName = reader.readString(this.fileNameLength);
				reader.skip(localExtraFieldsLength);

				if (this.compressedSize == -1 || this.uncompressedSize == -1)
				{
					throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " +
						"(compressedSize == -1 || uncompressedSize == -1)");
				}
				this.compressedFileData = reader.readString(this.compressedSize);

				compression = findCompression(this.compressionMethod);
				if (compression === null)
				{ // no compression found
					throw new Error("Corrupted zip : compression " + pretty(this.compressionMethod) +
						" unknown (inner file : " + this.fileName + ")");
				}
				this.uncompressedFileData = compression.uncompress(this.compressedFileData);

				if (this.uncompressedFileData.length !== this.uncompressedSize)
				{
					throw new Error("Bug : uncompressed data size mismatch");
				}

				if (this.loadOptions.checkCRC32 && JSZip.prototype.crc32(this.uncompressedFileData) !== this.crc32)
				{
					throw new Error("Corrupted zip : CRC32 mismatch");
				}
			},

			/**
			 * Read the central part of a zip file and add the info in this object.
			 * @param {StreamReader} reader the reader to use.
			 */
			readCentralPart:      function (reader)
			{
				this.versionMadeBy = reader.readString(2);
				this.versionNeeded = reader.readInt(2);
				this.bitFlag = reader.readInt(2);
				this.compressionMethod = reader.readString(2);
				this.date = reader.readDate();
				this.crc32 = reader.readInt(4);
				this.compressedSize = reader.readInt(4);
				this.uncompressedSize = reader.readInt(4);
				this.fileNameLength = reader.readInt(2);
				this.extraFieldsLength = reader.readInt(2);
				this.fileCommentLength = reader.readInt(2);
				this.diskNumberStart = reader.readInt(2);
				this.internalFileAttributes = reader.readInt(2);
				this.externalFileAttributes = reader.readInt(4);
				this.localHeaderOffset = reader.readInt(4);

				if (this.isEncrypted())
				{
					throw new Error("Encrypted zip are not supported");
				}

				this.fileName = reader.readString(this.fileNameLength);
				this.readExtraFields(reader);
				this.parseZIP64ExtraField(reader);
				this.fileComment = reader.readString(this.fileCommentLength);

				// warning, this is true only for zip with madeBy == DOS (plateform dependent feature)
				this.dir = this.externalFileAttributes & 0x00000010 ? true : false;
			},
			/**
			 * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
			 * @param {StreamReader} reader the reader to use.
			 */
			parseZIP64ExtraField: function (reader)
			{

				if (!this.extraFields[0x0001])
				{
					return;
				}

				// should be something, preparing the extra reader
				var extraReader = new StreamReader(this.extraFields[0x0001].value);

				// I really hope that these 64bits integer can fit in 32 bits integer, because js
				// won't let us have more.
				if (this.uncompressedSize === MAX_VALUE_32BITS)
				{
					this.uncompressedSize = extraReader.readInt(8);
				}
				if (this.compressedSize === MAX_VALUE_32BITS)
				{
					this.compressedSize = extraReader.readInt(8);
				}
				if (this.localHeaderOffset === MAX_VALUE_32BITS)
				{
					this.localHeaderOffset = extraReader.readInt(8);
				}
				if (this.diskNumberStart === MAX_VALUE_32BITS)
				{
					this.diskNumberStart = extraReader.readInt(4);
				}
			},
			/**
			 * Read the central part of a zip file and add the info in this object.
			 * @param {StreamReader} reader the reader to use.
			 */
			readExtraFields:      function (reader)
			{
				var start = reader.index,
					extraFieldId,
					extraFieldLength,
					extraFieldValue;

				this.extraFields = this.extraFields || {};

				while (reader.index < start + this.extraFieldsLength)
				{
					extraFieldId = reader.readInt(2);
					extraFieldLength = reader.readInt(2);
					extraFieldValue = reader.readString(extraFieldLength);

					this.extraFields[extraFieldId] = {
						id:     extraFieldId,
						length: extraFieldLength,
						value:  extraFieldValue
					};
				}
			},
			/**
			 * Apply an UTF8 transformation if needed.
			 */
			handleUTF8:           function ()
			{
				if (this.useUTF8())
				{
					this.fileName = JSZip.prototype.utf8decode(this.fileName);
					this.fileComment = JSZip.prototype.utf8decode(this.fileComment);
				}
			}
		};
		// }}} end of ZipEntry

		//  class ZipEntries {{{
		/**
		 * All the entries in the zip file.
		 * @constructor
		 * @param {String|ArrayBuffer|Uint8Array} data the binary stream to load.
		 * @param {Object} loadOptions Options for loading the stream.
		 */
		function ZipEntries(data, loadOptions)
		{
			this.files = [];
			this.loadOptions = loadOptions;
			if (data)
			{
				this.load(data);
			}
		}

		ZipEntries.prototype = {
			/**
			 * Check that the reader is on the speficied signature.
			 * @param {string} expectedSignature the expected signature.
			 * @throws {Error} if it is an other signature.
			 */
			checkSignature:                    function (expectedSignature)
			{
				var signature = this.reader.readString(4);
				if (signature !== expectedSignature)
				{
					throw new Error("Corrupted zip or bug : unexpected signature " +
						"(" + pretty(signature) + ", expected " + pretty(expectedSignature) + ")");
				}
			},
			/**
			 * Read the end of the central directory.
			 */
			readBlockEndOfCentral:             function ()
			{
				this.diskNumber = this.reader.readInt(2);
				this.diskWithCentralDirStart = this.reader.readInt(2);
				this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
				this.centralDirRecords = this.reader.readInt(2);
				this.centralDirSize = this.reader.readInt(4);
				this.centralDirOffset = this.reader.readInt(4);

				this.zipCommentLength = this.reader.readInt(2);
				this.zipComment = this.reader.readString(this.zipCommentLength);
			},
			/**
			 * Read the end of the Zip 64 central directory.
			 * Not merged with the method readEndOfCentral :
			 * The end of central can coexist with its Zip64 brother,
			 * I don't want to read the wrong number of bytes !
			 */
			readBlockZip64EndOfCentral:        function ()
			{
				this.zip64EndOfCentralSize = this.reader.readInt(8);
				this.versionMadeBy = this.reader.readString(2);
				this.versionNeeded = this.reader.readInt(2);
				this.diskNumber = this.reader.readInt(4);
				this.diskWithCentralDirStart = this.reader.readInt(4);
				this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
				this.centralDirRecords = this.reader.readInt(8);
				this.centralDirSize = this.reader.readInt(8);
				this.centralDirOffset = this.reader.readInt(8);

				this.zip64ExtensibleData = {};
				var extraDataSize = this.zip64EndOfCentralSize - 44,
					index = 0,
					extraFieldId,
					extraFieldLength,
					extraFieldValue;
				while (index < extraDataSize)
				{
					extraFieldId = this.reader.readInt(2);
					extraFieldLength = this.reader.readInt(4);
					extraFieldValue = this.reader.readString(extraFieldLength);
					this.zip64ExtensibleData[extraFieldId] = {
						id:     extraFieldId,
						length: extraFieldLength,
						value:  extraFieldValue
					};
				}
			},
			/**
			 * Read the end of the Zip 64 central directory locator.
			 */
			readBlockZip64EndOfCentralLocator: function ()
			{
				this.diskWithZip64CentralDirStart = this.reader.readInt(4);
				this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
				this.disksCount = this.reader.readInt(4);
				if (this.disksCount > 1)
				{
					throw new Error("Multi-volumes zip are not supported");
				}
			},
			/**
			 * Read the local files, based on the offset read in the central part.
			 */
			readLocalFiles:                    function ()
			{
				var i, file;
				for (i = 0; i < this.files.length; i++)
				{
					file = this.files[i];
					this.reader.setIndex(file.localHeaderOffset);
					this.checkSignature(JSZip.signature.LOCAL_FILE_HEADER);
					file.readLocalPart(this.reader);
					file.handleUTF8();
				}
			},
			/**
			 * Read the central directory.
			 */
			readCentralDir:                    function ()
			{
				var file;

				this.reader.setIndex(this.centralDirOffset);
				while (this.reader.readString(4) === JSZip.signature.CENTRAL_FILE_HEADER)
				{
					file = new ZipEntry({
						zip64: this.zip64
					}, this.loadOptions);
					file.readCentralPart(this.reader);
					this.files.push(file);
				}
			},
			/**
			 * Read the end of central directory.
			 */
			readEndOfCentral:                  function ()
			{
				var offset = this.reader.stream.lastIndexOf(JSZip.signature.CENTRAL_DIRECTORY_END);
				if (offset === -1)
				{
					throw new Error("Corrupted zip : can't find end of central directory");
				}
				this.reader.setIndex(offset);
				this.checkSignature(JSZip.signature.CENTRAL_DIRECTORY_END);
				this.readBlockEndOfCentral();


				/* extract from the zip spec :
				 4)  If one of the fields in the end of central directory
				 record is too small to hold required data, the field
				 should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
				 ZIP64 format record should be created.
				 5)  The end of central directory record and the
				 Zip64 end of central directory locator record must
				 reside on the same disk when splitting or spanning
				 an archive.
				 */
				if (this.diskNumber === MAX_VALUE_16BITS
					|| this.diskWithCentralDirStart === MAX_VALUE_16BITS
					|| this.centralDirRecordsOnThisDisk === MAX_VALUE_16BITS
					|| this.centralDirRecords === MAX_VALUE_16BITS
					|| this.centralDirSize === MAX_VALUE_32BITS
					|| this.centralDirOffset === MAX_VALUE_32BITS
					)
				{
					this.zip64 = true;

					/*
					 Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
					 the zip file can fit into a 32bits integer. This cannot be solved : Javascript represents
					 all numbers as 64-bit double precision IEEE 754 floating point numbers.
					 So, we have 53bits for integers and bitwise operations treat everything as 32bits.
					 see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
					 and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
					 */

					// should look for a zip64 EOCD locator
					offset = this.reader.stream.lastIndexOf(JSZip.signature.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
					if (offset === -1)
					{
						throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
					}
					this.reader.setIndex(offset);
					this.checkSignature(JSZip.signature.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
					this.readBlockZip64EndOfCentralLocator();

					// now the zip64 EOCD record
					this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
					this.checkSignature(JSZip.signature.ZIP64_CENTRAL_DIRECTORY_END);
					this.readBlockZip64EndOfCentral();
				}
			},
			/**
			 * Read a zip file and create ZipEntries.
			 * @param {String|ArrayBuffer|Uint8Array} data the binary string representing a zip file.
			 */
			load:                              function (data)
			{
				this.reader = new StreamReader(data);

				this.readEndOfCentral();
				this.readCentralDir();
				this.readLocalFiles();
			}
		};
		// }}} end of ZipEntries

		/**
		 * Implementation of the load method of JSZip.
		 * It uses the above classes to decode a zip file, and load every files.
		 * @param {String|ArrayBuffer|Uint8Array} data the data to load.
		 * @param {Object} options Options for loading the stream.
		 *  options.base64 : is the stream in base64 ? default : false
		 */
		JSZip.prototype.load = function (data, options)
		{
			var files, zipEntries, i, input;
			options = options || {};
			if (options.base64)
			{
				data = JSZipBase64.decode(data);
			}

			zipEntries = new ZipEntries(data, options);
			files = zipEntries.files;
			for (i = 0; i < files.length; i++)
			{
				input = files[i];
				this.file(input.fileName, input.uncompressedFileData, {
					binary:                true,
					optimizedBinaryString: true,
					date:                  input.date,
					dir:                   input.dir
				});
			}

			return this;
		};

	}());
	// enforcing Stuk's coding style
	// vim: set shiftwidth=3 softtabstop=3 foldmethod=marker:
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	var scripts = document.getElementsByTagName("script");
	var path = scripts[scripts.length - 1].src;
	document.srcPath = path.substring(0, path.lastIndexOf("/") + 1);

	function Runtime(canvasName, appName)
	{
		var file = new CFile();
		__scope.application = new CRunApp(canvasName, file, appName);
		file.getFile(appName, headerLoaded);
	}
	function headerLoaded()
	{
		__scope.application.load();
	}
	function updateApplication()
	{
		__scope.application.stepApplication();
	}
	__scope['Runtime'] = Runtime;
	__scope['headerLoaded'] = headerLoaded;
	__scope.ua = 'updateApplication';
	__scope[window.ua] = updateApplication;

	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	function Sprite()
	{
		this.x = 0;
		this.y = 0;
		this.visible = true;
		this.children = new Array();
		this.bZoom = false;
	}
	Sprite.prototype =
	{
		draw: function (context, xx, yy)
		{
			if (this.visible)
			{
				if (this.bZoom)
				{
					context._context.save();
					context._context.translate(this.xDest, this.yDest);
					if (this.angle != 0)
						context._context.rotate(-this.angle * 0.0174532925);
					context._context.scale(Math.max(0.001, this.scaleX), Math.max(0.001, this.scaleY));
					context._context.translate(-this.xSpot, -this.ySpot);
				}

				var n;
				for (n = 0; n < this.children.length; n++)
				{
					this.children[n].draw(context, xx + this.x, yy + this.y);
				}

				if (this.bZoom)
				{
					context._context.restore();
				}
			}
		},

		addChild: function (child)
		{
			this.children.push(child);
		},

		addChildIndex: function (child, index)
		{
			if (index >= this.children.length)
			{
				this.children.push(child);
			}
			else
			{
				if (index < 0) index = 0;
				this.children.splice(index, 0, child);
			}
		},

		removeAll: function ()
		{
			this.children.length = 0;
		},

		removeChild:    function (child)
		{
			var n;
			for (n = 0; n < this.children.length; n++)
			{
				if (this.children[n] == child)
				{
					this.children.splice(n, 1);
					return n;
				}
			}
			return -1;
		},
		getChildIndex:  function (child)
		{
			var n;
			for (n = 0; n < this.children.length; n++)
			{
				if (this.children[n] == child)
				{
					return n;
				}
			}
			return -1;
		},
		getNumChildren: function ()
		{
			return this.children.length;
		},
		setChildIndex:  function (child, index)
		{
			var n;
			var object = null;
			for (n = 0; n < this.children.length; n++)
			{
				if (this.children[n] == child)
				{
					object = this.children[n];
					break;
				}
			}
			if (object != null)
			{
				this.children.splice(n, 1);
				if (index > n)
					index--;
				if (index < 0)
					index = 0;
				if (index >= this.children.length)
					this.children.push(child);
				else
					this.children.splice(index, 0, child);
			}
		}
	}

	// CColMask object
	// ------------------------------------------------------------
	CColMask.CM_TEST_OBSTACLE = 0;
	CColMask.CM_TEST_PLATFORM = 1;
	CColMask.CM_OBSTACLE = 0x0001;
	CColMask.CM_PLATFORM = 0x0002;
	CColMask.COLMASK_XMARGIN = 64;
	CColMask.COLMASK_YMARGIN = 16;
	CColMask.HEIGHT_PLATFORM = 6;
	function CColMask()
	{
	}

	// CMask object
	// ----------------------------------------------------------------
	CMask.SCMF_FULL = 0x0000;
	CMask.SCMF_PLATFORM = 0x0001;
	CMask.GCMF_OBSTACLE = 0x0000;
	CMask.GCMF_PLATFORM = 0x0001;
	CMask.lMask =
		[
			0xFFFF,
			0x7FFF,
			0x3FFF,
			0x1FFF,
			0x0FFF,
			0x07FF,
			0x03FF,
			0x01FF,
			0x00FF,
			0x007F,
			0x003F,
			0x001F,
			0x000F,
			0x0007,
			0x0003,
			0x0001
		];
	CMask.rMask =
		[
			0x0000,
			0x8000,
			0xC000,
			0xE000,
			0xF000,
			0xF800,
			0xFC00,
			0xFE00,
			0xFF00,
			0xFF80,
			0xFFC0,
			0xFFE0,
			0xFFF0,
			0xFFF8,
			0xFFFC,
			0xFFFE,
			0xFFFF
		];
	CMask.topLeft = new CPoint();
	CMask.topRight = new CPoint();
	CMask.bottomLeft = new CPoint();
	CMask.bottomRight = new CPoint();
	function CMask()
	{
		this.mask = null;
		this.lineWidth = 0;
		this.height = 0;
		this.width = 0;
		this.xSpot = 0;
		this.ySpot = 0;
		this.lineWidth = 0;
	}
	CMask.prototype =
	{
		createMask: function (app, image, nFlags)
		{
			var x, y, s;

			this.width = image.width;
			this.height = image.height;
			this.xSpot = image.xSpot;
			this.ySpot = image.ySpot;

			var maskWidth = Math.floor(((this.width + 15) & 0xFFFFFFF0) / 16);
			this.lineWidth = maskWidth;
			var length = maskWidth * this.height + 1;
			if (typeof ArrayBuffer != 'undefined')
				this.mask = new Uint16Array(new ArrayBuffer(length * 2));
			else
			{
				this.mask = new Array(length);
				for (x = 0; x < length; x++)
					this.mask[x] = 0;
			}

			var canvas = document.createElement("canvas");
			canvas.width = image.width;
			canvas.height = image.height;
			var context = canvas.getContext("2d");
			if (image.mosaic == 0)
			{
				context.drawImage(image.img, 0, 0);
			}
			else
			{
			    context.drawImage(app.imageBank.mosaics[image.mosaic],
					image.mosaicX, image.mosaicY,
					image.width, image.height, 0, 0,
					image.width, image.height);
			}
			var imageData = context.getImageData(0, 0, this.width, this.height);

			if ((nFlags & CMask.GCMF_PLATFORM) == 0)
			{
			    for (y = 0; y < this.height; y++) {
			        var bitmapoffset = y * image.width * 4 + 3;
			        var maskoffset = y * maskWidth;
			        var bitmask = 0x8000;
			        for (x = 0; x < this.width; x++) {
			            if (imageData.data[bitmapoffset] != 0) {
			                this.mask[maskoffset] |= bitmask;
			            }

			            bitmapoffset += 4;
			            bitmask >>>= 1;

			            if (bitmask == 0) {
			                bitmask = 0x8000;
			                maskoffset++;
			            }
			        }
			    }
			}
			else
			{
				var endY, bm;
				for (x = 0; x < this.width; x++)
				{
					for (y = 0; y < this.height; y++)
					{
						if (imageData.data[(y * image.width + x) * 4 + 3] != 0)
						{
							break;
						}
					}
					if (y < this.height)
					{
						endY = Math.min(this.height, y + CColMask.HEIGHT_PLATFORM);
						bm = (0x8000 >> (x & 15));
						for (; y < endY; y++)
						{
							if (imageData.data[(y * image.width + x) * 4 + 3] != 0)
							{
								s = Math.floor((y * maskWidth) + (x & 0xFFFFFFF0) / 16);
								this.mask[s] |= bm;
							}
						}
					}
				}
			}
		},

		rotateRect: function (prc, pHotSpot, fAngle)
		{
			var x, y;
			var cosa, sina;

			if (fAngle == 90.0)
			{
				cosa = 0.0;
				sina = 1.0;
			}
			else if (fAngle == 180.0)
			{
				cosa = -1.0;
				sina = 0.0;
			}
			else if (fAngle == 270.0)
			{
				cosa = 0.0;
				sina = -1.0;
			}
			else
			{
				var arad = fAngle * Math.PI / 180.0;
				cosa = Math.cos(arad);
				sina = Math.sin(arad);
			}

			var nhxcos;
			var nhxsin;
			var nhycos;
			var nhysin;
			if (pHotSpot == null)
			{
				nhxcos = nhxsin = nhycos = nhysin = 0.0;
				CMask.topLeft.x = CMask.topLeft.y = 0;
			}
			else
			{
				nhxcos = -pHotSpot.x * cosa;
				nhxsin = -pHotSpot.x * sina;
				nhycos = -pHotSpot.y * cosa;
				nhysin = -pHotSpot.y * sina;
				CMask.topLeft.x = Math.floor(nhxcos + nhysin);
				CMask.topLeft.y = Math.floor(nhycos - nhxsin);
			}

			if (pHotSpot == null)
				x = prc.right;
			else
				x = prc.right - pHotSpot.x;
			nhxcos = x * cosa;
			nhxsin = x * sina;
			CMask.topRight.x = Math.floor(nhxcos + nhysin);
			CMask.topRight.y = Math.floor(nhycos - nhxsin);

			if (pHotSpot == null)
				y = prc.bottom;
			else
				y = prc.bottom - pHotSpot.y;
			nhycos = y * cosa;
			nhysin = y * sina;
			CMask.bottomRight.x = Math.floor(nhxcos + nhysin);
			CMask.bottomRight.y = Math.floor(nhycos - nhxsin);

			CMask.bottomLeft.x = CMask.topLeft.x + CMask.bottomRight.x - CMask.topRight.x;
			CMask.bottomLeft.y = CMask.topLeft.y + CMask.bottomRight.y - CMask.topRight.y;

			var xmin = Math.min(CMask.topLeft.x, Math.min(CMask.topRight.x, Math.min(CMask.bottomRight.x, CMask.bottomLeft.x)));
			var ymin = Math.min(CMask.topLeft.y, Math.min(CMask.topRight.y, Math.min(CMask.bottomRight.y, CMask.bottomLeft.y)));
			var xmax = Math.max(CMask.topLeft.x, Math.max(CMask.topRight.x, Math.max(CMask.bottomRight.x, CMask.bottomLeft.x)));
			var ymax = Math.max(CMask.topLeft.y, Math.max(CMask.topRight.y, Math.max(CMask.bottomRight.y, CMask.bottomLeft.y)));

			if (pHotSpot != null)
			{
				pHotSpot.x = -xmin;
				pHotSpot.y = -ymin;
			}

			prc.right = xmax - xmin;
			prc.bottom = ymax - ymin;
		},

		createRotatedMask: function (pMask, fAngle, fScaleX, fScaleY)
		{
			var x, y;

			var cx = pMask.width;
			var cy = pMask.height;

			var rc = new CRect();
			rc.right = Math.floor(pMask.width * fScaleX);
			rc.bottom = Math.floor(pMask.height * fScaleY);

			var hs = new CPoint();
			hs.x = Math.floor(pMask.xSpot * fScaleX);
			hs.y = Math.floor(pMask.ySpot * fScaleY);
			this.rotateRect(rc, hs, fAngle);
			var newCx = rc.right;
			var newCy = rc.bottom;
			if (newCx <= 0 || newCy <= 0)
				return false;

			var sMaskWidthWords = pMask.lineWidth;
			var dMaskWidthShorts = ((newCx + 15) & 0x7FFFFFF0) / 16;
			if (typeof ArrayBuffer != 'undefined')
				this.mask = new Uint16Array(new ArrayBuffer((dMaskWidthShorts * newCy + 1) * 2));
			else
				this.mask = new Array(dMaskWidthShorts * newCy + 1);
			var n;
			for (n = dMaskWidthShorts * newCy; n >= 0; n--)
				this.mask[n] = 0;

			this.lineWidth = dMaskWidthShorts;
			this.width = newCx;
			this.height = newCy;
			this.xSpot = hs.x;
			this.ySpot = hs.y;

			var alpha = (fAngle * 0.017453292);
			var cosa = Math.cos(alpha);
			var sina = Math.sin(alpha);

			var fxs = cx / 2 - ((newCx / 2) * cosa - (newCy / 2) * sina) / fScaleX;
			var fys = cy / 2 - ((newCx / 2) * sina + (newCy / 2) * cosa) / fScaleY;

			var pbd0 = 0;
			var pbd1 = pbd0;

			var nxs = Math.floor(fxs * 65536);
			var nys = Math.floor(fys * 65536);
			var ncosa = Math.floor((cosa * 65536) / fScaleX);
			var nsina = Math.floor((sina * 65536) / fScaleY);

			var newCxMul16 = newCx / 16;
			var newCxMod16 = newCx % 16;

			var ncosa2 = Math.floor((cosa * 65536) / fScaleY);
			var nsina2 = Math.floor((sina * 65536) / fScaleX);

			var cxs = cx * 65536;
			var cys = cy * 65536;

			var bMask;
			var b;
			for (y = 0; y < newCy; y++)
			{
				var txs = nxs;
				var tys = nys;
				var pbd2 = pbd1;
				var xs, ys;

				for (x = 0; x < newCxMul16; x++)
				{
					var bd = 0;

					// 1
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x8000;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 2
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x4000;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 3
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x2000;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 4
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x1000;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 5
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x0800;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 6
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x0400;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 7
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x0200;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 8
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x0100;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 9
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x0080;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 10
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x0040;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 11
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x0020;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 12
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x0010;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 13
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x0008;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 14
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x0004;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 15
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x0002;
						}
					}
					txs += ncosa;
					tys += nsina;

					// 16
					if (txs >= 0 && txs < cxs)
					{
						if (tys >= 0 && tys < cys)
						{
							xs = Math.floor(txs / 65536);
							ys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (xs % 16));
							b = pMask.mask[Math.floor(ys * sMaskWidthWords + xs / 16)];
							if ((b & bMask) != 0)
								bd |= 0x0001;
						}
					}
					txs += ncosa;
					tys += nsina;

					this.mask[pbd2++] = bd;
				}

				if (newCxMod16 != 0)
				{
					var bdMask = 0x8000;
					var bdbd = 0;
					for (x = 0; x < newCxMod16; x++, bdMask = ((bdMask >> 1) & 0x7FFF))
					{
						if (txs >= 0 && txs < cxs && tys >= 0 && tys < cys)
						{
							var bdxs = Math.floor(txs / 65536);
							var bdys = Math.floor(tys / 65536);
							bMask = (0x8000 >>> (bdxs % 16));
							b = pMask.mask[Math.floor(bdys * sMaskWidthWords + bdxs / 16)];
							if ((b & bMask) != 0)
								bdbd |= bdMask;
						}
						txs += ncosa;
						tys += nsina;
					}
					this.mask[pbd2] = bdbd;
				}

				pbd1 += dMaskWidthShorts;

				nxs -= nsina2;
				nys += ncosa2;

			}
			return true;
		},
		testMask:          function (x1, y1, yBase1, pMask2, x2, y2, yBase2)
		{
			var pLeft;
			var pRight;
			var x1Left, y1Left, x1Right, y1Right;
			var syLeft, syRight;
			var yBaseLeft, yBaseRight;

			if (x1 <= x2)
			{
				pLeft = this;
				pRight = pMask2;
				yBaseLeft = Math.floor(yBase1);
				yBaseRight = Math.floor(yBase2);
				x1Left = Math.floor(x1);
				y1Left = Math.floor(y1);
				x1Right = Math.floor(x2);
				y1Right = Math.floor(y2);
			}
			else
			{
				pLeft = pMask2;
				pRight = this;
				yBaseLeft = Math.floor(yBase2);
				yBaseRight = Math.floor(yBase1);
				x1Left = Math.floor(x2);
				y1Left = Math.floor(y2);
				x1Right = Math.floor(x1);
				y1Right = Math.floor(y1);
			}

			syLeft = pLeft.height;
			var startYLeft = 0;
			if (yBaseLeft != 0)
			{
				syLeft = yBaseLeft;
				y1Left += pLeft.height - yBaseLeft;
				startYLeft = pLeft.height - yBaseLeft;
			}
			syRight = pRight.height;
			var startYRight = 0;
			if (yBaseRight != 0)
			{
				syRight = yBaseRight;
				y1Right += pRight.height - yBaseRight;
				startYRight = pRight.height - yBaseRight;
			}
			//        syLeft = pLeft.height - yBaseLeft;
			//        syRight = pRight.height - yBaseRight;

			if (x1Left >= x1Right + pRight.width || x1Left + pLeft.width <= x1Right)
			{
				return false;
			}
			if (y1Left >= y1Right + syRight || y1Left + syLeft < y1Right)
			{
				return false;
			}

			var deltaX = x1Right - x1Left;
			var offsetX = Math.floor(deltaX / 16);
			var shiftX = deltaX % 16;
			var countX = Math.min(x1Left + pLeft.width - x1Right, pRight.width);
			countX = Math.floor((countX + 15) / 16);

			var deltaYLeft, deltaYRight, countY;
			if (y1Left <= y1Right)
			{
				deltaYLeft = y1Right - y1Left + startYLeft;
				deltaYRight = startYRight;
				countY = Math.min(y1Left + syLeft, y1Right + syRight) - y1Right;
			}
			else
			{
				deltaYLeft = startYLeft;
				deltaYRight = y1Left - y1Right + startYRight;
				countY = Math.min(y1Left + syLeft, y1Right + syRight) - y1Left;
			}
			var x, y;

			var offsetYLeft, offsetYRight;
			var leftX, middleX;
			var shortX;
			offsetYLeft = deltaYLeft * pLeft.lineWidth;
			offsetYRight = deltaYRight * pRight.lineWidth;
			if (shiftX != 0)
			{
			    switch (countX)
				{
					case 1:
						for (y = 0; y < countY; y++)
						{
							// Premier mot
							leftX = pLeft.mask[offsetYLeft + offsetX] << shiftX;
							if ((leftX & pRight.mask[offsetYRight]) != 0)
							{
								return true;
							}

							if (offsetX + 1 < pLeft.lineWidth)
							{
								middleX = pLeft.mask[offsetYLeft + offsetX + 1] << shiftX;
								middleX >>>= 16;
								if ((middleX & pRight.mask[offsetYRight]) != 0)
								{
									return true;
								}
							}
							offsetYLeft += pLeft.lineWidth;
							offsetYRight += pRight.lineWidth;
	                    }
						break;
					case 2:
						for (y = 0; y < countY; y++)
						{
							// Premier mot
							leftX = pLeft.mask[offsetYLeft + offsetX] << shiftX;
							if ((leftX & pRight.mask[offsetYRight]) != 0)
							{
								return true;
							}
							middleX = pLeft.mask[offsetYLeft + offsetX + 1] << shiftX;
							shortX = (middleX >>> 16);
							if ((shortX & pRight.mask[offsetYRight]) != 0)
							{
								return true;
							}

							// Milieu
							if ((middleX & pRight.mask[offsetYRight + 1]) != 0)
							{
								return true;
							}

							if (offsetX + 2 < pLeft.lineWidth)
							{
							    middleX = pLeft.mask[offsetYLeft + offsetX + 2] << shiftX;
								middleX >>>= 16;
								if ((middleX & pRight.mask[offsetYRight + 1]) != 0)
								{
									return true;
								}
							}
							offsetYLeft += pLeft.lineWidth;
							offsetYRight += pRight.lineWidth;
	                    }
						break;
					default:
						for (y = 0; y < countY; y++)
						{
							// Premier mot
							leftX = pLeft.mask[offsetYLeft + offsetX] << shiftX;
							if ((leftX & pRight.mask[offsetYRight]) != 0)
							{
								return true;
							}

							for (x = 0; x < countX - 1; x++)
							{
								middleX = pLeft.mask[offsetYLeft + offsetX + x + 1] << shiftX;
								shortX = (middleX >>> 16);
								if ((shortX & pRight.mask[offsetYRight + x]) != 0)
								{
									return true;
								}

								// Milieu
								if ((middleX & pRight.mask[offsetYRight + x + 1]) != 0)
								{
									return true;
								}
							}

							if (offsetX + x + 1 < pLeft.lineWidth)
							{
								middleX = pLeft.mask[offsetYLeft + offsetX + x + 1] << shiftX;
								middleX >>>= 16;
								if ((middleX & pRight.mask[offsetYRight + x]) != 0)
								{
									return true;
								}
							}
							offsetYLeft += pLeft.lineWidth;
							offsetYRight += pRight.lineWidth;
	                    }
						break;
				}
			}
			else
			{
				for (y = 0; y < countY; y++)
				{
					for (x = 0; x < countX; x++)
					{
						leftX = pLeft.mask[offsetYLeft + offsetX + x];
						if ((pRight.mask[offsetYRight + x] & leftX) != 0)
						{
							return true;
						}
					}
					offsetYLeft += pLeft.lineWidth;
					offsetYRight += pRight.lineWidth;
	            }
			}
			return false;
		},

		testRect2: function (x1Mask, y1Mask, htFoot1, x1Rect, y1Rect, rWidth, rHeight, htFoot2)
		{
			x1Mask = Math.floor(x1Mask);
			y1Mask = Math.floor(y1Mask);
			x1Rect = Math.floor(x1Rect);
			y1Rect = Math.floor(y1Rect);

			var startYMask = 0;
			var syMask = this.height;
			if (htFoot1 > 0)
			{
				startYMask = this.height - htFoot1;
				y1Mask += startYMask;
				syMask = htFoot1;
			}
			var startYRect = 0;
			var syRect = rHeight;
			if (htFoot2 > 0)
			{
				startYRect = rHeight - htFoot2;
				y1Rect += startYRect;
				syRect = htFoot2;
			}
			if (x1Mask >= x1Rect + rWidth || x1Mask + this.width <= x1Rect)
			{
				return false;
			}
			if (y1Mask >= y1Rect + syRect || y1Mask + syMask < y1Rect)
			{
				return false;
			}

			var startX, countX;
			var startY, countY;
			if (x1Mask <= x1Rect)
			{
				startX = x1Rect - x1Mask;
				countX = Math.min(this.width - startX, rWidth);
			}
			else
			{
				startX = 0;
				countX = Math.min(x1Rect + rWidth - x1Mask, this.width);
			}
			if (y1Mask <= y1Rect)
			{
				startY = y1Rect - y1Mask + startYMask;
				countY = Math.min(y1Mask + syMask, y1Rect + syRect) - y1Rect;
			}
			else
			{
				startY = startYMask;
				countY = Math.min(y1Mask + syMask, y1Rect + syRect) - y1Mask;
			}

			var xOffset = Math.floor(startX / 8);
			var nBytes = Math.floor((startX + countX + 15) / 16) - Math.floor(startX / 16);

			var m;
			var yOffset;
			var y, x;
			for (y = 0; y < countY; y++)
			{
				yOffset = (y + startY) * this.lineWidth;

				switch (nBytes)
				{
					case 1:
						m = (CMask.lMask[startX & 15] & CMask.rMask[((startX + countX - 1) & 15) + 1]);
						if ((this.mask[yOffset + xOffset] & m) != 0)
						{
							return true;
						}
						break;
					case 2:
						m = CMask.lMask[startX & 15];
						if ((this.mask[yOffset + xOffset] & m) != 0)
						{
							return true;
						}
						m = CMask.rMask[((startX + countX - 1) & 15) + 1];
						if ((this.mask[yOffset + xOffset + 1] & m) != 0)
						{
							return true;
						}
						break;
					default:
						m = CMask.lMask[startX & 15];
						if ((this.mask[yOffset + xOffset] & m) != 0)
						{
							return true;
						}
						for (x = 1; x < nBytes - 1; x++)
						{
							if (this.mask[yOffset + xOffset + x] != 0)
							{
								return true;
							}
						}
						m = CMask.rMask[((startX + countX - 1) & 15) + 1];
						if ((this.mask[yOffset + xOffset + x] & m) != 0)
						{
							return true;
						}
						break;
				}
			}
			return false;
		},
		/*
		 testRect:function(yBase1, xx, yy, w, h)
		 {
		 var x1 = xx;
		 if (x1 < 0)
		 {
		 w += x1;
		 x1 = 0;
		 }
		 var y1 = yy;
		 if (yBase1 != 0 && y1 >= 0)
		 {
		 y1 = yBase1 + y1;
		 h = height - y1;
		 }
		 if (y1 < 0)
		 {
		 h += y1;
		 y1 = 0;
		 }
		 var x2 = x1 + w;
		 if (x2 > this.width)
		 {
		 x2 = this.width;
		 }
		 var y2 = y1 + h;
		 if (y2 > this.height)
		 {
		 y2 = this.height;
		 }

		 var offset = (y1) * this.lineWidth;
		 var yCount = y2 - y1;
		 var xCount = Math.floor((x2 - x1) / 16) + 1;
		 var xOffset = Math.floor(x1 / 16);
		 var x, y;

		 var m;
		 var yOffset;
		 for (y = 0; y < yCount; y++)
		 {
		 yOffset = y * this.lineWidth + offset;

		 switch (xCount)
		 {
		 case 1:
		 m = (CMask.lMask[x1 & 15] & rMask[(x2 - 1) & 15]);
		 if ((this.mask[yOffset + xOffset] & m) != 0)
		 {
		 return true;
		 }
		 break;
		 case 2:
		 m = CMask.lMask[x1 & 15];
		 if ((this.mask[yOffset + xOffset] & m) != 0)
		 {
		 return true;
		 }
		 m = CMask.rMask[(x2 - 1) & 15];
		 if ((mask[yOffset + xOffset + 1] & m) != 0)
		 {
		 return true;
		 }
		 break;
		 default:
		 m = CMask.lMask[x1 & 15];
		 if ((this.mask[yOffset + xOffset] & m) != 0)
		 {
		 return true;
		 }
		 for (x = 1; x < xCount - 1; x++)
		 {
		 if (this.mask[yOffset + xOffset + 1] != 0)
		 {
		 return true;
		 }
		 }
		 m = CMask.rMask[(x2 - 1) & 15];
		 if ((this.mask[yOffset + xOffset + x] & m) != 0)
		 {
		 return true;
		 }
		 break;
		 }
		 }
		 return false;
		 },
		 */
		testPoint: function (x1Mask, y1Mask, x1, y1)
		{
			var xx = Math.floor(x1 - x1Mask);
			var yy = Math.floor(y1 - y1Mask);
			if (xx < 0 || xx >= this.width || yy < 0 || yy >= this.height)
			{
				return false;
			}

			var offset = (yy * this.lineWidth) + Math.floor(xx / 16);
			var m = ((0x8000) >>> (xx & 15));
			var data = this.mask[offset];
			if ((this.mask[offset] & m) != 0)
			{
				return true;
			}
			return false;
		},

	    // Test a point in the mask
		// DeltaX/Y = screen coordinates relative to the mask's hot spot
		testPointEx: function (deltaX, deltaY, angle, xScale, yScale)
		{
		    var xx = Math.floor(deltaX);
		    var yy = Math.floor(deltaY);
		    var xo = xx;
		    var yo = yy;

		    // Convert screen coordinates to mask coordinates
		    if (angle == 0)
		    {
		        // Scaling?
		        if ( xScale != 1.0 || yScale != 1.0 )
		        {
		            xo = Math.floor(xo / xScale);
		            yo = Math.floor(yo / yScale);
		        }

		        xo += this.xSpot;
		        yo += this.ySpot;
	        }
		    else
		    {
		        // Rotate position
		        var alpha = angle * 3.141592653589 / 180.0;
		        var cosa = Math.cos(alpha);
		        var sina = Math.sin(alpha);

		        xo = xx * cosa - yy * sina;
		        yo = yy * cosa + xx * sina;

		        // Scaling?
		        if ( xScale != 1.0 || yScale != 1.0 )
		        {
		            xo /= xScale;
		            yo /= yScale;
		        }

		        // Get position relative to top-left corner of rectangle
		        xo += this.xSpot;
		        yo += this.ySpot;
		    }

	        // Test pixel at mask coordinates
		    xx = Math.floor(xo);
		    yy = Math.floor(yo);
		    if (xx < 0 || xx >= this.width || yy < 0 || yy >= this.height) {
		        return false;
		    }

		    var offset = (yy * this.lineWidth) + Math.floor(xx / 16);
		    var m = ((0x8000) >>> (xx & 15));
		    var data = this.mask[offset];
		    if ((this.mask[offset] & m) != 0) {
		        return true;
		    }
		    return false;
		}

	}

	// CRotatedMask object
	// -----------------------------------------------------------------------
	function CRotatedMask()
	{
		this.mask = null;
		this.angle = 0;
		this.scaleX = 1.0;
		this.scaleY = 1.0;
		this.tick = 0;
	}

	// CRSpr object
	// -----------------------------------------------------------------------
	CRSpr.RSFLAG_HIDDEN = 0x0001;
	CRSpr.RSFLAG_INACTIVE = 0x0002;
	CRSpr.RSFLAG_SLEEPING = 0x0004;
	CRSpr.RSFLAG_ROTATE_ANTIA = 0x0010;
	CRSpr.RSFLAG_VISIBLE = 0x0020;
	CRSpr.RSFLAG_RAMBO = 0x0040;
	CRSpr.RSFLAG_COLBOX = 0x0080;
	CRSpr.SPRTYPE_TRUESPRITE = 0;
	CRSpr.SPRTYPE_OWNERDRAW = 1;
	CRSpr.BOP_COPY = 0;
	CRSpr.BOP_BLEND = 1;
	CRSpr.BOP_INVERT = 2;
	CRSpr.BOP_XOR = 3;
	CRSpr.BOP_AND = 4;
	CRSpr.BOP_OR = 5;
	CRSpr.BOP_BLEND_REPLACETRANSP = 6;
	CRSpr.BOP_DWROP = 7;
	CRSpr.BOP_ANDNOT = 8;
	CRSpr.BOP_ADD = 9;
	CRSpr.BOP_MONO = 10;
	CRSpr.BOP_SUB = 11;
	CRSpr.BOP_BLEND_DONTREPLACECOLOR = 12;
	CRSpr.BOP_EFFECTEX = 13;
	CRSpr.BOP_MAX = 13;
	CRSpr.BOP_MASK = 0x0000FFF;
	CRSpr.BOP_RGBAFILTER = 0x1000;
	CRSpr.BOP_SMOOTHING = 0x2000;

	function CRSpr()
	{
		this.hoPtr = null;
		this.rsFlash = 0;
		this.rsFlashCpt = 0;
		this.rsLayer = 0;
		this.rsZOrder = 0;
		this.rsCreaFlags = 0;
		this.rsBackColor = 0;
		this.rsEffect = 0;
		this.rsEffectParam = 0;
		this.rsFlags = 0;
		this.rsSpriteType = 0;
		this.rsTransparency = 0;
		this.rsTrans = null;
	}
	CRSpr.prototype =
	{
		init1: function (ho, ocPtr, cobPtr)
		{
			this.hoPtr = ho;

			this.rsLayer = cobPtr.cobLayer;
			this.rsZOrder = cobPtr.cobZOrder;

			this.rsFlags = 0;

			this.rsFlags |= CRSpr.RSFLAG_RAMBO;
			if ((this.hoPtr.hoLimitFlags & CObjInfo.OILIMITFLAGS_QUICKCOL) == 0)
				this.rsFlags &= ~CRSpr.RSFLAG_RAMBO;

			if ((this.hoPtr.hoOiList.oilOCFlags2 & CObjectCommon.OCFLAGS2_COLBOX) != 0)
				this.rsFlags |= CRSpr.RSFLAG_COLBOX;

			if ((cobPtr.cobFlags & CRun.COF_HIDDEN) != 0)
			{
				this.rsFlags |= CRSpr.RSFLAG_HIDDEN;
				if (this.hoPtr.hoType == COI.OBJ_TEXT)
				{
					this.hoPtr.hoFlags |= CObject.HOF_NOCOLLISION;
					this.rsFlags &= ~CRSpr.RSFLAG_RAMBO;
				}
			}
			else
			{
				this.rsFlags |= CRSpr.RSFLAG_VISIBLE;
			}
			this.rsEffect = this.hoPtr.hoOiList.oilInkEffect;
			this.rsEffectParam = this.hoPtr.hoOiList.oilEffectParam;
			var globalAlpha = 1;
			if ((this.rsEffect & CRSpr.BOP_RGBAFILTER) != 0)
				globalAlpha = (((this.rsEffectParam >>> 24) & 0xFF) / 255.0);
			else if ((this.rsEffect & CRSpr.BOP_MASK) == CRSpr.BOP_BLEND)
				globalAlpha = ((128 - this.rsEffectParam) / 128.0);
			this.rsTransparency = 128 - globalAlpha * 128;

			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_STATIC)
			{
				this.rsFlags |= CRSpr.RSFLAG_INACTIVE;
			}
		},

		init2: function (bTransition)
		{
			this.createSprite(bTransition);

			if (bTransition)
			{
				if (this.hoPtr.hoCommon.ocFadeIn)
				{
					this.hoPtr.hoFlags |= CObject.HOF_FADEIN;
				}
			}
		},

		handle: function ()
		{
			var rhPtr = this.hoPtr.hoAdRunHeader;
			var x1;
			var y1;
			var x2;
			var y2;

			if ((this.hoPtr.hoFlags & CObject.HOF_FADEIN) != 0)
			{
				if (!this.rsTrans)
				{
					this.createTransition(false);
				}
				this.performFadeIn();
				return;
			}
			if ((this.hoPtr.hoFlags & CObject.HOF_FADEOUT) != 0)
			{
				this.performFadeOut();
				return;
			}

			if ((this.rsFlags & CRSpr.RSFLAG_SLEEPING) == 0)
			{
				if (this.rsFlash != 0)
				{
					this.rsFlashCpt -= rhPtr.rhTimerDelta;
					if (this.rsFlashCpt < 0)
					{
						this.rsFlashCpt = this.rsFlash;
						if ((this.rsFlags & CRSpr.RSFLAG_VISIBLE) == 0)
						{
							this.rsFlags |= CRSpr.RSFLAG_VISIBLE;
							this.obShow();
						}
						else
						{
							this.rsFlags &= ~CRSpr.RSFLAG_VISIBLE;
							this.obHide();
						}
					}
				}

				if (this.hoPtr.rom != null)
					this.hoPtr.rom.move();

				if (this.hoPtr.roc.rcPlayer != 0)
					return;
				if ((this.hoPtr.hoOEFlags & CObjectCommon.OEFLAG_NEVERSLEEP) != 0)
				{
				    // Build 285.1: handle "Destroy if too far" even if "Inactivate if too far" is set to No
				    if ((this.hoPtr.hoOEFlags & CObjectCommon.OEFLAG_NEVERKILL) == 0 && (rhPtr.rhApp.dwOptions & CRunApp.AH2OPT_DESTROYIFNOINACTIVATE) != 0 )
				    {
				        x1 = this.hoPtr.hoX - this.hoPtr.hoImgXSpot;
				        y1 = this.hoPtr.hoY - this.hoPtr.hoImgYSpot;
				        x2 = x1 + this.hoPtr.hoImgWidth;
				        y2 = y1 + this.hoPtr.hoImgHeight;

				        if (x2<rhPtr.rh3XMinimumKill || x1>rhPtr.rh3XMaximumKill || y2<rhPtr.rh3YMinimumKill || y1>rhPtr.rh3YMaximumKill)
				            rhPtr.destroy_Add(this.hoPtr.hoNumber);
				    }
				    return;
				}

				x1 = this.hoPtr.hoX - this.hoPtr.hoImgXSpot;
				y1 = this.hoPtr.hoY - this.hoPtr.hoImgYSpot;
				x2 = x1 + this.hoPtr.hoImgWidth;
				y2 = y1 + this.hoPtr.hoImgHeight;

				if (x2 >= rhPtr.rh3XMinimum && x1 <= rhPtr.rh3XMaximum && y2 >= rhPtr.rh3YMinimum && y1 <= rhPtr.rh3YMaximum)
					return;

				if (x2 >= rhPtr.rh3XMinimumKill && x1 <= rhPtr.rh3XMaximumKill && y2 >= rhPtr.rh3YMinimumKill && y1 <= rhPtr.rh3YMaximumKill)
				{
					this.rsFlags |= CRSpr.RSFLAG_SLEEPING;
					this.rsZOrder = this.hoPtr.delSprite();
					return;
				}
				else
				{
					if ((this.hoPtr.hoOEFlags & CObjectCommon.OEFLAG_NEVERKILL) == 0)
					{
						rhPtr.destroy_Add(this.hoPtr.hoNumber);
					}
					return;
				}
			}
			else
			{
				x1 = this.hoPtr.hoX - this.hoPtr.hoImgXSpot;
				y1 = this.hoPtr.hoY - this.hoPtr.hoImgYSpot;
				x2 = x1 + this.hoPtr.hoImgWidth;
				y2 = y1 + this.hoPtr.hoImgHeight;
				if (x2 >= rhPtr.rh3XMinimum && x1 <= rhPtr.rh3XMaximum && y2 >= rhPtr.rh3YMinimum && y1 <= rhPtr.rh3YMaximum)
				{
					this.rsFlags &= ~CRSpr.RSFLAG_SLEEPING;
					this.init2(false);
					this.hoPtr.setChildIndex(this.rsZOrder);
				}
			}
		},

		createSprite: function (bTransition)
		{
			if ((this.hoPtr.hoOEFlags & CObjectCommon.OEFLAG_ANIMATIONS) != 0)
			{
				this.hoPtr.addSprite(this.hoPtr.hoX - this.hoPtr.hoAdRunHeader.rhWindowX, this.hoPtr.hoY - this.hoPtr.hoAdRunHeader.rhWindowY, this.hoPtr.roc.rcImage, this.rsLayer, (this.rsFlags & CRSpr.RSFLAG_HIDDEN) == 0);
				this.rsSpriteType = CRSpr.SPRTYPE_TRUESPRITE;
				this.hoPtr.setEffect(this.rsEffect, this.rsEffectParam);
			}
			else
			{
				this.hoPtr.hoFlags |= CObject.HOF_OWNERDRAW;
				this.hoPtr.addOwnerDrawSprite(this.hoPtr.hoX - this.hoPtr.hoAdRunHeader.rhWindowX, this.hoPtr.hoY - this.hoPtr.hoAdRunHeader.rhWindowY,
					this.rsLayer, (this.hoPtr.hoOEFlags & CObjectCommon.OEFLAG_QUICKDISPLAY) != 0, (this.rsFlags & CRSpr.RSFLAG_HIDDEN) == 0, -1);
				this.hoPtr.setEffect(this.rsEffect, this.rsEffectParam);
				this.rsSpriteType = CRSpr.SPRTYPE_OWNERDRAW;
			}
		},

		createTransition: function (bFadeOut)
		{
			this.hoPtr.hoFlags &= ~(CObject.HOF_FADEIN | CObject.HOF_FADEOUT);

			// Un fade?
			if (bFadeOut == false)
			{
				if (!this.hoPtr.hoCommon.ocFadeIn)
				{
					return false;
				}
				this.hoPtr.hoFlags |= CObject.HOF_FADEIN;
			}
			else
			{
				if (!this.hoPtr.hoCommon.ocFadeOut)
				{
					return false;
				}
				this.hoPtr.hoFlags |= CObject.HOF_FADEOUT;
			}

			// Demarre le fade
			this.rsTrans = this.hoPtr.hoAdRunHeader.rhApp.getTransitionManager().startObjectFade(this.hoPtr, bFadeOut);
			if (!this.rsTrans)
			{
				this.hoPtr.hoFlags &= ~(CObject.HOF_FADEIN | CObject.HOF_FADEOUT);
				return false;
			}
			return true;
		},

		performFadeIn: function ()
		{
			if ((this.hoPtr.hoFlags & CObject.HOF_FADEIN) != 0)
			{
				if (this.rsTrans.isCompleted())
				{
					this.hoPtr.hoFlags &= ~CObject.HOF_FADEIN;
					this.hoPtr.transitionImage = null;
					this.rsTrans = null;
					if (this.hoPtr.hoType >= 32)
					{
						hoPtr.ext.continueRunObject();
					}
					return false;
				}
				this.rsTrans.stepDraw(CTrans.TRFLAG_FADEIN);
				return true;
			}
			return false;
		},

		performFadeOut: function ()
		{
			if ((this.hoPtr.hoFlags & CObject.HOF_FADEOUT) != 0)
			{
				if (this.rsTrans.isCompleted())
				{
					this.rsTrans = null;
					this.transitionImage = null;
					this.hoPtr.hoAdRunHeader.destroy_Add(this.hoPtr.hoNumber);
					return false;
				}
				this.rsTrans.stepDraw(CTrans.TRFLAG_FADEOUT);
				return true;
			}
			return false;
		},

		initFadeOut: function ()
		{
			if (this.createTransition(true))
			{
				this.hoPtr.hoFlags |= CObject.HOF_NOCOLLISION;
				return true;
			}
			return false;
		},

		kill: function (fast)
		{
			this.rsZOrder = this.hoPtr.delSprite();
		},

		obHide: function ()
		{
			if ((this.rsFlags & CRSpr.RSFLAG_HIDDEN) == 0)
			{
				this.rsFlags |= CRSpr.RSFLAG_HIDDEN;
				this.hoPtr.roc.rcChanged = true;
				this.hoPtr.hideSprite();
			}
		},

		obShow: function ()
		{
			if ((this.rsFlags & CRSpr.RSFLAG_HIDDEN) != 0)
			{
				var pLayer = this.hoPtr.hoAdRunHeader.rhFrame.layers[this.hoPtr.hoLayer];
				if ((pLayer.dwOptions & (CLayer.FLOPT_TOHIDE | CLayer.FLOPT_VISIBLE)) == CLayer.FLOPT_VISIBLE)
				{
					this.rsFlags &= ~CRSpr.RSFLAG_HIDDEN;
					this.hoPtr.hoFlags &= ~CObject.HOF_NOCOLLISION;
					this.hoPtr.roc.rcChanged = true;
					this.hoPtr.showSprite();
				}
			}
		},

		setSemiTransparency: function (trans)
		{
			if (trans >= 0 && trans <= 128)
			{
				this.rsTransparency = trans;
				this.hoPtr.setTransparency(trans);
			}
		},

		getSemiTransparency: function ()
		{
			return this.rsTransparency;
		},

		setColFlag: function (flag)
		{
			if (flag)
			{
				this.rsFlags |= CRSpr.RSFLAG_RAMBO;
			}
			else
			{
				this.rsFlags &= ~CRSpr.RSFLAG_RAMBO;
			}
		},

		modifSpriteEffect: function (effect, effectParam)
		{
			this.rsEffect = effect;
			this.rsEffectParam = effectParam;
		}

	}
	// CDefStrings object
	// --------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */

	function CDefStrings()
	{
		this.nStrings = 0;
		this.strings = null;
	}
	CDefStrings.prototype =
	{
		load: function (file)
		{
			this.nStrings = file.readAShort();
			this.strings = new Array(this.nStrings);
			var n;
			for (n = 0; n < this.nStrings; n++)
			{
				this.strings[n] = file.readAString();
			}
		}
	}

	// CDefValues object
	// --------------------------------------------------------------
	function CDefValues()
	{
		this.nValues = 0;
		this.values = null;
		this.flags = 0;
	}
	CDefValues.prototype =
	{
	    load: function (file, initFlags)
	    {
			this.nValues = file.readAShort();
			this.values = new Array(this.nValues);
			var n;
			for (n = 0; n < this.nValues; n++)
			{
				this.values[n] = file.readAInt();
			}
			if (initFlags)
			    this.flags = file.readAInt();
	    }
	}

	// CRVal object
	// --------------------------------------------------------------
	CRVal.VALUES_NUMBEROF_ALTERABLE_DEFAULT = 26;
	CRVal.STRINGS_NUMBEROF_ALTERABLE_DEFAULT = 10;
	function CRVal()
	{
		this.rvValueFlags = 0;
		this.rvValues = null;
		this.rvStrings = null;
	}
	CRVal.prototype =
	{
		init:      function (ho, ocPtr, cob)
		{
		    this.rvValueFlags = 0;
		    var nValues = CRVal.VALUES_NUMBEROF_ALTERABLE_DEFAULT;
		    if (ocPtr.ocValues != null && ocPtr.ocValues.nValues > nValues)
		        nValues = ocPtr.ocValues.nValues;
		    this.rvValues = new Array(nValues);

		    var nStrings = CRVal.STRINGS_NUMBEROF_ALTERABLE_DEFAULT;
		    if (ocPtr.ocStrings != null && ocPtr.ocStrings.nStrings > nStrings)
		        nStrings = ocPtr.ocStrings.nStrings;
		    this.rvStrings = new Array(nStrings);

		    var n;
			for (n = 0; n < this.rvValues.length; n++)
				this.rvValues[n] = 0;
			for (n = 0; n < this.rvStrings.length; n++)
				this.rvStrings[n] = "";

			if (ocPtr.ocValues != null)
			{
			    this.rvValueFlags = ocPtr.ocValues.flags;
			    for (n = 0; n < ocPtr.ocValues.nValues; n++)
					this.rvValues[n] = ocPtr.ocValues.values[n];
			}
			if (ocPtr.ocStrings != null)
			{
				for (n = 0; n < ocPtr.ocStrings.nStrings; n++)
					this.rvStrings[n] = ocPtr.ocStrings.strings[n];
			}
		},
		kill:      function (bFast)
		{
			var n;
			for (n = 0; n < this.rvValues.length; n++)
				this.rvValues[n] = 0;
			for (n = 0; n < this.rvStrings.length; n++)
				this.rvStrings[n] = null;
		},
		getValue:  function (n)
		{
			if (n < this.rvValues.length)
				return this.rvValues[n];
			return 0;
		},
		getString: function (n)
		{
			if (n < this.rvStrings.length)
				return this.rvStrings[n];
			return "";
		},
		setString: function (n, s)
		{
			if (n >= this.rov.rvStrings.length)
				this.growStrings(n + 10);
			this.rvStrings[n] = s;
		},
		setValue:  function (n, v)
		{
			if (n >= this.rov.rvValues.length)
				this.growValues(n + 10);
			this.rvValues[n] = v;
		},
		growValues: function(num)
		{
			if (num > this.rvValues.length)
			{
				var n;
				for (n = this.rvValues.length; n < num; n++)
					this.rvValues[n] = 0;
			}
		},
		growStrings: function(num)
		{
			if (num > this.rvStrings.length)
			{
				var n;
				for (n = this.rvStrings.length; n < num; n++)
					this.rvStrings[n] = "";
			}
		}
	}


	// CEXTLOADER extension loading
	//----------------------------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CExtLoader.KPX_BASE = 32;
	function CExtLoader(a)
	{
		this.app = a;
		this.extensions = null;
		this.numOfConditions = 0;
	}

	CExtLoader.prototype =
	{

	    createList: function (file) {

	        var extMaxHandle = 25;
	        if (extMaxHandle) {
	            this.extensions = new Array(extMaxHandle);
	            this.numOfConditions = new Array(extMaxHandle);
	            var n;
	            for (n = 0; n < extMaxHandle; n++) {
	                this.extensions[n] = null;
	                this.numOfConditions[n] = 0;
	            }

	            var e;
	            // START_ADDEXT
	            e = new CExtLoad();
	            e.handle = 2;
	            this.addExt(e);
	            e = new CExtLoad();
	            e.handle = 3;
	            this.addExt(e);
	            e = new CExtLoad();
	            e.handle = 4;
	            this.addExt(e);
	            e = new CExtLoad();
	            e.handle = 6;
	            this.addExt(e);
	            e = new CExtLoad();
	            e.handle = 7;
	            this.addExt(e);
	            e = new CExtLoad();
	            e.handle = 9;
	            this.addExt(e);
	            e = new CExtLoad();
	            e.handle = 10;
	            this.addExt(e);
	            e = new CExtLoad();
	            e.handle = 12;
	            this.addExt(e);
	            e = new CExtLoad();
	            e.handle = 14;
	            this.addExt(e);
	            e = new CExtLoad();
	            e.handle = 17;
	            this.addExt(e);
	            e = new CExtLoad();
	            e.handle = 18;
	            this.addExt(e);
	            e = new CExtLoad();
	            e.handle = 19;
	            this.addExt(e);
	            e = new CExtLoad();
	            e.handle = 20;
	            this.addExt(e);
	            e = new CExtLoad();
	            e.handle = 21;
	            this.addExt(e);
	            // INCLUDE_ADDEXT
	        }
	    },

		addExt: function (e)
		{
		    var ext = e.loadRunObject();
		    if (ext != null) {
		        this.extensions[e.handle] = e;
		        this.numOfConditions[e.handle] = ext.getNumberOfConditions();
		    }
	    },
		    
		loadRunObject: function (type)
		{
			type -= CExtLoader.KPX_BASE;
			var ext = null;
			if (type < this.extensions.length && this.extensions[type] != null)
			{
				ext = this.extensions[type].loadRunObject();
			}
			return ext;
		},

		getNumberOfConditions: function (type)
		{
			type -= CExtLoader.KPX_BASE;
			if (type < this.extensions.length)
			{
				return this.numOfConditions[type];
			}
			return 0;
		}
	}

	//----------------------------------------------------------------------------------
	//
	// CEXTLOADER: Chargement des extensions
	//
	//----------------------------------------------------------------------------------
	function CExtLoad()
	{
		this.handle = 0;
	}

	CExtLoad.prototype =
	{

	    loadRunObject: function ()
		{
	        switch (this.handle) {
	            // START_NEWEXT
	        case 2:
	        return new CRunEasing();
	        case 3:
	        return new CRunPlatform();
	        case 4:
	        return new CRunKcArray();
	        case 6:
	        return new CRunKcButton();
	        case 7:
	        return new CRunkcedit();
	        case 9:
	        return new CRunkccombo();
	        case 10:
	        return new CRunkcwctrl();
	        case 12:
	        return new CRunkclist();
	        case 14:
	        return new CRunkcclock();
	        case 17:
	        return new CRunkcini();
	        case 18:
	        return new CRunparser();
	        case 19:
	        return new CRunBox2DParticules();
	        case 20:
	        return new CRunBox2DBase();
	        case 21:
	        return new CRunGet();
	            // INCLUDE_NEWEXT
	        }


			return null;
	        /*
			 if (document.debug==undefined)
			 {
			 var type = CExtLoad.types[this.name];
			 if (type)
			 return new type;
			 }
			 else
			 return new window['CRun' + this.name];
			 */
	    }
	}

	// CRUNEXTENSION Object
	//----------------------------------------------------------------------------------
	CRunExtension.REFLAG_DISPLAY = 1;
	CRunExtension.REFLAG_ONESHOT = 2;
	function CRunExtension()
	{
		this.ho = null;
		this.rh = null;
	}
	CRunExtension.prototype =
	{
		init: function (hoPtr)
		{
			this.ho = hoPtr;
			this.rh = hoPtr.hoAdRunHeader;
		},

		getNumberOfConditions: function ()
		{
			return 0;
		},

		createRunObject: function (file, cob, version)
		{
			return false;
		},

		handleRunObject: function ()
		{
			return CRunExtension.REFLAG_ONESHOT;
		},

		displayRunObject: function (context, xDraw, yDraw)
		{
		},

		destroyRunObject: function (bFast)
		{
		},
		createFont:       function ()
		{
		},
		pauseRunObject:   function ()
		{
		},

		continueRunObject: function ()
		{
		},

		getZoneInfos: function ()
		{
		},

		condition: function (num, cnd)
		{
			return false;
		},

		action: function (num, act)
		{
		},

		expression: function (num)
		{
			return null;
		},

		getRunObjectCollisionMask: function (flags)
		{
			return null;
		},

		getRunObjectFont: function ()
		{
			return null;
		},

		setRunObjectFont: function (fi, rc)
		{
		},

		getRunObjectTextColor: function ()
		{
			return 0;
		},

		setRunObjectTextColor: function (rgb)
		{
		},

		autoResize: function ()
		{
		},

		forcePosition: function ()
		{
		}
	}

	// CEXPEXTENSION : expressions extension
	// -----------------------------------------------------------------------------
	function CExpExtension()
	{
	}
	CExpExtension.prototype =
	{
		evaluate: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ExpressionObjects(this.oiList);
			if (pHo == null)
			{
				rhPtr.rh4Results[rhPtr.rh4PosPile] = 0;
				return;
			}
			var exp = (this.code >> 16) - CEventProgram.EVENTS_EXTBASE;				// Vire le type
			rhPtr.currentPtr = this;
			rhPtr.rh4Results[rhPtr.rh4PosPile] = pHo.expression(exp);
		}
	}

	// CACTEXTENSION : actions extension
	// -----------------------------------------------------------------------------

	function CActExtension()
	{
	}
	CActExtension.prototype =
	{
		execute: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.get_ActionObjects(this);
			if (pHo == null)
				return;

			var act = (this.evtCode >>> 16) - CEventProgram.EVENTS_EXTBASE;
			rhPtr.currentPtr = this;
			pHo.action(act, this);
		},

		getParamObject: function (rhPtr, num)
		{
			return rhPtr.rhEvtProg.get_ParamActionObjects(this.evtParams[num].oiList, this);
		},

		getParamBorder: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamShort: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamAltValue: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamDirection: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamEffect: function (rhPtr, num)
		{
			return this.evtParams[num].string;
		},

		getParamCreate: function (rhPtr, num)
		{
			return this.evtParams[num];
		},

		getParamAnimation: function (rhPtr, num)
		{
			if (this.evtParams[num].code == 10)
			{
				return this.evtParams[num].value;
			}
			return rhPtr.get_EventExpressionInt(this.evtParams[num]);
		},

		getParamPlayer: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamEvery: function (rhPtr, num)
		{
			return this.evtParams[num].delay;
		},

		getParamKey: function (rhPtr, num)
		{
			return this.evtParams[num].key;
		},

		getParamSpeed: function (rhPtr, num)
		{
			return rhPtr.get_EventExpressionInt(this.evtParams[num]);
		},

		getParamPosition: function (rhPtr, num)
		{
			var position = this.evtParams[num];
			var pInfo = new CPositionInfo();
			if (position.read_Position(rhPtr, 0, pInfo))
			    pInfo.found = true;
			return pInfo;
		},

		getParamJoyDirection: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamShoot: function (rhPtr, num)
		{
			return this.evtParams[num];
		},

		getParamZone: function (rhPtr, num)
		{
			return this.evtParams[num];
		},

		getParamExpression: function (rhPtr, num)
		{
			return rhPtr.get_EventExpressionInt(this.evtParams[num]);
		},

		getParamColour: function (rhPtr, num)
		{
			if (this.evtParams[num].code == 24)
			{
				return this.evtParams[num].color;
			}
			return CServices.swapRGB(rhPtr.get_EventExpressionInt(this.evtParams[num]));
		},

		getParamFrame: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamNewDirection: function (rhPtr, num)
		{
			if (this.evtParams[num].code == 29)
			{
				return this.evtParams[num].value;
			}
			return rhPtr.get_EventExpressionInt(this.evtParams[num]);
		},

		getParamClick: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamExpString: function (rhPtr, num)
		{
			return rhPtr.get_EventExpressionString(this.evtParams[num]);
		},

		getParamFilename: function (rhPtr, num)
		{
			if (this.evtParams[num].code == 40)
			{
				return this.evtParams[num].string;
			}
			return rhPtr.get_EventExpressionString(this.evtParams[num]);
		},

		getParamExpDouble: function (rhPtr, num)
		{
			return rhPtr.get_EventExpressionAny(this.evtParams[num]);
		},

		getParamFilename2: function (rhPtr, num)
		{
			if (this.evtParams[num].code == 63)
			{
				return this.evtParams[num].string;
			}
			return rhPtr.get_EventExpressionString(this.evtParams[num]);
		},

		getParamExtension: function (rhPtr, num)
		{
			var p = this.evtParams[num];
			if (p.data != 0)
			{
				return rhPtr.rhApp.file.createFromFile(p.data);
			}
			return null;
		},

		getParamTime: function (rhPtr, num)
		{
			if (this.evtParams[num].code == 2)
			{
				return this.evtParams[num].timer;
			}
			return rhPtr.get_EventExpressionInt(this.evtParams[num]);
		}
	}

	// EXTENSION conditions
	// ------------------------------------------------------------------------------
	function CCndExtension()
	{
	}
	CCndExtension.prototype =
	{
		eva1: function (rhPtr, pHo)
		{
			if (pHo == null)
				return this.eva2(rhPtr);

			pHo.hoFlags |= CObject.HOF_TRUEEVENT;
			var cond = -(this.evtCode >> 16) - CEventProgram.EVENTS_EXTBASE - 1;
			rhPtr.currentPtr = this;
			if (pHo.condition(cond, this))
			{
				rhPtr.rhEvtProg.evt_AddCurrentObject(pHo);
				return true;
			}
			return false;
		},

		eva2: function (rhPtr)
		{
			var pHo = rhPtr.rhEvtProg.evt_FirstObject(this.evtOiList);
			var cpt = rhPtr.rhEvtProg.evtNSelectedObjects;
			var cond = -(this.evtCode >> 16) - CEventProgram.EVENTS_EXTBASE - 1;

			rhPtr.currentPtr = this;
			while (pHo != null)
			{
				pHo.hoFlags &= ~CObject.HOF_TRUEEVENT;
				if (pHo.condition(cond, this))
				{
					if ((this.evtFlags2 & CEvent.EVFLAG2_NOT) != 0)
					{
						cpt--;
						rhPtr.rhEvtProg.evt_DeleteCurrentObject();
					}
				}
				else
				{
					if ((this.evtFlags2 & CEvent.EVFLAG2_NOT) == 0)
					{
						cpt--;
						rhPtr.rhEvtProg.evt_DeleteCurrentObject();
					}
				}
				pHo = rhPtr.rhEvtProg.evt_NextObject();
			}
			if (cpt != 0)
				return true;
			return false;
		},

		getParamObject: function (rhPtr, num)
		{
			return this.evtParams[num];
		},

		getParamTime: function (rhPtr, num)
		{
			if (this.evtParams[num].code == 2)
			{
				return this.evtParams[num].timer;
			}
			return rhPtr.get_EventExpressionInt(this.evtParams[num]);
		},

		getParamBorder: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamAltValue: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamDirection: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamAnimation: function (rhPtr, num)
		{
			if (this.evtParams[num].code == 10)
			{
				return this.evtParams[num].value;
			}
			return rhPtr.get_EventExpressionInt(this.evtParams[num]);
		},

		getParamPlayer: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamEvery: function (rhPtr, num)
		{
			return this.evtParams[num].delay;
		},

		getParamKey: function (rhPtr, num)
		{
			return this.evtParams[num].key;
		},

		getParamSpeed: function (rhPtr, num)
		{
			return rhPtr.get_EventExpressionInt(this.evtParams[num]);
		},

		getParamPosition: function (rhPtr, num)
		{
			//return this.evtParams[num];
		    var position = this.evtParams[num];
		    var pInfo = new CPositionInfo();
		    if (position.read_Position(rhPtr, 0, pInfo))
		        pInfo.found = true;
		    return pInfo;
		},

		getParamJoyDirection: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamExpression: function (rhPtr, num)
		{
			return rhPtr.get_EventExpressionInt(this.evtParams[num]);
		},

		getParamColour: function (rhPtr, num)
		{
			if (this.evtParams[num].code == 24)
			{
				return this.evtParams[num].color;
			}
			return CServices.swapRGB(rhPtr.get_EventExpressionInt(this.evtParams[num]));
		},

		getParamFrame: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamNewDirection: function (rhPtr, num)
		{
			if (this.evtParams[num].code == 29)
			{
				return this.evtParams[num].value;
			}
			return rhPtr.get_EventExpressionInt(this.evtParams[num]);
		},

		getParamClick: function (rhPtr, num)
		{
			return this.evtParams[num].value;
		},

		getParamExpString: function (rhPtr, num)
		{
			return rhPtr.get_EventExpressionString(this.evtParams[num]);
		},

		compareValues: function (rhPtr, num, value)
		{
			var value2 = rhPtr.get_EventExpressionAny(this.evtParams[num]);
			var comp = this.evtParams[num].comparaison;
			return CRun.compareTo(value, value2, comp);
		},

		compareTime: function (rhPtr, num, t)
		{
			var p = this.evtParams[num];
			return CRun.compareTo(t, p.timer, p.comparaison);
		}
	}

	/* Base for control extensions (James) */

	function CRunControl()
	{
		this.element = null;
		this.controlIgnoreHeight = false;
		this.bnShownOld = false;
	};

	CRunControl.prototype = CServices.extend(new CRunExtension(),
		{
			forcePosition: function ()
			{
				this.setPosition(this.ho.hoX, this.ho.hoY);
			},
			autoResize:    function ()
			{
				this.setPosition(this.ho.hoX, this.ho.hoY);
				this.setSize(this.ho.hoImgWidth, this.ho.hoImgHeight);
			},
			setElement:    function (e, visible)
			{
				this.element = e;

				e.style.position = 'absolute';

				this.setSize(this.ho.hoImgWidth, this.ho.hoImgHeight);
				this.setPosition(this.ho.hoX, this.ho.hoY);

				if (this.fontInfo)
					this.setFont(this.fontInfo);

				this.ho.bShown = visible;
				this.bShownOld = visible;
				if (this.rh.rhApp.loading)
				{
					e.style.visibility = 'hidden';
					this.bShownOld = false;
				}
				else
				{
					if (visible)
						e.style.visibility = 'visible';
					else
						e.style.visibility = 'hidden';
				}

				var container = this.rh.rhApp.container;

				container.appendChild(e);
			},
			getXOffset:    function ()
			{
			    if (this.rh.rhApp.canvas)
			        return this.rh.rhApp.canvas.offsetLeft;
			    return 0;
			},
			getYOffset:    function ()
			{
			    if (this.rh.rhApp.canvas)
			        return this.rh.rhApp.canvas.offsetTop;
			    return 0;
			},

			setX: function (x)
			{
				this.ctrlLastX = x;

				this.ho.setX(x);

				if (this.element)
					this.element.style.left = this.getXOffset() + this.rh.rhApp.xMouseOffset + (this.ho.hoX - this.ho.hoAdRunHeader.rhWindowX) * this.rh.rhApp.scaleX + 'px';
			},

			setY: function (y)
			{
				this.ctrlLastY = y;

				this.ho.setY(y);

				if (this.element)
				    this.element.style.top = this.getYOffset() + this.rh.rhApp.yMouseOffset + (this.ho.hoY - this.ho.hoAdRunHeader.rhWindowY) * this.rh.rhApp.scaleY + 'px';
			},

			setPosition: function (x, y)
			{
				this.ctrlLastX = x;
				this.ctrlLastY = y;

				this.ho.setPosition(x, y);

				if (this.element)
				{
				    this.element.style.left = this.getXOffset() + this.rh.rhApp.xMouseOffset + (this.ho.hoX - this.ho.hoAdRunHeader.rhWindowX) * this.rh.rhApp.scaleX + 'px';
				    this.element.style.top = this.getYOffset() + this.rh.rhApp.yMouseOffset + (this.ho.hoY - this.ho.hoAdRunHeader.rhWindowY) * this.rh.rhApp.scaleY + 'px';
				}
			},

			setWidth: function (width)
			{
				this.ctrlLastWidth = width;

				this.ho.setWidth(width);

				if (this.element)
					this.element.style.width = this.ho.hoImgWidth * this.rh.rhApp.scaleX + 'px';
			},

			setHeight: function (height)
			{
				this.ctrlLastHeight = height;

				this.ho.setHeight(height);

				if (this.element && !this.controlIgnoreHeight)
					this.element.style.height = this.ho.hoImgHeight * this.rh.rhApp.scaleY + 'px';
			},

			setSize: function (width, height)
			{
				this.ctrlLastWidth = width;
				this.ctrlLastHeight = height;

				this.ho.setSize(width, height);

				if (this.element)
				{
					this.element.style.width = this.ho.hoImgWidth * this.rh.rhApp.scaleX + 'px';
					if (!this.controlIgnoreHeight)
						this.element.style.height = this.ho.hoImgHeight * this.rh.rhApp.scaleY + 'px';
				}
			},

			setFont: function (fontInfo)
			{
				this.fontInfo = fontInfo;

				if (this.element)
					this.element.style.font = fontInfo.getFont();
			},

			destroyRunObject: function ()
			{
				if (this.element)
				{
					this.rh.rhApp.container.removeChild(this.element);
				}
			},

			getRunObjectFont: function ()
			{
				return this.fontInfo;
			},

			setRunObjectFont: function (fontInfo, rc)
			{
				this.setFont(fontInfo);
			},

			handleRunObject: function ()
			{
				if (!this.rh.rhApp.loading)
				{
					if (this.ho.bShown != this.bShownOld)
					{
					    this.bShownOld = this.ho.bShown;
					    if (this.element) {
					        if (this.ho.bShown)
					            this.element.style.visibility = 'visible';
					        else
					            this.element.style.visibility = 'hidden';
					    }
					}
				}
				if (this.ho.hoX != this.ctrlLastX ||
					this.ho.hoY != this.ctrlLastY)
				{
					this.setPosition(this.ho.hoX, this.ho.hoY);
				}

				if (this.ho.hoImgWidth != this.ctrlLastWidth ||
					this.ho.hoImgHeight != this.ctrlLastHeight)
				{
					this.setSize(this.ho.hoImgWidth, this.ho.hoImgHeight);
				}

				return 0;
			}
		});

	// CMoveDef object
	// ----------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */

	CMoveDef.MVTYPE_STATIC = 0;
	CMoveDef.MVTYPE_MOUSE = 1;
	CMoveDef.MVTYPE_RACE = 2;
	CMoveDef.MVTYPE_GENERIC = 3;
	CMoveDef.MVTYPE_BALL = 4;
	CMoveDef.MVTYPE_TAPED = 5;
	CMoveDef.MVTYPE_PLATFORM = 9;
	CMoveDef.MVTYPE_DISAPPEAR = 11;
	CMoveDef.MVTYPE_APPEAR = 12;
	CMoveDef.MVTYPE_BULLET = 13;
	CMoveDef.MVTYPE_EXT = 14;
	function CMoveDef()
	{
		this.mvType = 100;
		this.mvControl = 0;
		this.mvMoveAtStart = 0;
		this.mvDirAtStart = 0;
		this.mvOpt = 0;
	}
	CMoveDef.prototype =
	{
		setData: function (t, c, m, d, mo)
		{
			this.mvType = t;
			this.mvControl = c;
			this.mvMoveAtStart = m;
			this.mvDirAtStart = d;
			this.mvOpt = mo;
		}
	}

	// CMoveDefList object
	// ----------------------------------------------------------------
	function CMoveDefList()
	{
		this.nMovements = 0;
		this.moveList = null;
	}
	CMoveDefList.prototype =
	{
		load: function (file)
		{
			var debut = file.getFilePointer();
			this.nMovements = file.readAInt();
			this.moveList = new Array(this.nMovements);
			var n;
			for (n = 0; n < this.nMovements; n++)
			{
				file.seek(debut + 4 + 16 * n);

				var moduleNameOffset = file.readAInt();
				var mvtID = file.readAInt();
				var dataOffset = file.readAInt();
				var dataLength = file.readAInt();

				file.seek(debut + dataOffset);
				var control = file.readAShort();
				var type = file.readAShort();
				var move = file.readAByte();
				var mo = file.readAByte();
				file.skipBytes(2);
				var dirAtStart = file.readAInt();
				switch (type)
				{
					case 0:
						this.moveList[n] = new CMoveDefStatic();
						break;
					case 1:
						this.moveList[n] = new CMoveDefMouse();
						break;
					case 2:
						this.moveList[n] = new CMoveDefRace();
						break;
					case 3:
						this.moveList[n] = new CMoveDefGeneric();
						break;
					case 4:
						this.moveList[n] = new CMoveDefBall();
						break;
					case 5:
						this.moveList[n] = new CMoveDefPath();
						break;
					case 9:
						this.moveList[n] = new CMoveDefPlatform();
						break;
					case 14:
						this.moveList[n] = new CMoveDefExtension();
						break;
				}
				this.moveList[n].setData(type, control, move, dirAtStart, mo);
				this.moveList[n].load(file, dataLength - 12);
				if (type == 14)
				{
					file.seek(debut + moduleNameOffset);
					var name = file.readAString();
					name = name.substring(0, name.length - 4);
					name = name.toLowerCase();
					this.moveList[n].setModuleName(name, mvtID);
				}
			}
		}
	}

	// CMoveDefBall object
	// ------------------------------------------------------------------
	function CMoveDefBall()
	{
		this.mbSpeed = 0;
		this.mbBounce = 0;
		this.mbAngles = 0;
		this.mbSecurity = 0;
		this.mbDecelerate = 0;
	}
	CMoveDefBall.prototype = CServices.extend(new CMoveDef(),
		{
			load: function (file, length)
			{
				this.mbSpeed = file.readAShort();
				this.mbBounce = file.readAShort();
				this.mbAngles = file.readAShort();
				this.mbSecurity = file.readAShort();
				this.mbDecelerate = file.readAShort();
			}
		});

	// CMoveDefGeneric object
	// -----------------------------------------------------------------
	function CMoveDefGeneric()
	{
		this.mgSpeed = 0;
		this.mgAcc = 0;
		this.mgDec = 0;
		this.mgBounceMult = 0;
		this.mgDir = 0;
	}
	CMoveDefGeneric.prototype = CServices.extend(new CMoveDef(),
		{
			load: function (file, length)
			{
				this.mgSpeed = file.readAShort();
				this.mgAcc = file.readAShort();
				this.mgDec = file.readAShort();
				this.mgBounceMult = file.readAShort();
				this.mgDir = file.readAInt();
			}
		});

	// CMoveDefMouse object
	// -----------------------------------------------------------------
	function CMoveDefMouse()
	{
		this.mmDx = 0;
		this.mmFx = 0;
		this.mmDy = 0;
		this.mmFy = 0;
		this.mmFlags = 0;
	}
	CMoveDefMouse.prototype = CServices.extend(new CMoveDef(),
		{
			load: function (file, length)
			{
				this.mmDx = file.readShort();
				this.mmFx = file.readShort();
				this.mmDy = file.readShort();
				this.mmFy = file.readShort();
				this.mmFlags = file.readAShort();
			}
		});

	// CMoveDefPath object
	// -----------------------------------------------------------------
	function CMoveDefPath()
	{
		this.mtNumber = 0;
		this.mtMinSpeed = 0;
		this.mtMaxSpeed = 0;
		this.mtLoop = 0;
		this.mtRepos = 0;
		this.mtReverse = 0;
		this.steps = null;
	}
	CMoveDefPath.prototype = CServices.extend(new CMoveDef(),
		{
			load: function (file, length)
			{
				this.mtNumber = file.readAShort();
				this.mtMinSpeed = file.readAShort();
				this.mtMaxSpeed = file.readAShort();
				this.mtLoop = file.readAByte();
				this.mtRepos = file.readAByte();
				this.mtReverse = file.readAByte();
				file.skipBytes(1);

				this.steps = new Array(this.mtNumber);
				var n, next;
				var debut;
				for (n = 0; n < this.mtNumber; n++)
				{
					debut = file.getFilePointer();
					this.steps[n] = new CPathStep();
					file.readUnsignedByte();
					next = file.readUnsignedByte();
					this.steps[n].load(file);
					file.seek(debut + next);
				}
			}
		});

	// CPathStep object
	// ----------------------------------------------------------
	function CPathStep()
	{
		this.mdSpeed = 0;
		this.mdDir = 0;
		this.mdDx = 0;
		this.mdDy = 0;
		this.mdCosinus = 0;
		this.mdSinus = 0;
		this.mdLength = 0;
		this.mdPause = 0;
		this.mdName = null;
	}
	CPathStep.prototype =
	{
		load: function (file)
		{
			this.mdSpeed = file.readAByte();
			this.mdDir = file.readAByte();
			this.mdDx = file.readShort();
			this.mdDy = file.readShort();
			this.mdCosinus = file.readShort();
			this.mdSinus = file.readShort();
			this.mdLength = file.readAShort();
			this.mdPause = file.readAShort();
			var name = file.readAString();
			if (name.length > 0)
				this.mdName = name;
		}
	}

	// CMoveDefPlatform object
	// -------------------------------------------------------------
	function CMoveDefPlatform()
	{
		this.mpSpeed = 0;
		this.mpAcc = 0;
		this.mpDec = 0;
		this.mpJumpControl = 0;
		this.mpGravity = 0;
		this.mpJump = 0;
	}
	CMoveDefPlatform.prototype = CServices.extend(new CMoveDef(),
		{
			load: function (file, length)
			{
				this.mpSpeed = file.readAShort();
				this.mpAcc = file.readAShort();
				this.mpDec = file.readAShort();
				this.mpJumpControl = file.readAShort();
				this.mpGravity = file.readAShort();
				this.mpJump = file.readAShort();
			}
		});

	// CMoveDefRace object
	// ------------------------------------------------------------
	function CMoveDefRace()
	{
		this.mrSpeed = 0;
		this.mrAcc = 0;
		this.mrDec = 0;
		this.mrRot = 0;
		this.mrBounceMult = 0;
		this.mrAngles = 0;
		this.mrOkReverse = 0;
	}
	CMoveDefRace.prototype = CServices.extend(new CMoveDef(),
		{
			load: function (file, length)
			{
				this.mrSpeed = file.readAShort();
				this.mrAcc = file.readAShort();
				this.mrDec = file.readAShort();
				this.mrRot = file.readAShort();
				this.mrBounceMult = file.readAShort();
				this.mrAngles = file.readAShort();
				this.mrOkReverse = file.readAShort();
			}
		});

	// CMoveDefStatic object
	// ------------------------------------------------------------
	function CMoveDefStatic()
	{
	}
	CMoveDefStatic.prototype = CServices.extend(new CMoveDef(),
		{
			load: function (file, length)
			{
			}
		});

	// CMoveDefStatic object
	// ------------------------------------------------------------
	function CMoveDefExtension()
	{
		this.moduleName = null;
		this.mvtID = 0;
	    this.data = 0;
	    this.isPhysics = false;
	}
	CMoveDefExtension.prototype = CServices.extend(new CMoveDef(),
		{
			load:          function (file, length)
			{
				file.skipBytes(14);
				this.data = file.getFilePointer();
			},
			setModuleName: function (name, id)
			{
				this.moduleName = name;
				this.mvtID = id;
	            if (CServices.compareStringsIgnoreCase(this.moduleName, 'box2d8directions')
	                || CServices.compareStringsIgnoreCase(this.moduleName, 'box2dspring')
	                || CServices.compareStringsIgnoreCase(this.moduleName, 'box2dspaceship')
	                || CServices.compareStringsIgnoreCase(this.moduleName, 'box2dstatic')
	                || CServices.compareStringsIgnoreCase(this.moduleName, 'box2dracecar')
	                || CServices.compareStringsIgnoreCase(this.moduleName, 'box2daxial')
	                || CServices.compareStringsIgnoreCase(this.moduleName, 'box2dplatform')
	                || CServices.compareStringsIgnoreCase(this.moduleName, 'box2dbouncingball')
	                || CServices.compareStringsIgnoreCase(this.moduleName, 'box2dbackground')
	            ) {
	                this.isPhysics = true;
	            }
			}
		});

	// CMove object
	// ------------------------------------------------------------
	CMove.Cosinus32 =
		[
			256, 251, 236, 212, 181, 142, 97, 49,
			0, -49, -97, -142, -181, -212, -236, -251,
			-256, -251, -236, -212, -181, -142, -97, -49,
			0, 49, 97, 142, 181, 212, 236, 251
		];
	CMove.Sinus32 =
		[
			0, -49, -97, -142, -181, -212, -236, -251,
			-256, -251, -236, -212, -181, -142, -97, -49,
			0, 49, 97, 142, 181, 212, 236, 251,
			256, 251, 236, 212, 181, 142, 97, 49
		];
	CMove.accelerators =
		[
			0x0002, 0x0003, 0x0004, 0x0006, 0x0008, 0x000a, 0x000c, 0x0010, 0x0014, 0x0018,
			0x0030, 0x0038, 0x0040, 0x0048, 0x0050, 0x0058, 0x0060, 0x0068, 0x0070, 0x0078,
			0x0090, 0x00A0, 0x00B0, 0x00c0, 0x00d0, 0x00e0, 0x00f0, 0x0100, 0x0110, 0x0120,
			0x0140, 0x0150, 0x0160, 0x0170, 0x0180, 0x0190, 0x01a0, 0x01b0, 0x01c0, 0x01e0,
			0x0200, 0x0220, 0x0230, 0x0250, 0x0270, 0x0280, 0x02a0, 0x02b0, 0x02d0, 0x02e0,
			0x0300, 0x0310, 0x0330, 0x0350, 0x0360, 0x0380, 0x03a0, 0x03b0, 0x03d0, 0x03e0,
			0x0400, 0x0460, 0x04c0, 0x0520, 0x05a0, 0x0600, 0x0660, 0x06c0, 0x0720, 0x07a0,
			0x0800, 0x08c0, 0x0980, 0x0a80, 0x0b40, 0x0c00, 0x0cc0, 0x0d80, 0x0e80, 0x0f40,
			0x1000, 0x1990, 0x1332, 0x1460, 0x1664, 0x1800, 0x1999, 0x1b32, 0x1cc6, 0x1e64,
			0x2000, 0x266c, 0x2d98, 0x3404, 0x3a70, 0x40dc, 0x4748, 0x4db4, 0x5400, 0x6400,
			0x6400
		];
	CMove.Joy2Dir =
		[
			-1,
			8,
			24,
			-1,
			16,
			12,
			20,
			16,
			0,
			4,
			28,
			0,
			-1,
			8,
			24,
			-1
		];
	CMove.CosSurSin32 = [2599, 0, 844, 31, 479, 30, 312, 29, 210, 28, 137, 27, 78, 26, 25, 25, 0, 24];
	CMove.mvap_TableDirs =
		[
			0, -2, 0, 2, 0, -4, 0, 4, 0, -8, 0, 8, -4, 0, -8, 0, 0, 0,
			-2, -2, 2, 2, -4, -4, 4, 4, -8, -8, 8, 8, -4, 4, -8, 8, 0, 0,
			-2, 0, 2, 0, -4, 0, 4, 0, -8, 0, 8, 0, 0, 4, 0, 8, 0, 0,
			-2, 2, 2, -2, -4, 4, 4, -4, -8, 8, 8, -8, 4, 4, 8, 8, 0, 0,
			0, 2, 0, -2, 0, 4, 0, -4, 0, 8, 0, -8, 4, 0, 8, 0, 0, 0,
			2, 2, -2, -2, 4, 4, -4, -4, 8, 8, -8, -8, 4, -4, 8, -8, 0, 0,
			2, 0, -2, 0, 4, 0, -4, 0, 8, 0, -8, 0, 0, -4, 0, -8, 0, 0,
			2, -2, -2, 2, 4, -4, -4, 4, 8, -8, -8, 8, -4, -4, -8, -8, 0, 0
		];
	CMove.MVTOPT_8DIR_STICK = 0x01;
	CMove.getDeltaX = function (pente, angle)
	{
		return (pente * CMove.Cosinus32[angle]) / 256;
	}
	CMove.getDeltaY = function (pente, angle)
	{
		return (pente * CMove.Sinus32[angle]) / 256;
	}
	function CMove()
	{
		this.hoPtr = null;
		this.rmAcc = 0;
		this.rmDec = 0;
		this.rmCollisionCount = 0;
		this.rmStopSpeed = 0;
		this.rmAccValue = 0;
		this.rmDecValue = 0;
		this.rmOpt = 0;
	}

	CMove.prototype =
	{
		newMake_Move: function (speed, angle)
		{

			this.hoPtr.hoAdRunHeader.rh3CollisionCount++;
			this.rmCollisionCount = this.hoPtr.hoAdRunHeader.rh3CollisionCount;
			this.hoPtr.rom.rmMoveFlag = false;

			if (speed == 0)
			{
				this.hoPtr.hoAdRunHeader.newHandle_Collisions(this.hoPtr);
				return false;
			}

			var x, y;
			var speedShift;
			if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
			{
				speedShift = Math.floor(speed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef * 32.0);
			}
			else
			{
				speedShift = speed << 5;
			}
			while (speedShift > 2048)
			{
			    x = this.hoPtr.hoX * 65536 + (this.hoPtr.hoCalculX & 0x0000FFFF);
			    y = this.hoPtr.hoY * 65536 + (this.hoPtr.hoCalculY & 0x0000FFFF);
			    x += CMove.Cosinus32[angle] * 2048;
			    y += CMove.Sinus32[angle] * 2048;
				this.hoPtr.hoCalculX = x & 0x0000FFFF;
				this.hoPtr.hoX = Math.floor(x / 65536);
				this.hoPtr.hoCalculY = y & 0x0000FFFF;
				this.hoPtr.hoY = Math.floor(y / 65536);

				if (this.hoPtr.hoAdRunHeader.newHandle_Collisions(this.hoPtr))
				{
					return true;
				}
				if (this.hoPtr.rom.rmMoveFlag)
				{
					break;
				}
				speedShift -= 0x0800;
			}
			;
			if (!this.hoPtr.rom.rmMoveFlag)
			{
			    x = this.hoPtr.hoX * 65536 + (this.hoPtr.hoCalculX & 0x0000FFFF);
			    y = this.hoPtr.hoY * 65536 + (this.hoPtr.hoCalculY & 0x0000FFFF);
				x += CMove.Cosinus32[angle] * speedShift;
				y += CMove.Sinus32[angle] * speedShift;
				this.hoPtr.hoCalculX = x & 0x0000FFFF;
				this.hoPtr.hoX = Math.floor(x / 65536);
				this.hoPtr.hoCalculY = y & 0x0000FFFF;
				this.hoPtr.hoY = Math.floor(y / 65536);

				if (this.hoPtr.hoAdRunHeader.newHandle_Collisions(this.hoPtr))
				{
					return true;
				}
			}
			this.hoPtr.roc.rcChanged = true;
			if (!this.hoPtr.rom.rmMoveFlag)
				this.hoPtr.hoAdRunHeader.rhVBLObjet = 0;

			return this.hoPtr.rom.rmMoveFlag;
		},

		moveAtStart: function (mvPtr)
		{
			if (mvPtr.mvMoveAtStart == 0)
			{
				this.stop();
			}
		},

		getAccelerator: function (acceleration)
		{
			if (acceleration <= 100)
			{
				return CMove.accelerators[acceleration];
			}
			return acceleration << 8;
		},

		mv_Approach: function (bStickToObject)
		{
			if (bStickToObject)
			{
				this.mb_Approach(false);
				return;
			}

			var flag = false;

			switch (this.hoPtr.hoAdRunHeader.rhEvtProg.rhCurCode & 0xFFFF0000)
			{
				case (-12 << 16):         // CNDL_EXTOUTPLAYFIELD:
					var x = this.hoPtr.hoX - this.hoPtr.hoImgXSpot;
					var y = this.hoPtr.hoY - this.hoPtr.hoImgYSpot;
					var dir = this.hoPtr.hoAdRunHeader.quadran_Out(x, y, x + this.hoPtr.hoImgWidth, y + this.hoPtr.hoImgHeight);
					x = this.hoPtr.hoX;
					y = this.hoPtr.hoY;
					if ((dir & CRun.BORDER_LEFT) != 0)
						x = this.hoPtr.hoImgXSpot;
					if ((dir & CRun.BORDER_RIGHT) != 0)
						x = this.hoPtr.hoAdRunHeader.rhLevelSx - this.hoPtr.hoImgWidth + this.hoPtr.hoImgXSpot;
					if ((dir & CRun.BORDER_TOP) != 0)
						y = this.hoPtr.hoImgYSpot;
					if ((dir & CRun.BORDER_BOTTOM) != 0)
						y = this.hoPtr.hoAdRunHeader.rhLevelSy - this.hoPtr.hoImgHeight + this.hoPtr.hoImgYSpot;
					this.hoPtr.hoX = x;
					this.hoPtr.hoY = y;
					return;
				case (-13 << 16):	    // CNDL_EXTCOLBACK:
				case (-14 << 16):	    // CNDL_EXTCOLLISION:
					var index = (this.hoPtr.hoAdRunHeader.getDir(this.hoPtr) >> 2) * 18;
					do
					{
						if (this.tst_Position(this.hoPtr.hoX + CMove.mvap_TableDirs[index], this.hoPtr.hoY + CMove.mvap_TableDirs[index + 1], flag))
						{
							this.hoPtr.hoX += CMove.mvap_TableDirs[index];
							this.hoPtr.hoY += CMove.mvap_TableDirs[index + 1];
							return;
						}
						index += 2;
					} while (CMove.mvap_TableDirs[index] != 0 || CMove.mvap_TableDirs[index + 1] != 0);

					if (flag == false)
					{
						this.hoPtr.hoX = this.hoPtr.roc.rcOldX;
						this.hoPtr.hoY = this.hoPtr.roc.rcOldY;
						this.hoPtr.roc.rcImage = this.hoPtr.roc.rcOldImage;
						this.hoPtr.roc.rcAngle = this.hoPtr.roc.rcOldAngle;
						return;
					}
					break;
				default:
					break;
			}
		},

		mb_Approach: function (flag)
		{
			switch (this.hoPtr.hoAdRunHeader.rhEvtProg.rhCurCode & 0xFFFF0000)
			{
				case (-12 << 16):         // CNDL_EXTOUTPLAYFIELD:
					var x = this.hoPtr.hoX - this.hoPtr.hoImgXSpot;
					var y = this.hoPtr.hoY - this.hoPtr.hoImgYSpot;
					var dir = this.hoPtr.hoAdRunHeader.quadran_Out(x, y, x + this.hoPtr.hoImgWidth, y + this.hoPtr.hoImgHeight);
					x = this.hoPtr.hoX;
					y = this.hoPtr.hoY;
					if ((dir & CRun.BORDER_LEFT) != 0)
						x = this.hoPtr.hoImgXSpot;
					if ((dir & CRun.BORDER_RIGHT) != 0)
						x = this.hoPtr.hoAdRunHeader.rhLevelSx - this.hoPtr.hoImgWidth + this.hoPtr.hoImgXSpot;
					if ((dir & CRun.BORDER_TOP) != 0)
						y = this.hoPtr.hoImgYSpot;
					if ((dir & CRun.BORDER_BOTTOM) != 0)
						y = this.hoPtr.hoAdRunHeader.rhLevelSy - this.hoPtr.hoImgHeight + this.hoPtr.hoImgYSpot;
					this.hoPtr.hoX = x;
					this.hoPtr.hoY = y;
					return;

				case (-13 << 16):	    // CNDL_EXTCOLBACK:
				case (-14 << 16):	    // CNDL_EXTCOLLISION:
					var pt = new CPoint();
					if (this.mbApproachSprite(this.hoPtr.hoX, this.hoPtr.hoY, this.hoPtr.roc.rcOldX, this.hoPtr.roc.rcOldY, flag, pt))
					{
						this.hoPtr.hoX = pt.x;
						this.hoPtr.hoY = pt.y;
						return;
					}
					var index = (this.hoPtr.hoAdRunHeader.getDir(this.hoPtr) >> 2) * 18;
					do
					{
						if (this.tst_Position(this.hoPtr.hoX + CMove.mvap_TableDirs[index], this.hoPtr.hoY + CMove.mvap_TableDirs[index + 1], flag))
						{
							this.hoPtr.hoX += CMove.mvap_TableDirs[index];
							this.hoPtr.hoY += CMove.mvap_TableDirs[index + 1];
							return;
						}
						index += 2;
					} while (CMove.mvap_TableDirs[index] != 0 || CMove.mvap_TableDirs[index + 1] != 0);

					if (flag == false)
					{
						this.hoPtr.hoX = this.hoPtr.roc.rcOldX;
						this.hoPtr.hoY = this.hoPtr.roc.rcOldY;
						this.hoPtr.roc.rcImage = this.hoPtr.roc.rcOldImage;
						this.hoPtr.roc.rcAngle = this.hoPtr.roc.rcOldAngle;
						return;
					}
					break;
				default:
					break;
			}
		},

		tst_SpritePosition: function (x, y, htFoot, planCol, flag)
		{
			var sprOi;
			sprOi = -1;
			if (flag)
			{
				sprOi = this.hoPtr.hoOi;
			}
			var oilPtr = this.hoPtr.hoOiList;

			if ((oilPtr.oilLimitFlags & 0x000F) != 0)
			{
				var xx = x - this.hoPtr.hoImgXSpot;
				var yy = y - this.hoPtr.hoImgYSpot;
				if ((this.hoPtr.hoAdRunHeader.quadran_Out(xx, yy, xx + this.hoPtr.hoImgWidth, yy + this.hoPtr.hoImgHeight) & oilPtr.oilLimitFlags) != 0)
					return false;
			}

			if ((oilPtr.oilLimitFlags & 0x0010) != 0)
			{
				if (this.hoPtr.hoAdRunHeader.colMask_TestObject_IXY(this.hoPtr, this.hoPtr.roc.rcImage, this.hoPtr.roc.rcAngle, this.hoPtr.roc.rcScaleX, this.hoPtr.roc.rcScaleY, x, y, htFoot, planCol))
					return false;
			}

			if (oilPtr.oilLimitList == -1)
				return true;

			// Demande les collisions a cette position...
			var list = this.hoPtr.hoAdRunHeader.objectAllCol_IXY(this.hoPtr, this.hoPtr.roc.rcImage, this.hoPtr.roc.rcAngle, this.hoPtr.roc.rcScaleX, this.hoPtr.roc.rcScaleY, x, y, oilPtr.oilColList);
			if (list == null)
				return true;

			var lb = this.hoPtr.hoAdRunHeader.rhEvtProg.limitBuffer;
			var index;
			for (index = 0; index < list.size(); index++)
			{
				var hoSprite = list.get(index);
				var oi = hoSprite.hoOi;
				if (oi != sprOi)
				{
					var ll;
					for (ll = oilPtr.oilLimitList; lb[ll] >= 0; ll++)
					{
						if (lb[ll] == oi)
							return false;
					}
				}
			}
			return true;
		},

		tst_Position: function (x, y, flag)
		{
			var sprOi;

			sprOi = -1;
			if (flag)
				sprOi = this.hoPtr.hoOi;
			var oilPtr = this.hoPtr.hoOiList;

			if ((oilPtr.oilLimitFlags & 0x000F) != 0)
			{
				var xx = x - this.hoPtr.hoImgXSpot;
				var yy = y - this.hoPtr.hoImgYSpot;
				var dir = this.hoPtr.hoAdRunHeader.quadran_Out(xx, yy, xx + this.hoPtr.hoImgWidth, yy + this.hoPtr.hoImgHeight);
				if ((dir & oilPtr.oilLimitFlags) != 0)
					return false;
			}

			if ((oilPtr.oilLimitFlags & 0x0010) != 0)
			{
				if (this.hoPtr.hoAdRunHeader.colMask_TestObject_IXY(this.hoPtr, this.hoPtr.roc.rcImage, this.hoPtr.roc.rcAngle, this.hoPtr.roc.rcScaleX, this.hoPtr.roc.rcScaleY, x, y, 0, CRunFrame.CM_TEST_PLATFORM))
					return false;
			}

			if (oilPtr.oilLimitList == -1)
				return true;

			var list = this.hoPtr.hoAdRunHeader.objectAllCol_IXY(this.hoPtr, this.hoPtr.roc.rcImage, this.hoPtr.roc.rcAngle, this.hoPtr.roc.rcScaleX, this.hoPtr.roc.rcScaleY, x, y, oilPtr.oilColList);
			if (list == null)
				return true;

			var lb = this.hoPtr.hoAdRunHeader.rhEvtProg.limitBuffer;
			var index;
			for (index = 0; index < list.size(); index++)
			{
				var hoSprite = list.get(index);
				var oi = hoSprite.hoOi;
				if (oi != sprOi)
				{
					var ll;
					for (ll = oilPtr.oilLimitList; lb[ll] >= 0; ll++)
					{
						if (lb[ll] == oi) return false;
					}
				}
			}
			return true;
		},

		mpApproachSprite: function (destX, destY, maxX, maxY, htFoot, planCol, ptFinal)
		{
			var presX = destX;
			var presY = destY;
			var loinX = maxX;
			var loinY = maxY;

			var x = CServices.floatToInt((presX + loinX) / 2);
			var y = CServices.floatToInt((presY + loinY) / 2);
			var oldX, oldY;

			do
			{
				if (this.tst_SpritePosition(x + this.hoPtr.hoAdRunHeader.rhWindowX, y + this.hoPtr.hoAdRunHeader.rhWindowY, htFoot, planCol, false))
				{
					loinX = x;
					loinY = y;
					oldX = x;
					oldY = y;
					x = CServices.floatToInt((loinX + presX) / 2);
					y = CServices.floatToInt((loinY + presY) / 2);
					if (x == oldX && y == oldY)
					{
						if (loinX != presX || loinY != presY)
						{
							if (this.tst_SpritePosition(presX + this.hoPtr.hoAdRunHeader.rhWindowX, presY + this.hoPtr.hoAdRunHeader.rhWindowY, htFoot, planCol, false))
							{
								x = presX;
								y = presY;
							}
						}
						ptFinal.x = x;
						ptFinal.y = y;
						return true;
					}
				}
				else
				{
					presX = x;
					presY = y;
					oldX = x;
					oldY = y;
					x = CServices.floatToInt((loinX + presX) / 2);
					y = CServices.floatToInt((loinY + presY) / 2);
					if (x == oldX && y == oldY)
					{
						if (loinX != presX || loinY != presY)
						{
							if (this.tst_SpritePosition(loinX + this.hoPtr.hoAdRunHeader.rhWindowX, loinY + this.hoPtr.hoAdRunHeader.rhWindowY, htFoot, planCol, false))
							{
								ptFinal.x = loinX;
								ptFinal.y = loinY;
								return true;
							}
						}
						ptFinal.x = x;
						ptFinal.y = y;
						return false;
					}
				}
			} while (true);
		},

		mbApproachSprite: function (destX, destY, maxX, maxY, flag, ptFinal)
		{
			var presX = destX;
			var presY = destY;
			var loinX = maxX;
			var loinY = maxY;

			var x = CServices.floatToInt((presX + loinX) / 2);
			var y = CServices.floatToInt((presY + loinY) / 2);
			var oldX, oldY;

			do
			{
				if (this.tst_Position(x, y, flag))
				{
					loinX = x;
					loinY = y;
					oldX = x;
					oldY = y;
					x = CServices.floatToInt((loinX + presX) / 2);
					y = CServices.floatToInt((loinY + presY) / 2);
					if (x == oldX && y == oldY)
					{
						if (loinX != presX || loinY != presY)
						{
							if (this.tst_Position(presX, presY, flag))
							{
								x = presX;
								y = presY;
							}
						}
						ptFinal.x = x;
						ptFinal.y = y;
						return true;
					}
				}
				else
				{
					presX = x;
					presY = y;
					oldX = x;
					oldY = y;
					x = CServices.floatToInt((loinX + presX) / 2);
					y = CServices.floatToInt((loinY + presY) / 2);
					if (x == oldX && y == oldY)
					{
						if (loinX != presX || loinY != presY)
						{
							if (this.tst_Position(loinX, loinY, flag))
							{
								ptFinal.x = loinX;
								ptFinal.y = loinY;
								return true;
							}
						}
						ptFinal.x = x;
						ptFinal.y = y;
						return false;
					}
				}
			} while (true);
		},

		setAcc:      function (acc)
		{
			this.rmAcc = acc;
			this.rmAccValue = this.getAccelerator(acc);
			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
				this.movement.setAcc(acc);
		},
		setDec:      function (dec)
		{
			this.rmDec = dec;
			this.rmDecValue = this.getAccelerator(dec);
			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
				this.movement.setDec(dec);
		},
		setRotSpeed: function (speed)
		{
			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_RACE)
			{
				if (speed > 250) speed = 250;
				if (speed < 0) speed = 0;
				this.setRotSpeed(speed);
			}
			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
				this.movement.setRotSpeed(speed);
		},

		set8Dirs: function (dirs)
		{
			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_GENERIC)
				this.set8DirsGeneric(dirs);
			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
				this.movement.set8Dirs(dirs);
		},

		setGravity: function (gravity)
		{
			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_PLATFORM)
			{
				if (gravity > 250) gravity = 250;
				if (gravity < 0) gravity = 0;
				this.setGravity(gravity);
			}
			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
				this.movement.setGravity(gravity);
		},

		getSpeed:   function ()
		{
			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
				return this.movement.getSpeed();
			return this.hoPtr.roc.rcSpeed;
		},
		getDir:     function ()
		{
			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
			{
				if (this.movement.getDir)
				{
					return this.movement.getDir();
				}
			}
			return this.hoPtr.roc.rcDir;
		},
		getAcc:     function ()
		{
			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
				return this.movement.getAcceleration();
			return this.rmAcc;
		},
		getDec:     function ()
		{
			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
				return this.movement.getDeceleration();
			return this.rmDec;
		},
		getGravity: function ()
		{
			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_PLATFORM)
				return this.mp.MP_Gravity;
			if (this.hoPtr.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
				return this.movement.getGravity();
			return 0;
		},
		kill:       function (bFast)
		{
		},
		start:      function ()
		{
		}
	}


	// CMoveBall object
	// -----------------------------------------------------------------------
	CMoveBall.rebond_List =
		[
			0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			30, 31, 0, 1, 4, 3, 2, 1, 0, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 24, 25, 26, 27, 27, 28, 28, 28, 28, 29, 29,
			24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 16, 17, 18, 19, 19, 20, 20, 20, 20, 21, 21, 22, 23, 24, 25, 28, 27, 26, 25,
			0, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 20, 21, 22, 22, 23, 24, 24, 24, 24, 25, 26, 27, 28, 29, 30,
			8, 7, 6, 5, 4, 8, 9, 10, 11, 11, 12, 12, 12, 12, 13, 13, 14, 15, 16, 17, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9,
			0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			16, 15, 14, 13, 12, 11, 10, 9, 8, 12, 13, 14, 15, 15, 16, 16, 16, 16, 17, 17, 18, 19, 20, 21, 24, 23, 22, 21, 20, 19, 18, 17,
			16, 17, 18, 19, 20, 21, 22, 23, 24, 23, 22, 21, 20, 19, 18, 17, 16, 17, 18, 19, 20, 21, 22, 23, 24, 23, 22, 21, 20, 19, 18, 17,
			3, 3, 4, 4, 4, 4, 5, 5, 6, 7, 8, 9, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 31, 30, 29, 28, 0, 1, 2,
			0, 0, 1, 1, 2, 3, 4, 5, 8, 7, 6, 5, 4, 3, 2, 1, 0, 31, 30, 29, 28, 27, 26, 25, 24, 28, 29, 30, 31, 31, 0, 0,
			0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			0, 31, 30, 29, 28, 27, 26, 25, 24, 25, 26, 27, 28, 29, 30, 31, 0, 31, 30, 29, 28, 27, 25, 25, 24, 25, 26, 27, 28, 29, 30, 31,
			0, 4, 5, 6, 7, 7, 8, 8, 8, 8, 9, 9, 10, 11, 12, 13, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1,
			0, 1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 1,
			16, 15, 14, 13, 12, 11, 10, 9, 8, 9, 10, 11, 12, 13, 14, 15, 16, 15, 14, 13, 12, 11, 10, 9, 8, 9, 10, 11, 12, 13, 14, 15,
			0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31
		];
	CMoveBall.MaskBounce = [0xFFFFFFFC, 0xFFFFFFFE, 0xFFFFFFFF];
	CMoveBall.PlusAngles = [-4, 4, -2, 2, -1, 1];
	CMoveBall.PlusAnglesTry = [-4, 4, -4, 4, -4, 4];

	function CMoveBall()
	{
		this.MB_StartDir = 0;
		this.MB_Angles = 0;
		this.MB_Securite = 0;
		this.MB_SecuCpt = 0;
		this.MB_Bounce = 0;
		this.MB_Speed = 0;
		this.MB_MaskBounce = 0;
		this.MB_LastBounce = 0;
		this.MB_Blocked = false;
	}
	CMoveBall.prototype = CServices.extend(new CMove(),
		{
			init: function (ho, mvPtr)
			{
				this.hoPtr = ho;
				var mbPtr = mvPtr;

				this.hoPtr.hoCalculX = 0;
				this.hoPtr.hoCalculY = 0;
				this.hoPtr.roc.rcSpeed = mbPtr.mbSpeed;
				this.hoPtr.roc.rcMaxSpeed = mbPtr.mbSpeed;
				this.hoPtr.roc.rcMinSpeed = mbPtr.mbSpeed;
				this.MB_Speed = mbPtr.mbSpeed << 8;
				var dec = mbPtr.mbDecelerate;						//; Deceleration
				if (dec != 0)
				{
					dec = this.getAccelerator(dec);
					this.hoPtr.roc.rcMinSpeed = 0;							//; Vitesse mini= 0
				}
				this.rmDecValue = dec;
				this.MB_Bounce = mbPtr.mbBounce;				//; Randomizator
				this.MB_Angles = mbPtr.mbAngles;				//; Securite 0.100
				this.MB_MaskBounce = CMoveBall.MaskBounce[this.MB_Angles];
				this.MB_Blocked = false;
				this.MB_LastBounce = -1;

				this.MB_Securite = (100 - mbPtr.mbSecurity) / 8;
				this.MB_SecuCpt = this.MB_Securite;
				this.moveAtStart(mvPtr);
				this.hoPtr.roc.rcChanged = true;
			},

			move: function ()
			{
				this.hoPtr.rom.rmBouncing = false;
				this.hoPtr.hoAdRunHeader.rhVBLObjet = 1;

				this.hoPtr.roc.rcAnim = CAnim.ANIMID_WALK;
				if (this.hoPtr.roa != null)
					this.hoPtr.roa.animate();

				if (this.rmDecValue != 0)
				{
					var speed = this.MB_Speed;
					if (speed > 0)
					{
						var dSpeed = this.rmDecValue;
						if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
							dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
						speed -= dSpeed;
						if (speed < 0)
							speed = 0;
						this.MB_Speed = speed;
						speed >>= 8;
						this.hoPtr.roc.rcSpeed = speed;
					}
				}
				this.newMake_Move(this.hoPtr.roc.rcSpeed, this.hoPtr.hoAdRunHeader.getDir(this.hoPtr));
			},
			stop: function ()
			{
				if (this.rmStopSpeed == 0)
				{
					this.rmStopSpeed = this.hoPtr.roc.rcSpeed | 0x8000;
					this.hoPtr.roc.rcSpeed = 0;
					this.MB_Speed = 0;
					this.hoPtr.rom.rmMoveFlag = true;
				}
			},

			start:  function ()
			{
				var speed = this.rmStopSpeed;
				if (speed != 0)
				{
					speed &= 0x7FFF;
					this.hoPtr.roc.rcSpeed = speed;
					this.MB_Speed = speed << 8;
					this.rmStopSpeed = 0;
					this.hoPtr.rom.rmMoveFlag = true;
				}
			},
			bounce: function ()
			{
				if (this.rmStopSpeed != 0)
					return;

				if (this.hoPtr.hoAdRunHeader.rhLoopCount == this.MB_LastBounce)
					return;
				this.MB_LastBounce = this.hoPtr.hoAdRunHeader.rhLoopCount;

				if (this.rmCollisionCount == this.hoPtr.hoAdRunHeader.rh3CollisionCount)
				{
					this.mb_Approach(this.MB_Blocked);
				}

				var x = this.hoPtr.hoX;
				var y = this.hoPtr.hoY;
				var rebond = 0;
				x -= 8;
				y -= 8;
				if (this.tst_Position(x, y, this.MB_Blocked) == false)
					rebond |= 0x01;
				x += 16;
				if (this.tst_Position(x, y, this.MB_Blocked) == false)
					rebond |= 0x02;
				y += 16;
				if (this.tst_Position(x, y, this.MB_Blocked) == false)
					rebond |= 0x04;
				x -= 16;
				if (this.tst_Position(x, y, this.MB_Blocked) == false)
					rebond |= 0x08;

				var dir = CMoveBall.rebond_List[rebond * 32 + this.hoPtr.hoAdRunHeader.getDir(this.hoPtr)];
				dir &= this.MB_MaskBounce;
				if (!this.mvb_Test(dir))
				{
					var angles = CMoveBall.PlusAnglesTry[this.MB_Angles * 2 + 1];
					var angles2 = angles;
					var bFlag = false;
					do
					{
						dir -= angles;
						dir &= 31;
						if (this.mvb_Test(dir))
						{
							bFlag = true;
							break;
						}
						dir += 2 * angles;
						dir &= 31;
						if (this.mvb_Test(dir))
						{
							bFlag = true;
							break;
						}
						dir -= angles;
						dir &= 31;
						angles += angles2;
					} while (angles <= 16);

					if (bFlag == false)
					{
						this.MB_Blocked = true;
						this.hoPtr.roc.rcDir = this.hoPtr.hoAdRunHeader.random(32) & this.MB_MaskBounce;
						this.hoPtr.rom.rmBouncing = true;
						this.hoPtr.rom.rmMoveFlag = true;
						return;
					}
				}

				this.MB_Blocked = false;
				this.hoPtr.roc.rcDir = dir;
				var rnd = this.hoPtr.hoAdRunHeader.random(100);
				if (rnd < this.MB_Bounce)
				{
					rnd >>= 2;
					if (rnd < 25)
					{
						rnd -= 12;
						rnd &= 31;
						rnd &= this.MB_MaskBounce;
						if (this.mvb_Test(rnd))
						{
							this.hoPtr.roc.rcDir = rnd;
							this.hoPtr.rom.rmBouncing = true;
							this.hoPtr.rom.rmMoveFlag = true;
							return;
						}
					}
				}

				dir = this.hoPtr.hoAdRunHeader.getDir(this.hoPtr) & 0x0007;
				if (this.MB_SecuCpt != 12)
				{
					if (dir == 0)
					{
						this.MB_SecuCpt--;
						if (this.MB_SecuCpt < 0)
						{
							dir = this.hoPtr.hoAdRunHeader.getDir(this.hoPtr) + CMoveBall.PlusAngles[this.hoPtr.hoAdRunHeader.random(2) + this.MB_Angles * 2];
							dir &= 31;
							if (this.mvb_Test(dir))
							{
								this.hoPtr.roc.rcDir = dir;
								this.MB_SecuCpt = this.MB_Securite;
							}
						}
					}
					else
					{
						this.MB_SecuCpt = this.MB_Securite;
					}
				}
				this.hoPtr.rom.rmBouncing = true;
				this.hoPtr.rom.rmMoveFlag = true;
			},

			mvb_Test:    function (dir)
			{
				var calculX = this.hoPtr.hoX * 65536 + (this.hoPtr.hoCalculX & 0x0000FFFF);
				var calculY = this.hoPtr.hoY * 65536 + (this.hoPtr.hoCalculY & 0x0000FFFF);
				var x = (CMove.Cosinus32[dir] * 2048) + calculX;
				var y = (CMove.Sinus32[dir] * 2048) + calculY;
				x = Math.floor(x / 65536);
				y = Math.floor(y / 65536);
				return this.tst_Position(x, y, false);
			},
			setDir:      function (dir)
			{
			},
			setSpeed:    function (speed)
			{
				if (speed < 0)
					speed = 0;
				if (speed > 250)
					speed = 250;
				this.hoPtr.roc.rcSpeed = speed;
				this.MB_Speed = speed << 8;
				this.rmStopSpeed = 0;
				this.hoPtr.rom.rmMoveFlag = true;
			},
			setMaxSpeed: function (speed)
			{
				this.setSpeed(speed);
			},

			reverse:      function ()
			{
				if (this.rmStopSpeed == 0)
				{
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcDir += 16;
					this.hoPtr.roc.rcDir &= 31;
				}
			},
			setXPosition: function (x)
			{
				if (this.hoPtr.hoX != x)
				{
					this.hoPtr.hoX = x;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
					this.hoPtr.roc.rcCheckCollides = true;
				}
			},
			setYPosition: function (y)
			{
				if (this.hoPtr.hoY != y)
				{
					this.hoPtr.hoY = y;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
					this.hoPtr.roc.rcCheckCollides = true;
				}
			}
		});

	// CMoveBuller object
	// --------------------------------------------------------------
	function CMoveBullet()
	{
		this.MBul_Wait = false;
		this.MBul_ShootObject = null;
	}
	CMoveBullet.prototype = CServices.extend(new CMove(),
		{
			init:         function (ho, mvPtr)
			{
				this.hoPtr = ho;
				this.rhPtr = ho.hoAdRunHeader;
				this.rhPtr.GetBase();
				if (this.hoPtr.ros != null)
					this.hoPtr.ros.setColFlag(false);
				if (this.hoPtr.ros != null)
				{
					this.hoPtr.ros.rsFlags &= ~CRSpr.RSFLAG_VISIBLE;
					this.hoPtr.ros.obHide();
				}
				this.MBul_Wait = true;
				this.hoPtr.hoCalculX = 0;
				this.hoPtr.hoCalculY = 0;
				if (this.hoPtr.roa != null)
					this.hoPtr.roa.init_Animation(CAnim.ANIMID_WALK);
				this.hoPtr.roc.rcSpeed = 0;
				this.hoPtr.roc.rcCheckCollides = true;
				this.hoPtr.roc.rcChanged = true;
			},
			init2:        function (parent)
			{
				this.hoPtr.roc.rcMaxSpeed = this.hoPtr.roc.rcSpeed;
				this.hoPtr.roc.rcMinSpeed = this.hoPtr.roc.rcSpeed;
	            this.MBul_ShootObject = parent;
	            if (parent != null)
	                parent.hoFlags |= CObject.HOF_SHOOTER;
			},
			kill:         function (bFast)
			{
				this.freeBullet(this.hoPtr);
			},
			move:         function ()
			{
				if (this.MBul_Wait)
				{
					if (this.MBul_ShootObject.roa != null)
					{
						if (this.MBul_ShootObject.roa.raAnimOn == CAnim.ANIMID_SHOOT)
							return;
					}
					this.startBullet();
				}

				if (this.hoPtr.roa != null)
					this.hoPtr.roa.animate();
				this.newMake_Move(this.hoPtr.roc.rcSpeed, this.hoPtr.hoAdRunHeader.getDir(this.hoPtr));

				if (this.hoPtr.hoX < -64 || this.hoPtr.hoX > this.hoPtr.hoAdRunHeader.rhLevelSx + 64 || this.hoPtr.hoY < -64 || this.hoPtr.hoY > this.hoPtr.hoAdRunHeader.rhLevelSy + 64)
				{
					this.hoPtr.hoCallRoutine = false;
					this.hoPtr.hoAdRunHeader.destroy_Add(this.hoPtr.hoNumber);
				}
				if (this.hoPtr.roc.rcCheckCollides)
				{
					this.hoPtr.roc.rcCheckCollides = false;
					this.hoPtr.hoAdRunHeader.newHandle_Collisions(this.hoPtr);
				}
			},
			startBullet:  function ()
			{
				if (this.hoPtr.ros != null)
					this.hoPtr.ros.setColFlag(true);
				if (this.hoPtr.ros != null)
				{
					this.hoPtr.ros.rsFlags |= CRSpr.RSFLAG_VISIBLE;
					this.hoPtr.ros.obShow();
				}
				if (this.rhPtr.rh4Box2DBase != null)
				{
					var hoParent = this.MBul_ShootObject;
					var pMovement = this.rhPtr.GetMBase(hoParent);
					if (pMovement != null)
					{
						var pBase = this.rhPtr.rh4Box2DBase;
						var pMBase = new CRunMBase();
						this.MBul_MBase = pMBase;
						pMBase.InitBase(this.hoPtr, CRunMBase.MTYPE_OBJECT);
						pMBase.m_identifier = pBase.identifier;
						this.MBul_Body = pBase.rCreateBullet(pMovement.m_currentAngle, this.hoPtr.roc.rcSpeed / 250. * 50.0, pMBase);
						pMBase.m_body = this.MBul_Body;
						if (this.MBul_Body == null)
						{
							this.MBul_MBase = null;
						}
					}
				}
				this.MBul_Wait = false;
				this.MBul_ShootObject = null;
			},
			freeBullet:   function (hoPtr)
			{
				if (this.MBul_Body != null)
				{
					var rhPtr = this.hoPtr.hoAdRunHeader;
					pBase = rhPtr.rh4Box2DBase;
					pBase.rDestroyBody(this.MBul_Body);
					this.MBul_Body = null;
				}
				if (this.MBul_MBase != null)
				{
					this.MBul_MBase = null;
				}
			},
			setXPosition: function (x)
			{
				if (this.hoPtr.hoX != x)
				{
					this.hoPtr.hoX = x;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
					this.hoPtr.roc.rcCheckCollides = true;
				}
			},
			setYPosition: function (y)
			{
				if (this.hoPtr.hoY != y)
				{
					this.hoPtr.hoY = y;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
					this.hoPtr.roc.rcCheckCollides = true;
				}
			},
			setDir:       function (dir)
			{
			},
			reverse:      function (dir)
			{
			},
			stop:         function ()
			{
			},
			start:        function ()
			{
			},
			bounce:       function ()
			{
			},
			setSpeed:     function (speed)
			{
			},
			setMaxSpeed:  function (speed)
			{
			}
		});

	// CMoveDisappear object
	// ----------------------------------------------------------------
	function CMoveDisappear()
	{
	}
	CMoveDisappear.prototype = CServices.extend(new CMove(),
		{
			init:         function (ho, mvPtr)
			{
				this.hoPtr = ho;
			},
			move:         function ()
			{
				if ((this.hoPtr.hoFlags & CObject.HOF_FADEOUT) == 0)
				{
					if (this.hoPtr.roa != null)
					{
						this.hoPtr.roa.animate();
						if (this.hoPtr.roa.raAnimForced != CAnim.ANIMID_DISAPPEAR + 1)
						{
							this.hoPtr.hoAdRunHeader.destroy_Add(this.hoPtr.hoNumber);
						}
					}
				}
			},
			setXPosition: function (x)
			{
				if (this.hoPtr.hoX != x)
				{
					this.hoPtr.hoX = x;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
				}
			},
			setYPosition: function (y)
			{
				if (this.hoPtr.hoY != y)
				{
					this.hoPtr.hoY = y;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
				}
			},
			setDir:       function (dir)
			{
			},
			reverse:      function (dir)
			{
			},
			stop:         function ()
			{
			},
			start:        function ()
			{
			},
			bounce:       function ()
			{
			},
			setSpeed:     function (speed)
			{
			},
			setMaxSpeed:  function (speed)
			{
			}
		});

	// CMoveGeneric object
	// ---------------------------------------------------------------------
	function CMoveGeneric()
	{
		this.MG_Bounce = 0;
		this.MG_OkDirs = 0;
		this.MG_BounceMu = 0;
		this.MG_Speed = 0;
		this.MG_LastBounce = 0;
		this.MG_DirMask = 0;
	}
	CMoveGeneric.prototype = CServices.extend(new CMove(),
		{
			init: function (ho, mgPtr)
			{
				this.hoPtr = ho;

				this.hoPtr.hoCalculX = 0;
				this.hoPtr.hoCalculY = 0;
				this.MG_Speed = 0;
				this.hoPtr.roc.rcSpeed = 0;
				this.MG_Bounce = 0;
				this.MG_LastBounce = -1;
				this.hoPtr.roc.rcPlayer = mgPtr.mvControl;
				this.rmAcc = mgPtr.mgAcc;
				this.rmAccValue = this.getAccelerator(this.rmAcc);
				this.rmDec = mgPtr.mgDec;
				this.rmDecValue = this.getAccelerator(this.rmDec);
				this.hoPtr.roc.rcMaxSpeed = mgPtr.mgSpeed;
				this.hoPtr.roc.rcMinSpeed = 0;
				this.MG_BounceMu = mgPtr.mgBounceMult;
				this.MG_OkDirs = mgPtr.mgDir;
				this.rmOpt = mgPtr.mvOpt;
				this.hoPtr.roc.rcChanged = true;
			},

			move: function ()
			{
				var direction;
				var autorise;
				var speed, speed8, dir;

				this.hoPtr.hoAdRunHeader.rhVBLObjet = 1;

				direction = this.hoPtr.hoAdRunHeader.getDir(this.hoPtr);
				this.hoPtr.roc.rcOldDir = direction;

				if (this.MG_Bounce == 0)
				{
					this.hoPtr.rom.rmBouncing = false;

					autorise = 0;
					{
						var j = this.hoPtr.hoAdRunHeader.rhPlayer[this.hoPtr.roc.rcPlayer - 1] & 15;
						if (j != 0)
						{
							dir = CMove.Joy2Dir[j];
							if (dir != -1)
							{
								var flag = 1 << dir;
								if ((flag & this.MG_OkDirs) != 0)
								{
									autorise = 1;
									direction = dir;
								}
							}
						}
					}

					var dSpeed;
					speed = this.MG_Speed;
					if (autorise == 0)
					{
						if (speed != 0)
						{
							dSpeed = this.rmDecValue;
							if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
								dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
							speed -= dSpeed;
							if (speed <= 0)
								speed = 0;
						}
					}
					else
					{
						speed8 = speed >> 8;
						if (speed8 < this.hoPtr.roc.rcMaxSpeed)
						{
							dSpeed = this.rmAccValue;
							if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
								dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
							speed += dSpeed;
							speed8 = speed >> 8;
							if (speed8 > this.hoPtr.roc.rcMaxSpeed)
							{
								speed = this.hoPtr.roc.rcMaxSpeed << 8;
							}
						}
					}
					this.MG_Speed = speed;
					this.hoPtr.roc.rcSpeed = speed >> 8;

					this.hoPtr.roc.rcDir = direction;

					this.hoPtr.roc.rcAnim = CAnim.ANIMID_WALK;
					if (this.hoPtr.roa != null)
						this.hoPtr.roa.animate();

					if (this.newMake_Move(this.hoPtr.roc.rcSpeed, this.hoPtr.hoAdRunHeader.getDir(this.hoPtr)) == false)
					return;

					if (this.hoPtr.roc.rcSpeed == 0)
					{
						speed = this.MG_Speed;
						if (speed == 0)
						{
							return;
						}
						if (this.hoPtr.roc.rcOldDir == this.hoPtr.hoAdRunHeader.getDir(this.hoPtr))
						{
							return;
						}
						this.hoPtr.roc.rcSpeed = speed >> 8;
						this.hoPtr.roc.rcDir = this.hoPtr.roc.rcOldDir;
						if (this.newMake_Move(this.hoPtr.roc.rcSpeed, this.hoPtr.hoAdRunHeader.getDir(this.hoPtr)) == false)
						{
							return;
						}
					}
				}

				while (true)
				{
					if (this.MG_Bounce == 0 || this.hoPtr.hoAdRunHeader.rhVBLObjet == 0)
					{
						return;
					}
					speed = this.MG_Speed;
					speed -= this.rmDecValue;
					if (speed > 0)
					{
						this.MG_Speed = speed;
						speed >>= 8;
						this.hoPtr.roc.rcSpeed = speed;
						dir = this.hoPtr.hoAdRunHeader.getDir(this.hoPtr);
						if (this.MG_Bounce != 0)
						{
							dir += 16;
							dir &= 31;
						}
						if (this.newMake_Move(speed, dir) == false)
						{
							return;
						}
						continue;
					}
					else
					{
						this.MG_Speed = 0;
						this.hoPtr.roc.rcSpeed = 0;
						this.MG_Bounce = 0;
					}
					break;
				}
				;
			},

			bounce: function ()
			{
				if (this.rmCollisionCount == this.hoPtr.hoAdRunHeader.rh3CollisionCount)
				{
					this.mv_Approach((this.rmOpt & CMove.MVTOPT_8DIR_STICK) != 0);
				}
				if (this.hoPtr.hoAdRunHeader.rhLoopCount == this.MG_LastBounce)
					return;
				this.MG_LastBounce = this.hoPtr.hoAdRunHeader.rhLoopCount;
				this.MG_Bounce++;
				if (this.MG_Bounce >= 12)
				{
					this.stop();
					return;
				}
				this.hoPtr.rom.rmBouncing = true;
				this.hoPtr.rom.rmMoveFlag = true;
			},

			reverse: function ()
			{
			},

			setDir: function (dir)
			{
			},

			stop: function ()
			{
				this.hoPtr.roc.rcSpeed = 0;
				this.MG_Bounce = 0;
				this.MG_Speed = 0;
				this.hoPtr.rom.rmMoveFlag = true;
				if (this.rmCollisionCount == this.hoPtr.hoAdRunHeader.rh3CollisionCount)
				{
					this.mv_Approach((this.rmOpt & CMove.MVTOPT_8DIR_STICK) != 0);
					this.MG_Bounce = 0;
				}
			},

			start: function ()
			{
				this.hoPtr.rom.rmMoveFlag = true;
				this.rmStopSpeed = 0;
			},

			setMaxSpeed: function (speed)
			{
				if (speed < 0) speed = 0;
				if (speed > 250) speed = 250;
				this.hoPtr.roc.rcMaxSpeed = speed;
				if (this.hoPtr.roc.rcSpeed > speed)
				{
					this.hoPtr.roc.rcSpeed = speed;
					this.MG_Speed = speed << 8;
				}
				this.hoPtr.rom.rmMoveFlag = true;
			},

			setSpeed:        function (speed)
			{
				if (speed < 0) speed = 0;
				if (speed > 250) speed = 250;
				if (speed > this.hoPtr.roc.rcMaxSpeed)
				{
					speed = this.hoPtr.roc.rcMaxSpeed;
				}
				this.hoPtr.roc.rcSpeed = speed;
				this.MG_Speed = speed << 8;
				this.hoPtr.rom.rmMoveFlag = true;
			},
			setXPosition:    function (x)
			{
				if (this.hoPtr.hoX != x)
				{
					this.hoPtr.hoX = x;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
					this.hoPtr.roc.rcCheckCollides = true;
				}
			},
			setYPosition:    function (y)
			{
				if (this.hoPtr.hoY != y)
				{
					this.hoPtr.hoY = y;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
					this.hoPtr.roc.rcCheckCollides = true;
				}
			},
			set8DirsGeneric: function (dirs)
			{
				this.MG_OkDirs = dirs;
			}
		});

	// CMoveMouse object
	// ------------------------------------------------------------
	function CMoveMouse()
	{
		this.MM_DXMouse = 0;
		this.MM_DYMouse = 0;
		this.MM_FXMouse = 0;
		this.MM_FYMouse = 0;
		this.MM_Stopped = 0;
		this.MM_OldSpeed = 0;
	}
	CMoveMouse.prototype = CServices.extend(new CMove(),
		{
			init: function (ho, mmPtr)
			{
				this.hoPtr = ho;

				this.hoPtr.roc.rcPlayer = mmPtr.mvControl;
				this.MM_DXMouse = mmPtr.mmDx + this.hoPtr.hoX;
				this.MM_DYMouse = mmPtr.mmDy + this.hoPtr.hoY;
				this.MM_FXMouse = mmPtr.mmFx + this.hoPtr.hoX;
				this.MM_FYMouse = mmPtr.mmFy + this.hoPtr.hoY;
				this.hoPtr.roc.rcSpeed = 0;
				this.MM_OldSpeed = 0;
				this.MM_Stopped = 0;
				this.hoPtr.roc.rcMinSpeed = 0;
				this.hoPtr.roc.rcMaxSpeed = 100;
				this.rmOpt = mmPtr.mvOpt;
				this.moveAtStart(mmPtr);
				this.hoPtr.roc.rcChanged = true;
			},

			move: function ()
			{
				var newX = this.hoPtr.hoX;
				var newY = this.hoPtr.hoY;
				var deltaX, deltaY, flags, speed, dir, index;

				if (this.rmStopSpeed == 0)
				{
					if (this.hoPtr.hoAdRunHeader.rh2InputMask[this.hoPtr.roc.rcPlayer - 1] != 0)
					{
						newX = this.hoPtr.hoAdRunHeader.rh2MouseX;
						if (newX < this.MM_DXMouse)
							newX = this.MM_DXMouse;
						if (newX > this.MM_FXMouse)
							newX = this.MM_FXMouse;

						newY = this.hoPtr.hoAdRunHeader.rh2MouseY;
						if (newY < this.MM_DYMouse)
							newY = this.MM_DYMouse;
						if (newY > this.MM_FYMouse)
							newY = this.MM_FYMouse;

						deltaX = newX - this.hoPtr.hoX;
						deltaY = newY - this.hoPtr.hoY;
						flags = 0;
						if (deltaX < 0)
						{
							deltaX = -deltaX;
							flags |= 0x01;
						}
						if (deltaY < 0)
						{
							deltaY = -deltaY;
							flags |= 0x02;
						}
						speed = (deltaX + deltaY) << 2;
						if (speed > 250) speed = 250;
						this.hoPtr.roc.rcSpeed = speed;
						if (speed != 0)
						{
							deltaX <<= 8;
							if (deltaY == 0)
								deltaY = 1;
							deltaX /= deltaY;
							for (index = 0; ; index += 2)
							{
								if (deltaX >= CMove.CosSurSin32[index])
									break;
							}
							dir = CMove.CosSurSin32[index + 1];
							if ((flags & 0x02) != 0)
							{
								dir = -dir + 32;
								dir &= 31;
							}
							if ((flags & 0x01) != 0)
							{
								dir -= 8;
								dir &= 31;
								dir = -dir;
								dir &= 31;
								dir += 8;
								dir &= 31;
							}
							this.hoPtr.roc.rcDir = dir;
						}
					}
				}

				if (this.hoPtr.roc.rcSpeed != 0)
				{
					this.MM_Stopped = 0;
					this.MM_OldSpeed = this.hoPtr.roc.rcSpeed;
				}
				this.MM_Stopped++;
				if (this.MM_Stopped > 10)
					this.MM_OldSpeed = 0;
				this.hoPtr.roc.rcSpeed = this.MM_OldSpeed;
				if (this.hoPtr.roa != null)
					this.hoPtr.roa.animate();
				;

				this.hoPtr.hoX = newX;
				this.hoPtr.hoY = newY;
				this.hoPtr.roc.rcChanged = true;
				this.hoPtr.hoAdRunHeader.rh3CollisionCount++;
				this.rmCollisionCount = this.hoPtr.hoAdRunHeader.rh3CollisionCount;
				this.hoPtr.hoAdRunHeader.newHandle_Collisions(this.hoPtr);
			},

			stop:         function ()
			{
				if (this.rmCollisionCount == this.hoPtr.hoAdRunHeader.rh3CollisionCount)
				{
					this.mv_Approach((this.rmOpt & CMove.MVTOPT_8DIR_STICK) != 0);
				}
				this.hoPtr.roc.rcSpeed = 0;
			},
			start:        function ()
			{
				this.rmStopSpeed = 0;
				this.hoPtr.rom.rmMoveFlag = true;
			},
			bounce:       function ()
			{
				this.stop();
			},
			reverse:      function ()
			{
			},
			setDir:       function (dir)
			{
			},
			setXPosition: function (x)
			{
				if (this.hoPtr.hoX != x)
				{
					this.hoPtr.hoX = x;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
					this.hoPtr.roc.rcCheckCollides = true;
				}
			},
			setYPosition: function (y)
			{
				if (this.hoPtr.hoY != y)
				{
					this.hoPtr.hoY = y;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
					this.hoPtr.roc.rcCheckCollides = true;
				}
			}
		});

	// CMovePath object
	// --------------------------------------------------------------
	function CMovePath()
	{
		this.MT_Speed = 0;
		this.MT_Sinus = 0;
		this.MT_Cosinus = 0;
		this.MT_Longueur = 0;
		this.MT_XOrigin = 0;
		this.MT_YOrigin = 0;
		this.MT_XDest = 0;
		this.MT_YDest = 0;
		this.MT_MoveNumber = 0;
		this.MT_Direction = false;
		this.MT_Movement = null;
		this.MT_Calculs = 0;
		this.MT_XStart = 0;
		this.MT_YStart = 0;
		this.MT_Pause = 0;
		this.MT_GotoNode = null;
		this.MT_FlagBranch = false;
	}
	CMovePath.prototype = CServices.extend(new CMove(),
		{
			init: function (ho, mtPtr)
			{
				this.hoPtr = ho;

				this.MT_XStart = this.hoPtr.hoX;
				this.MT_YStart = this.hoPtr.hoY;

				this.MT_Direction = false;
				this.MT_Pause = 0;
				this.hoPtr.hoMark1 = 0;

				this.MT_Movement = mtPtr;
				this.hoPtr.roc.rcMinSpeed = mtPtr.mtMinSpeed;
				this.hoPtr.roc.rcMaxSpeed = mtPtr.mtMaxSpeed;
				this.MT_Calculs = 0;
				this.MT_GotoNode = null;
				this.mtGoAvant(0);
				this.moveAtStart(mtPtr);
				this.hoPtr.roc.rcSpeed = this.MT_Speed;
				this.hoPtr.roc.rcChanged = true;
				if (this.MT_Movement.steps.length == 0)
					this.stop();
			},

			move: function ()
			{
				this.hoPtr.hoMark1 = 0;

				this.hoPtr.roc.rcAnim = CAnim.ANIMID_WALK;
				if (this.hoPtr.roa != null)
					this.hoPtr.roa.animate();

				if (this.MT_Speed == 0)
				{
					var pause = this.MT_Pause;
					if (pause == 0)
					{
						this.hoPtr.roc.rcSpeed = 0;
						this.hoPtr.hoAdRunHeader.newHandle_Collisions(this.hoPtr);
						return;
					}
					pause -= this.hoPtr.hoAdRunHeader.rhTimerDelta;
					if (pause > 0)
					{
						this.MT_Pause = pause;
						this.hoPtr.roc.rcSpeed = 0;
						this.hoPtr.hoAdRunHeader.newHandle_Collisions(this.hoPtr);
						return;
					}
					this.MT_Pause = 0;
					this.MT_Speed = this.rmStopSpeed & 0x7FFF;
					this.rmStopSpeed = 0;
					this.hoPtr.roc.rcSpeed = this.MT_Speed;
				}

				var calculs;
				if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
					calculs = 256.0 * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
				else
					calculs = 0x100;
				this.hoPtr.hoAdRunHeader.rhMT_VBLCount = calculs;

				var breakMtNewSpeed;
				while (true)
				{
					breakMtNewSpeed = false;
					this.hoPtr.hoAdRunHeader.rhMT_VBLStep = calculs;
					calculs *= this.MT_Speed;
					calculs <<= 5;
					if (calculs <= 0x80000)
						this.hoPtr.hoAdRunHeader.rhMT_MoveStep = calculs;
					else
					{
						calculs = 0x80000 >>> 5;
						calculs /= this.MT_Speed;
						this.hoPtr.hoAdRunHeader.rhMT_VBLStep = calculs;
						this.hoPtr.hoAdRunHeader.rhMT_MoveStep = 0x80000;
					}
					while (true)
					{
						this.MT_FlagBranch = false;
						var flag = this.mtMove(this.hoPtr.hoAdRunHeader.rhMT_MoveStep);
						if (flag == true && this.MT_FlagBranch == false)
						{
							breakMtNewSpeed = true;
							break;
						}
						if (this.hoPtr.hoAdRunHeader.rhMT_VBLCount == this.hoPtr.hoAdRunHeader.rhMT_VBLStep)
						{
							breakMtNewSpeed = true;
							break;
						}
						if (this.hoPtr.hoAdRunHeader.rhMT_VBLCount > this.hoPtr.hoAdRunHeader.rhMT_VBLStep)
						{
							this.hoPtr.hoAdRunHeader.rhMT_VBLCount -= this.hoPtr.hoAdRunHeader.rhMT_VBLStep;
							calculs = this.hoPtr.hoAdRunHeader.rhMT_VBLCount;
							break;
						}
						calculs = this.hoPtr.hoAdRunHeader.rhMT_VBLCount * MT_Speed;
						calculs <<= 5;
						this.mtMove(calculs);
						breakMtNewSpeed = true;
						break;
					}
					;
					if (breakMtNewSpeed)
					{
						break;
					}
				}
				;
			},

			mtMove:      function (step)
			{
				step += this.MT_Calculs;
				var step2 = step >>> 16;
				if (step2 < this.MT_Longueur)
				{
					this.MT_Calculs = step;
					var x = (step2 * this.MT_Cosinus) / 16384 + this.MT_XOrigin;
					var y = (step2 * this.MT_Sinus) / 16384 + this.MT_YOrigin;

					this.hoPtr.hoX = x;
					this.hoPtr.hoY = y;
					this.hoPtr.roc.rcChanged = true;
					this.hoPtr.hoAdRunHeader.newHandle_Collisions(this.hoPtr);
					return this.hoPtr.rom.rmMoveFlag;
				}

				step2 -= this.MT_Longueur;
				step = (step2 << 16) | (step & 0xFFFF);
				if (this.MT_Speed != 0)
					step /= this.MT_Speed;
				step >>= 5;
				this.hoPtr.hoAdRunHeader.rhMT_VBLCount += step & 0xFFFF;

				this.hoPtr.hoX = this.MT_XDest;
				this.hoPtr.hoY = this.MT_YDest;
				this.hoPtr.roc.rcChanged = true;
				this.hoPtr.hoAdRunHeader.newHandle_Collisions(this.hoPtr);
				if (this.hoPtr.rom.rmMoveFlag)
					return true;

				this.hoPtr.hoMark1 = this.hoPtr.hoAdRunHeader.rhLoopCount;
				this.hoPtr.hoMT_NodeName = null;

				// Passe au node suivant
				var number = this.MT_MoveNumber;
				this.MT_Calculs = 0;
				if (this.MT_Direction == false)
				{
					number++;
					if (number < this.MT_Movement.mtNumber)
					{
						this.hoPtr.hoMT_NodeName = this.MT_Movement.steps[number].mdName;

						if (this.MT_GotoNode != null)
						{
							if (this.MT_Movement.steps[number].mdName != null)
							{
								if (CServices.compareStringsIgnoreCase(this.MT_GotoNode, this.MT_Movement.steps[number].mdName))
								{
									this.MT_MoveNumber = number;
									this.mtMessages();
									return this.mtTheEnd();
								}
							}
						}
						this.mtGoAvant(number);
						this.mtMessages();
						return this.hoPtr.rom.rmMoveFlag;
					}
					this.hoPtr.hoMark2 = this.hoPtr.hoAdRunHeader.rhLoopCount;
					this.MT_MoveNumber = number;
					if (this.MT_Direction)
					{
						this.mtMessages();
						return this.hoPtr.rom.rmMoveFlag;
					}
					if (this.MT_Movement.mtReverse != 0)
					{
						this.MT_Direction = true;
						number--;
						this.hoPtr.hoMT_NodeName = this.MT_Movement.steps[number].mdName;
						this.mtGoArriere(number);
						this.mtMessages();
						return this.hoPtr.rom.rmMoveFlag;
					}
					this.mtReposAtEnd();
					if (this.MT_Movement.mtLoop == 0)
					{
						this.mtTheEnd();
						this.mtMessages();
						return this.hoPtr.rom.rmMoveFlag;
					}
					number = 0;
					this.mtGoAvant(number);
					this.mtMessages();
					return this.hoPtr.rom.rmMoveFlag;
				}
				else
				{
					if (this.MT_GotoNode != null)
					{
						if (this.MT_Movement.steps[number].mdName != null)
						{
							if (CServices.compareStringsIgnoreCase(this.MT_GotoNode, this.MT_Movement.steps[number].mdName))
							{
								this.mtMessages();
								return this.mtTheEnd();			//; Fin du mouvement
							}
						}
					}
					this.hoPtr.hoMT_NodeName = this.MT_Movement.steps[number].mdName;
					this.MT_Pause = this.MT_Movement.steps[number].mdPause;
					number--;
					if (number >= 0)
					{
						this.mtGoArriere(number);
						this.mtMessages();
						return this.hoPtr.rom.rmMoveFlag;
					}
					this.mtReposAtEnd();
					if (this.MT_Direction == false)
					{
						this.mtMessages();
						return this.hoPtr.rom.rmMoveFlag;
					}
					if (this.MT_Movement.mtLoop == 0)
					{
						this.mtTheEnd();
						this.mtMessages();
						return this.hoPtr.rom.rmMoveFlag;
					}
					number = 0;
					this.MT_Direction = false;
					this.mtGoAvant(number);
					this.mtMessages();
					return this.hoPtr.rom.rmMoveFlag;
				}
			},
			mtGoAvant:   function (number)
			{
				if (number >= this.MT_Movement.steps.length)
					this.stop();
				else
				{
					this.MT_Direction = false;
					this.MT_MoveNumber = number;
					this.MT_Pause = this.MT_Movement.steps[number].mdPause;
					this.MT_Cosinus = this.MT_Movement.steps[number].mdCosinus;
					this.MT_Sinus = this.MT_Movement.steps[number].mdSinus;
					this.MT_XOrigin = this.hoPtr.hoX;
					this.MT_YOrigin = this.hoPtr.hoY;
					this.MT_XDest = this.hoPtr.hoX + this.MT_Movement.steps[number].mdDx;
					this.MT_YDest = this.hoPtr.hoY + this.MT_Movement.steps[number].mdDy;
					this.hoPtr.roc.rcDir = this.MT_Movement.steps[number].mdDir;
					this.mtBranche();
				}
			},
			mtGoArriere: function (number)
			{
				if (number >= this.MT_Movement.steps.length)
					this.stop();
				else
				{
					this.MT_Direction = true;
					this.MT_MoveNumber = number;
					this.MT_Cosinus = -this.MT_Movement.steps[number].mdCosinus;
					this.MT_Sinus = -this.MT_Movement.steps[number].mdSinus;
					this.MT_XOrigin = this.hoPtr.hoX;
					this.MT_YOrigin = this.hoPtr.hoY;
					this.MT_XDest = this.hoPtr.hoX - this.MT_Movement.steps[number].mdDx;
					this.MT_YDest = this.hoPtr.hoY - this.MT_Movement.steps[number].mdDy;
					var dir = this.MT_Movement.steps[number].mdDir;
					dir += 16;
					dir &= 31;
					this.hoPtr.roc.rcDir = dir;
					this.mtBranche();
				}
			},

			mtBranche:  function ()
			{
				this.MT_Longueur = this.MT_Movement.steps[this.MT_MoveNumber].mdLength;
				var speed = this.MT_Movement.steps[this.MT_MoveNumber].mdSpeed;

				var pause = this.MT_Pause;
				if (pause != 0)
				{
					this.MT_Pause = pause * 20;
					speed |= 0x8000;
					this.rmStopSpeed = speed;
				}
				if (this.rmStopSpeed != 0)
					speed = 0;
				if (speed != this.MT_Speed || speed != 0)
				{
					this.MT_Speed = speed;
					this.hoPtr.rom.rmMoveFlag = true;
					this.MT_FlagBranch = true;
				}
				this.hoPtr.roc.rcSpeed = this.MT_Speed;
			},
			mtMessages: function ()
			{
				if (this.hoPtr.hoMark1 == this.hoPtr.hoAdRunHeader.rhLoopCount)
				{
					this.hoPtr.hoAdRunHeader.rhEvtProg.rhCurParam0 = 0;
					this.hoPtr.hoAdRunHeader.rhEvtProg.handle_Event(this.hoPtr, (-20 << 16) | (this.hoPtr.hoType & 0xFFFF));	    // CNDL_EXTPATHNODE
					this.hoPtr.hoAdRunHeader.rhEvtProg.handle_Event(this.hoPtr, (-35 << 16) | (this.hoPtr.hoType & 0xFFFF));	    // CNDL_EXTPATHNODENAME
				}
				if (this.hoPtr.hoMark2 == this.hoPtr.hoAdRunHeader.rhLoopCount)
				{
					this.hoPtr.hoAdRunHeader.rhEvtProg.rhCurParam0 = 0;
					this.hoPtr.hoAdRunHeader.rhEvtProg.handle_Event(this.hoPtr, (-21 << 16) | (this.hoPtr.hoType & 0xFFFF));   // CNDL_EXTENDPATH
				}
			},

			mtTheEnd:     function ()
			{
				this.MT_Speed = 0;
				this.rmStopSpeed = 0;
				this.hoPtr.rom.rmMoveFlag = true;
				this.MT_FlagBranch = false;
				return true;
			},
			mtReposAtEnd: function ()
			{
				if (this.MT_Movement.mtRepos != 0)
				{
					this.hoPtr.hoX = this.MT_XStart;
					this.hoPtr.hoY = this.MT_YStart;
					this.hoPtr.roc.rcChanged = true;
				}
			},

			mtBranchNode: function (pName)
			{
				var number;
				for (number = 0; number < this.MT_Movement.mtNumber; number++)
				{
					if (this.MT_Movement.steps[number].mdName != null)
					{
						if (CServices.compareStringsIgnoreCase(pName, this.MT_Movement.steps[number].mdName))
						{
							if (this.MT_Direction == false)
							{
								this.mtGoAvant(number);
								this.hoPtr.hoMark1 = this.hoPtr.hoAdRunHeader.rhLoopCount;
								this.hoPtr.hoMT_NodeName = this.MT_Movement.steps[number].mdName;
								this.hoPtr.hoMark2 = 0;
								this.mtMessages();
							}
							else
							{
								if (number > 0)
								{
									number--;
									this.mtGoArriere(number);
									this.hoPtr.hoMark1 = this.hoPtr.hoAdRunHeader.rhLoopCount;
									this.hoPtr.hoMT_NodeName = this.MT_Movement.steps[number].mdName;
									this.hoPtr.hoMark2 = 0;
									this.mtMessages();
								}
							}
							this.hoPtr.rom.rmMoveFlag = true;
							return;
						}
					}
				}
			},
			mtGotoNode:   function (pName)
			{
				var number;

				for (number = 0; number < this.MT_Movement.mtNumber; number++)
				{
					if (this.MT_Movement.steps[number].mdName != null)
					{
						if (CServices.compareStringsIgnoreCase(pName, this.MT_Movement.steps[number].mdName))
						{
							if (number == this.MT_MoveNumber)
							{
								if (this.MT_Calculs == 0)
									return;
							}

							this.MT_GotoNode = pName;

							if (this.MT_Direction == false)
							{
								if (number > this.MT_MoveNumber)
								{
									if (this.MT_Speed != 0)
										return;
									if ((this.rmStopSpeed & 0x8000) != 0)
										this.start();
									else
										this.mtGoAvant(this.MT_MoveNumber);
									return;
								}
								else
								{
									if (this.MT_Speed != 0)
									{
										this.reverse();
										return;
									}
									if ((this.rmStopSpeed & 0x8000) != 0)
									{
										this.start();
										this.reverse();
									}
									else
										this.mtGoArriere(MT_MoveNumber - 1);
									return;
								}
							}
							else
							{
								if (number <= this.MT_MoveNumber)
								{
									if (this.MT_Speed != 0)
										return;
									if ((this.rmStopSpeed & 0x8000) != 0)
										this.start();
									else
									{
										this.mtGoArriere(this.MT_MoveNumber - 1);
									}
									return;
								}
								else
								{
									if (this.MT_Speed != 0)
									{
										this.reverse();
										return;
									}
									if ((this.rmStopSpeed & 0x8000) != 0)
									{
										this.start();
										this.reverse();
									}
									else
										this.mtGoAvant(this.MT_MoveNumber);
									return;
								}
							}
						}
					}
				}
			},

			stop:    function ()
			{
				if (this.rmStopSpeed == 0)
				{
					this.rmStopSpeed = this.MT_Speed | 0x8000;
				}
				this.MT_Speed = 0;
				this.hoPtr.rom.rmMoveFlag = true;
			},
			start:   function ()
			{
				if ((this.rmStopSpeed & 0x8000) != 0)
				{
					this.MT_Speed = this.rmStopSpeed & 0x7FFF;
					this.MT_Pause = 0;
					this.rmStopSpeed = 0;
					this.hoPtr.rom.rmMoveFlag = true;
				}
			},
			reverse: function ()
			{
				if (this.rmStopSpeed == 0)
				{
					this.hoPtr.rom.rmMoveFlag = true;
					var number = this.MT_MoveNumber;
					if (this.MT_Calculs == 0)
					{
						this.MT_Direction = !this.MT_Direction;
						if (this.MT_Direction)
						{
							if (number == 0)
							{
								this.MT_Direction = !this.MT_Direction;
								return;
							}
							number--;
							this.mtGoArriere(number);
						}
						else
						{
							this.mtGoAvant(number);
						}
					}
					else
					{
						this.MT_Direction = !this.MT_Direction;
						this.MT_Cosinus = -this.MT_Cosinus;
						this.MT_Sinus = -this.MT_Sinus;
						var x1 = this.MT_XOrigin;
						var x2 = this.MT_XDest;
						this.MT_XOrigin = x2;
						this.MT_XDest = x1;
						x1 = this.MT_YOrigin;
						x2 = this.MT_YDest;
						this.MT_YOrigin = x2;
						this.MT_YDest = x1;
						this.hoPtr.roc.rcDir += 16;
						this.hoPtr.roc.rcDir &= 31;
						var calcul = this.MT_Calculs >>> 16;
						calcul = this.MT_Longueur - calcul;
						this.MT_Calculs = (calcul << 16) | (this.MT_Calculs & 0xFFFF);
					}
				}
			},

			setXPosition: function (x)
			{
				var x2 = this.hoPtr.hoX;
				this.hoPtr.hoX = x;

				x2 -= this.MT_XOrigin;
				x -= x2;
				x2 = this.MT_XDest - this.MT_XOrigin + x;
				this.MT_XDest = x2;
				x2 = this.MT_XOrigin;
				this.MT_XOrigin = x;
				x2 -= x;
				this.MT_XStart -= x2;
				this.hoPtr.rom.rmMoveFlag = true;
				this.hoPtr.roc.rcChanged = true;
				this.hoPtr.roc.rcCheckCollides = true;
			},
			setYPosition: function (y)
			{
				var y2 = this.hoPtr.hoY;
				this.hoPtr.hoY = y;

				y2 -= this.MT_YOrigin;
				y -= y2;
				y2 = this.MT_YDest - this.MT_YOrigin + y;
				this.MT_YDest = y2;
				y2 = this.MT_YOrigin;
				this.MT_YOrigin = y;
				y2 -= y;
				this.MT_YStart -= y2;
				this.hoPtr.rom.rmMoveFlag = true;
				this.hoPtr.roc.rcChanged = true;
				this.hoPtr.roc.rcCheckCollides = true;
			},

			setSpeed:    function (speed)
			{
				if (speed < 0)
					speed = 0;
				if (speed > 250)
					speed = 250;
				this.MT_Speed = speed;
				this.hoPtr.roc.rcSpeed = speed;
				this.hoPtr.rom.rmMoveFlag = true;
			},
			setMaxSpeed: function (speed)
			{
				this.setSpeed(speed);
			},
			setDir:      function (dir)
			{
			}
		});

	// CMovePlatform object
	// -----------------------------------------------------------------
	CMovePlatform.MPJC_NOJUMP = 0;
	CMovePlatform.MPJC_DIAGO = 1;
	CMovePlatform.MPJC_BUTTON1 = 2;
	CMovePlatform.MPJC_BUTTON2 = 3;
	CMovePlatform.MPTYPE_WALK = 0;
	CMovePlatform.MPTYPE_CLIMB = 1;
	CMovePlatform.MPTYPE_JUMP = 2;
	CMovePlatform.MPTYPE_FALL = 3;
	CMovePlatform.MPTYPE_CROUCH = 4;
	CMovePlatform.MPTYPE_UNCROUCH = 5;
	function CMovePlatform()
	{
		this.MP_Type = 0;
		this.MP_Bounce = 0;
		this.MP_BounceMu = 0;
		this.MP_XSpeed = 0;
		this.MP_Gravity = 0;
		this.MP_Jump = 0;
		this.MP_YSpeed = 0;
		this.MP_XMB = 0;
		this.MP_YMB = 0;
		this.MP_HTFOOT = 0;
		this.MP_JumpControl = 0;
		this.MP_JumpStopped = 0;
		this.MP_PreviousDir = 0;
		this.MP_ObjectUnder = null;
		this.MP_XObjectUnder = 0;
		this.MP_YObjectUnder = 0;
		this.MP_NoJump = false;
	}
	CMovePlatform.prototype = CServices.extend(new CMove(),
		{
			init: function (ho, mpPtr)
			{
				this.hoPtr = ho;
				this.rhPtr = this.hoPtr.hoAdRunHeader;

				this.hoPtr.hoCalculX = 0;
				this.hoPtr.hoCalculY = 0;
				this.MP_XSpeed = 0;
				this.hoPtr.roc.rcSpeed = 0;
				this.MP_Bounce = 0;
				this.hoPtr.roc.rcPlayer = mpPtr.mvControl;
				this.rmAcc = mpPtr.mpAcc;
				this.rmAccValue = this.getAccelerator(this.rmAcc);
				this.rmDec = mpPtr.mpDec;
				this.rmDecValue = this.getAccelerator(this.rmDec);
				this.hoPtr.roc.rcMaxSpeed = mpPtr.mpSpeed;
				this.hoPtr.roc.rcMinSpeed = 0;

				this.MP_Gravity = mpPtr.mpGravity;
				this.MP_Jump = mpPtr.mpJump;
				var jump = mpPtr.mpJumpControl;
				if (jump > 3)
					jump = CMovePlatform.MPJC_DIAGO;
				this.MP_JumpControl = jump;
				this.MP_YSpeed = 0;

				this.MP_JumpStopped = 0;
				this.MP_ObjectUnder = null;

				this.moveAtStart(mpPtr);
				this.MP_PreviousDir = this.hoPtr.hoAdRunHeader.getDir(this.hoPtr);
				this.hoPtr.roc.rcChanged = true;
				this.MP_Type = CMovePlatform.MPTYPE_WALK;
			},

			move: function ()
			{
				var x, y;
				this.hoPtr.hoAdRunHeader.rhVBLObjet = 1;
				var joyDir = this.hoPtr.hoAdRunHeader.rhPlayer[this.hoPtr.roc.rcPlayer - 1];
				this.calcMBFoot();

				var xSpeed = this.MP_XSpeed;
				var speed8, dSpeed;
				if (this.MP_JumpStopped == 0)
				{
					if (xSpeed <= 0)
					{
						if ((joyDir & 4) != 0)
						{
							dSpeed = this.rmAccValue;
							if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
								dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
							xSpeed -= dSpeed;
							speed8 = xSpeed / 256;
							if (speed8 < -this.hoPtr.roc.rcMaxSpeed)
								xSpeed = -this.hoPtr.roc.rcMaxSpeed * 256;
						}
						else if (xSpeed < 0)
						{
							dSpeed = this.rmDecValue;
							if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
								dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
							xSpeed += dSpeed;
							if (xSpeed > 0)
								xSpeed = 0;
						}
						if ((joyDir & 8) != 0)
							xSpeed = -xSpeed;
					}
					if (xSpeed >= 0)
					{
						if ((joyDir & 8) != 0)
						{
							dSpeed = this.rmAccValue;
							if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
								dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
							xSpeed += dSpeed;
							speed8 = xSpeed / 256;
							if (speed8 > this.hoPtr.roc.rcMaxSpeed)
								xSpeed = this.hoPtr.roc.rcMaxSpeed * 256;
						}
						else if (xSpeed > 0)
						{
							dSpeed = this.rmDecValue;
							if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
								dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
							xSpeed -= dSpeed;
							if (xSpeed < 0)
								xSpeed = 0;
						}
						if ((joyDir & 4) != 0)
						{
							xSpeed = -xSpeed;
						}
					}
					this.MP_XSpeed = xSpeed;
				}

				var ySpeed = this.MP_YSpeed;
				var flag = false;
				while (true)
				{
					switch (this.MP_Type)
					{
						case 2:     // MPTYPE_FALL:
						case 3:     // MPTYPE_JUMP:
							dSpeed = this.MP_Gravity << 5;
							if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
								dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
							ySpeed = ySpeed + dSpeed;
							if (ySpeed > 0xFA00)
								ySpeed = 0xFA00;
							break;
						case 0:     // MPTYPE_WALK:
							if ((joyDir & 1) != 0)
							{
								if (this.rhPtr.check_Ladder(this.hoPtr.hoLayer, this.hoPtr.hoX + this.MP_XMB, this.hoPtr.hoY + this.MP_YMB - 4) == CRun.INTBAD)
									break;
								this.MP_Type = CMovePlatform.MPTYPE_CLIMB;
								flag = true;
								continue;
							}
							if ((joyDir & 2) != 0)
							{
								if (this.rhPtr.check_Ladder(this.hoPtr.hoLayer, this.hoPtr.hoX + this.MP_XMB, this.hoPtr.hoY + this.MP_YMB + 4) == CRun.INTBAD)
									break;
								this.MP_Type = CMovePlatform.MPTYPE_CLIMB;
								flag = true;
								continue;
							}
							break;
						case 1:         // MPTYPE_CLIMB:
							if (flag == false)
							{
								this.MP_JumpStopped = 0;
								if (this.rhPtr.check_Ladder(this.hoPtr.hoLayer, this.hoPtr.hoX + this.MP_XMB, this.hoPtr.hoY + this.MP_YMB) == CRun.INTBAD)
									if (this.rhPtr.check_Ladder(this.hoPtr.hoLayer, this.hoPtr.hoX + this.MP_XMB, this.hoPtr.hoY + this.MP_YMB - 4) == CRun.INTBAD)
										break;
							}
							if (ySpeed <= 0)
							{
								if ((joyDir & 1) != 0)
								{
									dSpeed = this.rmAccValue;
									if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
										dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
									ySpeed -= dSpeed;
									speed8 = ySpeed / 256;
									if (speed8 < -this.hoPtr.roc.rcMaxSpeed)
										ySpeed = -this.hoPtr.roc.rcMaxSpeed * 256;
								}
								else
								{
									dSpeed = this.rmDecValue;
									if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
										dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
									ySpeed += dSpeed;
									if (ySpeed > 0)
										ySpeed = 0;
								}
								if ((joyDir & 2) != 0)
									ySpeed = -ySpeed;
							}
							if (ySpeed >= 0)
							{
								if ((joyDir & 2) != 0)
								{
									dSpeed = this.rmAccValue;
									if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
										dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
									ySpeed += dSpeed;
									speed8 = ySpeed / 256;
									if (speed8 > this.hoPtr.roc.rcMaxSpeed)
										ySpeed = this.hoPtr.roc.rcMaxSpeed * 256;
								}
								else
								{
									dSpeed = this.rmDecValue;
									if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
										dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
									ySpeed -= dSpeed;
									if (ySpeed < 0)
										ySpeed = 0;
								}
								if ((joyDir & 1) != 0)
									ySpeed = -ySpeed;
							}
							break;
					}
					break;
				}
				this.MP_YSpeed = ySpeed;

				var dir = 0;
				if (xSpeed < 0)
					dir = 16;
				var sX = xSpeed;
				var sY = ySpeed;
				if (sY != 0)
				{
					var flags = 0;
					if (sX < 0)
					{
						flags |= 1;
						sX = -sX;
					}
					if (sY < 0)
					{
						flags |= 2;
						sY = -sY;
					}
					sX <<= 8;
					sX = sX / sY;
					var i;
					for (i = 0; ; i += 2)
					{
						if (sX >= CMove.CosSurSin32[i])
							break;
					}
					dir = CMove.CosSurSin32[i + 1];
					if ((flags & 0x02) != 0)
					{
						dir = -dir + 32;
						dir &= 31;
					}
					if ((flags & 0x01) != 0)
					{
						dir -= 8;
						dir &= 31;
						dir = -dir;
						dir &= 31;
						dir += 8;
						dir &= 31;
					}
				}

				sX = xSpeed;
				var cosinus = CMove.Cosinus32[dir];
				var sinus = CMove.Sinus32[dir];
				if (cosinus < 0)
					cosinus = -cosinus;
				if (sinus < 0)
					sinus = -sinus;
				if (cosinus < sinus)
				{
					cosinus = sinus;
					sX = ySpeed;
				}
				if (sX < 0)
					sX = -sX;
				sX = sX / cosinus;
				if (sX > 250)
					sX = 250;
				this.hoPtr.roc.rcSpeed = sX;

				switch (this.MP_Type)
				{
					case 1:
						if (ySpeed < 0)
							this.hoPtr.roc.rcDir = 8;
						else if (ySpeed > 0)
							this.hoPtr.roc.rcDir = 24;
						break;
					case 3:
						this.hoPtr.roc.rcDir = dir;
						break;
					default:
						if (xSpeed < 0)
							this.hoPtr.roc.rcDir = 16;
						else if (xSpeed > 0)
							this.hoPtr.roc.rcDir = 0;
						break;
				}

				switch (this.MP_Type)
				{
					case 4:      // MPTYPE_CROUCH:
						this.hoPtr.roc.rcAnim = CAnim.ANIMID_CROUCH;
						break;
					case 5:     // MPTYPE_UNCROUCH:
						this.hoPtr.roc.rcAnim = CAnim.ANIMID_UNCROUCH;
						break;
					case 3:     // MPTYPE_FALL:
						this.hoPtr.roc.rcAnim = CAnim.ANIMID_FALL;
						break;
					case 2:     // MPTYPE_JUMP:
						this.hoPtr.roc.rcAnim = CAnim.ANIMID_JUMP;
						break;
					case 1:     // MPTYPE_CLIMB:
						this.hoPtr.roc.rcAnim = CAnim.ANIMID_CLIMB;
						break;
					default:
						this.hoPtr.roc.rcAnim = CAnim.ANIMID_WALK;
						break;
				}

				if (this.hoPtr.roa != null)
					this.hoPtr.roa.animate();
				this.calcMBFoot();

				this.newMake_Move(this.hoPtr.roc.rcSpeed, dir);

				if ((this.MP_Type == CMovePlatform.MPTYPE_WALK || this.MP_Type == CMovePlatform.MPTYPE_CLIMB) && this.MP_NoJump == false)
				{
					var bJump = false;
					var j = this.MP_JumpControl;
					if (j != 0)
					{
						j--;
						if (j == 0)
						{
							if ((joyDir & 5) == 5)
								bJump = true;
							if ((joyDir & 9) == 9)
								bJump = true;
						}
						else
						{
							j <<= 4;
							if ((joyDir & j) != 0)
								bJump = true;
						}
					}
					if (bJump)
					{
						this.MP_YSpeed = -this.MP_Jump << 8;
						this.MP_Type = CMovePlatform.MPTYPE_JUMP;
					}
				}
				switch (this.MP_Type)
				{
					case 2:         // MPTYPE_JUMP:
						if (this.MP_YSpeed >= 0)
							this.MP_Type = CMovePlatform.MPTYPE_FALL;
						break;

					case 3:         // MPTYPE_FALL:
						if (this.rhPtr.check_Ladder(this.hoPtr.hoLayer, this.hoPtr.hoX + this.MP_XMB, this.hoPtr.hoY + this.MP_YMB) != CRun.INTBAD)
						{
							this.MP_YSpeed = 0;
							this.MP_Type = CMovePlatform.MPTYPE_CLIMB;
							this.hoPtr.roc.rcDir = 8;
						}
						break;

					case 0:         // MPTYPE_WALK:
						if ((joyDir & 3) != 0 && (joyDir & 12) == 0)
						{
							if (this.rhPtr.check_Ladder(this.hoPtr.hoLayer, this.hoPtr.hoX + this.MP_XMB, this.hoPtr.hoY + this.MP_YMB) != CRun.INTBAD)
							{
								this.MP_Type = CMovePlatform.MPTYPE_CLIMB;
								this.MP_XSpeed = 0;
								break;
							}
						}
						if ((joyDir & 2) != 0)
						{
							if (this.hoPtr.roa != null)
							{
								if (this.hoPtr.roa.anim_Exist(CAnim.ANIMID_CROUCH))
								{
									this.MP_XSpeed = 0;
									this.MP_Type = CMovePlatform.MPTYPE_CROUCH;
								}
							}
						}

						if (this.rhPtr.check_Ladder(this.hoPtr.hoLayer, this.hoPtr.hoX + this.MP_XMB, this.hoPtr.hoY + this.MP_YMB) != CRun.INTBAD)
							break;

						if (this.tst_SpritePosition(this.hoPtr.hoX, this.hoPtr.hoY + 10, this.MP_HTFOOT, CRunFrame.CM_TEST_PLATFORM, true) == false)
						{
							x = this.hoPtr.hoX - this.hoPtr.hoAdRunHeader.rhWindowX;
							y = this.hoPtr.hoY - this.hoPtr.hoAdRunHeader.rhWindowY;
							var d = y + this.MP_HTFOOT - 1;
							var pt = new CPoint();
							this.mpApproachSprite(x, d, x, y, this.MP_HTFOOT, CRunFrame.CM_TEST_PLATFORM, pt);

							this.hoPtr.hoX = pt.x + this.hoPtr.hoAdRunHeader.rhWindowX;
							this.hoPtr.hoY = pt.y + this.hoPtr.hoAdRunHeader.rhWindowY;
							this.MP_NoJump = false;
						}
						else
						{
							this.MP_Type = CMovePlatform.MPTYPE_FALL;
						}
						break;

					case 1:         // MPTYPE_CLIMB:
						if (this.rhPtr.check_Ladder(this.hoPtr.hoLayer, this.hoPtr.hoX + this.MP_XMB, this.hoPtr.hoY + this.MP_YMB) == CRun.INTBAD)
						{
							if (this.MP_YSpeed < 0)
							{
								for (sY = 0; sY < 32; sY++)
								{
									if (this.rhPtr.check_Ladder(this.hoPtr.hoLayer, this.hoPtr.hoX + this.MP_XMB, this.hoPtr.hoY + this.MP_YMB + sY) != CRun.INTBAD)
									{
										this.hoPtr.hoY += sY;
										break;
									}
								}
							}
							this.MP_YSpeed = 0;
						}
						if ((joyDir & 12) != 0)
						{
							this.MP_Type = CMovePlatform.MPTYPE_WALK;
							this.MP_YSpeed = 0;
						}
						break;

					case 4:         // MPTYPE_CROUCH:
						if ((joyDir & 2) == 0)
						{
							if (this.hoPtr.roa != null)
							{
								if (this.hoPtr.roa.anim_Exist(CAnim.ANIMID_UNCROUCH))
								{
									this.MP_Type = CMovePlatform.MPTYPE_UNCROUCH;
									this.hoPtr.roc.rcAnim = CAnim.ANIMID_UNCROUCH;
									this.hoPtr.roa.animate();
									this.hoPtr.roa.raAnimRepeat = 1;
									break;
								}
							}
							this.MP_Type = CMovePlatform.MPTYPE_WALK;
						}
						break;

					case 5:         // MPTYPE_UNCROUCH:
						if (this.hoPtr.roa != null)
						{
							if (this.hoPtr.roa.raAnimNumberOfFrame == 0)
							{
								this.MP_Type = CMovePlatform.MPTYPE_WALK;
							}
						}
						break;
				}

				if (this.MP_Type == CMovePlatform.MPTYPE_WALK || this.MP_Type == CMovePlatform.MPTYPE_CROUCH || this.MP_Type == CMovePlatform.MPTYPE_UNCROUCH)
				{
					do
					{
						var pOiColList = null;
						if (this.hoPtr.hoOiList != null)
						{
							pOiColList = this.hoPtr.hoOiList.oilColList;
						}
						if (this.hoPtr.hoAdRunHeader.objectAllCol_IXY(this.hoPtr, this.hoPtr.roc.rcImage, this.hoPtr.roc.rcAngle, this.hoPtr.roc.rcScaleX, this.hoPtr.roc.rcScaleY, this.hoPtr.hoX, this.hoPtr.hoY, pOiColList) == null)
						{
							var list = this.hoPtr.hoAdRunHeader.objectAllCol_IXY(this.hoPtr, this.hoPtr.roc.rcImage, this.hoPtr.roc.rcAngle, this.hoPtr.roc.rcScaleX, this.hoPtr.roc.rcScaleY, this.hoPtr.hoX, this.hoPtr.hoY + 1, pOiColList);
							if (list != null && list.size() == 1)
							{
								var pHo2 = list.get(0);
								if (this.MP_ObjectUnder == null || this.MP_ObjectUnder != pHo2)
								{
									if (this.hoPtr.hoOi != pHo2.hoOi)
									{
										this.MP_ObjectUnder = pHo2;
										this.MP_XObjectUnder = pHo2.hoX;
										this.MP_YObjectUnder = pHo2.hoY;
										break;
									}
								}
								var dx = pHo2.hoX - this.MP_XObjectUnder;
								var dy = pHo2.hoY - this.MP_YObjectUnder;
								this.MP_XObjectUnder = pHo2.hoX;
								this.MP_YObjectUnder = pHo2.hoY;

								this.hoPtr.hoX += dx;
								this.hoPtr.hoY += dy;
								this.hoPtr.hoAdRunHeader.newHandle_Collisions(this.hoPtr);
								this.hoPtr.roc.rcChanged = true;
								break;
							}
						}
						this.MP_ObjectUnder = null;
					} while (false);
				}
				else
				{
					this.MP_ObjectUnder = null;
				}
			},

			mpStopIt: function ()
			{
				this.hoPtr.roc.rcSpeed = 0;
				this.MP_XSpeed = 0;
				this.MP_YSpeed = 0;
			},
			bounce:   function ()
			{
				this.stop();
			},
			stop:     function ()
			{
				this.MP_Bounce = 0;

				if (this.rmCollisionCount != this.hoPtr.hoAdRunHeader.rh3CollisionCount)
				{
					this.mpStopIt();
					return;
				}
				this.hoPtr.rom.rmMoveFlag = true;
				var scrX = this.hoPtr.hoX - this.hoPtr.hoAdRunHeader.rhWindowX;
				var scrY = this.hoPtr.hoY - this.hoPtr.hoAdRunHeader.rhWindowY;
				var x, y, dir;

				switch (this.hoPtr.hoAdRunHeader.rhEvtProg.rhCurCode & 0xFFFF0000)
				{
					case (-12 << 16):         // CNDL_EXTOUTPLAYFIELD:
						x = this.hoPtr.hoX - this.hoPtr.hoImgXSpot;
						y = this.hoPtr.hoY - this.hoPtr.hoImgYSpot;
						dir = this.hoPtr.hoAdRunHeader.quadran_Out(x, y, x + this.hoPtr.hoImgWidth, y + this.hoPtr.hoImgHeight);

						x = this.hoPtr.hoX;
						y = this.hoPtr.hoY;
						if ((dir & CRun.BORDER_LEFT) != 0)
						{
							x = this.hoPtr.hoImgXSpot;
							this.MP_XSpeed = 0;
							this.MP_NoJump = true;
						}
						if ((dir & CRun.BORDER_RIGHT) != 0)
						{
							x = this.hoPtr.hoAdRunHeader.rhLevelSx - this.hoPtr.hoImgWidth + this.hoPtr.hoImgXSpot;
							this.MP_XSpeed = 0;
							this.MP_NoJump = true;
						}
						if ((dir & CRun.BORDER_TOP) != 0)
						{
							y = this.hoPtr.hoImgYSpot;
							this.MP_YSpeed = 0;
							this.MP_NoJump = false;
						}
						if ((dir & CRun.BORDER_BOTTOM) != 0)
						{
							y = this.hoPtr.hoAdRunHeader.rhLevelSy - this.hoPtr.hoImgHeight + this.hoPtr.hoImgYSpot;
							this.MP_YSpeed = 0;
							this.MP_NoJump = false;
						}
						this.hoPtr.hoX = x;
						this.hoPtr.hoY = y;
						if (this.MP_Type == CMovePlatform.MPTYPE_JUMP)
							this.MP_Type = CMovePlatform.MPTYPE_FALL;
						else
							this.MP_Type = CMovePlatform.MPTYPE_WALK;
						this.MP_JumpStopped = 0;
						return;

					case (-13 << 16):	    // CNDL_EXTCOLBACK:
					case (-14 << 16):	    // CNDL_EXTCOLLISION:
						this.MP_NoJump = false;
						var pt = new CPoint();
						if (this.MP_Type == CMovePlatform.MPTYPE_FALL)
						{
							this.mpApproachSprite(scrX, scrY, this.hoPtr.roc.rcOldX - this.hoPtr.hoAdRunHeader.rhWindowX, this.hoPtr.roc.rcOldY - this.hoPtr.hoAdRunHeader.rhWindowY, this.MP_HTFOOT, CRunFrame.CM_TEST_PLATFORM, pt);

							this.hoPtr.hoX = pt.x + this.hoPtr.hoAdRunHeader.rhWindowX;
							this.hoPtr.hoY = pt.y + this.hoPtr.hoAdRunHeader.rhWindowY;
							this.MP_Type = CMovePlatform.MPTYPE_WALK;
							this.hoPtr.roc.rcChanged = true;

							if (this.tst_SpritePosition(this.hoPtr.hoX, this.hoPtr.hoY + 1, 0, CRunFrame.CM_TEST_PLATFORM, true))
							{
								this.hoPtr.roc.rcSpeed = 0;
								this.MP_XSpeed = 0;
							}
							else
							{
								this.MP_JumpStopped = 0;
								this.hoPtr.roc.rcSpeed = Math.abs(this.MP_XSpeed / 256);
								this.MP_YSpeed = 0;
							}
							return;
						}
						if (this.MP_Type == CMovePlatform.MPTYPE_WALK)
						{
							if (this.mpApproachSprite(scrX, scrY, scrX, scrY - this.MP_HTFOOT, 0, CRunFrame.CM_TEST_PLATFORM, pt))
							{
								this.hoPtr.hoX = pt.x + this.hoPtr.hoAdRunHeader.rhWindowX;
								this.hoPtr.hoY = pt.y + this.hoPtr.hoAdRunHeader.rhWindowY;
								this.hoPtr.roc.rcChanged = true;
								return;
							}
							if (this.mpApproachSprite(scrX, scrY, this.hoPtr.roc.rcOldX - this.hoPtr.hoAdRunHeader.rhWindowX, this.hoPtr.roc.rcOldY - this.hoPtr.hoAdRunHeader.rhWindowY, 0, CRunFrame.CM_TEST_PLATFORM, pt))
							{
								this.hoPtr.hoX = pt.x + this.hoPtr.hoAdRunHeader.rhWindowX;
								this.hoPtr.hoY = pt.y + this.hoPtr.hoAdRunHeader.rhWindowY;
								this.hoPtr.roc.rcChanged = true;
								this.mpStopIt();
								return;
							}
						}
						if (this.MP_Type == CMovePlatform.MPTYPE_JUMP)
						{
							if (this.mpApproachSprite(scrX, scrY, scrX, scrY - this.MP_HTFOOT, 0, CRunFrame.CM_TEST_PLATFORM, pt))
							{
								this.hoPtr.hoX = pt.x + this.hoPtr.hoAdRunHeader.rhWindowX;
								this.hoPtr.hoY = pt.y + this.hoPtr.hoAdRunHeader.rhWindowY;
								this.hoPtr.roc.rcChanged = true;
								return;
							}
							this.MP_JumpStopped = 1;
							this.MP_XSpeed = 0;
						}
						if (this.MP_Type == CMovePlatform.MPTYPE_CLIMB)
						{
							if (this.mpApproachSprite(scrX, scrY, this.hoPtr.roc.rcOldX - this.hoPtr.hoAdRunHeader.rhWindowX, this.hoPtr.roc.rcOldY - this.hoPtr.hoAdRunHeader.rhWindowY, 0, CRunFrame.CM_TEST_PLATFORM, pt))
							{
								this.hoPtr.hoX = pt.x + this.hoPtr.hoAdRunHeader.rhWindowX;
								this.hoPtr.hoY = pt.y + this.hoPtr.hoAdRunHeader.rhWindowY;
								this.hoPtr.roc.rcChanged = true;
								this.mpStopIt();
								return;
							}
						}
						this.hoPtr.roc.rcImage = this.hoPtr.roc.rcOldImage;
						this.hoPtr.roc.rcAngle = this.hoPtr.roc.rcOldAngle;
						if (this.tst_SpritePosition(this.hoPtr.hoX, this.hoPtr.hoY, 0, CRunFrame.CM_TEST_PLATFORM, true))
							return;

						this.hoPtr.hoX = this.hoPtr.roc.rcOldX;
						this.hoPtr.hoY = this.hoPtr.roc.rcOldY;
						this.hoPtr.roc.rcChanged = true;
						break;
				}
			},

			setXPosition: function (x)
			{
				if (this.hoPtr.hoX != x)
				{
					this.hoPtr.hoX = x;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
					this.hoPtr.roc.rcCheckCollides = true;
				}
			},
			setYPosition: function (y)
			{
				if (this.hoPtr.hoY != y)
				{
					this.hoPtr.hoY = y;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
					this.hoPtr.roc.rcCheckCollides = true;
				}
			},

			setSpeed: function (speed)
			{
				if (speed < 0) speed = 0;
				if (speed > 250) speed = 250;
				if (speed > this.hoPtr.roc.rcMaxSpeed)
				{
					speed = this.hoPtr.roc.rcMaxSpeed;
				}
				this.hoPtr.roc.rcSpeed = speed;
				this.MP_XSpeed = this.hoPtr.roc.rcSpeed * CMove.Cosinus32[this.hoPtr.hoAdRunHeader.getDir(this.hoPtr)];
				this.MP_YSpeed = this.hoPtr.roc.rcSpeed * CMove.Sinus32[this.hoPtr.hoAdRunHeader.getDir(this.hoPtr)];
				this.hoPtr.rom.rmMoveFlag = true;
			},

			setMaxSpeed: function (speed)
			{
				if (speed < 0) speed = 0;
				if (speed > 250) speed = 250;
				this.hoPtr.roc.rcMaxSpeed = speed;
				speed <<= 8;
				if (this.MP_XSpeed > speed)
					this.MP_XSpeed = speed;
				this.hoPtr.rom.rmMoveFlag = true;
			},

			setGravity: function (gravity)
			{
				this.MP_Gravity = gravity;
			},

			setDir: function (dir)
			{
				this.hoPtr.roc.rcDir = dir;
				this.MP_XSpeed = this.hoPtr.roc.rcSpeed * CMove.Cosinus32[dir];
				this.MP_YSpeed = this.hoPtr.roc.rcSpeed * CMove.Sinus32[dir];
			},

			calcMBFoot: function ()
			{
				var ifo;

				if (this.hoPtr.roc.rcImage > 0)
					ifo = this.hoPtr.hoAdRunHeader.rhApp.imageBank.getImageInfoEx(this.hoPtr.roc.rcImage, this.hoPtr.roc.rcAngle, this.hoPtr.roc.rcScaleX, this.hoPtr.roc.rcScaleY);
				else
				{
					ifo = new CImage();
					ifo.width = this.hoPtr.hoImgWidth;
					ifo.height = this.hoPtr.hoImgHeight;
					ifo.xSpot = this.hoPtr.hoImgXSpot;
					ifo.ySpot = this.hoPtr.hoImgYSpot;
				}
				this.MP_XMB = 0;
				this.MP_YMB = ifo.height - ifo.ySpot;
				this.MP_HTFOOT = ((ifo.height * 2) + ifo.height) >>> 3;
			},

			mpHandle_Background: function ()
			{
				this.calcMBFoot();
				if (this.rhPtr.check_Ladder(this.hoPtr.hoLayer, this.hoPtr.hoX + this.MP_XMB, this.hoPtr.hoY + this.MP_YMB) != CRun.INTBAD)
					return;

				if (this.hoPtr.hoAdRunHeader.colMask_TestObject_IXY(this.hoPtr, this.hoPtr.roc.rcImage, this.hoPtr.roc.rcAngle, this.hoPtr.roc.rcScaleX, this.hoPtr.roc.rcScaleY, this.hoPtr.hoX, this.hoPtr.hoY, 0, CRunFrame.CM_TEST_OBSTACLE) == false)
				{
					if (this.MP_Type == CMovePlatform.MPTYPE_JUMP && this.MP_YSpeed < 0)
						return;

					if (this.hoPtr.hoAdRunHeader.colMask_TestObject_IXY(this.hoPtr, this.hoPtr.roc.rcImage, this.hoPtr.roc.rcAngle, this.hoPtr.roc.rcScaleX, this.hoPtr.roc.rcScaleY, this.hoPtr.hoX, this.hoPtr.hoY, this.MP_HTFOOT, CRunFrame.CM_TEST_PLATFORM) == false)
						return;
				}
				this.hoPtr.hoAdRunHeader.rhEvtProg.handle_Event(this.hoPtr, (-13 << 16) | (this.hoPtr.hoType & 0xFFFF));
			}
		});

	// CMoveRace object
	// -----------------------------------------------------------
	CMoveRace.RaceMask =
		[
			0xFFFFFFF8,
			0xFFFFFFFC,
			0xFFFFFFFE,
			0xFFFFFFFF
		];
	function CMoveRace()
	{
		this.MR_Bounce = 0;
		this.MR_BounceMu = 0;
		this.MR_Speed = 0;
		this.MR_RotSpeed = 0;
		this.MR_RotCpt = 0;
		this.MR_RotPos = 0;
		this.MR_RotMask = 0;
		this.MR_OkReverse = 0;
		this.MR_OldJoy = 0;
		this.MR_LastBounce = 0;
	}
	CMoveRace.prototype = CServices.extend(new CMove(),
		{
			init: function (ho, mrPtr)
			{
				this.hoPtr = ho;

				this.MR_Speed = 0;
				this.hoPtr.roc.rcSpeed = 0;
				this.MR_Bounce = 0;
				this.MR_LastBounce = -1;
				this.hoPtr.roc.rcPlayer = mrPtr.mvControl;
				this.rmAcc = mrPtr.mrAcc;
				this.rmAccValue = this.getAccelerator(mrPtr.mrAcc);
				this.rmDec = mrPtr.mrDec;
				this.rmDecValue = this.getAccelerator(mrPtr.mrDec);
				this.hoPtr.roc.rcMaxSpeed = mrPtr.mrSpeed;
				this.hoPtr.roc.rcMinSpeed = 0;
				this.MR_BounceMu = mrPtr.mrBounceMult;
				this.MR_OkReverse = mrPtr.mrOkReverse;
				this.hoPtr.rom.rmReverse = 0;
				this.rmOpt = mrPtr.mvOpt;
				this.MR_OldJoy = 0;

				this.MR_RotMask = CMoveRace.RaceMask[mrPtr.mrAngles];
				this.MR_RotSpeed = mrPtr.mrRot;
				this.MR_RotCpt = 0;
				this.MR_RotPos = this.hoPtr.hoAdRunHeader.getDir(this.hoPtr);
				this.hoPtr.hoCalculX = 0;
				this.hoPtr.hoCalculY = 0;
				this.moveAtStart(mrPtr);

				this.hoPtr.roc.rcChanged = true;
			},

			move: function ()
			{
				var j;
				var add, accel, speed, dir, speed8;
				var dSpeed;

				this.hoPtr.hoAdRunHeader.rhVBLObjet = 1;

				if (this.MR_Bounce == 0)
				{
					this.hoPtr.rom.rmBouncing = false;

					j = this.hoPtr.hoAdRunHeader.rhPlayer[this.hoPtr.roc.rcPlayer - 1] & 0x0F;

					add = 0;
					if ((j & 0x08) != 0)
						add = -1;
					if ((j & 0x04) != 0)
						add = 1;
					if (add != 0)
					{
						dSpeed = this.MR_RotSpeed;
						if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
							dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
						this.MR_RotCpt += dSpeed;
						while (this.MR_RotCpt > 100)
						{
							this.MR_RotCpt -= 100;
							this.MR_RotPos += add;
							this.MR_RotPos &= 31;
							this.hoPtr.roc.rcDir = this.MR_RotPos & this.MR_RotMask;
						}
						;
						this.hoPtr.roc.rcChanged = true;
					}

					accel = 0;
					if (this.hoPtr.rom.rmReverse != 0)
					{
						if ((j & 0x01) != 0)
							accel = 1;
						if ((j & 0x02) != 0)
							accel = 2;
					}
					else
					{
						if ((j & 0x01) != 0)
							accel = 2;
						if ((j & 0x02) != 0)
							accel = 1;
					}
					speed = this.MR_Speed;
					while (true)
					{
						if ((accel & 1) != 0)
						{
							if (this.MR_Speed == 0)
							{
								if (this.MR_OkReverse == 0)
									break;
								if ((this.MR_OldJoy & 0x03) != 0)
									break;
								this.hoPtr.rom.rmReverse ^= 1;
								dSpeed = this.rmAccValue;
								if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
									dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
								speed += dSpeed;
								speed8 = speed >> 8;
								if (speed8 > this.hoPtr.roc.rcMaxSpeed)
								{
									speed = this.hoPtr.roc.rcMaxSpeed << 8;
									this.MR_Speed = speed;
								}
								this.MR_Speed = speed;
								break;
							}
							dSpeed = this.rmDecValue;
							if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
								dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
							speed -= dSpeed;
							if (speed < 0)
								speed = 0;
							this.MR_Speed = speed;
						}
						else if ((accel & 2) != 0)
						{
							dSpeed = this.rmAccValue;
							if ((this.hoPtr.hoAdRunHeader.rhFrame.leFlags & CRunFrame.LEF_TIMEDMVTS) != 0)
								dSpeed = dSpeed * this.hoPtr.hoAdRunHeader.rh4MvtTimerCoef;
							speed += dSpeed;
							speed8 = speed >> 8;
							if (speed8 > this.hoPtr.roc.rcMaxSpeed)
							{
								speed = this.hoPtr.roc.rcMaxSpeed << 8;
								this.MR_Speed = speed;
							}
							this.MR_Speed = speed;
						}
						break;
					}
					;
					this.MR_OldJoy = j;

					this.hoPtr.roc.rcSpeed = this.MR_Speed >> 8;
					this.hoPtr.roc.rcAnim = CAnim.ANIMID_WALK;
					if (this.hoPtr.roa != null)
						this.hoPtr.roa.animate();

					dir = this.hoPtr.hoAdRunHeader.getDir(this.hoPtr);
					if (this.hoPtr.rom.rmReverse != 0)
					{
						dir += 16;
						dir &= 31;
					}
					if (this.newMake_Move(this.hoPtr.roc.rcSpeed, dir) == false)
					{
						return;
					}
				}
				do
				{
					if (this.MR_Bounce == 0)
						break;
					if (this.hoPtr.hoAdRunHeader.rhVBLObjet == 0)
						break;
					speed = this.MR_Speed;
					speed -= this.rmDecValue;
					if (speed <= 0)
					{
						this.MR_Speed = 0;
						this.MR_Bounce = 0;
						break;
					}
					this.MR_Speed = speed;
					speed >>= 8;
					dir = this.hoPtr.hoAdRunHeader.getDir(this.hoPtr);
					if (this.MR_Bounce != 0)
					{
						dir += 16;
						dir &= 31;
					}
					if (this.newMake_Move(speed, dir) == false)
						break;
				} while (true);
			},

			reverse: function ()
			{
			},

			stop:   function ()
			{
				this.MR_Bounce = 0;
				this.MR_Speed = 0;
				this.hoPtr.rom.rmReverse = 0;
				if (this.rmCollisionCount == this.hoPtr.hoAdRunHeader.rh3CollisionCount)
				{
					this.mv_Approach((this.rmOpt & CMove.MVTOPT_8DIR_STICK) != 0);
					this.hoPtr.rom.rmMoveFlag = true;
				}
			},
			start:  function ()
			{
				this.rmStopSpeed = 0;
				this.hoPtr.rom.rmMoveFlag = true;
			},
			bounce: function ()
			{
				if (this.rmCollisionCount == this.hoPtr.hoAdRunHeader.rh3CollisionCount)
				{
					this.mv_Approach((this.rmOpt & CMove.MVTOPT_8DIR_STICK) != 0);
				}
				if (this.hoPtr.hoAdRunHeader.rhLoopCount != this.MR_LastBounce)
				{
					this.MR_Bounce = this.hoPtr.rom.rmReverse;
					this.hoPtr.rom.rmReverse = 0;
					this.MR_Bounce++;
					if (this.MR_Bounce >= 16)
					{
						this.stop();
						return;
					}
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.rom.rmBouncing = true;
				}
			},

			setSpeed:    function (speed)
			{
				if (speed < 0) speed = 0;
				if (speed > 250) speed = 250;
				if (speed > this.hoPtr.roc.rcMaxSpeed)
					speed = this.hoPtr.roc.rcMaxSpeed;
				speed <<= 8;
				this.MR_Speed = speed;
				this.hoPtr.rom.rmMoveFlag = true;
			},
			setMaxSpeed: function (speed)
			{
				if (speed < 0) speed = 0;
				if (speed > 250) speed = 250;
				this.hoPtr.roc.rcMaxSpeed = speed;
				speed <<= 8;
				if (this.MR_Speed > speed)
				{
					this.MR_Speed = speed;
				}
				this.hoPtr.rom.rmMoveFlag = true;
			},

			setRotSpeed:  function (speed)
			{
				this.MR_RotSpeed = speed;
			},
			setXPosition: function (x)
			{
				if (this.hoPtr.hoX != x)
				{
					this.hoPtr.hoX = x;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
					this.hoPtr.roc.rcCheckCollides = true;
				}
			},
			setYPosition: function (y)
			{
				if (this.hoPtr.hoY != y)
				{
					this.hoPtr.hoY = y;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
					this.hoPtr.roc.rcCheckCollides = true;
				}
			},

			setDir: function (dir)
			{
				this.MR_RotPos = dir;
				this.hoPtr.roc.rcDir = dir & this.MR_RotMask;
			}
		});

	// CMoveStatic object
	// -----------------------------------------------------------
	function CMoveStatic()
	{
	}
	CMoveStatic.prototype = CServices.extend(new CMove(),
		{
			init:         function (ho, mvPtr)
			{
				this.hoPtr = ho;
				this.hoPtr.roc.rcSpeed = 0;
				this.hoPtr.roc.rcCheckCollides = true;
				this.hoPtr.roc.rcChanged = true;
			},
			move:         function ()
			{
				if (this.hoPtr.roa != null)
				{
					if (this.hoPtr.roa.animate())
					{
						//return; Removed in build 291, see bug #4750
					}
				}
				if (this.hoPtr.roc.rcCheckCollides)
				{
					this.hoPtr.roc.rcCheckCollides = false;
					this.hoPtr.hoAdRunHeader.newHandle_Collisions(this.hoPtr);
				}
			},
			setXPosition: function (x)
			{
				if (this.hoPtr.hoX != x)
				{
					this.hoPtr.hoX = x;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
				}
				this.hoPtr.roc.rcCheckCollides = true;
			},
			setYPosition: function (y)
			{
				if (this.hoPtr.hoY != y)
				{
					this.hoPtr.hoY = y;
					this.hoPtr.rom.rmMoveFlag = true;
					this.hoPtr.roc.rcChanged = true;
				}
				this.hoPtr.roc.rcCheckCollides = true;
			},
			setDir:       function (dir)
			{
			},
			reverse:      function (dir)
			{
			},
			stop:         function ()
			{
			},
			start:        function ()
			{
			},
			bounce:       function ()
			{
			},
			setSpeed:     function (speed)
			{
			},
			setMaxSpeed:  function (speed)
			{
			}
		});

	// CMoveExtension object
	// -----------------------------------------------------------
	function CMoveExtension(m)
	{
		this.movement = m;
		this.callParam = 0;
	}
	CMoveExtension.prototype = CServices.extend(new CMove(),
		{
			init:         function (ho, mvPtr)
			{
				this.hoPtr = ho;

				var file = ho.hoAdRunHeader.rhApp.file.createFromFile(mvPtr.data);
				this.movement.initialize(file);
				this.hoPtr.roc.rcCheckCollides = true;
				this.hoPtr.roc.rcChanged = true;
			},
			kill:         function ()
			{
				this.movement.kill();
			},
			move:         function ()
			{
				/*      // FRANCOIS
				 if (typeof this.movement == 'undefined')
				 {
				 debugger;
				 return;
				 }
				 */
				if (this.movement.move())
				{
					this.hoPtr.roc.rcChanged = true;
				}
			},
			stop:         function ()
			{
				this.movement.stop(this.rmCollisionCount == this.hoPtr.hoAdRunHeader.rh3CollisionCount);
			},
			start:        function ()
			{
				this.movement.start();
			},
			bounce:       function ()
			{
				this.movement.bounce(this.rmCollisionCount == this.hoPtr.hoAdRunHeader.rh3CollisionCount);
			},
			setSpeed:     function (speed)
			{
				this.movement.setSpeed(speed);
			},
			setMaxSpeed:  function (speed)
			{
				this.movement.setMaxSpeed(speed);
			},
			reverse:      function ()
			{
				this.movement.reverse();
			},
			setXPosition: function (x)
			{
				this.movement.setXPosition(x);
				this.hoPtr.roc.rcChanged = true;
				this.hoPtr.roc.rcCheckCollides = true;
			},
			setYPosition: function (y)
			{
				this.movement.setYPosition(y);
				this.hoPtr.roc.rcChanged = true;
				this.hoPtr.roc.rcCheckCollides = true;
			},
			setDir:       function (dir)
			{
				this.movement.setDir(dir);
				this.hoPtr.roc.rcChanged = true;
				this.hoPtr.roc.rcCheckCollides = true;
			},
			callMovement: function (func, param)
			{
				this.callParam = param;
				return this.movement.actionEntry(func);
			}
		});

	// CRunMvtExtension object
	// ---------------------------------------------------------------

	function CRunMvtExtension()
	{
		this.ho = null;
		this.rh = null;
	}
	CRunMvtExtension.prototype =
	{
		init: function (hoPtr)
		{
			this.ho = hoPtr;
			this.rh = this.ho.hoAdRunHeader;
		},

		initialize: function (file)
		{
		},

		kill: function ()
		{
		},

		move: function ()
		{
			return false;
		},

		setPosition: function (x, y)
		{
		},

		setXPosition: function (x)
		{
		},

		setYPosition: function (y)
		{
		},

		stop: function (bCurrent)
		{
		},

		bounce: function (bCurrent)
		{
		},

		reverse: function ()
		{
		},

		start: function ()
		{
		},

		setSpeed: function (speed)
		{
		},

		setMaxSpeed: function (speed)
		{
		},

		setDir: function (dir)
		{
		},

		setAcc: function (acc)
		{
		},

		setDec: function (dec)
		{
		},

		setRotSpeed: function (speed)
		{
		},

		set8Dirs: function (dirs)
		{
		},

		setGravity: function (gravity)
		{
		},

		extension: function (func, param)
		{
			return 0;
		},

		actionEntry: function (action)
		{
			return 0;
		},

		getSpeed: function ()
		{
			return 0;
		},

		getAcceleration: function ()
		{
			return 0;
		},

		getDeceleration: function ()
		{
			return 0;
		},

		getGravity: function ()
		{
			return 0;
		},
		getDir:     function ()
		{
			return this.ho.roc.rcDir;
		},
		dirAtStart: function (dir)
		{
			return this.ho.rom.dirAtStart(this.ho, dir, 32);
		},

		animations: function (anm)
		{
			this.ho.roc.rcAnim = anm;
			if (this.ho.roa != null)
			{
				this.ho.roa.animate();
			}
		},

		collisions: function ()
		{
			this.ho.hoAdRunHeader.rh3CollisionCount++;
			this.ho.rom.rmMovement.rmCollisionCount = this.ho.hoAdRunHeader.rh3CollisionCount;
			this.ho.hoAdRunHeader.newHandle_Collisions(this.ho);
		},

		approachObject: function (destX, destY, originX, originY, htFoot, planCol, ptDest)
		{
			destX -= this.ho.hoAdRunHeader.rhWindowX;
			destY -= this.ho.hoAdRunHeader.rhWindowY;
			originX -= this.ho.hoAdRunHeader.rhWindowX;
			originY -= this.ho.hoAdRunHeader.rhWindowY;
			var bRet = this.ho.rom.rmMovement.mpApproachSprite(destX, destY, originX, originY, htFoot, planCol, ptDest);
			ptDest.x += this.ho.hoAdRunHeader.rhWindowX;
			ptDest.y += this.ho.hoAdRunHeader.rhWindowY;
			return bRet;
		},

		moveIt: function ()
		{
			return this.ho.rom.rmMovement.newMake_Move(this.ho.roc.rcSpeed, this.ho.hoAdRunHeader.getDir(this.ho));
		},

		testPosition: function (x, y, htFoot, planCol, flag)
		{
			return this.ho.rom.rmMovement.tst_SpritePosition(x, y, htFoot, planCol, flag);
		},

		getJoystick: function (player)
		{
			return this.ho.hoAdRunHeader.rhPlayer[player];
		},

		colMaskTestRect: function (x, y, sx, sy, layer, plan)
		{
			return !this.ho.hoAdRunHeader.colMask_Test_Rect(x, y, sx, sy, layer, plan);
		},

		colMaskTestPoint: function (x, y, layer, plan)
		{
			return !this.ho.hoAdRunHeader.colMask_Test_XY(x, y, layer, plan);
		},

		getParamDouble: function ()
		{
			return this.ho.rom.rmMovement.callParam;
		},

		getParam: function ()
		{
			return this.ho.rom.rmMovement.callParam;
		}

	}

	// CRMvt object
	// ---------------------------------------------------------------
	CRMvt.EF_GOESINPLAYFIELD = 0x0001;
	CRMvt.EF_GOESOUTPLAYFIELD = 0x0002;
	CRMvt.EF_WRAP = 0x0004;
	function CRMvt()
	{
		this.rmObject = null;
		this.rmMvtNum = 0;
		this.rmMovement = null;
		this.rmWrapping = 0;
		this.rmMoveFlag = false;
		this.rmReverse = 0;
		this.rmBouncing = false;
		this.rmEventFlags = 0;
	}
	CRMvt.prototype =
	{
		init:             function (nMove, hoPtr, ocPtr, cob, forcedType)
		{
			this.rmObject = hoPtr;

			if (this.rmMovement != null)
				this.rmMovement.kill();

			if (cob != null)
			{
				hoPtr.roc.rcDir = cob.cobDir;
			}
			this.rmWrapping = hoPtr.hoOiList.oilWrap;

			var mvPtr = null;
			hoPtr.roc.rcMovementType = -1;
			if (ocPtr.ocMovements != null)
			{
				if (nMove < ocPtr.ocMovements.nMovements)
				{
					mvPtr = ocPtr.ocMovements.moveList[nMove];
					this.rmMvtNum = nMove;
					if (forcedType == -1)
					{
						forcedType = mvPtr.mvType;
					}
					hoPtr.roc.rcMovementType = forcedType;
					switch (forcedType)
					{
						case 0:
							this.rmMovement = new CMoveStatic();
							break;
						case 1:
							this.rmMovement = new CMoveMouse();
							break;
						case 2:
							this.rmMovement = new CMoveRace();
							break;
						case 3:
							this.rmMovement = new CMoveGeneric();
							break;
						case 4:
							this.rmMovement = new CMoveBall();
							break;
						case 5:
							this.rmMovement = new CMovePath();
							break;
						case 9:
							this.rmMovement = new CMovePlatform();
							break;
						case 14:
							this.rmMovement = this.loadMvtExtension(hoPtr, mvPtr);
							if (this.rmMovement == null)
								this.rmMovement = new CMoveStatic();
							break;
					}
					hoPtr.roc.rcDir = this.dirAtStart(hoPtr, mvPtr.mvDirAtStart, hoPtr.roc.rcDir);
					this.rmMovement.init(hoPtr, mvPtr);
				}
			}
			if (hoPtr.roc.rcMovementType == -1)
			{
				hoPtr.roc.rcMovementType = 0;
				this.rmMovement = new CMoveStatic();
				this.rmMovement.init(hoPtr, null);
				hoPtr.roc.rcDir = 0;
			}
		},
		loadMvtExtension: function (hoPtr, mvDef)
		{
			var extName = mvDef.moduleName;
			/*
			 var index = extName.indexOf('-');
			 while (index > 0)
			 {
			 extName = extName.substring(0, index) + '_' + extName.substring(index+1, extName.length);
			 index = extName.indexOf('-');
			 }
			 */
			var object = null;

			// STARTCUT
			// ENDCUT

			/*
			 if (document.debug==undefined)
			 {
			 if (!CRMvt.types[extName])
			 {
			 var extFile = new CFile();
			 extFile.openFile(document.srcPath + extName+ '.js');
			 (new Function(extFile.ccfBytes)).call(CRMvt.types);
			 }
			 var type = CRMvt.types[extName];
			 if (type)
			 object=new type;
			 }
			 else
			 {
			 object=new window['CRunMvt' + extName];
			 }
			 */
			if (object != null)
			{
				object.init(hoPtr);
				var mvExt = new CMoveExtension(object);
				return mvExt;
			}
			return null;
		},

		initSimple: function (hoPtr, forcedType, bRestore)
		{
			this.rmObject = hoPtr;

			if (this.rmMovement != null)
				this.rmMovement.kill();

			hoPtr.roc.rcMovementType = forcedType;
			switch (forcedType)
			{
				case 11:
					this.rmMovement = new CMoveDisappear();
					break;
				case 13:
					this.rmMovement = new CMoveBullet();
					break;
			}
			this.rmMovement.hoPtr = hoPtr;
			if (bRestore == false)
			{
				this.rmMovement.init(hoPtr, null);
			}
		},

		kill: function (bFast)
		{
			this.rmMovement.kill();
		},

		move: function ()
		{
			this.rmMovement.move();
		},

		nextMovement:     function (hoPtr)
		{
			var ocPtr = hoPtr.hoCommon;
			if (ocPtr.ocMovements != null)
			{
				if (this.rmMvtNum + 1 < ocPtr.ocMovements.nMovements)
				{
					this.init(this.rmMvtNum + 1, hoPtr, ocPtr, null, -1);
					var pMovement = hoPtr.hoAdRunHeader.GetMBase(hoPtr);
					if (pMovement)
						pMovement.CreateBody();
				}
			}
		},
		previousMovement: function (hoPtr)
		{
			var ocPtr = hoPtr.hoCommon;
			if (ocPtr.ocMovements != null)
			{
				if (this.rmMvtNum - 1 >= 0)
				{
					this.init(this.rmMvtNum - 1, hoPtr, ocPtr, null, -1);
					var pMovement = hoPtr.hoAdRunHeader.GetMBase(hoPtr);
					if (pMovement)
						pMovement.CreateBody();
				}
			}
		},
		selectMovement:   function (hoPtr, mvt)
		{
			var ocPtr = hoPtr.hoCommon;
			if (ocPtr.ocMovements != null)
			{
				if (mvt >= 0 && mvt < ocPtr.ocMovements.nMovements)
				{
					this.init(mvt, hoPtr, ocPtr, null, -1);
					var pMovement = hoPtr.hoAdRunHeader.GetMBase(hoPtr);
					if (pMovement)
						pMovement.CreateBody();
				}
			}
		},

		dirAtStart: function (hoPtr, dirAtStart, dir)
		{
			if (dir < 0 || dir >= 32)
			{
				var cpt = 0;
				var das = dirAtStart;
				var das2;
				var n;
				for (n = 0; n < 32; n++)
				{
					das2 = das;
					das >>= 1;
					if ((das2 & 1) != 0)
						cpt++;
				}

				if (cpt == 0)
					dir = 0;
				else
				{
					cpt = hoPtr.hoAdRunHeader.random(cpt);
					das = dirAtStart;
					for (dir = 0; ; dir++)
					{
						das2 = das;
						das >>= 1;
						if ((das2 & 1) != 0)
						{
							cpt--;
							if (cpt < 0)
							{
								break;
							}
						}
					}
				}
			}
			return dir;
		}
	}





	//----------------------------------------------------------------------------------
	//
	// CRunEasing
	//
	//----------------------------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CRunEasing.CON_ANYOBJECTSTOPPED = 0;
	CRunEasing.CON_SPECIFICOBJECTSTOPPED = 1;
	CRunEasing.CON_ISOBJECTMOVING = 2;
	CRunEasing.CND_LAST = 3;

	CRunEasing.ACT_MOVEOBJ = 0;
	CRunEasing.ACT_STOPOBJECT = 1;
	CRunEasing.ACT_STOPALLOBJECTS = 2;
	CRunEasing.ACT_REVERSEOBJECT = 3;
	CRunEasing.ACT_SETAMPLITUDE = 4;
	CRunEasing.ACT_SETOVERSHOOT = 5;
	CRunEasing.ACT_SETPERIOD = 6;
	CRunEasing.ACT_SETOBJECTAMPLITUDE = 7;
	CRunEasing.ACT_SETOBJECTOVERSHOOT = 8;
	CRunEasing.ACT_SETOBJECTPERIOD = 9;
	CRunEasing.ACT_MOVEOBJEXPLICIT = 10;

	CRunEasing.EXP_GETNUMCONTROLLED = 0;
	CRunEasing.EXP_GETSTOPPEDFIXED = 1;
	CRunEasing.EXP_EASEIN = 2;
	CRunEasing.EXP_EASEOUT = 3;
	CRunEasing.EXP_EASEINOUT = 4;
	CRunEasing.EXP_EASEOUTIN = 5;
	CRunEasing.EXP_EASEINBETWEEN = 6;
	CRunEasing.EXP_EASEOUTBETWEEN = 7;
	CRunEasing.EXP_EASEINOUTBETWEEN = 8;
	CRunEasing.EXP_EASEOUTINBETWEEN = 9;
	CRunEasing.EXP_GETAMPLITUDE = 10;
	CRunEasing.EXP_GETOVERSHOOT = 11;
	CRunEasing.EXP_GETPERIOD = 12;
	CRunEasing.EXP_GETDEFAULTAMPLITUDE = 13;
	CRunEasing.EXP_GETDEFAULTOVERSHOOT = 14;
	CRunEasing.EXP_GETDEFAULTPERIOD = 15;
	CRunEasing.EASEIN = 0;
	CRunEasing.EASEOUT = 1;
	CRunEasing.EASEINOUT = 2;
	CRunEasing.EASEOUTIN = 3;

	function CRunEasing()
	{
		this.controlled;
		this.deleted;
		this.easeVars;
		this.controlledCount;
		this.currentMovedObj;
		this.currentMoved;
	}
	CRunEasing.prototype = CServices.extend(new CRunExtension(),
		{
			getNumberOfConditions: function ()
			{
				return CRunEasing.CND_LAST;
			},

			createRunObject: function (file, cob, version)
			{
				this.controlled = {};
				this.deleted = {};
				this.controlledCount = 0;
				this.currentMovedObj = null;
				this.currentMoved = null;
				this.easeVars = new CRunEasingVars();

				var bParser = new BinaryParser(false);
				var temp = file.readInString(4);
				this.easeVars.overshoot = bParser.toFloat(temp);
				temp = file.readInString(4);
				this.easeVars.amplitude = bParser.toFloat(temp);
				temp = file.readInString(4);
				this.easeVars.period = bParser.toFloat(temp);

				return false;
			},

			handleRunObject: function ()
			{
				var finnishedMoving = false;
				var step;

				var key;
				for (key in this.controlled)
				{
				    var object = this.GetObjectFromFixed(key);
					var moved = this.controlled[key];

					if (object != null)
					{
						if (moved.timeMode == 0)
						{
							var currentTime = new Date();
							var diff = (currentTime.getTime() - moved.startdate.getTime());

							step = diff / (moved.timespan);

							if (diff >= moved.timespan)
							{
								finnishedMoving = true;
							}
						}
						else
						{
							moved.eventloop_step++;
							step = moved.eventloop_step / (moved.timespan);

							if (moved.eventloop_step >= moved.timespan)
							{
								finnishedMoving = true;
							}
						}

						var easeStep = (this.calculateEasingValue(moved.easingMode, moved.functionA, moved.functionB, step, moved));

						//                object.hoX = ((moved.startX + (moved.destX - moved.startX) * easeStep + 0.5));
						//                object.hoY = ((moved.startY + (moved.destY - moved.startY) * easeStep + 0.5));
						object.hoX = CServices.floatToInt((moved.startX + (moved.destX - moved.startX) * easeStep + 0.5));
						object.hoY = CServices.floatToInt((moved.startY + (moved.destY - moved.startY) * easeStep + 0.5));
						object.roc.rcChanged = true;

						if (finnishedMoving)
						{
							finnishedMoving = false;

							object.hoX = CServices.floatToInt(moved.destX);
							object.hoY = CServices.floatToInt(moved.destY);

							this.deleted[key] = moved;
							delete this.controlled[key];
							this.controlledCount--;
						}
					}
					else
					{
						delete this.controlled[object];
						this.controlledCount--;
					}
				}

				//Trigger the 'Object stopped moving' events
				for (var dkey in this.deleted)
				{
					this.currentMovedObj = this.GetObjectFromFixed(dkey);
					this.currentMoved = (this.deleted[dkey]);
					this.ho.generateEvent(CRunEasing.CON_ANYOBJECTSTOPPED, 0);
					this.ho.generateEvent(CRunEasing.CON_SPECIFICOBJECTSTOPPED, 0);
					delete this.deleted[dkey];
				}
				this.currentMovedObj = null;
				this.currentMoved == null;
				return 0;
			},


			// Conditions
			// -------------------------------------------------
			condition:       function (num, cnd)
			{
				switch (num)
				{
					case CRunEasing.CON_ANYOBJECTSTOPPED:
						return this.con_AnyObjectStopped();
					case CRunEasing.CON_SPECIFICOBJECTSTOPPED:
						return this.con_SpecificObjectStopped(cnd);
					case CRunEasing.CON_ISOBJECTMOVING:
						return this.con_IsObjectMoving(cnd, CCnd.negaFALSE(this.rh.currentPtr));
				}
				return false;
			},

			// Actions
			// -------------------------------------------------
			action:          function (num, act)
			{
				switch (num)
				{
					case CRunEasing.ACT_MOVEOBJ:
						this.act_MoveObj(act.getParamObject(this.rh, 0), act.getParamExtension(this.rh, 1), act.getParamExpression(this.rh, 2), act.getParamExpression(this.rh, 3), act.getParamExtension(this.rh, 4), act.getParamExpression(this.rh, 5));
						break;
					case CRunEasing.ACT_STOPOBJECT:
						this.act_StopObject(act.getParamObject(this.rh, 0));
						break;
					case CRunEasing.ACT_STOPALLOBJECTS:
						this.act_StopAllObjects();
						break;
				    case CRunEasing.ACT_REVERSEOBJECT:
						this.act_ReverseObject(act.getParamObject(this.rh, 0));
						break;
					case CRunEasing.ACT_SETAMPLITUDE:
						this.act_SetAmplitude(act.getParamExpDouble(this.rh, 0));
						break;
					case CRunEasing.ACT_SETOVERSHOOT:
						this.act_SetOvershoot(act.getParamExpDouble(this.rh, 0));
						break;
					case CRunEasing.ACT_SETPERIOD:
						this.act_SetPeriod(act.getParamExpDouble(this.rh, 0));
						break;
					case CRunEasing.ACT_SETOBJECTAMPLITUDE:
						this.act_SetObjectAmplitude(act.getParamObject(this.rh, 0), act.getParamExpDouble(this.rh, 1));
						break;
					case CRunEasing.ACT_SETOBJECTOVERSHOOT:
						this.act_SetObjectOvershoot(act.getParamObject(this.rh, 0), act.getParamExpDouble(this.rh, 1));
						break;
					case CRunEasing.ACT_SETOBJECTPERIOD:
						this.act_SetObjectPeriod(act.getParamObject(this.rh, 0), act.getParamExpDouble(this.rh, 1));
						break;
					case CRunEasing.ACT_MOVEOBJEXPLICIT:
						this.act_MoveObjExplicit(act.getParamExpression(this.rh, 0), act.getParamExpression(this.rh, 1), act.getParamExpression(this.rh, 2), act.getParamExpression(this.rh, 3), act.getParamExpression(this.rh, 4), act.getParamExpression(this.rh, 5), act.getParamExpression(this.rh, 6), act.getParamExpression(this.rh, 7));
						break;
				}
			},

			// Expressions
			// -------------------------------------------------
			expression:      function (num)
			{
				switch (num)
				{
					case CRunEasing.EXP_GETNUMCONTROLLED:
						return this.exp_GetNumControlled();
					case CRunEasing.EXP_GETSTOPPEDFIXED:
						return this.exp_GetStoppedFixed();
					case CRunEasing.EXP_EASEIN:
						return this.exp_EaseIn(this.ho.getExpParam(), this.ho.getExpParam());
					case CRunEasing.EXP_EASEOUT:
						return this.exp_EaseOut(this.ho.getExpParam(), this.ho.getExpParam());
					case CRunEasing.EXP_EASEINOUT:
						return this.exp_EaseInOut(this.ho.getExpParam(), this.ho.getExpParam(), this.ho.getExpParam());
					case CRunEasing.EXP_EASEOUTIN:
						return this.exp_EaseOutIn(this.ho.getExpParam(), this.ho.getExpParam(), this.ho.getExpParam());
					case CRunEasing.EXP_EASEINBETWEEN:
						return this.exp_EaseInBetween(this.ho.getExpParam(), this.ho.getExpParam(), this.ho.getExpParam(), this.ho.getExpParam());
					case CRunEasing.EXP_EASEOUTBETWEEN:
						return this.exp_EaseOutBetween(this.ho.getExpParam(), this.ho.getExpParam(), this.ho.getExpParam(), this.ho.getExpParam());
					case CRunEasing.EXP_EASEINOUTBETWEEN:
						return this.exp_EaseInOutBetween(this.ho.getExpParam(), this.ho.getExpParam(), this.ho.getExpParam(), this.ho.getExpParam(), this.ho.getExpParam());
					case CRunEasing.EXP_EASEOUTINBETWEEN:
						return this.exp_EaseOutInBetween(this.ho.getExpParam(), this.ho.getExpParam(), this.ho.getExpParam(), this.ho.getExpParam(), this.ho.getExpParam());
					case CRunEasing.EXP_GETAMPLITUDE:
						return this.exp_GetAmplitude(this.ho.getExpParam());
					case CRunEasing.EXP_GETOVERSHOOT:
						return this.exp_GetOvershoot(this.ho.getExpParam());
					case CRunEasing.EXP_GETPERIOD:
						return this.exp_GetPeriod(this.ho.getExpParam());
					case CRunEasing.EXP_GETDEFAULTAMPLITUDE:
						return this.exp_GetDefaultAmplitude();
					case CRunEasing.EXP_GETDEFAULTOVERSHOOT:
						return this.exp_GetDefaultOvershoot();
					case CRunEasing.EXP_GETDEFAULTPERIOD:
						return this.exp_GetDefaultPeriod();
				}
				return 0;
			},

			con_AnyObjectStopped: function ()
			{
				return true;
			},

			con_SpecificObjectStopped: function (cnd)
			{
				var oiList = cnd.evtParams[0].oiList;
				if (this.select == null)
					this.select = new ObjectSelection(this.rh.rhApp);
				if (this.currentMovedObj != null && this.select.objectIsOfType(this.currentMovedObj, oiList))
				{
					this.select.selectOneObject(this.currentMovedObj);
					return true;
				}
				return false;
			},

			//Should it select the given object?
			filterMoving:              function (rdPtr, object)
			{
				return (rdPtr.controlled[rdPtr.GetFixedFromObject(object)] != null);
			},

			con_IsObjectMoving: function (cnd, isNegated)
			{
				var oiList = cnd.evtParams[0].oiList;
				if (this.select == null)
					this.select = new ObjectSelection(this.rh.rhApp);
				return this.select.filterObjects(this, oiList, isNegated, this.filterMoving);
			},

			act_MoveObj: function (obj, easingMode, targetX, targetY, timeMode, time)
			{
				if (obj === undefined || obj === null || obj.hoX === undefined || obj.hoY === undefined)
					return;

				var easingVars = new CRunEasingVars();
				easingVars.amplitude = this.easeVars.amplitude;
				easingVars.overshoot = this.easeVars.overshoot;
				easingVars.period = this.easeVars.period;
				easingVars.startX = obj.hoX;
				easingVars.startY = obj.hoY;
				easingVars.destX = targetX;
				easingVars.destY = targetY;
				easingVars.timespan = time;
				easingVars.fixed = this.GetFixedFromObject(obj);

				easingMode.skipBytes(1);
				easingVars.easingMode = easingMode.readAByte();
				easingVars.functionA = easingMode.readAByte();
				easingVars.functionB = easingMode.readAByte();

				easingVars.timeMode = timeMode.readAByte();
				if (easingVars.timeMode == 0)
				{
					easingVars.startdate = new Date();
				}

				var key = this.GetFixedFromObject(obj);
				if ( this.controlled[key] == null )
				    this.controlledCount++;
			    this.controlled[key] = easingVars;
			},

			act_MoveObjExplicit: function (fixed, easingMode, funcA, funcB, targetX, targetY, timeMode, time)
			{
				var easingVars = new CRunEasingVars();
				easingVars.amplitude = this.easeVars.amplitude;
				easingVars.overshoot = this.easeVars.overshoot;
				easingVars.period = this.easeVars.period;

				var obj = this.GetObjectFromFixed(fixed);
				if (obj == null)
					return;

				easingVars.fixed = fixed;
				easingVars.easingMode = easingMode;
				easingVars.functionA = funcA;
				easingVars.functionB = funcB;
				easingVars.startX = obj.hoX;
				easingVars.startY = obj.hoY;
				easingVars.destX = targetX;
				easingVars.destY = targetY;
				easingVars.timespan = time;

				easingVars.timeMode = timeMode;
				if (easingVars.timeMode == 0)
				{
					easingVars.startdate = new Date();
				}

				var key = this.GetFixedFromObject(obj);
				if (this.controlled[key] == null)
				    this.controlledCount++;
				this.controlled[key] = easingVars;
			},

			act_StopObject: function (obj)
			{
				var key = this.GetFixedFromObject(obj);
				if (this.controlled[key] != null)
				{
					delete this.controlled[key];
					this.controlledCount--;
				}
			},

			act_StopAllObjects: function ()
			{
				for (var obj in this.controlled)
				{
					delete this.controlled[this.GetFixedFromObject(obj)];
				}
				this.controlledCount = 0;
			},

			act_ReverseObject: function (object)
			{
				var reversed = null;
				var fixed = this.GetFixedFromObject(object);

				if (this.controlled[fixed] != null)
				{
					reversed = this.controlled[fixed];
					delete this.controlled[fixed];
					this.controlledCount--;
	            }
				if (reversed == null)
				{
					reversed = new CRunEasingVars();
				}

				//If it was the object that was just stopped then use that one.
				if (reversed.fixed == 0)
				{
				    if (this.currentMoved != null && this.currentMoved.fixed == fixed)
					{
						reversed = this.currentMoved;
					}
					else
					{	//If no object found, abort
						return;
					}
				}

				reversed.destX = reversed.startX;
				reversed.destY = reversed.startY;

				reversed.startX = object.hoX;
				reversed.startY = object.hoY;

				//Recalculate the time it should take moving to the previous position
				if (reversed.timeMode == 0)
				{
					reversed.timespan = Math.floor(new Date().getTime() - reversed.startdate.getTime());
					reversed.startdate = new Date();
				}
				else
				{
					reversed.timespan = reversed.eventloop_step;
					reversed.eventloop_step = 0;
				}

				this.controlled[fixed] = reversed;
				this.controlledCount++;
			},

			act_SetAmplitude: function (val)
			{
				this.easeVars.amplitude = val;
			},

			act_SetOvershoot: function (val)
			{
				this.easeVars.overshoot = val;
			},

			act_SetPeriod: function (val)
			{
				this.easeVars.period = val;
			},

			act_SetObjectAmplitude: function (obj, val)
			{
				var key = this.GetFixedFromObject(obj);
				var vars = (this.controlled[key]);
				if (vars == null)
				{
					return;
				}

				vars.amplitude = val;
				this.controlled[key] = vars;
			},

			act_SetObjectOvershoot: function (obj, val)
			{
				var key = this.GetFixedFromObject(obj);
				var vars = (this.controlled[key]);
				if (vars == null)
				{
					return;
				}

				vars.overshoot = val;
				this.controlled[key] = vars;
			},

			act_SetObjectPeriod: function (obj, val)
			{
				var key = this.GetFixedFromObject(obj);
				var vars = (this.controlled[key]);
				if (vars == null)
				{
					return;
				}

				vars.period = val;
				this.controlled[key] = vars;
			},

			exp_GetNumControlled: function ()
			{
				return (this.controlledCount);
			},

			exp_GetStoppedFixed: function ()
			{
				if (this.currentMovedObj == null)
				{
					return 0;
				}
				return (this.GetFixedFromObject(this.currentMovedObj));
			},

			exp_EaseIn: function (func, step)
			{
				return (this.easeIn(func, step, this.easeVars));
			},

			exp_EaseOut: function (func, step)
			{
				return (this.easeOut(func, step, this.easeVars));
			},

			exp_EaseInOut: function (funcA, funcB, step)
			{
				return (this.easeInOut(funcA, funcB, step, this.easeVars));
			},

			exp_EaseOutIn: function (funcA, funcB, step)
			{
				return (this.easeOutIn(funcA, funcB, step, this.easeVars));
			},

			exp_EaseInBetween: function (start, end, func, step)
			{
				var ease = this.easeIn(func, step, this.easeVars);
				return (start + (end - start) * ease);
			},

			exp_EaseOutBetween: function (start, end, func, step)
			{
				var ease = this.easeOut(func, step, this.easeVars);
				return (start + (end - start) * ease);
			},

			exp_EaseInOutBetween: function (start, end, funcA, funcB, step)
			{
				var ease = this.easeInOut(funcA, funcB, step, this.easeVars);
				return (start + (end - start) * ease);
			},

			exp_EaseOutInBetween: function (start, end, funcA, funcB, step)
			{
				var ease = this.easeOutIn(funcA, funcB, step, this.easeVars);
				return (start + (end - start) * ease);
			},

			exp_GetAmplitude: function (fixed)
			{
				var obj = this.GetControlledFromFixed(fixed);
				if (obj != null)
				{
					var vars = (this.controlled[fixed]);
					return (vars.amplitude);
				}
				return (-1);
			},

			exp_GetOvershoot: function (fixed)
			{
				var obj = this.GetControlledFromFixed(fixed);
				if (obj != null)
				{
					var vars = (this.controlled[fixed]);
					return (vars.overshoot);
				}
				return (-1);
			},

			exp_GetPeriod: function (fixed)
			{
				var obj = this.GetControlledFromFixed(fixed);
				if (obj != null)
				{
					var vars = (this.controlled[fixed]);
					return (vars.period);
				}
				return (-1);
			},

			exp_GetDefaultAmplitude: function ()
			{
				return (this.easeVars.amplitude);
			},

			exp_GetDefaultOvershoot: function ()
			{
				return (this.easeVars.overshoot);
			},

			exp_GetDefaultPeriod: function ()
			{
				return (this.easeVars.period);
			},


			//Easing functions:
			linear:               function (step, vars)
			{
				return step;
			},
			quad:                 function (step, vars)
			{
				return Math.pow(step, 2.0);
			},
			cubic:                function (step, vars)
			{
				return Math.pow(step, 3.0);
			},
			quart:                function (step, vars)
			{
				return Math.pow(step, 4.0);
			},
			quint:                function (step, vars)
			{
				return Math.pow(step, 5.0);
			},
			sine:                 function (step, vars)
			{
				return 1.0 - Math.sin((1 - step) * 90.0 * Math.PI / 180.0);
			},
			expo:                 function (step, vars)
			{
				return Math.pow(2.0, step * 10.0) / 1024.0;
			},
			circ:                 function (step, vars)
			{
				return 1.0 - Math.sqrt(1.0 - Math.pow(step, 2.0));
			},
			back:                 function (step, vars)
			{
				return (vars.overshoot + 1.0) * Math.pow(step, 3.0) - vars.overshoot * Math.pow(step, 2.0);
			},
			elastic:              function (step, vars)
			{
				step -= 1.0;
				var amp = Math.max(1.0, vars.amplitude);
				var s = (vars.period / (2.0 * Math.PI) * Math.asin(1.0 / amp));
				return -(amp * Math.pow(2.0, 10 * step) * Math.sin((step - s) * (2 * Math.PI) / vars.period));
			},
			bounce:               function (step, vars)
			{
				step = 1 - step;
				if (step < (8 / 22.0))
				{
					return 1 - 7.5625 * step * step;
				}
				else if (step < (16 / 22.0))
				{
					step -= 12 / 22.0;
					return 1 - vars.amplitude * (7.5625 * step * step + 0.75) - (1 - vars.amplitude);
				}
				else if (step < (20 / 22.0))
				{
					step -= 18 / 22.0;
					return 1 - vars.amplitude * (7.5625 * step * step + 0.9375) - (1 - vars.amplitude);
				}
				else
				{
					step -= 21 / 22.0;
					return 1 - vars.amplitude * (7.5625 * step * step + 0.984375) - (1 - vars.amplitude);
				}
			},

			doFunction: function (number, step, vars)
			{
				switch (number)
				{
					default:
					case 0:
						return this.linear(step, vars);
					case 1:
						return this.quad(step, vars);
					case 2:
						return this.cubic(step, vars);
					case 3:
						return this.quart(step, vars);
					case 4:
						return this.quint(step, vars);
					case 5:
						return this.sine(step, vars);
					case 6:
						return this.expo(step, vars);
					case 7:
						return this.circ(step, vars);
					case 8:
						return this.back(step, vars);
					case 9:
						return this.elastic(step, vars);
					case 10:
						return this.bounce(step, vars);
				}
			},

			easeIn: function (func, step, vars)
			{
				return this.doFunction(func, step, vars);
			},

			easeOut: function (func, step, vars)
			{
				return 1.0 - this.doFunction(func, 1.0 - step, vars);
			},

			easeInOut: function (functionA, functionB, step, vars)
			{
				if (step < 0.5)
				{
					return this.easeIn(functionA, step * 2.0, vars) / 2.0;
				}
				else
				{
					return this.easeOut(functionB, (step - 0.5) * 2.0, vars) / 2.0 + 0.5;
				}
			},

			easeOutIn: function (functionA, functionB, step, vars)
			{
				if (step < 0.5)
				{
					return this.easeOut(functionA, step * 2.0, vars) / 2.0;
				}
				else
				{
					return this.easeIn(functionB, (step - 0.5) * 2.0, vars) / 2.0 + 0.5;
				}
			},

			calculateEasingValue: function (mode, functionA, functionB, step, vars)
			{
				switch (mode)
				{
					default:
					case CRunEasing.EASEIN:
						return this.easeIn(functionA, step, vars);
					case CRunEasing.EASEOUT:
						return this.easeOut(functionA, step, vars);
					case CRunEasing.EASEINOUT:
						return this.easeInOut(functionA, functionB, step, vars);
					case CRunEasing.EASEOUTIN:
						return this.easeOutIn(functionA, functionB, step, vars);
				}
			},

			GetFixedFromObject:     function (obj)
			{
				return (obj.hoCreationId << 16) + (obj.hoNumber & 0xFFFF);
			},
			GetControlledFromFixed: function (fixedvalue)
			{
				var fixed;
				for (fixed in controlled)
				{
					if (fixed == fixedvalue)
					{
						return this.GetObjectFromFixed(fixed);
					}
				}
				return null;
			},
			GetObjectFromFixed:     function (fixed)
			{
				return (this.ho.hoAdRunHeader.rhObjectList[fixed & 0x0000FFFF]);
			}
		});

	function CRunEasingVars()
	{
		this.overshoot = 0;
		this.amplitude = 0;
		this.period = 0;

		this.startX = 0;
		this.startY = 0;
		this.destX = 0;
		this.destY = 0;

		this.easingMode = 0;
		this.functionA = 0;
		this.functionB = 0;

		this.timeMode = 0;
		this.startdate = null;

		this.timespan = 0;
		this.eventloop_step = 0;
		this.fixed = 0;
	}

	//+ Jonas Raoni Soares Silva
	//@ http://jsfromhell.com/classes/binary-parser [rev. #1]
	BinaryParser = function (bigEndian, allowExceptions)
	{
		this.bigEndian = bigEndian, this.allowExceptions = allowExceptions;
	};

	BinaryParser.prototype =
	{
		encodeFloat: function (number, precisionBits, exponentBits)
		{
			var bias = Math.pow(2, exponentBits - 1) - 1, minExp = -bias + 1, maxExp = bias, minUnnormExp = minExp - precisionBits,
				status = isNaN(n = parseFloat(number)) || n == -Infinity || n == +Infinity ? n : 0,
				exp = 0, len = 2 * bias + 1 + precisionBits + 3, bin = new Array(len),
				signal = (n = status !== 0 ? 0 : n) < 0, n = Math.abs(n), intPart = Math.floor(n), floatPart = n - intPart,
				i, lastBit, rounded, j, result;
			for (i = len; i; bin[--i] = 0);
			for (i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2));
			for (i = bias + 1; floatPart > 0 && i; (bin[++i] = ((floatPart *= 2) >= 1) - 0) && --floatPart);
			for (i = -1; ++i < len && !bin[i];);
			if (bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1))) + 1])
			{
				if (!(rounded = bin[lastBit]))
					for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]);
				for (j = lastBit + 1; rounded && --j >= 0; (bin[j] = !bin[j] - 0) && (rounded = 0));
			}
			for (i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];);

			(exp = bias + 1 - i) >= minExp && exp <= maxExp ? ++i : exp < minExp &&
				(exp != bias + 1 - len && exp < minUnnormExp && this.warn("encodeFloat::float underflow"), i = bias + 1 - (exp = minExp - 1));
			(intPart || status !== 0) && (this.warn(intPart ? "encodeFloat::float overflow" : "encodeFloat::" + status),
				exp = maxExp + 1, i = bias + 2, status == -Infinity ? signal = 1 : isNaN(status) && (bin[i] = 1));
			for (n = Math.abs(exp + bias), j = exponentBits + 1, result = ""; --j; result = (n % 2) + result, n = n >>= 1);
			for (n = 0, j = 0, i = (result = (signal ? "1" : "0") + result + bin.slice(i, i + precisionBits).join("")).length, r = [];
			     i; n += (1 << j) * result.charAt(--i), j == 7 && (r[r.length] = String.fromCharCode(n), n = 0), j = (j + 1) % 8);
			r[r.length] = n ? String.fromCharCode(n) : "";
			return (this.bigEndian ? r.reverse() : r).join("");
		},

		encodeInt: function (number, bits, signed)
		{
			var max = Math.pow(2, bits), r = [];
			(number >= max || number < -(max >> 1)) && this.warn("encodeInt::overflow") && (number = 0);
			number < 0 && (number += max);
			for (; number; r[r.length] = String.fromCharCode(number % 256), number = Math.floor(number / 256));
			for (bits = -(-bits >> 3) - r.length; bits--; r[r.length] = "\0");
			return (this.bigEndian ? r.reverse() : r).join("");
		},

		decodeFloat: function (data, precisionBits, exponentBits)
		{
			var b = ((b = new this.Buffer(this.bigEndian, data)).checkBuffer(precisionBits + exponentBits + 1), b),
				bias = Math.pow(2, exponentBits - 1) - 1, signal = b.readBits(precisionBits + exponentBits, 1),
				exponent = b.readBits(precisionBits, exponentBits), significand = 0,
				divisor = 2, curByte = b.buffer.length + (-precisionBits >> 3) - 1,
				byteValue, startBit, mask;
			do
				for (byteValue = b.buffer[++curByte], startBit = precisionBits % 8 || 8, mask = 1 << startBit;
				     mask >>= 1; (byteValue & mask) && (significand += 1 / divisor), divisor *= 2);
			while (precisionBits -= startBit);
			return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity
				: (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand
				: Math.pow(2, exponent - bias) * (1 + significand) : 0);
		},

		decodeInt: function (data, bits, signed)
		{
			var b = new this.Buffer(this.bigEndian, data), x = b.readBits(0, bits), max = Math.pow(2, bits);
			return signed && x >= max / 2 ? x - max : x;
		},

		warn: function (msg)
		{
			if (this.allowExceptions)
				throw new Error(msg);
			return 1;
		},

		toSmall: function (data)
		{
			return this.decodeInt(data, 8, true);
		},

		fromSmall: function (number)
		{
			return this.encodeInt(number, 8, true);
		},

		toByte: function (data)
		{
			return this.decodeInt(data, 8, false);
		},

		fromByte: function (number)
		{
			return this.encodeInt(number, 8, false);
		},

		toShort: function (data)
		{
			return this.decodeInt(data, 16, true);
		},

		fromShort: function (number)
		{
			return this.encodeInt(number, 16, true);
		},

		toWord: function (data)
		{
			return this.decodeInt(data, 16, false);
		},

		fromWord: function (number)
		{
			return this.encodeInt(number, 16, false);
		},

		toInt: function (data)
		{
			return this.decodeInt(data, 32, true);
		},

		fromInt: function (number)
		{
			return this.encodeInt(number, 32, true);
		},

		toDWord: function (data)
		{
			return this.decodeInt(data, 32, false);
		},

		fromDWord: function (number)
		{
			return this.encodeInt(number, 32, false);
		},

		toFloat: function (data)
		{
			return this.decodeFloat(data, 23, 8);
		},

		fromFloat: function (number)
		{
			return this.encodeFloat(number, 23, 8);
		},

		toDouble: function (data)
		{
			return this.decodeFloat(data, 52, 11);
		},

		fromDouble: function (number)
		{
			return this.encodeFloat(number, 52, 11);
		}
	};

	BinaryParser.prototype.Buffer = function (bigEndian, buffer)
	{
		this.bigEndian = bigEndian || 0, this.buffer = [], this.setBuffer(buffer);
	};

	BinaryParser.prototype.Buffer.prototype =
	{
		readBits: function (start, length)
		{
			//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)
			function shl(a, b)
			{
				for (++b; --b; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1);
				return a;
			}

			if (start < 0 || length <= 0)
				return 0;
			this.checkBuffer(start + length);
			for (var offsetLeft, offsetRight = start % 8, curByte = this.buffer.length - (start >> 3) - 1,
				     lastByte = this.buffer.length + (-(start + length) >> 3), diff = curByte - lastByte,
				     sum = ((this.buffer[curByte] >> offsetRight) & ((1 << (diff ? 8 - offsetRight : length)) - 1))
					     + (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[lastByte++] & ((1 << offsetLeft) - 1))
					     << (diff-- << 3) - offsetRight : 0); diff; sum += shl(this.buffer[lastByte++], (diff-- << 3) - offsetRight)
				);
			return sum;
		},

		setBuffer: function (data)
		{
			if (data)
			{
				for (var l, i = l = data.length, b = this.buffer = new Array(l); i; b[l - i] = data.charCodeAt(--i));
				this.bigEndian && b.reverse();
			}
		},

		hasNeededBits: function (neededBits)
		{
			return this.buffer.length >= -(-neededBits >> 3);
		},

		checkBuffer: function (neededBits)
		{
			if (!this.hasNeededBits(neededBits))
				throw new Error("checkBuffer::missing bytes");
		}
	};
	//----------------------------------------------------------------------------------
	//
	// CRunPlatform: Platform Movement object
	//
	//----------------------------------------------------------------------------------
	this.Platform = CRunPlatform;

	CRunPlatform.AID_ColObstacle = 0;
	CRunPlatform.AID_ColJumpThrough = 1;
	CRunPlatform.AID_SetObject = 2;
	CRunPlatform.AID_MoveRight = 3;
	CRunPlatform.AID_MoveLeft = 4;
	CRunPlatform.AID_Jump = 5;
	CRunPlatform.AID_SetXVelocity = 6;
	CRunPlatform.AID_SetYVelocity = 7;
	CRunPlatform.AID_SetMaxXVelocity = 8;
	CRunPlatform.AID_SetMaxYVelocity = 9;
	CRunPlatform.AID_SetXAccel = 10;
	CRunPlatform.AID_SetXDecel = 11;
	CRunPlatform.AID_SetGravity = 12;
	CRunPlatform.AID_SetJumpStrength = 13;
	CRunPlatform.AID_SetJumpHoldHeight = 14;
	CRunPlatform.AID_SetStepUp = 15;
	CRunPlatform.AID_JumpHold = 16;
	CRunPlatform.AID_Pause = 17;
	CRunPlatform.AID_UnPause = 18;
	CRunPlatform.AID_SetSlopeCorrection = 19;
	CRunPlatform.AID_SetAddXVelocity = 20;
	CRunPlatform.AID_SetAddYVelocity = 21;
	CRunPlatform.CID_ObstacleTest = 0;
	CRunPlatform.CID_JumpThroughTest = 1;
	CRunPlatform.CID_IsOnGround = 2;
	CRunPlatform.CID_IsJumping = 3;
	CRunPlatform.CID_IsFalling = 4;
	CRunPlatform.CID_IsPaused = 5;
	CRunPlatform.CID_IsMoving = 6;
	CRunPlatform.EID_GetXVelocity = 0;
	CRunPlatform.EID_GetYVelocity = 1;
	CRunPlatform.EID_GetMaxXVelocity = 2;
	CRunPlatform.EID_GetMaxYVelocity = 3;
	CRunPlatform.EID_GetXAccel = 4;
	CRunPlatform.EID_GetXDecel = 5;
	CRunPlatform.EID_GetGravity = 6;
	CRunPlatform.EID_GetJumpStrength = 7;
	CRunPlatform.EID_GetJumpHoldHeight = 8;
	CRunPlatform.EID_GetStepUp = 9;
	CRunPlatform.EID_GetSlopeCorrection = 10;
	CRunPlatform.EID_GetAddXVelocity = 11;
	CRunPlatform.EID_GetAddYVelocity = 12;

	function CRunPlatform()
	{
		this.ObjFixed = 0;
		this.ObjShortCut = 0;
		this.Col = null;
		this.PFMove = null;
	}
	CRunPlatform.prototype = CServices.extend(new CRunExtension(),
		{
			getNumberOfConditions: function ()
			{
				return 7;
			},

			fixString: function (input)
			{
				var i;
				for (i = 0; i < input.length; i++)
				{
					if (input.charCodeAt(i) < 10)
					{
						return input.substring(0, i);
					}
				}
				return input;
			},

			createRunObject: function (file, cob, version)
			{
				file.setUnicode(false);
				file.skipBytes(8);
				this.PFMove = new CRunPlatformMove();
				this.PFMove.MaxXVelocity = CServices.floatToInt(parseFloat(this.fixString(file.readAString(16))));
				this.PFMove.MaxYVelocity = CServices.floatToInt(parseFloat(this.fixString(file.readAString(16))));
				this.PFMove.XAccel = CServices.floatToInt(parseFloat(this.fixString(file.readAString(16))));
				this.PFMove.XDecel = CServices.floatToInt(parseFloat(this.fixString(file.readAString(16))));
				this.PFMove.Gravity = CServices.floatToInt(parseFloat(this.fixString(file.readAString(16))));
				this.PFMove.JumpStrength = CServices.floatToInt(parseFloat(this.fixString(file.readAString(16))));
				this.PFMove.JumpHoldHeight = CServices.floatToInt(parseFloat(this.fixString(file.readAString(16))));
				this.PFMove.StepUp = CServices.floatToInt(parseFloat(this.fixString(file.readAString(16))));
				this.PFMove.SlopeCorrection = CServices.floatToInt(parseFloat(this.fixString(file.readAString(16))));
				this.Col = new CRunPlatformCOL();
				this.Col.JumpThroughColTop = file.readAByte() == 1 ? true : false;
				this.Col.EnableJumpThrough = file.readAByte() == 1 ? true : false;
				return true;
			},

			GetCObject: function (Fixed)
			{
				var pHo;
				for (pHo = this.ho.getFirstObject(); pHo != null; pHo = this.ho.getNextObject())
				{
					if (((pHo.hoCreationId << 16) + pHo.hoNumber) == Fixed)
					{
						return pHo;
					}
				}
				return null;
			},

			IsOverObstacle: function ()
			{
				this.Col.Obstacle = false;
				this.ho.generateEvent(CRunPlatform.CID_ObstacleTest, this.ho.getEventParam());
				return this.Col.Obstacle;
			},

			IsOverJumpThrough: function ()
			{
				if (!this.Col.EnableJumpThrough)
				{
					return false;
				}
				this.Col.JumpThrough = false;
				this.ho.generateEvent(CRunPlatform.CID_JumpThroughTest, this.ho.getEventParam());
				return this.Col.JumpThrough;
			},

			handleRunObject: function ()
			{
				var Object = this.GetCObject(this.ObjFixed);
				// If Object is valid, do movement
				if (!this.PFMove.Paused && Object != null)
				{
					if (this.PFMove.RightKey && !this.PFMove.LeftKey)
					{
						this.PFMove.XVelocity += this.PFMove.XAccel; // add to x velocity when pressing right
					}
					if (this.PFMove.LeftKey && !this.PFMove.RightKey)
					{
						this.PFMove.XVelocity -= this.PFMove.XAccel; // sub from x velocity when pressing left
					}
					if (this.PFMove.XVelocity != 0 && ((!this.PFMove.LeftKey && !this.PFMove.RightKey) || (this.PFMove.LeftKey && this.PFMove.RightKey)))
					{
						// slow the object down when not pressing right or left
						this.PFMove.XVelocity -= this.PFMove.XVelocity / Math.abs(this.PFMove.XVelocity) * this.PFMove.XDecel;
						if (this.PFMove.XVelocity <= this.PFMove.XDecel && this.PFMove.XVelocity >= 0 - this.PFMove.XDecel)
						{
							this.PFMove.XVelocity = 0; // set x velocity to 0 when it's close to 0
						}
					}
					/////////////////////////////////////////////////////////////////////////
					// MOVEMENT LOOPS
					// set velocitities to max and min
					this.PFMove.XVelocity = Math.min(Math.max(this.PFMove.XVelocity, 0 - this.PFMove.MaxXVelocity), this.PFMove.MaxXVelocity);
					this.PFMove.YVelocity = Math.min(Math.max(this.PFMove.YVelocity + this.PFMove.Gravity, 0 - this.PFMove.MaxYVelocity), this.PFMove.MaxYVelocity);
					var tmpXVelocity = this.PFMove.XVelocity + this.PFMove.AddXVelocity;
					var tmpYVelocity = this.PFMove.YVelocity + this.PFMove.AddYVelocity;
					this.PFMove.XMoveCount += Math.abs(tmpXVelocity);
					this.PFMove.YMoveCount += Math.abs(tmpYVelocity);

					// X MOVEMENT LOOP
					while (this.PFMove.XMoveCount > 100)
					{
						if (!this.IsOverObstacle())
						{
							Object.hoX += tmpXVelocity / Math.abs(tmpXVelocity);
						}

						if (this.IsOverObstacle())
						{
							var up;
							for (up = 0; up < this.PFMove.StepUp; up++) // Step up (slopes)
							{
								Object.hoY--;
								if (!this.IsOverObstacle())
								{
									break;
								}
							}
							if (this.IsOverObstacle())
							{
								Object.hoY += this.PFMove.StepUp;
								Object.hoX -= tmpXVelocity / Math.abs(tmpXVelocity);
								this.PFMove.XVelocity = this.PFMove.XMoveCount = 0;
							}
						}
						this.PFMove.XMoveCount -= 100;
						Object.roc.rcChanged = true;
					}

					// Y MOVEMENT LOOP
					while (this.PFMove.YMoveCount > 100)
					{
						if (!this.IsOverObstacle())
						{
							Object.hoY += tmpYVelocity / Math.abs(tmpYVelocity);
							this.PFMove.OnGround = false;
						}

						if (this.IsOverObstacle())
						{
							Object.hoY -= tmpYVelocity / Math.abs(tmpYVelocity);
							if (tmpYVelocity > 0)
							{
								this.PFMove.OnGround = true;
							}
							this.PFMove.YVelocity = this.PFMove.YMoveCount = 0;
						}

						if (this.IsOverJumpThrough() && tmpYVelocity > 0)
						{
							if (this.Col.JumpThroughColTop)
							{
								Object.hoY--;
								if (!this.IsOverJumpThrough())
								{
									Object.hoY -= tmpYVelocity / Math.abs(tmpYVelocity);
									this.PFMove.YVelocity = this.PFMove.YMoveCount = 0;
									this.PFMove.OnGround = true;
								}
								Object.hoY++;
							}
							else
							{
								Object.hoY -= tmpYVelocity / Math.abs(tmpYVelocity);
								this.PFMove.YVelocity = this.PFMove.YMoveCount = 0;
								this.PFMove.OnGround = true;
							}
						}
						this.PFMove.YMoveCount -= 100;
						Object.roc.rcChanged = true;

					}
					if (this.PFMove.SlopeCorrection > 0 && tmpYVelocity >= 0)
					{
						var tmp = false;
						// Slope correction
						var sc;
						for (sc = 0; sc < this.PFMove.SlopeCorrection; sc++)
						{
							Object.hoY++;
							if (this.IsOverObstacle())
							{
								Object.hoY--;
								this.PFMove.OnGround = true;
								tmp = true;
								break;
							}
						}
						if (tmp == false)
						{
							Object.hoY -= this.PFMove.SlopeCorrection;
						}
					}
				}
				// Reset values
				this.PFMove.RightKey = false;
				this.PFMove.LeftKey = false;
				return 0;
			},

			action: function (num, act)
			{
				switch (num)
				{
					case CRunPlatform.AID_ColObstacle:
						this.Col.Obstacle = true;
						break;
					case CRunPlatform.AID_ColJumpThrough:
						this.Col.JumpThrough = true;
						break;
					case CRunPlatform.AID_SetObject:
						this.SetObject(act.getParamObject(this.rh, 0));
						break;
					case CRunPlatform.AID_MoveRight:
						this.PFMove.RightKey = true;
						break;
					case CRunPlatform.AID_MoveLeft:
						this.PFMove.LeftKey = true;
						break;
					case CRunPlatform.AID_Jump:
						this.PFMove.YVelocity = 0 - this.PFMove.JumpStrength;
						break;
					case CRunPlatform.AID_SetXVelocity:
						this.PFMove.XVelocity = act.getParamExpression(this.rh, 0);
						break;
					case CRunPlatform.AID_SetYVelocity:
						this.PFMove.YVelocity = act.getParamExpression(this.rh, 0);
						break;
					case CRunPlatform.AID_SetMaxXVelocity:
						this.PFMove.MaxXVelocity = act.getParamExpression(this.rh, 0);
						break;
					case CRunPlatform.AID_SetMaxYVelocity:
						this.PFMove.MaxYVelocity = act.getParamExpression(this.rh, 0);
						break;
					case CRunPlatform.AID_SetXAccel:
						this.PFMove.XAccel = act.getParamExpression(this.rh, 0);
						break;
					case CRunPlatform.AID_SetXDecel:
						this.PFMove.XDecel = act.getParamExpression(this.rh, 0);
						break;
					case CRunPlatform.AID_SetGravity:
						this.PFMove.Gravity = act.getParamExpression(this.rh, 0);
						break;
					case CRunPlatform.AID_SetJumpStrength:
						this.PFMove.JumpStrength = act.getParamExpression(this.rh, 0);
						break;
					case CRunPlatform.AID_SetJumpHoldHeight:
						this.PFMove.JumpHoldHeight = act.getParamExpression(this.rh, 0);
						break;
					case CRunPlatform.AID_SetStepUp:
						this.PFMove.StepUp = act.getParamExpression(this.rh, 0);
						break;
					case CRunPlatform.AID_JumpHold:
						this.PFMove.YVelocity -= this.PFMove.JumpHoldHeight;
						break;
					case CRunPlatform.AID_Pause:
						this.PFMove.Paused = true;
						break;
					case CRunPlatform.AID_UnPause:
						this.PFMove.Paused = false;
						break;
					case CRunPlatform.AID_SetSlopeCorrection:
						this.PFMove.SlopeCorrection = act.getParamExpression(this.rh, 0);
						break;
					case CRunPlatform.AID_SetAddXVelocity:
						this.PFMove.AddXVelocity = act.getParamExpression(this.rh, 0);
						break;
					case CRunPlatform.AID_SetAddYVelocity:
						this.PFMove.AddYVelocity = act.getParamExpression(this.rh, 0);
						break;
				}
			},

			SetObject: function (object)
			{
				if (object != null)
				{
					this.ObjFixed = (object.hoCreationId << 16) + object.hoNumber;
				}
				else
				{
					this.ObjFixed = 0;
				}
			},

			condition: function (num, cnd)
			{
				switch (num)
				{
					case CRunPlatform.CID_ObstacleTest:
						return true;
					case CRunPlatform.CID_JumpThroughTest:
						return true;
					case CRunPlatform.CID_IsOnGround:
						return this.PFMove.OnGround;
					case CRunPlatform.CID_IsJumping:
						return (!this.PFMove.OnGround && this.PFMove.YVelocity <= 0);
					case CRunPlatform.CID_IsFalling:
						return (!this.PFMove.OnGround && this.PFMove.YVelocity > 0);
					case CRunPlatform.CID_IsPaused:
						return this.PFMove.Paused;
					case CRunPlatform.CID_IsMoving:
						return (Math.abs(this.PFMove.XVelocity) > 0);
				}
				return false;
			},

			expression: function (num)
			{
				switch (num)
				{
					case CRunPlatform.EID_GetXVelocity:
						return (this.PFMove.XVelocity);
					case CRunPlatform.EID_GetYVelocity:
						return (this.PFMove.YVelocity);
					case CRunPlatform.EID_GetMaxXVelocity:
						return (this.PFMove.MaxXVelocity);
					case CRunPlatform.EID_GetMaxYVelocity:
						return (this.PFMove.MaxYVelocity);
					case CRunPlatform.EID_GetXAccel:
						return (this.PFMove.XAccel);
					case CRunPlatform.EID_GetXDecel:
						return (this.PFMove.XDecel);
					case CRunPlatform.EID_GetGravity:
						return (this.PFMove.Gravity);
	                case CRunPlatform.EID_GetJumpStrength:
						return (this.PFMove.JumpStrength);
					case CRunPlatform.EID_GetJumpHoldHeight:
						return (this.PFMove.JumpHoldHeight);
					case CRunPlatform.EID_GetStepUp:
						return (this.PFMove.StepUp);
					case CRunPlatform.EID_GetSlopeCorrection:
						return (this.PFMove.SlopeCorrection);
					case CRunPlatform.EID_GetAddXVelocity:
						return (this.PFMove.AddXVelocity);
					case CRunPlatform.EID_GetAddYVelocity:
						return (this.PFMove.AddYVelocity);
				}
				return (0);//won't be used
			}
		});

	function CRunPlatformCOL()
	{
		this.Obstacle = false;
		this.JumpThrough = false;
		this.JumpThroughColTop = false;
		this.EnableJumpThrough = false;
	}
	function CRunPlatformMove()
	{
		this.XVelocity = 0;
		this.YVelocity = 0;
		this.MaxXVelocity = 0;
		this.MaxYVelocity = 0;
		this.AddXVelocity = 0;
		this.AddYVelocity = 0;
		this.XMoveCount = 0;
		this.YMoveCount = 0;
		this.XAccel = 0;
		this.XDecel = 0;
		this.Gravity = 0;
		this.JumpStrength = 0;
		this.JumpHoldHeight = 0;
		this.StepUp = 0;
		this.SlopeCorrection = 0;

		this.OnGround = false;
		this.RightKey = false;
		this.LeftKey = false;
		this.Paused = false;
	}



		

	//----------------------------------------------------------------------------------
	//
	// CRunKcArray: array object
	//
	//----------------------------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CRunKcArray.ARRAY_GLOBAL = 0x0008;
	CRunKcArray.ARRAY_TYPENUM = 0x0001;
	CRunKcArray.ARRAY_TYPETXT = 0x0002;
	CRunKcArray.INDEX_BASE1 = 0x0004;

	CRunKcArray.ACT_SETINDEXA = 0;
	CRunKcArray.ACT_SETINDEXB = 1;
	CRunKcArray.ACT_SETINDEXC = 2;
	CRunKcArray.ACT_ADDINDEXA = 3;
	CRunKcArray.ACT_ADDINDEXB = 4;
	CRunKcArray.ACT_ADDINDEXC = 5;
	CRunKcArray.ACT_WRITEVALUE = 6;
	CRunKcArray.ACT_WRITESTRING = 7;
	CRunKcArray.ACT_CLEARARRAY = 8;
	CRunKcArray.ACT_LOAD = 9;
	CRunKcArray.ACT_LOADSELECTOR = 10;
	CRunKcArray.ACT_SAVE = 11;
	CRunKcArray.ACT_SAVESELECTOR = 12;
	CRunKcArray.ACT_WRITEVALUE_X = 13;
	CRunKcArray.ACT_WRITEVALUE_XY = 14;
	CRunKcArray.ACT_WRITEVALUE_XYZ = 15;
	CRunKcArray.ACT_WRITESTRING_X = 16;
	CRunKcArray.ACT_WRITESTRING_XY = 17;
	CRunKcArray.ACT_WRITESTRING_XYZ = 18;

	CRunKcArray.CND_INDEXAEND = 0;
	CRunKcArray.CND_INDEXBEND = 1;
	CRunKcArray.CND_INDEXCEND = 2;

	CRunKcArray.EXP_INDEXA = 0;
	CRunKcArray.EXP_INDEXB = 1;
	CRunKcArray.EXP_INDEXC = 2;
	CRunKcArray.EXP_READVALUE = 3;
	CRunKcArray.EXP_READSTRING = 4;
	CRunKcArray.EXP_READVALUE_X = 5;
	CRunKcArray.EXP_READVALUE_XY = 6;
	CRunKcArray.EXP_READVALUE_XYZ = 7;
	CRunKcArray.EXP_READSTRING_X = 8;
	CRunKcArray.EXP_READSTRING_XY = 9;
	CRunKcArray.EXP_READSTRING_XYZ = 10;
	CRunKcArray.EXP_DIMX = 11;
	CRunKcArray.EXP_DIMY = 12;
	CRunKcArray.EXP_DIMZ = 13;

	function CRunKcArray()
	{
		this.pArray = null;
	}
	CRunKcArray.prototype = CServices.extend(new CRunExtension(),
		{
			getNumberOfConditions: function ()
			{
				return 3;
			},

			createRunObject: function (file, cob, version)
			{
				var rhPtr = this.ho.hoAdRunHeader;

				var lDimensionX = file.readAInt();
				var lDimensionY = file.readAInt();
				var lDimensionZ = file.readAInt();
				var lFlags = file.readAInt();

				var pData = null;
				if ((lFlags & CRunKcArray.ARRAY_GLOBAL) != 0)
				{
					var pExtData = rhPtr.getStorage(this.ho.hoIdentifier);
					if (pExtData == null) //first global object of this type
					{
						this.pArray = new CRunKcArrayData(lFlags, lDimensionX, lDimensionY, lDimensionZ);
						pData = new CRunKcArrayCGlobalDataList();
						pData.AddObject(this);
						rhPtr.addStorage(pData, this.ho.hoIdentifier);
					}
					else
					{
						pData = pExtData;
						var found = pData.FindObject(this.ho.hoOiList.oilName);
						if (found != null) //found array object of same name
						{
							this.pArray = found; //share data
						}
						else
						{
							this.pArray = new CRunKcArrayData(lFlags, lDimensionX, lDimensionY, lDimensionZ);
							pData.AddObject(this);
						}
					}
				}
				else
				{
					this.pArray = new CRunKcArrayData(lFlags, lDimensionX, lDimensionY, lDimensionZ);
				}
				return true;
			},

			// Conditions
			// --------------------------------------------------
			condition:       function (num, cnd)
			{
				switch (num)
				{
					case CRunKcArray.CND_INDEXAEND:
						return this.EndIndexA();
					case CRunKcArray.CND_INDEXBEND:
						return this.EndIndexB();
					case CRunKcArray.CND_INDEXCEND:
						return this.EndIndexC();
				}
				return false;
			},

			EndIndexA: function ()
			{
				if (this.pArray.lIndexA >= this.pArray.lDimensionX - 1)
				{
					return true;
				}
				return false;
			},

			EndIndexB: function ()
			{
				if (this.pArray.lIndexB >= this.pArray.lDimensionY - 1)
				{
					return true;
				}
				return false;
			},

			EndIndexC: function ()
			{
				if (this.pArray.lIndexC >= this.pArray.lDimensionZ - 1)
				{
					return true;
				}
				return false;
			},

			// Actions
			// -------------------------------------------------
			action:    function (num, act)
			{
				switch (num)
				{
					case CRunKcArray.ACT_SETINDEXA:
						this.SetIndexA(act.getParamExpression(this.rh, 0));
						break;
					case CRunKcArray.ACT_SETINDEXB:
						this.SetIndexB(act.getParamExpression(this.rh, 0));
						break;
					case CRunKcArray.ACT_SETINDEXC:
						this.SetIndexC(act.getParamExpression(this.rh, 0));
						break;
					case CRunKcArray.ACT_ADDINDEXA:
						this.IncIndexA();
						break;
					case CRunKcArray.ACT_ADDINDEXB:
						this.IncIndexB();
						break;
					case CRunKcArray.ACT_ADDINDEXC:
						this.IncIndexC();
						break;
					case CRunKcArray.ACT_WRITEVALUE:
						this.WriteValue(act.getParamExpression(this.rh, 0));
						break;
					case CRunKcArray.ACT_WRITESTRING:
						this.WriteString(act.getParamExpString(this.rh, 0));
						break;
					case CRunKcArray.ACT_CLEARARRAY:
						this.ClearArray();
						break;
					case CRunKcArray.ACT_LOAD:
						this.load(CServices.parseName(act.getParamFilename(this.rh, 0)));
						break;
					case CRunKcArray.ACT_LOADSELECTOR:
						break;
					case CRunKcArray.ACT_SAVE:
						this.save(CServices.parseName(act.getParamFilename(this.rh, 0)));
						break;
					case CRunKcArray.ACT_SAVESELECTOR:
						break;
					case CRunKcArray.ACT_WRITEVALUE_X:
						this.WriteValue_X(act.getParamExpression(this.rh, 0),
							act.getParamExpression(this.rh, 1));
						break;
					case CRunKcArray.ACT_WRITEVALUE_XY:
						this.WriteValue_XY(act.getParamExpression(this.rh, 0),
							act.getParamExpression(this.rh, 1),
							act.getParamExpression(this.rh, 2));
						break;
					case CRunKcArray.ACT_WRITEVALUE_XYZ:
						this.WriteValue_XYZ(act.getParamExpression(this.rh, 0),
							act.getParamExpression(this.rh, 1),
							act.getParamExpression(this.rh, 2),
							act.getParamExpression(this.rh, 3));
						break;
					case CRunKcArray.ACT_WRITESTRING_X:
						this.WriteString_X(act.getParamExpString(this.rh, 0),
							act.getParamExpression(this.rh, 1));
						break;
					case CRunKcArray.ACT_WRITESTRING_XY:
						this.WriteString_XY(act.getParamExpString(this.rh, 0),
							act.getParamExpression(this.rh, 1),
							act.getParamExpression(this.rh, 2));
						break;
					case CRunKcArray.ACT_WRITESTRING_XYZ:
						this.WriteString_XYZ(act.getParamExpString(this.rh, 0),
							act.getParamExpression(this.rh, 1),
							act.getParamExpression(this.rh, 2),
							act.getParamExpression(this.rh, 3));
						break;
				}
			},
			SetIndexA: function (i)
			{
				if ((this.pArray.lFlags & CRunKcArray.INDEX_BASE1) != 0)
				{
					this.pArray.lIndexA = i - 1;
				}
				else
				{
					this.pArray.lIndexA = i;
				}
			},

			SetIndexB: function (i)
			{
				if ((this.pArray.lFlags & CRunKcArray.INDEX_BASE1) != 0)
				{
					this.pArray.lIndexB = i - 1;
				}
				else
				{
					this.pArray.lIndexB = i;
				}
			},

			SetIndexC: function (i)
			{
				if ((this.pArray.lFlags & CRunKcArray.INDEX_BASE1) != 0)
				{
					this.pArray.lIndexC = i - 1;
				}
				else
				{
					this.pArray.lIndexC = i;
				}
			},

			IncIndexA: function ()
			{
				this.pArray.lIndexA++;
			},

			IncIndexB: function ()
			{
				this.pArray.lIndexB++;
			},

			IncIndexC: function ()
			{
				this.pArray.lIndexC++;
			},

			WriteValue: function (value)
			{
				this.WriteValueXYZ(value, this.pArray.lIndexA, this.pArray.lIndexB, this.pArray.lIndexC);
			},

			WriteString: function (value)
			{
				this.WriteStringXYZ(value, this.pArray.lIndexA, this.pArray.lIndexB, this.pArray.lIndexC);
			},

			ClearArray: function ()
			{
				this.pArray.clean(false);
			},

			WriteValue_X: function (value, x)
			{
				x -= this.pArray.oneBased();
				this.WriteValueXYZ(value, x, this.pArray.lIndexB, this.pArray.lIndexC);
			},

			WriteValue_XY: function (value, x, y)
			{
				x -= this.pArray.oneBased();
				y -= this.pArray.oneBased();
				this.WriteValueXYZ(value, x, y, this.pArray.lIndexC);
			},

			WriteValue_XYZ: function (value, x, y, z)
			{
				x -= this.pArray.oneBased();
				y -= this.pArray.oneBased();
				z -= this.pArray.oneBased();
				this.WriteValueXYZ(value, x, y, z);
			},

			WriteValueXYZ: function (value, x, y, z)
			{
				//x,y,z should be fixed for 1-based index if used before this function
				if ((x < 0) || (y < 0) || (z < 0))
				{
					return;
				}
				if ((this.pArray.lFlags & CRunKcArray.ARRAY_TYPENUM) != 0)
				{
					// Expand if required
					if ((x >= this.pArray.lDimensionX) || (y >= this.pArray.lDimensionY) || (z >= this.pArray.lDimensionZ))
					{
						var newDimX = Math.max(this.pArray.lDimensionX, x + 1);
						var newDimY = Math.max(this.pArray.lDimensionY, y + 1);
						var newDimZ = Math.max(this.pArray.lDimensionZ, z + 1);
						this.pArray.expand(newDimX, newDimY, newDimZ);
					}
					//write
					this.pArray.lIndexA = x;
					this.pArray.lIndexB = y;
					this.pArray.lIndexC = z;
					this.pArray.numberArray[z * this.pArray.lDimensionY * this.pArray.lDimensionX + y * this.pArray.lDimensionX + x] = value;
				}
			},

			WriteString_X: function (value, x)
			{
				x -= this.pArray.oneBased();
				this.WriteStringXYZ(value, x, this.pArray.lIndexB, this.pArray.lIndexC);
			},

			WriteString_XY: function (value, x, y)
			{
				x -= this.pArray.oneBased();
				y -= this.pArray.oneBased();
				this.WriteStringXYZ(value, x, y, this.pArray.lIndexC);
			},

			WriteString_XYZ: function (value, x, y, z)
			{
				x -= this.pArray.oneBased();
				y -= this.pArray.oneBased();
				z -= this.pArray.oneBased();
				this.WriteStringXYZ(value, x, y, z);
			},

			WriteStringXYZ: function (value, x, y, z)
			{
				//x,y,z should be fixed for 1-based index if used before this function
				if ((x < 0) || (y < 0) || (z < 0))
				{
					return;
				}
				if ((this.pArray.lFlags & CRunKcArray.ARRAY_TYPETXT) != 0)
				{
					// Expand if required
					if ((x >= this.pArray.lDimensionX) || (y >= this.pArray.lDimensionY) || (z >= this.pArray.lDimensionZ))
					{
						var newDimX = Math.max(this.pArray.lDimensionX, x + 1);
						var newDimY = Math.max(this.pArray.lDimensionY, y + 1);
						var newDimZ = Math.max(this.pArray.lDimensionZ, z + 1);
						this.pArray.expand(newDimX, newDimY, newDimZ);
					}
					//write
					this.pArray.lIndexA = x;
					this.pArray.lIndexB = y;
					this.pArray.lIndexC = z;
					this.pArray.stringArray[z * this.pArray.lDimensionY * this.pArray.lDimensionX + y * this.pArray.lDimensionX + x] = value;
				}
			},

			save:       function (name)
			{
				var dimX = this.pArray.lDimensionX;
				var dimY = this.pArray.lDimensionY;
				var dimZ = this.pArray.lDimensionZ;
				var flags = this.pArray.lFlags;
				var text = "";
				text += flags.toString() + CIni.separator;
				text += dimX.toString() + CIni.separator;
				text += dimY.toString() + CIni.separator;
				text += dimZ.toString() + CIni.separator;
				var z, y, x;
				if (flags & CRunKcArray.ARRAY_TYPENUM)
				{
					for (z = 0; z < dimZ; z++)
					{
						for (y = 0; y < dimY; y++)
						{
							for (x = 0; x < dimX; x++)
							{
								text += this.pArray.numberArray[z * dimY * dimX + y * dimX + x].toString() + CIni.separator;
							}
						}
					}
				}
				else if (CRunKcArray.ARRAY_TYPETXT)
				{
					for (z = 0; z < dimZ; z++)
					{
						for (y = 0; y < dimY; y++)
						{
							for (x = 0; x < dimX; x++)
							{
								text += this.pArray.stringArray[z * dimY * dimX + y * dimX + x] + CIni.separator;
							}
						}
					}
				}
				localStorage.setItem(name, text);
			},
			load:       function (name)
			{
				var text = localStorage.getItem(name);
				if (text)
				{
					var flags, begin = 0, end;
					var dimX, dimY, dimZ;

					end = text.indexOf(CIni.separator, 0);
					flags = parseInt(text.substring(begin, end));
					begin = end + CIni.separator.length;

					end = text.indexOf(CIni.separator, begin);
					dimX = parseInt(text.substring(begin, end));
					begin = end + CIni.separator.length;

					end = text.indexOf(CIni.separator, begin);
					dimY = parseInt(text.substring(begin, end));
					begin = end + CIni.separator.length;

					end = text.indexOf(CIni.separator, begin);
					dimZ = parseInt(text.substring(begin, end));
					begin = end + CIni.separator.length;

					var z, y, x, newArray;
					if (flags & CRunKcArray.ARRAY_TYPENUM)
					{
						newArray = new Array(dimZ * dimY * dimX);
						for (z = 0; z < dimZ; z++)
						{
							for (y = 0; y < dimY; y++)
							{
								for (x = 0; x < dimX; x++)
								{
									end = text.indexOf(CIni.separator, begin);
									newArray[z * dimY * dimX + y * dimX + x] = parseInt(text.substring(begin, end));
									begin = end + CIni.separator.length;
								}
							}
						}
						//if no try error thus far
						if (flags != this.pArray.lFlags || dimX != this.pArray.lDimensionX || dimY != this.pArray.lDimensionY || dimZ != this.pArray.lDimensionZ)
						{
							this.pArray.lFlags = flags;
							this.pArray.lDimensionX = dimX;
							this.pArray.lDimensionY = dimY;
							this.pArray.lDimensionZ = dimZ;
							this.pArray.lIndexA = 0;
							this.pArray.lIndexB = 0;
							this.pArray.lIndexC = 0;
						}
						this.pArray.numberArray = newArray;
					}
					else if (CRunKcArray.ARRAY_TYPETXT)
					{
						newArray = new Array(dimZ * dimY * dimX);
						for (z = 0; z < dimZ; z++)
						{
							for (y = 0; y < dimY; y++)
							{
								for (x = 0; x < dimX; x++)
								{
									end = text.indexOf(CIni.separator, begin);
									newArray[z * dimY * dimX + y * dimX + x] = text.substring(begin, end);
									begin = end + CIni.separator.length;
								}
							}
						}
						//if no try error thus far
						if (flags != this.pArray.lFlags || dimX != this.pArray.lDimensionX || dimY != this.pArray.lDimensionY || dimZ != this.pArray.lDimensionZ)
						{
							this.pArray.lFlags = flags;
							this.pArray.lDimensionX = dimX;
							this.pArray.lDimensionY = dimY;
							this.pArray.lDimensionZ = dimZ;
							this.pArray.lIndexA = 0;
							this.pArray.lIndexB = 0;
							this.pArray.lIndexC = 0;
						}
						this.pArray.stringArray = newArray;
					}
					return;
				}

				var file = null;
				var efile = this.rh.rhApp.getEmbeddedFile(name);
				if (efile != null)
				{
					file = efile.open();
				}
				/*
				 if (file==null)
				 {
				 file=new CFile();
				 file.openFile(name);
				 if (file.ccfBytes.length==0)
				 {
				 file=null;
				 }
				 }
				 */
				var x, y, z;
				if (file != null)
				{
					file.setUnicode(false);
					var headerHead = file.readAString(9);
					file.setUnicode(true);
					var newArray;
					if (headerHead == "CNC ARRAY" || headerHead == "MFU ARRAY")
					{
						file.skipBytes(1);
						var version = file.readAShort();
						var revision = file.readAShort();
						if (((version == 1) || (version == 2)) && (revision == 0))
						{
							var dimX = file.readAInt();
							var dimY = file.readAInt();
							var dimZ = file.readAInt();
							var flags = file.readAInt();
							//header read
							if ((dimX >= 0) && (dimY >= 0) && (dimZ >= 0))
							{
								if ((flags & CRunKcArray.ARRAY_TYPENUM) != 0)
								{
									newArray = new Array(dimZ * dimY * dimX);
									for (z = 0; z < dimZ; z++)
									{
										for (y = 0; y < dimY; y++)
										{
											for (x = 0; x < dimX; x++)
											{
												newArray[z * dimY * dimX + y * dimX + x] = file.readAInt();
											}
										}
									}
									//if no try error thus far
									if (flags != this.pArray.lFlags || dimX != this.pArray.lDimensionX || dimY != this.pArray.lDimensionY || dimZ != this.pArray.lDimensionZ)
									{
										this.pArray.lFlags = flags;
										this.pArray.lDimensionX = dimX;
										this.pArray.lDimensionY = dimY;
										this.pArray.lDimensionZ = dimZ;
										this.pArray.lIndexA = 0;
										this.pArray.lIndexB = 0;
										this.pArray.lIndexC = 0;
									}
									this.pArray.numberArray = newArray;
									//fin
								}
								else if ((flags & CRunKcArray.ARRAY_TYPETXT) != 0)
								{
									newArray = new Array(dimZ * dimY * dimX);
									for (z = 0; z < dimZ; z++)
									{
										for (y = 0; y < dimY; y++)
										{
											for (x = 0; x < dimX; x++)
											{
												var length = file.readAInt();
												if (length > 0)
												{
													newArray[z * dimY * dimX + y * dimX + x] = file.readAString(length);
												}
											}
										}
									}
									//if no try error thus far
									if (flags != this.pArray.lFlags || dimX != this.pArray.lDimensionX || dimY != this.pArray.lDimensionY || dimZ != this.pArray.lDimensionZ)
									{
										this.pArray.lFlags = flags;
										this.pArray.lDimensionX = dimX;
										this.pArray.lDimensionY = dimY;
										this.pArray.lDimensionZ = dimZ;
										this.pArray.lIndexA = 0;
										this.pArray.lIndexB = 0;
										this.pArray.lIndexC = 0;
									}
									this.pArray.stringArray = newArray;
									//fin
								}
							}
						}
					}
				}
			},

			// Expressions
			// --------------------------------------------
			expression: function (num)
			{
				switch (num)
				{
					case CRunKcArray.EXP_INDEXA:
						return this.IndexA();
					case CRunKcArray.EXP_INDEXB:
						return this.IndexB();
					case CRunKcArray.EXP_INDEXC:
						return this.IndexC();
					case CRunKcArray.EXP_READVALUE:
						return this.ReadValue();
					case CRunKcArray.EXP_READSTRING:
						return this.ReadString();
					case CRunKcArray.EXP_READVALUE_X:
						return this.ReadValue_X(this.ho.getExpParam());
					case CRunKcArray.EXP_READVALUE_XY:
						return this.ReadValue_XY(this.ho.getExpParam(),
							this.ho.getExpParam());
					case CRunKcArray.EXP_READVALUE_XYZ:
						return this.ReadValue_XYZ(this.ho.getExpParam(),
							this.ho.getExpParam(),
							this.ho.getExpParam());
					case CRunKcArray.EXP_READSTRING_X:
						return this.ReadString_X(this.ho.getExpParam());
					case CRunKcArray.EXP_READSTRING_XY:
						return this.ReadString_XY(this.ho.getExpParam(),
							this.ho.getExpParam());
					case CRunKcArray.EXP_READSTRING_XYZ:
						return this.ReadString_XYZ(this.ho.getExpParam(),
							this.ho.getExpParam(),
							this.ho.getExpParam());
					case CRunKcArray.EXP_DIMX:
						return this.Exp_DimX();
					case CRunKcArray.EXP_DIMY:
						return this.Exp_DimY();
					case CRunKcArray.EXP_DIMZ:
						return this.Exp_DimZ();
				}
				return (0);
			},

			IndexA: function ()
			{
				if ((this.pArray.lFlags & CRunKcArray.INDEX_BASE1) != 0)
				{
					return (this.pArray.lIndexA + 1);
				}
				else
				{
					return (this.pArray.lIndexA);
				}
			},

			IndexB: function ()
			{
				if ((this.pArray.lFlags & CRunKcArray.INDEX_BASE1) != 0)
				{
					return (this.pArray.lIndexB + 1);
				}
				else
				{
					return (this.pArray.lIndexB);
				}
			},

			IndexC: function ()
			{
				if ((this.pArray.lFlags & CRunKcArray.INDEX_BASE1) != 0)
				{
					return (this.pArray.lIndexC + 1);
				}
				else
				{
					return (this.pArray.lIndexC);
				}
			},

			ReadValue: function ()
			{
				return this.ReadValueXYZ(this.pArray.lIndexA,
					this.pArray.lIndexB,
					this.pArray.lIndexC);
			},

			ReadString: function ()
			{
				return this.ReadStringXYZ(this.pArray.lIndexA,
					this.pArray.lIndexB,
					this.pArray.lIndexC);
			},

			ReadValue_X: function (x)
			{
				return this.ReadValueXYZ(x - this.pArray.oneBased(),
					this.pArray.lIndexB,
					this.pArray.lIndexC);
			},

			ReadValue_XY: function (x, y)
			{
				return this.ReadValueXYZ(x - this.pArray.oneBased(),
					y - this.pArray.oneBased(),
					this.pArray.lIndexC);
			},

			ReadValue_XYZ: function (x, y, z)
			{
				return this.ReadValueXYZ(x - this.pArray.oneBased(),
					y - this.pArray.oneBased(),
					z - this.pArray.oneBased());
			},

			ReadValueXYZ: function (x, y, z)
			{
				//x y z should be fixed for 1-based, if so
				if ((x < 0) || (y < 0) || (z < 0))
				{
					return (0);
				}
				if ((this.pArray.lFlags & CRunKcArray.ARRAY_TYPENUM) != 0)
				{
					if ((x < this.pArray.lDimensionX) && (y < this.pArray.lDimensionY) && (z < this.pArray.lDimensionZ))
					{
						var position = z * this.pArray.lDimensionY * this.pArray.lDimensionX + y * this.pArray.lDimensionX + x;
						var value = this.pArray.numberArray[position];
						if (value != 0)
						{
							var toto = 0;
						}
						return (this.pArray.numberArray[z * this.pArray.lDimensionY * this.pArray.lDimensionX + y * this.pArray.lDimensionX + x]);
					}
				}
				return (0);
			},

			ReadString_X: function (x)
			{
				return this.ReadStringXYZ(x - this.pArray.oneBased(),
					this.pArray.lIndexB,
					this.pArray.lIndexC);
			},

			ReadString_XY: function (x, y)
			{
				return this.ReadStringXYZ(x - this.pArray.oneBased(),
					y - this.pArray.oneBased(),
					this.pArray.lIndexC);
			},

			ReadString_XYZ: function (x, y, z)
			{
				return this.ReadStringXYZ(x - this.pArray.oneBased(),
					y - this.pArray.oneBased(),
					z - this.pArray.oneBased());
			},

			ReadStringXYZ: function (x, y, z)
			{
				var ret = "";

				//x y z should be fixed for 1-based, if so
				if ((x >= 0) && (y >= 0) && (z >= 0))
				{
					if ((this.pArray.lFlags & CRunKcArray.ARRAY_TYPETXT) != 0)
					{
						if ((x < this.pArray.lDimensionX) && (y < this.pArray.lDimensionY) && (z < this.pArray.lDimensionZ))
						{
							var r = this.pArray.stringArray[z * this.pArray.lDimensionY * this.pArray.lDimensionX + y * this.pArray.lDimensionX + x];
							if (r != null)
							{
								ret = r;
							}
						}
					}
				}
				return ret;
			},

			Exp_DimX: function ()
			{
				return (this.pArray.lDimensionX);
			},

			Exp_DimY: function ()
			{
				return (this.pArray.lDimensionY);
			},

			Exp_DimZ: function ()
			{
				return (this.pArray.lDimensionZ);
			}
		});

	// Helper objects
	// ----------------------------------------------------------------
	function CRunKcArrayCGlobalDataList()
	{
		this.dataList = new CArrayList();
		this.names = new CArrayList();
	}
	CRunKcArrayCGlobalDataList.prototype =
	{
		FindObject: function (objectName)
		{
			var i;
			for (i = 0; i < this.names.size(); i++)
			{
				var s = this.names.get(i);
				if (s == objectName)
				{
					return this.dataList.get(i);
				}
			}
			return null;
		},
		AddObject:  function (o)
		{
			this.dataList.add(o.pArray);
			this.names.add(o.ho.hoOiList.oilName);
		}
	}

	function CRunKcArrayData(flags, dimX, dimY, dimZ)
	{
		this.lIndexA = 0;
		this.lIndexB = 0;
		this.lIndexC = 0;
		dimX = Math.max(1, dimX);
		dimY = Math.max(1, dimY);
		dimZ = Math.max(1, dimZ);

		this.lFlags = flags;
		this.lDimensionX = dimX;
		this.lDimensionY = dimY;
		this.lDimensionZ = dimZ;

	    //prepare arrays for first time
		this.clean(false);
	}
	CRunKcArrayData.prototype =
	{
		oneBased: function ()
		{
			if ((this.lFlags & 0x0004) != 0)     // INDEX_BASE1
			{
				return 1;
			}
			return 0;
		},
		expand: function (newX, newY, newZ) {
		    //inputs should always be equal or larger than current dimensions
		    var oldX = this.lDimensionX;
		    var oldY = this.lDimensionY;
		    var oldZ = this.lDimensionZ;
		    var oldTotal = oldX * oldY * oldZ;
		    var newTotal = newX * newY * newZ;
		    var x, y, z;

		    //get array pointers
		    var oldArray;
		    var nullValue;

		    if ((this.lFlags & 0x0001) != 0) {
		        //ARRAY_TYPENUM
		        oldArray = this.numberArray;
		        nullValue = 0;
		    } else {
		        //ARRAY_TYPETXT
		        oldArray = this.stringArray;
		        nullValue = null;
		    }

		    var newArray = new Array(newTotal).fill(nullValue);

		    //copy old data
		    for (z = 0; z < oldZ; z++) {
		        for (y = 0; y < oldY; y++) {
		            for (x = 0; x < oldX; x++) {
		                newArray[z * newY * newX + y * newX + x] = oldArray[z * oldY * oldX + y * oldX + x];
		            }
		        }
		    }

		    //update array pointers
		    if ((this.lFlags & 0x0001) != 0) {
		        //ARRAY_TYPENUM
		        this.numberArray = newArray;
		    } else {
		        //ARRAY_TYPETXT
		        this.stringArray = newArray;
		    }

		    //update dimensions
		    this.lDimensionX = newX;
		    this.lDimensionY = newY;
		    this.lDimensionZ = newZ;
		},
		clean: function (nullString) {
		    var total = this.lDimensionX * this.lDimensionY * this.lDimensionZ;

		    if ((this.lFlags & 0x0001) != 0) {
		        //ARRAY_TYPENUM
		        if (this.numberArray == null) {
		            this.numberArray = new Array(total);
		        }

		        for (index = 0; index < total; index++) {
		            this.numberArray[index] = 0;
		        }

		    } else if ((this.lFlags & 0x0002) != 0) {
		        //ARRAY_TYPETXT
		        if (this.stringArray == null) {
		            this.stringArray = new Array(total);
		        }

		        //check what format string should have
		        if (nullString) {
		            //null
		            for (index = 0; index < total; index++) {
		                this.stringArray[index] = null;
		            }
		        } else {
		            //empty string
		            for (index = 0; index < total; index++) {
		                this.stringArray[index] = "";
		            }
		        }
		    }
		}
	}
		
	/* Button object (James) */
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CRunKcButton.BTNTYPE_PUSHTEXT = 0;
	CRunKcButton.BTNTYPE_CHECKBOX = 1;
	CRunKcButton.BTNTYPE_RADIOBTN = 2;
	CRunKcButton.BTNTYPE_PUSHBITMAP = 3;
	CRunKcButton.BTNTYPE_PUSHTEXTBITMAP = 4;
	CRunKcButton.ALIGN_ONELINELEFT = 0;
	CRunKcButton.ALIGN_CENTER = 1;
	CRunKcButton.ALIGN_CENTERINVERSE = 2;
	CRunKcButton.ALIGN_ONELINERIGHT = 3;
	CRunKcButton.BTN_HIDEONSTART = 0x0001;
	CRunKcButton.BTN_DISABLEONSTART = 0x0002;
	CRunKcButton.BTN_TEXTONLEFT = 0x0004;
	CRunKcButton.BTN_TRANSP_BKD = 0x0008;
	CRunKcButton.BTN_SYSCOLOR = 0x0010;

	function CRunKcButton()
	{
		this.button =
		{
			clickedEvent: -1,
			background:   null,
			foreground:   null,
			flags:        0
		};
	};

	CRunKcButton.prototype = CServices.extend(new CRunControl(),
		{
			update: function (e)
			{
				if (e === undefined)
					e = this.element;

				switch (this.button.type)
				{
					case CRunKcButton.BTNTYPE_CHECKBOX:

						e = this.button.checkboxLabel;

					case CRunKcButton.BTNTYPE_PUSHTEXT:

						while (e.firstChild)
							e.removeChild(e.firstChild);

						e.appendChild(document.createTextNode(this.button.strings[0]));

						break;

					case CRunKcButton.BTNTYPE_RADIOBTN:

						var i = 0, that = this;

						this.eachElement(function ()
						{
							while (this.firstChild)
								this.removeChild(this.firstChild);

							this.appendChild(document.createTextNode(that.button.strings[i++]));

						}, e, 'label');

						break;

					case CRunKcButton.BTNTYPE_PUSHTEXTBITMAP:
					case CRunKcButton.BTNTYPE_PUSHBITMAP:

						var disabled = false;

						this.eachElement(function ()
						{
							if (this.disabled)
								disabled = true;

						}, e);

						var img = this.rh.rhApp.imageBank.getImageFromHandle
							(
								this.button.images
									[disabled ? 2 : (this.button.bitmapMouseDown ? 1 : 0)]
							);

						if (img == null)
							img = this.rh.rhApp.imageBank.getImageFromHandle(this.button.images[0]);

						while (e.firstChild)
							e.removeChild(e.firstChild);

						var img_el = img.createElement();
						img_el.style.display = 'inline-block';

						if (this.button.type == CRunKcButton.BTNTYPE_PUSHTEXTBITMAP)
						{
							e.appendChild(document.createTextNode(this.button.strings[0]));

							switch (this.button.alignImageText)
							{
								case CRunKcButton.ALIGN_ONELINELEFT:

									e.insertBefore(img_el, e.firstChild);
									break;

								case CRunKcButton.ALIGN_ONELINERIGHT:

									e.appendChild(img_el);
									break;

								case CRunKcButton.ALIGN_CENTER:

									e.insertBefore(document.createElement('br'), e.firstChild);
									e.insertBefore(img_el, e.firstChild);
									break;

								case CRunKcButton.ALIGN_CENTERINVERSE:

									e.appendChild(document.createElement('br'));
									e.appendChild(img_el);
									break;
							}
							;

							break;
						}
						else
						{
							e.appendChild(img_el);
						}

						break;
				}
				;
			},

			updateColor: function (e)
			{
				if (this.button.flags & CRunKcButton.BTN_SYSCOLOR)
					return;

				if (this.button.type == CRunKcButton.BTNTYPE_PUSHBITMAP)
					return;

				if (e === undefined)
					e = this.element;

				if (this.button.flags & CRunKcButton.BTN_TRANSP_BKD)
					e.style.backgroundColor = 'transparent';
				else
					e.style.backgroundColor = CServices.getColorString(this.button.background);

				var that = this;

				this.eachElement(function ()
				{
					this.style.color = CServices.getColorString(that.button.foreground);

				}, e, 'label');
			},

			eachElement: function (f, e, tag)
			{
				if (e === undefined)
					e = this.element;

				if (tag === undefined)
					tag = 'input';

				switch (this.button.type)
				{
					case CRunKcButton.BTNTYPE_PUSHTEXT:
					case CRunKcButton.BTNTYPE_PUSHBITMAP:
					case CRunKcButton.BTNTYPE_PUSHTEXTBITMAP:

						if (f.call(e) === false)
							return;

						break;

					case CRunKcButton.BTNTYPE_CHECKBOX:

						if (f.call(tag == 'label' ? this.button.checkboxLabel
							: this.button.checkbox) === false)
						{
							return;
						}

						break;

					case CRunKcButton.BTNTYPE_RADIOBTN:

						var nodeIndex = 0, node;

						for (; ;)
						{
							while ((node = e.childNodes[nodeIndex])
								.tagName.toLowerCase() != tag)
							{
								if ((++nodeIndex) >= e.childNodes.length)
									break;
							}

							if (f.call(node) === false)
								return;

							if ((++nodeIndex) >= e.childNodes.length)
								break;

						}

						break;
				}
				;
			},

			getNumberOfConditions: function ()
			{
				return 6;
			},

			createRunObject: function (file, cob, version)
			{
				this.ho.hoImgWidth = file.readAShort();
				this.ho.hoImgHeight = file.readAShort();

				var button = this.button;

				button.type = file.readAShort();
				button.radioCount = file.readAShort();
				button.flags = file.readAInt();

				var fontInfo = file.readLogFont();

				button.foreground = file.readAColor();
				button.background = file.readAColor();

				button.images = new Array(3);

				for (var i = 0; i < 3; ++i)
					button.images[i] = file.readAShort();

				if (button.type == CRunKcButton.BTNTYPE_PUSHBITMAP
					|| button.type == CRunKcButton.BTNTYPE_PUSHTEXTBITMAP)
				{
					this.ho.loadImageList(button.images);
				}

				if (button.type == CRunKcButton.BTNTYPE_PUSHBITMAP)
				{
					this.ho.hoImgWidth = 1;
					this.ho.hoImgHeight = 1;

					for (var i = 0; i < 3; ++i)
					{
						var image = this.ho.hoAdRunHeader.rhApp.imageBank
							.getImageFromHandle(button.images[i]);

						if (image)
						{
							this.ho.hoImgWidth = Math.max(this.ho.hoImgWidth, image.width);
							this.ho.hoImgHeight = Math.max(this.ho.hoImgHeight, image.height);
						}
					}
				}

				file.readAShort();
				/* fourth word in image array */
				file.readAInt();
				/* ebtnSecu */

				button.alignImageText = file.readAShort();

				if (button.type == CRunKcButton.BTNTYPE_RADIOBTN)
				{
					button.tooltip = '';

					var e = document.createElement('div'),
						group = 'mmf-radio-group-' + this.ho.hoHFII;

					button.strings = new Array(button.radioCount);

					for (var i = 0; i < button.radioCount; ++i)
					{
						button.strings[i] = file.readAString();

						var box = document.createElement('input'),
							label = document.createElement('label');

						box.setAttribute('name', group);

						box.type = 'radio';
						box.id = 'mmf-radio-' + this.ho.hoHFII + '-' + i;

						label.setAttribute('for', box.id);

						label.style.position = 'relative';
						label.style.top = '-2px';
						label.style.display = 'inline-block';
						label.style.height = ((1 / button.radioCount) * 100).toString() + "%";

						if (i > 0)
							e.appendChild(document.createElement('br'));

						e.appendChild(box);
						e.appendChild(label);
					}
				}
				else
				{
					button.strings = [file.readAString()];
					button.tooltip = file.readAString();

					switch (button.type)
					{
						case CRunKcButton.BTNTYPE_CHECKBOX:

							var e = document.createElement('div');

							button.checkbox = document.createElement('input');
							button.checkbox.type = 'checkbox';
							button.checkbox.id = 'mmf-checkbox-' + this.ho.hoHFII;

							button.checkboxLabel = document.createElement('label');
							button.checkboxLabel.setAttribute('for', button.checkbox.id);

							if (button.flags & CRunKcButton.BTN_TEXTONLEFT)
							{
								e.appendChild(button.checkboxLabel);
								e.appendChild(button.checkbox);
							}
							else
							{
								e.appendChild(button.checkbox);
								e.appendChild(button.checkboxLabel);
							}

							break;

						case CRunKcButton.BTNTYPE_PUSHBITMAP:

							var e = document.createElement('div');
							break;

						default:

							var e = document.createElement('button');
							break;
					}
					;
				}

				e.title = button.tooltip;

				if (button.flags & CRunKcButton.BTN_DISABLEONSTART)
				{
					this.eachElement(function ()
					{
						this.disabled = true;
					}, e);
				}

				this.update(e);
				this.updateColor(e);

				this.setFont(fontInfo, e);
				this.setElement(e, (button.flags & CRunKcButton.BTN_HIDEONSTART) == 0);

				var that = this;

				if (button.type == CRunKcButton.BTNTYPE_PUSHBITMAP
					|| button.type == CRunKcButton.BTNTYPE_PUSHTEXTBITMAP)
				{
					e.onmousedown = function ()
					{
					    that.rh.rhApp.forceMouseButton(true);
						that.button.bitmapMouseDown = true;
						that.update();
					};

					e.onmouseup = function ()
					{
						that.rh.rhApp.forceMouseButton(false);
						that.button.bitmapMouseDown = false;
						that.update();

						that.button.clickedEvent = that.ho.getEventCount();
						that.ho.generateEvent(1, 0);
					};
				}
				else
				{
					e.onclick = function ()
					{
					    // Enable sounds in Chrome
					    that.rh.rhApp.enableSoundsInChrome();
					    that.button.clickedEvent = that.ho.getEventCount();
						that.ho.generateEvent(1, 0);
					};
					e.onmousedown = function ()
					{
					    that.rh.rhApp.forceMouseButton(true);
					};
					e.onmouseup = function ()
					{
						that.rh.rhApp.forceMouseButton(false);
					};
				}
			},

			condition: function (num, cnd)
			{
				switch (num)
				{
					case 0: /* Box checked? */
						return this.button.type == CRunKcButton.BTNTYPE_CHECKBOX
							&& this.button.checkbox.checked;

					case 1: /* On click */
						return (this.ho.hoFlags & CObject.HOF_TRUEEVENT) != 0 ||
							(this.ho.getEventCount() ==
								this.button.clickedEvent);

					case 2: /* Box not checked? */
						return this.button.type == CRunKcButton.BTNTYPE_CHECKBOX
							&& !this.button.checkbox.checked;

					case 3: /* Visible? */
						return this.button.visible;

					case 4: /* Enabled? */
						return this.button.enabled;

					case 5: /* Radio enabled? */

						if (this.button.type != CRunKcButton.BTNTYPE_RADIOBTN)
							return false;

						if (index < 0 || index >= this.button.strings.length)
							return false;

						var index = cnd.getParamExpression(this.rh, 0), i = 0, node;

						this.eachElement(function ()
						{
							if (i == index)
							{
								node = this;
								return false;
							}

							++i;
						});

						return !node.disabled;
				}
				;
			},

			action: function (num, act)
			{
				switch (num)
				{
					case 0: /* Change text */

						this.button.strings[0] = act.getParamExpString(this.rh, 0);
						this.update();

						break;

					case 1: /* Show */
						this.ho.bShown = true;
						this.element.style.visibility = 'visible';
						break;

					case 2: /* Hide */
						this.ho.bShown = false;
						this.element.style.visibility = 'hidden';
						break;

					case 3: /* Enable */

						this.eachElement(function ()
						{
							this.disabled = false;
						});

						if (this.button.type == CRunKcButton.BTNTYPE_PUSHBITMAP
							|| this.button.type == CRunKcButton.BTNTYPE_PUSHTEXTBITMAP)
						{
							this.update();
							/* change image */
						}

						break;

					case 4: /* Disable */

						this.eachElement(function ()
						{
							this.disabled = true;
						});

						if (this.button.type == CRunKcButton.BTNTYPE_PUSHBITMAP
							|| this.button.type == CRunKcButton.BTNTYPE_PUSHTEXTBITMAP)
						{
							this.update();
						}

						break;

					case 5: /* Set position */

						var position = act.getParamPosition(this.rh, 0);
						if (position.found)
							this.setPosition(position.x, position.y);
						break;

					case 6: /* Set width */

						this.setWidth(act.getParamExpression(this.rh, 0));
						break;

					case 7: /* Set height */

						this.setHeight(act.getParamExpression(this.rh, 0));
						break;

					case 8: /* Change radio text */

						if (this.button.type != CRunKcButton.BTNTYPE_RADIOBTN)
							return;

						var index = act.getParamExpression(this.rh, 0),
							newText = act.getParamExpString(this.rh, 1);

						if (index < 0 && index >= this.button.strings.length)
							return;

						this.button.strings[index] = newText;
						this.update();

						break;

					case 9: /* Enable radio button */
					case 10: /* Disable radio button */

						if (this.button.type != CRunKcButton.BTNTYPE_RADIOBTN)
							return;

						var index = act.getParamExpression(this.rh, 0);

						if (index < 0 && index >= this.button.strings.length)
							return;

						this.eachElement(function ()
						{
							if (i == index)
							{
								this.disabled = (num == 10);
								return false;
							}

							++i;
						});

						break;

					case 11: /* Select radio button */

						if (this.button.type != CRunKcButton.BTNTYPE_RADIOBTN)
							return;

						var index = act.getParamExpression(this.rh, 0);

						//if (index < 0 && index >= this.button.strings.length)
						//	return;

						var i = 0;

						this.eachElement(function ()
						{
							if (i == index)
							{
								this.checked = true;
								return false;
							}
							if(index < 0)
								this.checked = false;
							++i;
						});

						break;

					case 12: /* Set X position */

						this.setX(act.getParamExpression(this.rh, 0));
						break;

					case 13: /* Set Y position */

						this.setY(act.getParamExpression(this.rh, 0));
						break;

					case 14: /* Check */

						if (this.button.type == CRunKcButton.BTNTYPE_CHECKBOX)
							this.button.checkbox.checked = true;

						break;

					case 15: /* Uncheck */

						this.eachElement(function ()
						{
							this.checked = false;
						});

						break;

					case 16: /* Set menu command ID */
						break;

					case 17: /* Set tooltip */

						this.button.tooltip = act.getParamExpString(this.rh, 0);

						if (this.element)
							this.element.title = this.button.tooltip;

						break;
				}
				;
			},

			expression: function (num)
			{
				switch (num)
				{
					case 0: /* Get width */
						return this.ho.hoImgWidth;

					case 1: /* Get height */
						return this.ho.hoImgHeight;

					case 2: /* Get X */
						return this.ho.hoX;

					case 3: /* Get Y */
						return this.ho.hoY;

					case 4: /* Get selected radio index */

						if (this.button.type != CRunKcButton.BTNTYPE_RADIOBTN)
							return 0;

						var index = 0, found = false;

						this.eachElement(function ()
						{
							if (this.checked)
							{
								found = true;
								return false;
							}

							++index;
						});

						return found ? index : -1;

					case 5: /* Get text */

						var index = this.ho.getExpParam();

						if (index < 0 || index >= this.button.strings.length)
							return '';

						return this.button.strings[index];

					case 6: /* Get tooltip */
						return this.button.tooltip;
				}
				;
			},

			getRunObjectTextColor: function ()
			{
				return this.button.foreground;
			},

			setRunObjectTextColor: function (rgb)
			{
				this.button.foreground = rgb;
				this.updateColor();
			},

			setFont: function (font, e)
			{
				if (e === undefined)
					e = this.element;

				CRunControl.prototype.setFont.call(this, font);

				this.eachElement(function ()
				{
					this.style.font = e.style.font;

				}, e, 'label');
			}
		});


	/* Edit object (James) */
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CRunkcedit.EDIT_HSCROLLBAR = 0x0001;
	CRunkcedit.EDIT_HSCROLLAUTOSCROLL = 0x0002;
	CRunkcedit.EDIT_VSCROLLBAR = 0x0004;
	CRunkcedit.EDIT_VSCROLLAUTOSCROLL = 0x0008;
	CRunkcedit.EDIT_READONLY = 0x0010;
	CRunkcedit.EDIT_MULTILINE = 0x0020;
	CRunkcedit.EDIT_PASSWORD = 0x0040;
	CRunkcedit.EDIT_BORDER = 0x0080;
	CRunkcedit.EDIT_HIDEONSTART = 0x0100;
	CRunkcedit.EDIT_UPPERCASE = 0x0200;
	CRunkcedit.EDIT_LOWERCASE = 0x0400;
	CRunkcedit.EDIT_TABSTOP = 0x0800;
	CRunkcedit.EDIT_SYSCOLOR = 0x1000;
	CRunkcedit.EDIT_3DLOOK = 0x2000;
	CRunkcedit.EDIT_TRANSP = 0x4000;
	CRunkcedit.EDIT_ALIGN_HCENTER = 0x00010000;
	CRunkcedit.EDIT_ALIGN_RIGHT = 0x00020000;

	this.kcedit = CRunkcedit;

	function CRunkcedit()
	{
		this.edit =
		{
			doubleClickEvent: -1,
			changedEvent:     false,
			background:       null,
			foreground:       null,
			flags:            0,
			caretPosition:	  0
		};
	};

	CRunkcedit.prototype = CServices.extend(new CRunControl(),
		{
			updateColor: function (e)
			{
				if (e === undefined)
					e = this.element;

				if (this.edit.flags & CRunkcedit.EDIT_SYSCOLOR)
					return;

				if (this.edit.flags & CRunkcedit.EDIT_TRANSP)
					e.style.backgroundColor = 'transparent';
				else
					e.style.backgroundColor = CServices.getColorString(this.edit.background);

				e.style.color = CServices.getColorString(this.edit.foreground);
			},

			getNumberOfConditions: function ()
			{
				return 7;
			},

			createRunObject: function (file, cob, version)
			{
				this.ho.hoImgWidth = file.readAShort();
				this.ho.hoImgHeight = file.readAShort();

				var edit = this.edit;

				var fontInfo = this.ho.hoAdRunHeader.rhApp.bUnicode ?
					file.readLogFont() : file.readLogFont16();

				file.skipBytes(4 * 16);

				edit.foreground = file.readAColor();
				edit.background = file.readAColor();

				file.skipBytes(40 * 2);
				/* text style */

				edit.flags = file.readAInt();
				edit.caretPosition = 0;
				
				if (edit.flags & CRunkcedit.EDIT_MULTILINE)
				{
					var e = document.createElement('textarea');
				}
				else
				{
					var e = document.createElement('input');
					if (!(edit.flags & CRunkcedit.EDIT_PASSWORD))
						e.type = 'text';
					else
						e.type = 'password';
				}
				if (edit.flags & CRunkcedit.EDIT_ALIGN_HCENTER)
					e.style.textAlign = "center";
				if (edit.flags & CRunkcedit.EDIT_ALIGN_RIGHT)
					e.style.textAlign = "right";

				if (edit.flags & CRunkcedit.EDIT_READONLY)
					e.readOnly = true;

				this.updateColor(e);

				if (edit.flags & CRunkcedit.EDIT_3DLOOK)
				{
					e.style.borderStyle = 'inset';
					e.style.borderWidth = '2px';
				this.ho.hoImgWidth -= 4;
				this.ho.hoImgHeight -= 4;
				}
				else
				{
					e.style.borderStyle = 'solid';

					if (edit.flags & CRunkcedit.EDIT_BORDER)
					{
						e.style.borderWidth = '1px';
						e.style.borderColor = '#000000';
						this.ho.hoImgWidth -= 2;
						this.ho.hoImgHeight -= 2;
					}
					else
					{
						e.style.borderWidth = '0px';
					}
				}
				if (edit.flags & CRunkcedit.EDIT_UPPERCASE)
				    e.style.textTransform = "uppercase";
				if (edit.flags & CRunkcedit.EDIT_LOWERCASE)
				    e.style.textTransform = "lowercase";

				this.setFont(fontInfo);
				if (fontInfo.lfUnderline)
					e.style.textDecoration = "underline";
				if (fontInfo.lfStrikeOut)
					e.style.textDecoration = "line-through";

				this.setElement(e, (edit.flags & CRunkcedit.EDIT_HIDEONSTART) == 0);
				this.oldText = "";

				var that = this;

				e.ondblclick = function ()
				{
					that.edit.caretPosition = that.element.selectionStart;
					that.edit.doubleClickEvent = that.ho.getEventCount();
					that.ho.generateEvent(2, 0);
				};

				e.onchange = function ()
				{
					that.edit.caretPosition = that.element.selectionStart;
				};

				e.onclick = function ()
				{
					that.edit.caretPosition = that.element.selectionStart;
				};

				e.onkeyup = function ()
				{
					that.edit.caretPosition = that.element.selectionStart;
				};

			},
			handleRunObject: function()
			{
				if (this.element.value != this.oldText)
				{
					this.edit.changedEvent = true;
					this.oldText = this.element.value;
				}
				CRunControl.prototype.handleRunObject.call(this);
			},
			condition: function (num, cnd)
			{
				switch (num)
				{
					case 0: /* Is visible? */
						return this.element.style.visibility != 'hidden';

					case 1: /* Is enabled? */
						return !this.element.disabled;

					case 2: /* Can undo? */
						return false;

					case 3: /* Just been modified? */
						return this.edit.changedEvent;

					case 4: /* Has focus */
						return document.activeElement == this.element;

					case 5: /* Is number? */
						return !isNaN(parseInt(this.element.value, 10));

					case 6: /* Is selected? */
						return (this.element.selectionEnd
							- this.element.selectionStart) > 0;
				}
				;
			},

			action: function (num, act)
			{
				switch (num)
				{
					case 0: /* Load text */

						var filename = CServices.parseName(act.getParamFilename(this.rh, 0));
						this.element.value = '';
						var text = localStorage.getItem(filename);
						if (text)
						{
							this.element.value = text;
							break;
						}
						try
						{
						    var file, efile = this.rh.rhApp.getEmbeddedFile(filename);
						    if (efile)
						        file = efile.open();
						    if (!file) {
						        file = new CFile();
						        file.openFile(filename);
						    }
						    if (!file)
						        break;
						    file.detectUnicode();
							this.element.value = file.readAString(file.getLength());
						}
						catch (e)
						{
							if (document.debug)
								throw e;
						}
						break;

					case 1: /* Load text with selector */
						break;

					case 2: /* Save text */
						var name = CServices.parseName(act.getParamFilename(this.rh, 0));
						localStorage.setItem(name, this.element.value);
						break;

					case 3: /* Save text with selector */
						break;

					case 4: /* Set text */

						this.element.value = act.getParamExpString(this.rh, 0);
						break;

					case 5: /* Replace selection */

						this.element.value =
							[
								this.element.value.substring(0, this.element.selectionStart),
								act.getParamExpString(this.rh, 0),
								this.element.value.substring(this.element.selectionEnd)

							].join('');

						break;

					case 6: /* Cut */
						break;

					case 7: /* Copy */
						break;

					case 8: /* Paste */
						break;

					case 9: /* Clear */

						this.element.value = '';
						break;

					case 10: /* Undo */
						break;

					case 11: /* Clear undo buffer */
						break;

					case 12: /* Show */
						this.ho.bShown = true;
						this.element.style.visibility = 'visible';
						break;

					case 13: /* Hide */
						this.ho.bShown = false;
						this.element.style.visibility = 'hidden';
						break;

					case 14: /* Set font from selector */
						break;

					case 15: /* Set color from selector */
						break;

					case 16: /* Activate */

						this.element.focus();
						break;

					case 17: /* Enable */

						this.element.disabled = false;
						break;

					case 18: /* Disable */

						this.element.disabled = true;
						break;

					case 19: /* Read-only on */

						this.element.readOnly = true;
						break;

					case 20: /* Read-only off */

						this.element.readOnly = false;
						break;

					case 21: /* Text modified */
						this.edit.changedEvent = true;
						break;

					case 22: /* Text not modified */
						this.edit.changedEvent = false;
						break;

					case 23: /* Limit text length */

						this.element.setAttribute
							('maxlength', act.getParamExpression(this.rh, 0));

						break;

					case 24: /* Set position */

						var position = act.getParamPosition(this.rh, 0);
						if (position.found)
							this.setPosition(position.x, position.y);

						break;

					case 25: /* Set X position */

						this.setX(act.getParamExpression(this.rh, 0));
						break;

					case 26: /* Set Y position */

						this.setY(act.getParamExpression(this.rh, 0));
						break;

					case 27: /* Set size */

						this.setSize(act.getParamExpression(this.rh, 0),
							act.getParamExpression(this.rh, 1));

						break;

					case 28: /* Set width */

						this.setWidth(act.getParamExpression(this.rh, 0));
						break;

					case 29: /* Set height */

						this.setHeight(act.getParamExpression(this.rh, 0));
						break;

					case 30: /* Deactivate */

						this.element.blur();
						break;

					case 31: /* Scroll to top */

						this.element.scrollTop = 0;
						break;

					case 32: /* Scroll to line */
						break;

					case 33: /* Scroll to end */

						this.element.scrollTop = 99999;
						break;

					case 34: /* Set color */

						this.edit.foreground = act.getParamColour(this.rh, 0);
						this.updateColor();

						break;

					case 35: /* Set background color */

						this.edit.background = act.getParamColour(this.rh, 0);
						this.updateColor();

						break;

					case 36: /* insert Text at caret position */

						var textAdd = act.getParamExpString(this.rh, 0);
						var pos = act.getParamExpression(this.rh, 1);
						this.element.value =
							[
								this.element.value.substring(0, pos),
								textAdd,
								this.element.value.substring(pos, this.element.value.length)
							].join('');
						break;
					case 37: /* Set caret position		*/
						var posx = act.getParamExpression(this.rh, 0);
						this.element.setSelectionRange(posx, posx);
						this.element.onchange();
						break;
				}
				;
			},

			expression: function (num)
			{
				switch (num)
				{
					case 0: /* Get text */
						if (this.edit.flags & CRunkcedit.EDIT_UPPERCASE)
							return this.element.value.toUpperCase();
						else if (this.edit.flags & CRunkcedit.EDIT_LOWERCASE)
							return this.element.value.toLowerCase();
						return this.element.value;

					case 1: /* Get selection text */
						return this.element.value.substring
							(this.element.selectionStart, this.element.selectionEnd);

					case 2: /* Get X */
						return this.ho.hoX;

					case 3: /* Get Y */
						return this.ho.hoY;

					case 4: /* Get width */
						return this.ho.hoImgWidth;

					case 5: /* Get height */
						return this.ho.hoImgHeight;

					case 6: /* Get value */

						var v = parseInt(this.element.value, 10);

						return isNaN(v) ? 0 : v;

					case 7: /* Get first line */

						var i = Math.min(this.element.value.indexOf('\r'),
							this.element.value.indexOf('\n'));

						return i == -1 ? '' : this.element.substring(0, i);

					case 8: /* Get line count */
						return this.element.value.split('\n').length;

					case 9: /* Get color */
						return this.edit.foreground;

					case 10: /* Get background color */
						return this.edit.background;
						
					case 11: /* Get Caret Position */
						return this.edit.caretPosition;
				}
				;
			},

			getRunObjectTextColor: function ()
			{
				return this.edit.foreground;
			},

			setRunObjectTextColor: function (rgb)
			{
				this.edit.foreground = rgb;
				this.updateColor();
			}
		});


	/* Combo object (James) */
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CRunkccombo.COMBO_SIMPLE = 0x0001;
	CRunkccombo.COMBO_DROPDOWN = 0x0002;
	CRunkccombo.COMBO_DROPDOWNLIST = 0x0004;
	CRunkccombo.COMBO_SCROLLBAR = 0x0008;
	CRunkccombo.COMBO_SORT = 0x0010;
	CRunkccombo.COMBO_HIDEONSTART = 0x0020;
	CRunkccombo.COMBO_SYSCOLOR = 0x0040;
	CRunkccombo.COMBO_SCROLLTONEWLINE = 0x0080;
	CRunkccombo.COMBO_ONEBASE = 0x0100;
	CRunkccombo.COMBO_JUSTCREATED = 0x8000;

	this.kccombo = CRunkccombo;

	function CRunkccombo()
	{
		this.combo =
		{
			doubleClickEvent:      -1,
			selectionChangedEvent: -1,
			oneBased:              true,
			background:            null,
			foreground:            null,
			flags:                 0
		};
	};

	CRunkccombo.prototype = CServices.extend(new CRunControl(),
		{
			getIndex: function (act, index, verify)
			{

				if (verify && (index < 0 || index >= this.element.options.length))
					throw new Error("Bad index: " + index);

				var varIndex = (act ? act.getParamExpression(this.rh, index)
					: this.ho.getExpParam()) -
					(this.combo.oneBased ? 1 : 0);

				return varIndex;
			},

			fixIndex: function (index)
			{
				return index + (this.combo.oneBased ? 1 : 0);
			},

			updateColor: function (e)
			{
				if (e === undefined)
					e = this.element;

				if (this.combo.flags & CRunkccombo.COMBO_SYSCOLOR)
					return;

				e.style.backgroundColor = CServices.getColorString(this.combo.background);
				e.style.color = CServices.getColorString(this.combo.foreground);
			},

			sort: function (e)
			{
				Array.prototype.sort.call(e.options, function (a, b)
				{
				    return (a.value == b.value) ? 0 : (a.value > b.value) ? 1 : -1;
				});
			},

			getNumberOfConditions: function ()
			{
				return 6;
			},

			createRunObject: function (file, cob, version)
			{
				this.controlIgnoreHeight = true;

				this.ho.hoImgWidth = file.readAShort();
				this.ho.hoImgHeight = file.readAShort();

				var combo = this.combo;

				var fontInfo = this.ho.hoAdRunHeader.rhApp.bUnicode ?
					file.readLogFont() : file.readLogFont16();

				combo.foreground = file.readAColor();

				file.skipBytes(40 * 2);
				/* text style */

				combo.flags = file.readAInt();

				var lineCount = file.readShort();

				combo.background = file.readAColor();

				file.skipBytes(12);

				var e = document.createElement('select');

				combo.oneBased = (combo.flags & CRunkccombo.COMBO_ONEBASE) != 0;

				while ((lineCount--) > 0)
					e.add(new Option(file.readAString()));

				if (combo.flags & CRunkccombo.COMBO_SORT)
					this.sort(e);

				this.updateColor(e);

				this.setFont(fontInfo);
				this.setElement(e, (combo.flags & CRunkccombo.COMBO_HIDEONSTART) == 0);

				var that = this;

				e.ondblclick = function ()
				{
					that.combo.doubleClickEvent = that.ho.getEventCount();
					that.ho.generateEvent(2, 0);
				};

				e.onchange = function ()
				{
					that.combo.selectionChangedEvent = that.ho.getEventCount();
					that.ho.generateEvent(3, 0);
				};
			},

			condition: function (num, cnd)
			{
				switch (num)
				{
					case 0: /* Is visible? */
						return this.element.style.visibility != 'hidden';

					case 1: /* Is enabled? */
						return !this.element.disabled;

					case 2: /* Double clicked */

						return (this.ho.hoFlags & CObject.HOF_TRUEEVENT) != 0 ||
							(this.ho.getEventCount() ==
								this.combo.doubleClickEvent);

					case 3: /* Selection changed */

						return (this.ho.hoFlags & CObject.HOF_TRUEEVENT) != 0 ||
							(this.ho.getEventCount() ==
								this.combo.selectionChangedEvent);

					case 4: /* Has focus */
						return document.activeElement == this.element;

					case 5: /* Is dropped? */
						return false;

				}
				;
			},

			action: function (num, act)
			{
				try
				{
					switch (num)
					{
						case 0: /* Load list */

							var filename = CServices.parseName(act.getParamFilename(this.rh, 0));
							this.element.options.length = 0;
							var text = localStorage.getItem(filename);
							var end, begin = 0;
							if (text)
							{
								while (begin < text.length)
								{
									end = text.indexOf(CIni.separator, begin);
									this.element.add(new Option(text.substring(begin, end)));
									begin = end + CIni.separator.length;
								}
								break;
							}


							try
							{
								var file, efile = this.rh.rhApp.getEmbeddedFile(filename);

								if (efile)
									file = efile.open();

								if (!file)
								{
									file = new CFile();
									file.openFile(filename);
								}

								if (!file)
									break;

								file.detectUnicode();

								var i = 0;
								while (!file.isEOF())
								    this.element.add(new Option(file.readAStringEOL()));
							}
							catch (e)
							{
								if (document.debug)
									throw e;

								this.element.options.length = 0;
							}
							break;

						case 1: /* Load drives list */
							break;

						case 2: /* Load directory list */
							break;

						case 3: /* Load files list */
							break;

						case 4: /* Save list */
							var name = CServices.parseName(act.getParamFilename(this.rh, 0));
							var length = this.element.options.length;
							var text = "";
							for (n = 0; n < length; n++)
								text += this.element.options[n].text + CIni.separator;
							localStorage.setItem(name, text);
							break;

						case 5: /* Reset */

							this.element.options.length = 0;
							break;

						case 6: /* Add line */

							this.element.add(new Option(act.getParamExpString(this.rh, 0)));

							if (this.combo.flags & CRunkccombo.COMBO_SORT)
								this.sort(this.element);

							break;

						case 7: /* Insert line */

						    var position = this.getIndex(act, 0, false);
							var line = act.getParamExpString(this.rh, 1);

							if (position < 0 || position >= this.element.size)
							    this.element.add(new Option(line));
							else
							    this.element.add(new Option(line), position);

							if (this.combo.flags & CRunkccombo.COMBO_SORT)
								this.sort(this.element);

							break;

						case 8: /* Delete line */

							this.element.remove(this.getIndex(act, 0, true));
							break;

						case 9: /* Set current line */

							this.element.selectedIndex = this.getIndex(act, 0, false);
							break;

						case 10: /* Show */
							this.ho.bShown = true;
							this.element.style.visibility = 'visible';
							break;

						case 11: /* Hide */
							this.ho.bShown = false;
							this.element.style.visibility = 'hidden';
							break;

						case 12: /* Activate */

							this.element.focus();
							break;

						case 13: /* Enable */

							this.element.disabled = false;
							break;

						case 14: /* Disable */

							this.element.disabled = true;
							break;

						case 15: /* Set position */

							var position = act.getParamPosition(this.rh, 0);
							if (position.found)
								this.setPosition(position.x, position.y);

							break;

						case 16: /* Set X position */

							this.setX(act.getParamExpression(this.rh, 0));
							break;

						case 17: /* Set Y position */

							this.setY(act.getParamExpression(this.rh, 0));
							break;

						case 18: /* Set size */

							this.setSize(act.getParamExpression(this.rh, 0),
								act.getParamExpression(this.rh, 1));

							break;

						case 19: /* Set width */

							this.setWidth(act.getParamExpression(this.rh, 0));
							break;

						case 20: /* Set height */

							this.setHeight(act.getParamExpression(this.rh, 0));
							break;

						case 21: /* Deactivate */

							this.element.blur();
							break;

						case 22: /* Set text */

							break;

						case 23: /* Scroll to top */

							this.element.selectedIndex = 0;
							break;

						case 24: /* Scroll to line */

							this.element.selectedIndex = this.getIndex(act, 0, true);
							break;

						case 25: /* Scroll to end */

							this.element.selectedIndex = this.element.options.length - 1;
							break;

						case 26: /* Set color */

							this.combo.foreground = act.getParamColour(this.rh, 0);
							this.updateColor();

							break;

						case 27: /* Set background color */

							this.combo.background = act.getParamColour(this.rh, 0);
							this.updateColor();

							break;

						case 28: /* Load font list */

							break;

						case 29: /* Load font size list */

							break;

						case 30: /* Set line data */

							var index = this.getIndex(act, 0, true),
								data = act.getParamExpString(this.rh, 1);

							this.element.options[index].setAttribute('data-mmf', data);

							break;

						case 31: /* Change line */

							var index = this.getIndex(act, 0, true),
								text = act.getParamExpString(this.rh, 1);

							this.element.options[index].text = text;

							break;
					}
					;
				}
				catch (e)
				{
					/* Probably a bad index */

					// console.log('kccombo: ' + e);
				}
			},

			expression: function (num)
			{
				switch (num)
				{
					case 0: /* Get selection index */
						return this.fixIndex(this.element.selectedIndex);

					case 1: /* Get selection text */
						if (this.element.options[this.element.selectedIndex])
							return this.element.options[this.element.selectedIndex].text;
						return "";

					case 2: /* Get selection directory */
						return '';

					case 3: /* Get selection drive */
						return '';

					case 4: /* Get line text */

						try
						{
							return this.element.options[this.getIndex(null, 0, true)].text;
						}
						catch (e)
						{
							return '';
						}

					case 5: /* Get line directory */

						this.ho.getExpParam();
						return '';

					case 6: /* Get line drive */

						this.ho.getExpParam();
						return '';

					case 7: /* Get number of lines */
						return this.element.options.length;

					case 8: /* Get X */
						return this.ho.hoX;

					case 9: /* Get Y */
						return this.ho.hoY;

					case 10: /* Get width */
						return this.ho.hoImgWidth;

					case 11: /* Get height */
						return this.ho.hoImgHeight;

					case 12: /* Get edit text */
						if (this.element.options[this.element.selectedIndex])
							return this.element.options[this.element.selectedIndex].text;
						return "";

					case 13: /* Get color */
						return this.combo.foreground;

					case 14: /* Get background color */
						return this.combo.background;

					case 15: /* Find string */

						var string = this.ho.getExpParam(),
							startIndex = this.getIndex(null, 0, false);

						if (startIndex >= this.element.options.length)
							return -1;

						if (startIndex < 0)
							startIndex = 0;

						for (var i = startIndex; i < this.element.options.length; ++i)
							if (this.element.options[i].text.indexOf(string) !== -1)
								return this.fixIndex(i);

						return -1;

					case 16: /* Find string exact */

						var string = this.ho.getExpParam(),
							startIndex = this.getIndex(null, 0, false);

						if (startIndex >= this.element.options.length)
							return -1;

						if (startIndex < 0)
							startIndex = 0;

						for (var i = startIndex; i < this.element.options.length; ++i)
							if (this.element.options[i].text.toLowerCase() == string)
								return this.fixIndex(i);

						return -1;

					case 17: /* Get last index */
						return this.element.options.length - (this.combo.oneBased ? 0 : 1);

					case 18: /* Get line data */

						try
						{
						    return  Number(this.element.options[this.getIndex(null, 0, true)].getAttribute('data-mmf'));
						}
						catch (e)
						{
							return '';
						}
				}
				;
			},

			getRunObjectTextColor: function ()
			{
				return this.combo.foreground;
			},

			setRunObjectTextColor: function (rgb)
			{
				this.combo.foreground = rgb;
				this.updateColor();
			}
		});


	//----------------------------------------------------------------------------------
	//
	// CRUNKCWCTRL Objet Window Control
	//
	//----------------------------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CRunkcwctrl.CND_ISICONIC = 0;
	CRunkcwctrl.CND_ISMAXIMIZED = 1;
	CRunkcwctrl.CND_ISVISIBLE = 2;
	CRunkcwctrl.CND_ISAPPACTIVE = 3;
	CRunkcwctrl.CND_HASFOCUS = 4;
	CRunkcwctrl.CND_ISATTACHEDTODESKTOP = 5;
	CRunkcwctrl.CND_LAST = 6;
	CRunkcwctrl.ACT_SETBACKCOLOR = 23;
	CRunkcwctrl.EXP_GETXPOSITION = 0;
	CRunkcwctrl.EXP_GETYPOSITION = 1;
	CRunkcwctrl.EXP_GETXSIZE = 2;
	CRunkcwctrl.EXP_GETYSIZE = 3;
	CRunkcwctrl.EXP_GETSCREENXSIZE = 4;
	CRunkcwctrl.EXP_GETSCREENYSIZE = 5;
	CRunkcwctrl.EXP_GETSCREENDEPTH = 6;
	CRunkcwctrl.EXP_GETCLIENTXSIZE = 7;
	CRunkcwctrl.EXP_GETCLIENTYSIZE = 8;
	CRunkcwctrl.EXP_GETTITLE = 9;
	CRunkcwctrl.EXP_GETBACKCOLOR = 10;
	CRunkcwctrl.EXP_GETXFRAME = 11;
	CRunkcwctrl.EXP_GETYFRAME = 12;
	CRunkcwctrl.EXP_GETWFRAME = 13;
	CRunkcwctrl.EXP_GETHFRAME = 14;

	function CRunkcwctrl()
	{
	}
	CRunkcwctrl.prototype = CServices.extend(new CRunExtension(),
		{
			getNumberOfConditions: function ()
			{
				return CRunkcwctrl.CND_LAST;
			},

			// Conditions
			// --------------------------------------------------
			condition:             function (num, cnd)
			{
				switch (num)
				{
					case CRunkcwctrl.CND_ISICONIC:
						return false;
					case CRunkcwctrl.CND_ISMAXIMIZED:
						return false;
					case CRunkcwctrl.CND_ISVISIBLE:
						return true;
					case CRunkcwctrl.CND_ISAPPACTIVE:
						return true;
					case CRunkcwctrl.CND_HASFOCUS:
						return this.rh.rhApp.bActivated;
					case CRunkcwctrl.CND_ISATTACHEDTODESKTOP:
						return false;
				}
				return false;
			},

			// Expressions
			// --------------------------------------------
			getScreenWidth:        function ()
			{
				return screen.width;
			},
			getScreenHeight:       function ()
			{
				return screen.height;
			},
			getWindowWidth:        function ()
			{
				var winW = 630;
				if (document.body && document.body.offsetWidth)
				{
					winW = document.body.offsetWidth;
				}
				if (document.compatMode == 'CSS1Compat' &&
					document.documentElement &&
					document.documentElement.offsetWidth)
				{
					winW = document.documentElement.offsetWidth;
				}
				if (window.innerWidth && window.innerHeight)
				{
					winW = window.innerWidth;
				}
				return winW;
			},
			getWindowHeight:       function ()
			{
				return winH;
			},
			expression:            function (num)
			{
				switch (num)
				{
					case CRunkcwctrl.EXP_GETXPOSITION:
						return (0);
					case CRunkcwctrl.EXP_GETYPOSITION:
						return (0);
					case CRunkcwctrl.EXP_GETXSIZE:
						return window.outerWidth;
					case CRunkcwctrl.EXP_GETYSIZE:
						return window.outerHeight;
					case CRunkcwctrl.EXP_GETSCREENXSIZE:
						return this.getScreenWidth();
					case CRunkcwctrl.EXP_GETSCREENYSIZE:
						return this.getScreenHeight();
					case CRunkcwctrl.EXP_GETSCREENDEPTH:
						return window.colorDepth;
					case CRunkcwctrl.EXP_GETCLIENTXSIZE:
						return window.innerWidth;
					case CRunkcwctrl.EXP_GETCLIENTYSIZE:
						return window.innerHeight;
					case CRunkcwctrl.EXP_GETTITLE:
						return document.title;
					case CRunkcwctrl.EXP_GETBACKCOLOR:
						return (this.rh.rhApp.gaBorderColour);
					case CRunkcwctrl.EXP_GETXFRAME:
						return (0);
					case CRunkcwctrl.EXP_GETYFRAME:
						return (0);
					case CRunkcwctrl.EXP_GETWFRAME:
						return this.rh.rhApp.gaCxWin;
					case CRunkcwctrl.EXP_GETHFRAME:
						return this.rh.rhApp.gaCyWin;
				}
				return 0;
			}
		});

	/* List object (James) */
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CRunkclist.LIST_FREEFLAG = 0x0001,
		CRunkclist.LIST_VSCROLLBAR = 0x0002,
		CRunkclist.LIST_SORT = 0x0004,
		CRunkclist.LIST_BORDER = 0x0008,
		CRunkclist.LIST_HIDEONSTART = 0x0010,
		CRunkclist.LIST_SYSCOLOR = 0x0020,
		CRunkclist.LIST_3DLOOK = 0x0040,
		CRunkclist.LIST_SCROLLTONEWLINE = 0x0080;

	this.kclist = CRunkclist;

	function CRunkclist()
	{
		this.list =
		{
			doubleClickEvent:      -1,
			selectionChangedEvent: -1,
			oneBased:              true,
			background:            null,
			foreground:            null,
			flags:                 0
	    };

	    this.listCreated = false;
	    this.listFontInfo = '';
	    this.listFocused = false;
	    this.listDisabled = false;
	    this.listSelectedIndex = -1;
	    this.listRows = new CArrayList();
	};

	CRunkclist.prototype = CServices.extend(new CRunControl(),
		{
			_getIndex: function (act, index, verify)
			{
				index = (act ? act.getParamExpression(this.rh, index) : this.ho.getExpParam()) - (this.list.oneBased ? 1 : 0);

	            if (verify && (index < 0 || index >= this.countRows()))
					throw new Error("Bad index: " + index);

				return index;
			},

			_fixIndex: function (index)
			{
				return index + (this.list.oneBased ? 1 : 0);
			},

	        _indexInBounds: function (index) {
	            if (index < 0) {
	                return 0;
	            }

	            var total = this.countRows();
	            if (index >= total) {
	                return total - 1;
	            }

	            return index;
	        },

			_updateColor: function (e)
			{
	            if (this.listCreated) {
	                if (this.list.flags & CRunkclist.LIST_SYSCOLOR) {
	                    return;
	                }

	                this.element.style.backgroundColor = CServices.getColorString(this.list.background);
	                this.element.style.color = CServices.getColorString(this.list.foreground);
	            }
			},

	        _updateListRowIndexes: function (start) {
	            var total = this.countRows();
	            var row;
	            for (var index = start; index < total; index++) {
	                row = this.listRows.get(index);
	                row.index = index;
	            }
	        },

	        _createList: function () {
	            if (!this.listCreated) {
	                var total = this.countRows();
	                var list = this.list;
	                this.listCreated = true;

	                //create the element
	                var element = document.createElement('select');
	                element.className = 'fusionRunControlKcList';
	                element.size = 10;
	                element.style['overflow-y'] = 'auto';     // automatic scrollbar (not in ua)

	                //apply theme
	                //Runtime.onThemeElement(element, CRuntime.THEME_ELEMENT_LIST);

	                //setup "look" of the list
	                if (list.flags & CRunkclist.LIST_3DLOOK) {
	                    element.style.borderStyle = 'inset';
	                    element.style.borderWidth = '2px';
	                } else {
	                    element.style.borderStyle = 'solid';

	                    if (list.flags & CRunkclist.LIST_BORDER) {
	                        element.style.borderWidth = '1px';
	                        element.style.borderColor = '#000000';
	                    } else {
	                        element.style.borderWidth = '0px';
	                    }
	                }

	                //add events
	                var that = this;
	                element.ondblclick = function () {
	                    that.list.doubleClickEvent = that.ho.getEventCount();
	                    that.ho.generateEvent(2, 0);
	                };

	                element.onchange = function () {
	                    that.listSelectedIndex = that.element.selectedIndex;
	                    that.list.selectionChangedEvent = that.ho.getEventCount();
	                    that.ho.generateEvent(3, 0);
	                };

	                element.onfocus = function () {
	                    that.listFocused = true;
	                };

	                element.onblur = function () {
	                    that.listFocused = false;
	                };

	                //update the extension runtime
	                this.setElement(element, (list.flags & CRunkclist.LIST_HIDEONSTART) == 0);

	                //add data into the list
	                var row;
	                for (var index = 0; index < total; index++) {
	                    row = this.listRows.get(index);
	                    this.addRow(row.value);

	                    if (row.data != null) {
	                        this.setRowData(index, row.data);
	                    }
	                }

	                //dont need row array anymore
	                this.listRows = null;

	                //apply our previous states
	                this.selectRow(this.listSelectedIndex);

	                if (this.listDisabled) {
	                    this.disableList();
	                } else {
	                    this.enableList();
	                }

	                if (this.listFocused) {
	                    this.focusList();
	                } else {
	                    this.blurList();
	                }

	                //set font of list
	                this.setFont(this.listFontInfo);

	                //update colors
	                this._updateColor();
	            }
	        },

			getNumberOfConditions: function ()
			{
				return 5;
			},

			createRunObject: function (file, cob, version)
			{
	            //helpful pointers
	            var list = this.list;

	            //dimensions
	            this.ho.hoImgWidth = file.readAShort();
	            this.ho.hoImgHeight = file.readAShort();

	            //get font info
	            this.listFontInfo = this.ho.hoAdRunHeader.rhApp.bUnicode ? file.readLogFont() : file.readLogFont16();

	            //foreground color
	            list.foreground = file.readAColor();

	            //skip text style and custom colors
	            file.skipBytes(40 * 2 + 16 * 4);

	            //background color
	            list.background = file.readAColor();

	            //flags
	            list.flags = file.readAInt();

	            //number of lines to read
	            var lineCount = file.readShort();

	            //is it 1 based indexing?
	            list.oneBased = file.readAInt() == 1;

	            //skip secure
	            file.skipBytes(4 * 3);

	            //make sure teh list is created if set to at start
	            if ((list.flags & CRunkclist.LIST_HIDEONSTART) == 0) {
	                this._createList();
	            }

	            //add starting data to the list, without sorting
	            while ((lineCount--) > 0) {
	                this.addRow(file.readAString(), false);
	            }

	            //now sort
	            this.sortRows();
	        },

			/*
			 handleRunObject:function()
			 {
			 if (!this.rh.rhApp.loading && this.visible)
			 this.element.style.visibility = 'visible';

			 return CRunExtension.REFLAG_DISPLAY;
			 },

			 displayRunObject:function(context, xx, yy)
			 {
			 this.setPosition(this.ho.hoX, this.ho.hoY);
			 return 0;
			 },
			 */
			condition:       function (num, cnd)
			{
				switch (num)
				{
					case 0: /* Is visible? */
	                    return this.listVisible;

					case 1: /* Is enabled? */
	                    return !this.listDisabled;

					case 2: /* Double clicked */

	                    return (this.ho.hoFlags & CObject.HOF_TRUEEVENT) != 0 || (this.ho.getEventCount() == this.list.doubleClickEvent);

					case 3: /* Selection changed */

	                    return (this.ho.hoFlags & CObject.HOF_TRUEEVENT) != 0 || (this.ho.getEventCount() == this.list.selectionChangedEvent);

					case 4: /* Has focus */
	                    return this.listFocused;
				}
				;
			},

			action: function (num, act)
			{
				try
				{
					switch (num)
					{
	                    case 0: /* Load list */

	                        this.clearRows();

							var filename = CServices.parseName(act.getParamFilename(this.rh, 0));
							var text = localStorage.getItem(filename);
							var end, begin = 0;
							if (text)
							{
								while (begin < text.length)
								{
									end = text.indexOf(CIni.separator, begin);
	                                this.addRow(text.substring(begin, end), false);
									begin = end + CIni.separator.length;
								}
	                            this.sortRows();
								break;
							}

							try
							{
								var file, efile = this.rh.rhApp.getEmbeddedFile(filename);

								if (efile)
									file = efile.open();

								if (!file)
								{
									file = new CFile();
									file.openFile(filename);
								}

								if (!file)
								    break;

								file.detectUnicode();

								var i = 0;
								while (!file.isEOF()) {
	                                this.addRow(file.readAStringEOL(), false);
								}

	                            this.sortRows();
							}
							catch (e)
							{
								if (document.debug)
									throw e;

	                            this.clearRows();
							}

							break;

						case 1: /* Load drives list */
							break;

						case 2: /* Load directory list */
							break;

						case 3: /* Load files list */
							break;

						case 4: /* Save list */
							var name = CServices.parseName(act.getParamFilename(this.rh, 0));
	                        localStorage.setItem(name, this.implodeRows(CIni.separator));
							break;

						case 5: /* Reset */
	                        this.clearRows();
							break;

						case 6: /* Add line */
	                        this.addRow(act.getParamExpString(this.rh, 0), true);
							break;

						case 7: /* Insert line */
						    var position = this._getIndex(act, 0, false);
							var line = act.getParamExpString(this.rh, 1);

	                        if (position < 0 || position >= this.countRows()) {
	                            this.addRow(line, true);
	                        } else {
	                            this.insertRow(line, position, true);
	                        }
							break;

						case 8: /* Delete line */
	                        this.removeRow(this._getIndex(act, 0, true));
							break;

						case 9: /* Set current line */
	                        this.selectRow(this._getIndex(act, 0, false));
							break;

						case 10: /* Show */
							this.ho.bShown = true;
	                        this.showList();
							break;

						case 11: /* Hide */
	                        this.ho.bShown = false;
	                        this.hideList();
							break;

						case 12: /* Activate */
	                        this.focusList();
							break;

						case 13: /* Enable */
	                        this.enableList();
							break;

						case 14: /* Disable */
	                        this.disableList();
							break;

						case 15: /* Set position */
							var position = act.getParamPosition(this.rh, 0);
	                        if (position.found) {
	                            this.setPosition(position.x, position.y);
	                        }
							break;

						case 16: /* Set X position */
							this.setX(act.getParamExpression(this.rh, 0));
							break;

						case 17: /* Set Y position */
							this.setY(act.getParamExpression(this.rh, 0));
							break;

						case 18: /* Set size */
							this.setSize(act.getParamExpression(this.rh, 0), act.getParamExpression(this.rh, 1));
							break;

						case 19: /* Set width */
							this.setWidth(act.getParamExpression(this.rh, 0));
							break;

						case 20: /* Set height */
							this.setHeight(act.getParamExpression(this.rh, 0));
							break;

						case 21: /* Deactivate */
	                        this.blurList();
							break;

						case 22: /* Scroll to top */
	                        this.scrollListTo(0);
							break;

						case 23: /* Scroll to line */
	                        this.scrollListTo(this._getIndex(act, 0, true));
							break;

						case 24: /* Scroll to end */
	                        this.scrollListTo(this.countRows() - 1);
							break;

						case 25: /* Set color */
	                        this.list.foreground = act.getParamColour(this.rh, 0);
	                        this._updateColor();
							break;

						case 26: /* Set background color */
	                        this.list.background = act.getParamColour(this.rh, 0);
	                        this._updateColor();
							break;

						case 27: /* Load font list */
							break;

						case 28: /* Load font size list */
							break;

						case 29: /* Set line data */
	                        var index = this._getIndex(act, 0, true);
	                        var data = act.getParamExpression(this.rh, 1);
	                        this.setRowData(index, data);
							break;

						case 30: /* Change line */
	                        var index = this._getIndex(act, 0, true);
	                        var text = act.getParamExpString(this.rh, 1);

	                        this.setRow(index, text);
							break;
					}
				}
				catch (e)
				{
				}
			},

			expression: function (num)
			{
				switch (num)
				{
					case 0: /* Get selection index */
	                    return this._fixIndex(this.getSelectedRowIndex());

					case 1: /* Get selection text */
	                    return this.getSelectedRow();

					case 2: /* Get selection directory */
						return '';

					case 3: /* Get selection drive */
						return '';

	                case 4: /* Get line text */
	                    return this.getRow(this._getIndex(null, 0, false));

					case 5: /* Get line directory */
						this.ho.getExpParam();
						return '';

					case 6: /* Get line drive */
						this.ho.getExpParam();
						return '';

					case 7: /* Get number of lines */
	                    return this.countRows();

					case 8: /* Get X */
						return this.ho.hoX;

					case 9: /* Get Y */
						return this.ho.hoY;

					case 10: /* Get width */
						return this.ho.hoImgWidth;

					case 11: /* Get height */
						return this.ho.hoImgHeight;

					case 12: /* Get color */
						return this.list.foreground;

					case 13: /* Get background color */
						return this.list.background;

					case 14: /* Find string */
	                    var what = this.ho.getExpParam().toLowerCase();
	                    var startIndex = this._getIndex(null, 0, false);
	                    var result = this.findRow(what, startIndex, false);

	                    //check for not found
	                    if (result == -1) {
	                        return result;
	                    }

	                    //make sure the index is correct for return
	                    return this._fixIndex(result);

					case 15: /* Find string exact */
	                    var what = this.ho.getExpParam().toLowerCase();
	                    var startIndex = this._getIndex(null, 0, false);
	                    var result = this.findRow(what, startIndex, true);

	                    //check for not found
	                    if (result == -1) {
	                        return result;
	                    }

	                    //make sure the index is correct for return
	                    return this._fixIndex(result);

					case 16: /* Get last index */
	                    return this.countRows() - (this.list.oneBased ? 0 : 1);

	                case 17: /* Get line data */
	                    return this.getRowData(this._getIndex(null, 0, false));
				}
			},

	        getRunObjectTextColor: function () {
	            return this.list.foreground;
	        },

	        setRunObjectTextColor: function (rgb) {
	            this.list.foreground = rgb;
	            this._updateColor();
	        },

	        //list api
	        showList: function () {
	            //make sure the list is created
	            this._createList();

	            if (this.listCreated) {
	                this.element.style.visibility = 'visible';
	            }
	        },

	        hideList: function () {
	            if (this.listCreated) {
	                this.element.style.visibility = 'hidden';
	            }
	        },

	        focusList: function () {
	            this.listFocused = true;

	            if (this.listCreated) {
	                this.element.focus();
	            }
	        },

	        blurList: function () {
	            this.listFocused = false;

	            if (this.listCreated) {
	                this.element.blur();
	            }
	        },

	        enableList: function () {
	            this.listDisabled = false;

	            if (this.listCreated) {
	                this.element.disabled = false;
	            }
	        },

	        disableList: function () {
	            this.listDisabled = true;

	            if (this.listCreated) {
	                this.element.disabled = true;
	            }
	        },

	        scrollListTo: function (index) {
	            //fix bounds of index
	            index = this._indexInBounds(index);

	            this.listSelectedIndex = index;
	            if (this.listCreated) {
	                this.element.selectedIndex = index;
	            }
	        },

	        //row api
	        getRow: function (index) {
	            if (index < 0 || index >= this.countRows()) {
	                return "";
	            }

	            //where is the data stored?
	            if (this.listCreated) {
	                //list
	                return this.element.options[index].textContent;
	            } else {
	                //array
	                return this.listRows.get(index).value;
	            }
	        },

	        getRowData: function (index) {
	            //check out of bounds
	            if (index < 0 || index >= this.countRows()) {
	                return "";
	            }

	            //where is the data stored?
	            var result = null;
	            if (this.listCreated) {
	                //list

	                //get data and check it existed!
	                result = Number(this.element.options[index].getAttribute('data-mmf'));

	            } else {
	                //array
	                result = this.listRows.get(index).data;
	            }

	            //check result
	            if (result == null) {
	                return "";
	            }

	            return result;
	        },

	        addRow: function (value, sort) {
	            //add row

	            //where is the data stored?
	            if (this.listCreated) {
	                //list
	                this.element.add(new Option(value));
	            } else {
	                //array
	                this.listRows.add({
	                    index: this.countRows(),
	                    value: value,
	                    data: null,
	                });
	            }

	            //do we need to sort?
	            if (sort) {
	                this.sortRows();
	            }
	        },

	        insertRow: function (value, index, sort) {
	            //insert row

	            //where is the data stored?
	            if (this.listCreated) {
	                //list
	                this.element.add(new Option(value), index);
	            } else {
	                //array
	                this.listRows.insert(index, {
	                    index: 0,
	                    value: value,
	                    data: null,
	                });

	                //update all indexes
	                this._updateListRowIndexes(index + 1);
	            }

	            //do we need to sort?
	            if (sort) {
	                this.sortRows();
	            }
	        },

	        setRow: function (index, value) {
	            if (index < 0 || index >= this.countRows()) {
	                return;
	            }

	            //where is the data stored?
	            if (this.listCreated) {
	                //list
	                this.element.options[index].textContent = value;
	            } else {
	                //array
	                var row = this.listRows.get(index);
	                row.value = value;
	            }
	        },

	        setRowData: function (index, data) {
	            if (index < 0 || index >= this.countRows()) {
	                return;
	            }

	            //where is the data stored?
	            if (this.listCreated) {
	                //list
	                this.element.options[index].setAttribute('data-mmf', data);
	            } else {
	                //array
	                var row = this.listRows.get(index);
	                row.data = data;
	            }

	        },

	        findRow: function (what, start, exact) {
	            //fix start index
	            var total = this.countRows();
	            if (start >= total) {
	                return -1;
	            }

	            if (start < 0) {
	                start = 0;
	            }

	            //do teh search
	            if (exact) {
	                //row must match exactly

	                //where is the data stored?
	                if (this.listCreated) {
	                    //from list
	                    for (var index = start; index < total; ++index) {
	                        //TODO: should this really be tolowercase...?
	                        if (this.element.options[index].textContent.toLowerCase() == what) {
	                            return index;
	                        }
	                    }
	                } else {
	                    //from array
	                    for (var index = start; index < total; ++index) {
	                        //TODO: should this really be tolowercase...?
	                        if (this.listRows.get(index).value.toLowerCase() == what) {
	                            return index;
	                        }
	                    }
	                }
	            } else {
	                //row can contain string

	                //where is the data stored?
	                if (this.listCreated) {
	                    //list
	                    for (var index = start; index < total; ++index) {
	                        if (this.element.options[index].textContent.toLowerCase().indexOf(what) !== -1) {
	                            return index;
	                        }
	                    }
	                } else {
	                    //array
	                    for (var index = start; index < total; ++index) {
	                        if (this.listRows.get(index).value.toLowerCase().indexOf(what) !== -1) {
	                            return index;
	                        }
	                    }
	                }
	            }

	            return -1;
	        },

	        sortRows: function () {
	            //only sort if the list is specified to sort
	            if (this.list.flags & CRunkclist.LIST_SORT) {
	                //where is the data stored?
	                if (this.listCreated) {
	                    //list
	                    Array.prototype.sort.call(this.element.options, function (a, b) {
	                        return (a.text == b.text) ? 0 : (a.text > b.text) ? 1 : -1;
	                    });
	                } else {
	                    //array
	                    this.listRows.sort(function (a, b) {
	                        return (a.value == b.value) ? 0 : (a.value > b.value) ? 1 : -1;
	                    });

	                    //update all indexes
	                    this._updateListRowIndexes(0);
	                }
	            }
	        },

	        removeRow: function (index) {
	            //remove row at index
	            if (index < 0 || index >= this.countRows()) {
	                return;
	            }

	            //where is the data stored?
	            if (this.listCreated) {
	                //list
	                this.element.remove(index);
	            } else {
	                //array
	                this.listRows.removeIndex(index);

	                //update all indexes
	                this._updateListRowIndexes(index);
	            }

	            //move selected index
	            if (this.listSelectedIndex != -1) {
	                this.listSelectedIndex -= 1;
	                if (this.listSelectedIndex < 0) {
	                    this.listSelectedIndex = 0;
	                }
	            }
	        },

	        clearRows: function () {
	            //where is the data stored?
	            this.listSelectedIndex = -1;

	            if (this.listCreated) {
	                //list
	                this.element.options.length = 0;
	            } else {
	                //array
	                this.listRows.clear();
	            }
	        },

	        countRows: function () {
	            //get number of rows

	            //where is the data stored?
	            if (this.listCreated) {
	                //list
	                return this.element.options.length;
	            } else {
	                //array
	                return this.listRows.size();
	            }
	        },

	        implodeRows: function (separator) {
	            //convert data into string
	            var total = this.countRows();
	            var build = "";
	            for (var index = 0; index < total; index++) {
	                build += this.getRow(index) + separator;
	            }
	            return build;
	        },

	        //selection api
	        selectRow: function (index) {
	            if (index < 0 || index >= this.countRows()) {
	                return;
	            }
	            this.listSelectedIndex = index;

	            if (this.listCreated) {
	                this.element.selectedIndex = index;
	            }
	        },

	        getSelectedRow: function () {
	            return this.getRow(this.getSelectedRowIndex());
	        },

	        getSelectedRowIndex: function () {
	            return this.listSelectedIndex;
	        }
	 
		});


	//----------------------------------------------------------------------------------
	//
	// CRunkcclock: date & time object
	//
	//----------------------------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */

	CRunkcclock.CND_CMPCHRONO = 0;
	CRunkcclock.CND_NEWSECOND = 1;
	CRunkcclock.CND_NEWMINUTE = 2;
	CRunkcclock.CND_NEWHOUR = 3;
	CRunkcclock.CND_NEWDAY = 4;
	CRunkcclock.CND_NEWMONTH = 5;
	CRunkcclock.CND_NEWYEAR = 6;
	CRunkcclock.CND_CMPCOUNTDOWN = 7;
	CRunkcclock.CND_VISIBLE = 8;
	CRunkcclock.ACT_SETCENTIEMES = 0;
	CRunkcclock.ACT_SETSECONDES = 1;
	CRunkcclock.ACT_SETMINUTES = 2;
	CRunkcclock.ACT_SETHOURS = 3;
	CRunkcclock.ACT_SETDAYOFWEEK = 4;
	CRunkcclock.ACT_SETDAYOFMONTH = 5;
	CRunkcclock.ACT_SETMONTH = 6;
	CRunkcclock.ACT_SETYEAR = 7;
	CRunkcclock.ACT_RESETCHRONO = 8;
	CRunkcclock.ACT_STARTCHRONO = 9;
	CRunkcclock.ACT_STOPCHRONO = 10;
	CRunkcclock.ACT_SHOW = 11;
	CRunkcclock.ACT_HIDE = 12;
	CRunkcclock.ACT_SETPOSITION = 13;
	CRunkcclock.ACT_SETCOUNTDOWN = 14;
	CRunkcclock.ACT_STARTCOUNTDOWN = 15;
	CRunkcclock.ACT_STOPCOUNTDOWN = 16;
	CRunkcclock.ACT_SETXPOSITION = 17;
	CRunkcclock.ACT_SETYPOSITION = 18;
	CRunkcclock.ACT_SETXSIZE = 19;
	CRunkcclock.ACT_SETYSIZE = 20;
	CRunkcclock.EXP_GETCENTIEMES = 0;
	CRunkcclock.EXP_GETSECONDES = 1;
	CRunkcclock.EXP_GETMINUTES = 2;
	CRunkcclock.EXP_GETHOURS = 3;
	CRunkcclock.EXP_GETDAYOFWEEK = 4;
	CRunkcclock.EXP_GETDAYOFMONTH = 5;
	CRunkcclock.EXP_GETMONTH = 6;
	CRunkcclock.EXP_GETYEAR = 7;
	CRunkcclock.EXP_GETCHRONO = 8;
	CRunkcclock.EXP_GETCENTERX = 9;
	CRunkcclock.EXP_GETCENTERY = 10;
	CRunkcclock.EXP_GETHOURX = 11;
	CRunkcclock.EXP_GETHOURY = 12;
	CRunkcclock.EXP_GETMINUTEX = 13;
	CRunkcclock.EXP_GETMINUTEY = 14;
	CRunkcclock.EXP_GETSECONDX = 15;
	CRunkcclock.EXP_GETSECONDY = 16;
	CRunkcclock.EXP_GETCOUNTDOWN = 17;
	CRunkcclock.EXP_GETXPOSITION = 18;
	CRunkcclock.EXP_GETYPOSITION = 19;
	CRunkcclock.EXP_GETXSIZE = 20;
	CRunkcclock.EXP_GETYSIZE = 21;
	CRunkcclock.ANALOG_CLOCK = 0;
	CRunkcclock.DIGITAL_CLOCK = 1;
	CRunkcclock.INVISIBLE = 2;
	CRunkcclock.CALENDAR = 3;
	CRunkcclock.CLOCK = 0;
	CRunkcclock.STOPWATCH = 1;
	CRunkcclock.COUNTDOWN = 2;
	CRunkcclock.SHORTDATE = 0;
	CRunkcclock.LONGDATE = 1;
	CRunkcclock.FIXEDDATE = 2;

	CRunkcclock.months =
		[
			0,
			267840000,
			509760000,
			777600000,
			1123200000,
			1304640000,
			1563840000,
			1831680000,
			2099520000,
			2358720000,
			2626560000,
			2885760000
		];
	CRunkcclock.szRoman =
		[
			"I",
			"II",
			"III",
			"IV",
			"V",
			"VI",
			"VII",
			"VIII",
			"IX",
			"X",
			"XI",
			"XII"
		];

	this.kcclock = CRunkcclock;
	/* export to extension loader */

	function CRunkcclock()
	{
		this.ADJ = 3;
		this.sType = 0;
		this.sClockMode = 0;
		this.sClockBorder = false;
		this.sAnalogClockLines = false;
		this.sAnalogClockMarkerType = 0;
		this.sFont = null;
		this.crFont = 0;
		this.sAnalogClockSeconds = false;
		this.crAnalogClockSeconds = 0;
		this.sAnalogClockMinutes = false;
		this.crAnalogClockMinutes = 0;
		this.sAnalogClockHours = false;
		this.crAnalogClockHours = 0;
		this.sDigitalClockType = 0;
		this.sCalendarType = 0;
		this.sCalendarFormat = 0;
		this.lCountdownStart = 0;
		this.sMinWidth = 0;
		this.sMinHeight = 0;
		this.sVisible = false;
		this.lastRecordedTime = null;
		this.sDisplay = false;
		this.sUpdateCounter = 0;
		this.dChronoCounter = 0;
		this.dChronoStart = 0;
		this.lChrono = 0;
		this.sEventCount = 0;
		this.sCenterX = 0;
		this.sCenterY = 0;
		this.sHourX = 0;
		this.sHourY = 0;
		this.sMinuteX = 0;
		this.sMinuteY = 0;
		this.sSecondX = 0;
		this.sSecondY = 0;
		this.initialTime = null;
		this.startTimer = null;
		this.fontString = null;
		this.measureSurf = null;
		this.textSurface = null;
		this.textSurfaces = null;
		this.oldSzDate = null;
	};

	CRunkcclock.prototype = CServices.extend(new CRunExtension(),
		{
			getNumberOfConditions: function ()
			{
				return 9;
			},

			createRunObject: function (file, cob, version)
			{
				this.ho.setX(cob.cobX);
				this.ho.setY(cob.cobY);
				this.ho.hoImgXSpot = 0;
				this.ho.hoImgYSpot = 0;
				this.ho.setWidth(file.readAShort());
				this.ho.setHeight(file.readAShort());
				file.skipBytes(4 * 16);
				this.sType = file.readAShort();
				this.sClockMode = file.readAShort();
				this.sClockBorder = (file.readAShort() == 0) ? false : true;
				this.sAnalogClockLines = (file.readAShort() == 0) ? false : true;
				this.sAnalogClockMarkerType = file.readAShort();
				this.sFont = file.readLogFont();
				if ((this.sFont.lfHeight == 8) && (this.sFont.lfFaceName.toUpperCase() == "SYSTEM"))
				{
					this.sFont.init();
					//            this.sFont.lfHeight = 13;
					//            this.sFont.lfWeight = 700;
				}
				this.fontString = this.sFont.getFont();
				this.crFont = file.readAColor();
				file.skipBytes(40 * 2);
				this.sAnalogClockSeconds = (file.readAShort() == 0) ? false : true;
				this.crAnalogClockSeconds = file.readAColor();
				this.sAnalogClockMinutes = (file.readAShort() == 0) ? false : true;
				this.crAnalogClockMinutes = file.readAColor();
				this.sAnalogClockHours = (file.readAShort() == 0) ? false : true;
				this.crAnalogClockHours = file.readAColor();
				this.sDigitalClockType = file.readAShort();
				this.sCalendarType = file.readAShort();
				this.sCalendarFormat = file.readAShort();
				file.skipBytes(40 * 2);
				var sCountDownHours = file.readAShort();
				var sCountDownMinutes = file.readAShort();
				var sCountDownSeconds = file.readAShort();
				this.lCountdownStart = (sCountDownHours * 360000) + (sCountDownMinutes * 6000) + (sCountDownSeconds * 100);
				this.sMinWidth = file.readAShort();
				this.sMinHeight = file.readAShort();
				this.sDisplay = true;
				this.initialTime = new Date();
				this.startTimer = new Date();
				this.lastRecordedTime = new Date();
				this.dChronoCounter = 0;
				this.dChronoStart = 0;

				return true;
			},

			handleRunObject: function ()
			{
				var ret = 0;
				if (this.sDisplay)
				{
					this.sDisplay = false;
					ret = CRunExtension.REFLAG_DISPLAY;
				}
				var dCurrentChronoCounter;

				this.sUpdateCounter = 0;

				var cTime = this.getCurrentTime();

				dCurrentChronoCounter = Math.floor(CRunkcclock.months[cTime.getMonth()] + (cTime.getDate() - 1) * 8640000 + cTime.getHours() * 360000 + cTime.getMinutes() * 6000 + cTime.getSeconds() * 100 + cTime.getMilliseconds() / 10.0);
				if ((dCurrentChronoCounter < this.dChronoCounter) || ((dCurrentChronoCounter > (this.dChronoCounter + 200)) && (this.dChronoCounter != 0)))
				{
					if (this.dChronoStart != 0)
					{
						this.lChrono += Math.abs(this.dChronoCounter - this.dChronoStart);
						this.dChronoStart = dCurrentChronoCounter;
					}
				}
				this.dChronoCounter = dCurrentChronoCounter;
				switch (this.sType)
				{
					case CRunkcclock.ANALOG_CLOCK:
					case CRunkcclock.DIGITAL_CLOCK:
					case CRunkcclock.INVISIBLE:
						if (this.lastRecordedTime.getSeconds() != cTime.getSeconds())
						{
							this.sEventCount = this.rh.rh4EventCount;
							this.lastRecordedTime.setSeconds(cTime.getSeconds());
							this.ho.pushEvent(CRunkcclock.CND_NEWSECOND, this.ho.getEventParam());
							ret = CRunExtension.REFLAG_DISPLAY;
							if (this.lastRecordedTime.getMinutes() != cTime.getMinutes())
							{
								this.sEventCount = this.rh.rh4EventCount;
								this.lastRecordedTime.setMinutes(cTime.getMinutes());
								this.ho.pushEvent(CRunkcclock.CND_NEWMINUTE, this.ho.getEventParam());
								if (this.lastRecordedTime.getHours() != cTime.getHours())
								{
									this.sEventCount = this.rh.rh4EventCount;
									this.lastRecordedTime.setHours(cTime.getHours());
									this.ho.pushEvent(CRunkcclock.CND_NEWHOUR, this.ho.getEventParam());
								}
							}
						}
						break;
					case CRunkcclock.CALENDAR:
						if (this.lastRecordedTime.getHours() != cTime.getHours())
						{
							this.lastRecordedTime.setHours(cTime.getHours());
							if (this.lastRecordedTime.getDate() != cTime.getDate())
							{
								this.sEventCount = this.rh.rh4EventCount;
								this.lastRecordedTime.setDate(cTime.getDate());
								this.ho.pushEvent(CRunkcclock.CND_NEWDAY, this.ho.getEventParam());
								ret = CRunExtension.REFLAG_DISPLAY;
								if (this.lastRecordedTime.getMonth() != cTime.getMonth())
								{
									this.sEventCount = this.rh.rh4EventCount;
									this.lastRecordedTime.setMonth(cTime.getMonth());
									this.ho.pushEvent(CRunkcclock.CND_NEWMONTH, this.ho.getEventParam());
									if (this.lastRecordedTime.fullYear != cTime.fullYear)
									{
										this.sEventCount = this.rh.rh4EventCount;
										this.lastRecordedTime.fullYear = cTime.fullYear;
										this.ho.pushEvent(CRunkcclock.CND_NEWYEAR, this.ho.getEventParam());
									}
								}
							}
						}
						break;
					default:
						break;
				}
				this.lastRecordedTime.setTime(cTime.getTime());
				return ret;
			},

			displayRunObject: function (context, xDraw, yDraw)
			{
				var rhPtr = this.ho.hoAdRunHeader;
				var rc = new CRect();
				var rcNewRect;

				rc.left = xDraw + this.ho.hoX;
				rc.right = rc.left + this.ho.hoImgWidth;
				rc.top = yDraw + this.ho.hoY;
				rc.bottom = rc.top + this.ho.hoImgHeight;
				var hour = this.lastRecordedTime.getHours();
				var hsecond = Math.floor(this.lastRecordedTime.getMilliseconds() / 10);
				var minute = this.lastRecordedTime.getMinutes();
				var second = this.lastRecordedTime.getSeconds();
				var day = this.lastRecordedTime.getDate();
				var year = this.lastRecordedTime.getFullYear();
				var month = (this.lastRecordedTime.getMonth() + 1);
				var dayofweek = (this.lastRecordedTime.getDay());
				var lCurrentChrono;
				var usHour, usMinute, usSecond;
				var dChronoStop;

				switch (this.sType)
				{
					case CRunkcclock.ANALOG_CLOCK:
						if (CRunkcclock.CLOCK == this.sClockMode)
						{
							if (hour > 11)
							{
								hour -= 12;
							}
							if (this.sAnalogClockMarkerType != 2)
							{
								rcNewRect = new CRect();
								rcNewRect.left = rc.left + (this.sMinWidth / 2);
								rcNewRect.right = rc.right - (this.sMinWidth / 2);
								rcNewRect.top = rc.top + (this.sMinHeight / 2);
								rcNewRect.bottom = rc.bottom - (this.sMinHeight / 2);
								this.RunDisplayAnalogTime(context, hour, minute, second, rcNewRect);
							}
							else
							{
								this.RunDisplayAnalogTime(context, hour, minute, second, rc);
							}
						}
						else
						{
							if (this.dChronoStart != 0)
							{
								dChronoStop = CRunkcclock.months[month - 1] + ((day - 1) * 8640000) + (hour * 360000) + (minute * 6000) + (second * 100) + hsecond;
								lCurrentChrono = this.lChrono + (dChronoStop - this.dChronoStart);
							}
							else
							{
								lCurrentChrono = this.lChrono;
							}

							// Countdown
							if (CRunkcclock.COUNTDOWN == this.sClockMode)
							{
								lCurrentChrono = this.lCountdownStart - lCurrentChrono;
								if (lCurrentChrono < 0)
								{
									lCurrentChrono = 0;
								}
							}

							// Compute hours, minutes & seconds
							usHour = Math.floor(lCurrentChrono / 360000);
							if (usHour > 11)
							{
								usHour -= 12;
							}
							usMinute = Math.floor((lCurrentChrono - (usHour * 360000)) / 6000);
							usSecond = Math.floor((lCurrentChrono - (usHour * 360000) - (usMinute * 6000)) / 100);

							// Display
							if (this.sAnalogClockMarkerType != 2)
							{
								rcNewRect = new CRect();
								rcNewRect.left = rc.left + (this.sMinWidth / 2);
								rcNewRect.right = rc.right - (this.sMinWidth / 2);
								rcNewRect.top = rc.top + (this.sMinHeight / 2);
								rcNewRect.bottom = rc.bottom - (this.sMinHeight / 2);
								this.RunDisplayAnalogTime(context, usHour, usMinute, usSecond, rcNewRect);
							}
							else
							{
								this.RunDisplayAnalogTime(context, usHour, usMinute, usSecond, rc);
							}
						}
						break;

					case CRunkcclock.DIGITAL_CLOCK: // Digital clock
					{
						var szTime;
						var szTrailing;
						var sHours;
						var sMinutes;
						var sSeconds;
						switch (this.sDigitalClockType)
						{
							case 0:
								if (CRunkcclock.CLOCK == this.sClockMode)
								{
									var AM = " AM";
									if (hour > 11)
									{
										hour -= 12;
										AM = "";
									}
									sHours = hour.toString();
									sHours = this.checkNumberOfDigits(sHours);
									sMinutes = minute.toString();
									sMinutes = this.checkNumberOfDigits(sMinutes);
									szTime = sHours + ":" + sMinutes + AM;
									this.RunDisplayDigitalTime(context, szTime, rc);
								}
								else
								{
									if (this.dChronoStart != 0)
									{
										dChronoStop = CRunkcclock.months[month - 1] + ((day - 1) * 8640000) + (hour * 360000) + (minute * 6000) + (second * 100) + hsecond;
										lCurrentChrono = this.lChrono + (dChronoStop - this.dChronoStart);
									}
									else
									{
										lCurrentChrono = this.lChrono;
									}
									// Countdown
									if (CRunkcclock.COUNTDOWN == this.sClockMode)
									{
										lCurrentChrono = this.lCountdownStart - lCurrentChrono;
										if (lCurrentChrono < 0)
										{
											lCurrentChrono = 0;
										}
									}
									// Compute hours, minutes & seconds
									usHour = Math.floor(lCurrentChrono / 360000);
									if (usHour > 11)
									{
										usHour -= 12;
									}
									usMinute = Math.floor((lCurrentChrono - (usHour * 360000)) / 6000);
									sHours = usHour.toString();
									sHours = this.checkNumberOfDigits(sHours);
									sMinutes = usMinute.toString();
									sMinutes = this.checkNumberOfDigits(sMinutes);
									szTime = sHours + ":" + sMinutes;
									this.RunDisplayDigitalTime(context, szTime, rc);
								}
								break;

							case 1:
								if (CRunkcclock.CLOCK == this.sClockMode)
								{
									// Display
									var AM = " AM";
									if (hour > 12) // avant, c'etait 11, donc on affichait 00 PM pour midi
									{
										hour -= 12;
										AM = "";
									}
									sHours = hour.toString();
									sHours = this.checkNumberOfDigits(sHours);
									sMinutes = minute.toString();
									sMinutes = this.checkNumberOfDigits(sMinutes);
									sSeconds = second.toString();
									sSeconds = this.checkNumberOfDigits(sSeconds);
									szTime = sHours + ":" + sMinutes + ":" + sSeconds + AM;
									this.RunDisplayDigitalTime(context, szTime, rc);
								}
								else
								{
									// Get current chrono
									if (this.dChronoStart != 0)
									{
										dChronoStop = CRunkcclock.months[month - 1] + ((day - 1) * 8640000) + (hour * 360000) + (minute * 6000) + (second * 100) + hsecond;
										lCurrentChrono = this.lChrono + (dChronoStop - this.dChronoStart);
									}
									else
									{
										lCurrentChrono = this.lChrono;
									}
									// Countdown
									if (CRunkcclock.COUNTDOWN == this.sClockMode)
									{
										lCurrentChrono = this.lCountdownStart - lCurrentChrono;
										if (lCurrentChrono < 0)
										{
											lCurrentChrono = 0;
										}
									}
									// Compute hours, minutes & seconds
									usHour = Math.floor(lCurrentChrono / 360000);
									if (usHour > 11)
									{
										usHour -= 12;
									}
									usMinute = Math.floor((lCurrentChrono - (usHour * 360000)) / 6000);
									usSecond = Math.floor((lCurrentChrono - (usHour * 360000) - (usMinute * 6000)) / 100);

									// Display
									if (usHour > 11)
									{
										usHour -= 12;
									}
									sHours = usHour.toString();
									sHours = this.checkNumberOfDigits(sHours);
									sMinutes = usMinute.toString();
									sMinutes = this.checkNumberOfDigits(sMinutes);
									sSeconds = usSecond.toString();
									sSeconds = this.checkNumberOfDigits(sSeconds);
									szTime = sHours + ":" + sMinutes + ":" + sSeconds;
									this.RunDisplayDigitalTime(context, szTime, rc);
								}
								break;

							case 2:
								if (CRunkcclock.CLOCK == this.sClockMode)
								{
									sHours = hour.toString();
									sHours = this.checkNumberOfDigits(sHours);
									sMinutes = minute.toString();
									sMinutes = this.checkNumberOfDigits(sMinutes);
									szTime = sHours + ":" + sMinutes;
									this.RunDisplayDigitalTime(context, szTime, rc);
								}
								else
								{
									// Get current chrono
									if (this.dChronoStart != 0)
									{
										dChronoStop = CRunkcclock.months[month - 1] + ((day - 1) * 8640000) + (hour * 360000) + (minute * 6000) + (second * 100) + hsecond;
										lCurrentChrono = this.lChrono + (dChronoStop - this.dChronoStart);
									}
									else
									{
										lCurrentChrono = this.lChrono;
									}

									// Countdown
									if (CRunkcclock.COUNTDOWN == this.sClockMode)
									{
										lCurrentChrono = this.lCountdownStart - lCurrentChrono;
										if (lCurrentChrono < 0)
										{
											lCurrentChrono = 0;
										}
									}

									// Compute hours, minutes & seconds
									usHour = Math.floor(lCurrentChrono / 360000);
									usMinute = Math.floor((lCurrentChrono - (usHour * 360000)) / 6000);

									// Display
									sHours = usHour.toString();
									sHours = this.checkNumberOfDigits(sHours);
									sMinutes = usMinute.toString();
									sMinutes = this.checkNumberOfDigits(sMinutes);
									szTime = sHours + ":" + sMinutes;
									this.RunDisplayDigitalTime(context, szTime, rc);
								}
								break;

							case 3:
								if (CRunkcclock.CLOCK == this.sClockMode)
								{
									sHours = hour.toString();
									sHours = this.checkNumberOfDigits(sHours);
									sMinutes = minute.toString();
									sMinutes = this.checkNumberOfDigits(sMinutes);
									sSeconds = second.toString();
									sSeconds = this.checkNumberOfDigits(sSeconds);
									szTime = sHours + ":" + sMinutes + ":" + sSeconds;
									this.RunDisplayDigitalTime(context, szTime, rc);
								}
								else
								{

									// Get current chrono
									if (this.dChronoStart != 0)
									{
										dChronoStop = CRunkcclock.months[month - 1] + ((day - 1) * 8640000) + (hour * 360000) + (minute * 6000) + (second * 100) + hsecond;
										lCurrentChrono = this.lChrono + (dChronoStop - this.dChronoStart);
									}
									else
									{
										lCurrentChrono = this.lChrono;
									}

									// Countdown
									if (CRunkcclock.COUNTDOWN == this.sClockMode)
									{
										lCurrentChrono = this.lCountdownStart - lCurrentChrono;
										if (lCurrentChrono < 0)
										{
											lCurrentChrono = 0;
										}
									}

									// Compute hours, minutes & seconds
									usHour = Math.floor(lCurrentChrono / 360000);
									usMinute = Math.floor((lCurrentChrono - (usHour * 360000)) / 6000);
									usSecond = Math.floor((lCurrentChrono - (usHour * 360000) - (usMinute * 6000)) / 100);

									// Display
									sHours = usHour.toString();
									sHours = this.checkNumberOfDigits(sHours);
									sMinutes = usMinute.toString();
									sMinutes = this.checkNumberOfDigits(sMinutes);
									sSeconds = usSecond.toString();
									sSeconds = this.checkNumberOfDigits(sSeconds);
									szTime = sHours + ":" + sMinutes + ":" + sSeconds;
									this.RunDisplayDigitalTime(context, szTime, rc);
								}
								break;

							default:
								break;
						}
						break;
					}

					case CRunkcclock.CALENDAR: // Calendar
						var szDate;
						var formatString;
						switch (this.sCalendarType)
						{
							case CRunkcclock.SHORTDATE:
								formatString = "dd/mm/yyyy";
								break;

							case CRunkcclock.LONGDATE:
								formatString = "dddd dd mmmm yyyy";
								break;

							case CRunkcclock.FIXEDDATE:
								switch (this.sCalendarFormat)
								{
									case 0:
										formatString = "dd/mm/yyyy";
										break;
									case 1:
										formatString = "dd mmmm yyyy";
										break;
									case 2:
										formatString = "dd mmmm, yyyy";
										break;
									case 3:
										formatString = "mmmm dd, yyyy";
										break;
									case 4:
										formatString = "dd-mmm-yyyy";
										break;
									case 5:
										formatString = "mmmm, yyyy";
										break;
									case 6:
										formatString = "mmm-yy";
										break;
								}
								break;

							default:
								break;
						}
						szDate = this.lastRecordedTime.format(formatString);
						this.RunDisplayCalendar(context, szDate, rc);
						break;

					default:
						break;
				}
			},

			checkNumberOfDigits: function (s)
			{
				if (s.length < 2)
				{
					s = "0" + s;
				}
				return s;
			},

			RunDisplayAnalogTime: function (context, sHour, sMinutes, sSeconds, rc)
			{
				var pntPoints = new Array(3);
				var n;
				pntPoints[0] = new CPoint();
				pntPoints[1] = new CPoint();
				pntPoints[2] = new CPoint();
				var sRayon;
				var a;

				// Set center
				pntPoints[0].y = rc.top + ((rc.bottom - rc.top) / 2);
				pntPoints[0].x = rc.left + ((rc.right - rc.left) / 2);
				this.sCenterY = pntPoints[0].x;
				this.sCenterX = pntPoints[0].y;

				// Set radius
				if ((rc.right - rc.left) > (rc.bottom - rc.top))
				{
					sRayon = ((rc.bottom - rc.top) / 2);
				}
				else
				{
					sRayon = ((rc.right - rc.left) / 2);
				}
				sRayon--;

				// Display hours
				context.lineCap = 'round';
				if (true == this.sAnalogClockHours)
				{
					pntPoints[1].x = pntPoints[0].x + (Math.cos(( ((sHour) + Number(sMinutes) / 60.0) * 0.523) - 1.570) * (sRayon / 1.5));
					pntPoints[1].y = pntPoints[0].y + (Math.sin(( ((sHour) + Number(sMinutes) / 60.0) * 0.523) - 1.570) * (sRayon / 1.5));
					this.sHourX = pntPoints[1].x;
					this.sHourY = pntPoints[1].y;
					context.renderLine(pntPoints[0].x, pntPoints[0].y, pntPoints[1].x, pntPoints[1].y, this.crAnalogClockHours, 2, 0, 0);
				}
				// Display minutes
				if (true == this.sAnalogClockMinutes)
				{
					pntPoints[1].x = pntPoints[0].x + (Math.cos(((sMinutes) * 0.104) - 1.570) * sRayon);
					pntPoints[1].y = pntPoints[0].y + (Math.sin(((sMinutes) * 0.104) - 1.570) * sRayon);
					this.sMinuteX = pntPoints[1].x;
					this.sMinuteY = pntPoints[1].y;
					context.renderLine(pntPoints[0].x, pntPoints[0].y, pntPoints[1].x, pntPoints[1].y, this.crAnalogClockMinutes, 2, 0, 0);
				}
				// Display seconds
				if (true == this.sAnalogClockSeconds)
				{
					pntPoints[1].x = pntPoints[0].x + (Math.cos((Number(sSeconds) * 0.104) - 1.570) * sRayon);
					pntPoints[1].y = pntPoints[0].y + (Math.sin((Number(sSeconds) * 0.104) - 1.570) * sRayon);
					this.sSecondX = pntPoints[1].x;
					this.sSecondY = pntPoints[1].y;
					context.renderLine(pntPoints[0].x, pntPoints[0].y, pntPoints[1].x, pntPoints[1].y, this.crAnalogClockSeconds, 1, 0, 0);
				}

				// Draw lines
				if (true == this.sAnalogClockLines)
				{
					for (a = 1; a < 13; a++)
					{
						pntPoints[1].x = pntPoints[0].x + (Math.cos((a * 0.523) - 1.570) * (sRayon * 0.9));
						pntPoints[1].y = pntPoints[0].y + (Math.sin((a * 0.523) - 1.570) * (sRayon * 0.9));
						pntPoints[2].x = pntPoints[0].x + (Math.cos((a * 0.523) - 1.570) * sRayon);
						pntPoints[2].y = pntPoints[0].y + (Math.sin((a * 0.523) - 1.570) * sRayon);
						context.renderLine(pntPoints[1].x, pntPoints[1].y, pntPoints[2].x, pntPoints[2].y, this.crFont, 1, 0, 0);
					}
				}

				// Draw markers
				if (this.sAnalogClockMarkerType != 2)
				{
					var szString;
					var textWidth;
					var textHeight;
					var rcFont = new CRect();

					// Display
					var a;
					if (this.textSurfaces == null)
						this.textSurfaces = new Array(13);
					if (!this.measureSurf)
						this.measureSurf = new CTextSurface(this.rh.rhApp, 2, 2);
					for (a = 1; a < 13; a++)
					{
						var x, y;
						if (0 == this.sAnalogClockMarkerType)
						{
							szString = a.toString();
						}
						else
						{
							szString = CRunkcclock.szRoman[a - 1];
						}
						textWidth = this.measureSurf.measureText(szString, this.sFont);
						textHeight = this.sFont.lfHeight;

						x = pntPoints[0].x + (Math.cos((a * 0.523) - 1.570) * sRayon);
						y = pntPoints[0].y + (Math.sin((a * 0.523) - 1.570) * sRayon);
						switch (a)
						{
							case 1:
							case 2:
								rcFont.left = x;
								rcFont.bottom = y;
								rcFont.right = rcFont.left + textWidth;
								rcFont.top = rcFont.bottom - textHeight;
								break;

							case 3:
								rcFont.left = x + 2;
								rcFont.top = y - (textHeight / 2);
								rcFont.right = rcFont.left + textWidth;
								rcFont.bottom = rcFont.top + textHeight;
								break;

							case 4:
							case 5:
								rcFont.left = x;
								rcFont.top = y;
								rcFont.right = rcFont.left + textWidth;
								rcFont.bottom = rcFont.top + textHeight;
								break;

							case 6:
								rcFont.left = x - (textWidth / 2);
								rcFont.top = y + 1;
								rcFont.right = rcFont.left + textWidth;
								rcFont.bottom = rcFont.top + textHeight;
								break;

							case 7:
							case 8:
								rcFont.right = x;
								rcFont.top = y;
								rcFont.left = rcFont.right - textWidth;
								rcFont.bottom = rcFont.top + textHeight;
								break;

							case 9:
								rcFont.right = x - 2;
								rcFont.top = y - (textHeight / 2);
								rcFont.left = rcFont.right - textWidth;
								rcFont.bottom = rcFont.top + textHeight;
								break;

							case 10:
							case 11:
								rcFont.right = x;
								rcFont.bottom = y;
								rcFont.left = rcFont.right - textWidth;
								rcFont.top = rcFont.bottom - textHeight;
								break;

							case 12:
								rcFont.left = x - (textWidth / 2);
								rcFont.bottom = y - 1;
								rcFont.right = rcFont.left + textWidth;
								rcFont.top = rcFont.bottom - textHeight;
								break;
						}
						if (!this.textSurfaces[a])
						{
							this.textSurfaces[a] = new CTextSurface(this.rh.rhApp, textWidth, textHeight);
							this.textSurfaces[a].setText(szString, CServices.DT_LEFT | CServices.DT_TOP, null, this.sFont, this.crFont);
						}
						var X = rcFont.left + (rcFont.right - rcFont.left) / 2 - textWidth / 2;
						var Y = rcFont.top + (rcFont.bottom - rcFont.top) / 2 + textHeight / 2 - textHeight + 2;
						this.textSurfaces[a].draw(context, X, Y);
					}
				}

				// Draw border if needed
				if (true == this.sClockBorder)
				{
					context.renderEllipse(pntPoints[0].x - sRayon, pntPoints[0].y - sRayon, sRayon * 2, sRayon * 2, 1, this.crFont, 0, 0);
					context.renderEllipse(pntPoints[0].x - sRayon, pntPoints[0].y - sRayon, sRayon * 2 + 1, sRayon * 2 + 1, 1, this.crFont, 0, 0);
				}
			},

			RunDisplayDigitalTime: function (context, szTime, rc)
			{
				// Display text
				if (!this.measureSurf)
					this.measureSurf = new CTextSurface(this.rh.rhApp, 2, 2);
				var width = this.measureSurf.measureText(szTime, this.sFont);
				var height = this.sFont.lfHeight;
				var X = rc.left + (rc.right - rc.left) / 2 - width / 2;
				var Y = rc.top + (rc.bottom - rc.top) / 2 - height / 2;
				if (this.textSurface == null || szTime != this.oldSzTime)
				{
					this.oldSzTime = szTime;
					this.textSurface = new CTextSurface(this.rh.rhApp, width, height);
					this.textSurface.setText(szTime, CServices.DT_TOP | CServices.DT_LEFT, null, this.sFont, this.crFont);
				}
				this.textSurface.draw(context, Math.floor(X), Math.floor(Y), 0, 0);
				if (true == this.sClockBorder)
				{
					context.renderRect(rc.left + 1, rc.top + 1, rc.right - rc.left, rc.bottom - rc.top, this.crFont, 2, 0, 0);
				}
			},

			RunDisplayCalendar: function (context, szDate, rc)
			{
				if (!this.measureSurf)
					this.measureSurf = new CTextSurface(this.rh.rhApp, 2, 2);
				var width = this.measureSurf.measureText(szDate, this.sFont);
				var height = this.sFont.lfHeight;
				var X = rc.left + (rc.right - rc.left) / 2 - width / 2;
				var Y = rc.top + (rc.bottom - rc.top) / 2 - height / 2;
				if (this.textSurface == null || this.oldSzDate != szDate)
				{
					this.oldSzDate = szDate;
					this.textSurface = new CTextSurface(this.rh.rhApp, width, height);
					this.textSurface.setText(szDate, CServices.DT_TOP | CServices.DT_LEFT, null, this.sFont, this.crFont);
				}
				this.textSurface.draw(context, Math.floor(X), Math.floor(Y));
			},

			getCurrentTime: function ()
			{
				//output = initialTime + (currentTime - startTimer)
				var output = new Date();
				output.setTime(this.initialTime.getTime() + (output.getTime() - this.startTimer.getTime()));
				return output;
			},

			changeTime: function (date)
			{
				this.initialTime.setTime(date.getTime());
				this.lastRecordedTime.setTime(date.getTime());
				this.startTimer = new Date();
			},

			condition: function (num, cnd)
			{
				switch (num)
				{
					case CRunkcclock.CND_CMPCHRONO:
						return this.CmpChrono(cnd);
					case CRunkcclock.CND_NEWSECOND:
						return this.NewSecond();
					case CRunkcclock.CND_NEWMINUTE:
						return this.NewSecond();
					case CRunkcclock.CND_NEWHOUR:
						return this.NewSecond();
					case CRunkcclock.CND_NEWDAY:
						return this.NewSecond();
					case CRunkcclock.CND_NEWMONTH:
						return this.NewSecond();
					case CRunkcclock.CND_NEWYEAR:
						return this.NewSecond();
					case CRunkcclock.CND_CMPCOUNTDOWN:
						return this.CmpCountdown(cnd);
					case CRunkcclock.CND_VISIBLE:
						return this.IsVisible();
				}
				return false;
			},

			CmpChrono: function (cnd)
			{
				if (this.dChronoStart != 0)
				{
					var c = this.getCurrentTime();
					var dChronoStop = Math.floor(CRunkcclock.months[c.getMonth()] +
						((c.getDate() - 1) * 8640000) + (c.getHours() * 360000) +
						(c.getMinutes() * 6000) + (c.getSeconds() * 100) + (c.getMilliseconds() / 10));
					return this.compareTime(cnd, 0, ((this.lChrono + (dChronoStop - this.dChronoStart)) * 10));
				}
				else
				{
					return this.compareTime(cnd, 0, this.lChrono * 10);
				}
			},

			compareTime: function (cnd, num, value1)
			{
				var value2 = cnd.evtParams[num].timer;
				var comp = cnd.evtParams[num].comparaison;
				switch (comp)
				{
					case 0:	// COMPARE_EQ:
						return value1 == value2;
					case 1:	// COMPARE_NE:
						return value1 != value2;
					case 2:	// COMPARE_LE:
						return value1 <= value2;
					case 3:	// COMPARE_LT:
						return value1 < value2;
					case 4:	// COMPARE_GE:
						return value1 >= value2;
					case 5:	// COMPARE_GT:
						return value1 > value2;
				}
				return false;
			},

			NewSecond: function ()
			{
				if ((this.ho.hoFlags & CObject.HOF_TRUEEVENT) != 0)
				{
					return true;
				}
				if (this.rh.rh4EventCount == sEventCount)
				{
					return true;
				}
				return false;
			},

			CmpCountdown: function (cnd)
			{
				var lCurrentChrono;
				if (this.dChronoStart != 0)
				{
					var c = this.getCurrentTime();
					var dChronoStop = Math.floor(CRunkcclock.months[c.getMonth()] +
						((c.getDate() - 1) * 8640000) + (c.getHours() * 360000) +
						(c.getMinutes() * 6000) + (c.getSeconds() * 100) + (c.getMilliseconds() / 10));
					lCurrentChrono = this.lCountdownStart - (this.lChrono + (dChronoStop - this.dChronoStart));
				}
				else
				{
					lCurrentChrono = this.lCountdownStart - this.lChrono;
					return this.compareTime(cnd, 0, lCurrentChrono * 10);        //this.lChrono * 10);
				}
				if (lCurrentChrono < 0)
				{
					lCurrentChrono = 0;
				}
				return this.compareTime(cnd, 0, lCurrentChrono * 10);
			},

			IsVisible: function ()
			{
				return this.ho.bShown;
			},


			action: function (num, act)
			{
				switch (num)
				{
					case CRunkcclock.ACT_SETCENTIEMES:
						this.SetCentiemes(act.getParamExpression(this.rh, 0));
						break;
					case CRunkcclock.ACT_SETSECONDES:
						this.SetSeconds(act.getParamExpression(this.rh, 0));
						break;
					case CRunkcclock.ACT_SETMINUTES:
						this.SetMinutes(act.getParamExpression(this.rh, 0));
						break;
					case CRunkcclock.ACT_SETHOURS:
						this.SetHours(act.getParamExpression(this.rh, 0));
						break;
					case CRunkcclock.ACT_SETDAYOFWEEK:
						this.SetDayOfWeek(act.getParamExpression(this.rh, 0));
						break;
					case CRunkcclock.ACT_SETDAYOFMONTH:
						this.SetDayOfMonth(act.getParamExpression(this.rh, 0));
						break;
					case CRunkcclock.ACT_SETMONTH:
						this.SetMonth(act.getParamExpression(this.rh, 0));
						break;
					case CRunkcclock.ACT_SETYEAR:
						this.SetYear(act.getParamExpression(this.rh, 0));
						break;
					case CRunkcclock.ACT_RESETCHRONO:
						this.ResetChrono();
						break;
					case CRunkcclock.ACT_STARTCHRONO:
						this.StartChrono();
						break;
					case CRunkcclock.ACT_STOPCHRONO:
						this.StopChrono();
						break;
					case CRunkcclock.ACT_SHOW:
						this.Show();
						break;
					case CRunkcclock.ACT_HIDE:
						this.Hide();
						break;
					case CRunkcclock.ACT_SETPOSITION:
						this.SetPosition(act.getParamPosition(this.rh, 0));
						break;
					case CRunkcclock.ACT_SETCOUNTDOWN:
						this.SetCountdown(act.getParamTime(this.rh, 0));
						break;
					case CRunkcclock.ACT_STARTCOUNTDOWN:
						this.StartCountdown();
						break;
					case CRunkcclock.ACT_STOPCOUNTDOWN:
						this.StopCountdown();
						break;
					case CRunkcclock.ACT_SETXPOSITION:
						this.SetXPosition(act.getParamExpression(this.rh, 0));
						break;
					case CRunkcclock.ACT_SETYPOSITION:
						this.SetYPosition(act.getParamExpression(this.rh, 0));
						break;
					case CRunkcclock.ACT_SETXSIZE:
						this.SetXSize(act.getParamExpression(this.rh, 0));
						break;
					case CRunkcclock.ACT_SETYSIZE:
						this.SetYSize(act.getParamExpression(this.rh, 0));
						break;
				}
			},

			SetCentiemes: function (hundredths)
			{
				if ((hundredths >= 0) && (hundredths < 100))
				{
					var c = this.getCurrentTime();
					c.setMilliseconds(hundredths * 10);
					this.changeTime(c);
					this.ho.redraw();
				}
			},

			SetSeconds: function (secs)
			{
				if ((secs >= 0) && (secs < 60))
				{
					var c = this.getCurrentTime();
					c.setSeconds(secs);
					this.changeTime(c);
					this.ho.redraw();
				}
			},

			SetMinutes: function (mins)
			{
				if ((mins >= 0) && (mins < 60))
				{
					var c = this.getCurrentTime();
					c.setMinutes(mins);
					this.changeTime(c);
					this.ho.redraw();
				}
			},

			SetHours: function (hours)
			{
				if ((hours >= 0) && (hours < 24))
				{
					var c = this.getCurrentTime();
					c.setHours(hours);
					this.changeTime(c);
					this.ho.redraw();
				}
			},

			SetDayOfWeek: function (day)
			{
			},

			SetDayOfMonth: function (day)
			{
				if ((day >= 1) && (day < 32)) //1 based from c++
				{
					var c = this.getCurrentTime();
					c.setDate(day);
					this.changeTime(c);
					this.ho.redraw();
				}
			},

			SetMonth: function (month)
			{
				if ((month >= 1) && (month < 13)) //1 based from c++
				{
					var c = this.getCurrentTime();
					c.setMonth(month - 1);
					this.changeTime(c);
					this.ho.redraw();
				}
			},

			SetYear: function (year)
			{
				if ((year > 1979) && (year < 2100)) //y2.1k
				{
					var c = this.getCurrentTime();
					c.setFullYear(year);
					this.changeTime(c);
					this.ho.redraw();
				}
			},

			ResetChrono: function ()
			{
				this.dChronoStart = 0;
				this.lChrono = 0;
				this.ho.redraw();
			},

			StartChrono: function ()
			{
				if (this.dChronoStart == 0)
				{
					var c = this.getCurrentTime();
					var month = c.getMonth();
					var day = c.getDate();
					this.dChronoStart = Math.floor(CRunkcclock.months[c.getMonth()] +
						((c.getDate() - 1) * 8640000) + (c.getHours() * 360000) +
						(c.getMinutes() * 6000) + (c.getSeconds() * 100) + (c.getMilliseconds() / 10));
				}
			},

			StopChrono: function ()
			{
				if (this.dChronoStart != 0)
				{
					var c = this.getCurrentTime();
					var dChronoStop = Math.floor(CRunkcclock.months[c.getMonth()] +
						((c.getDate() - 1) * 8640000) + (c.getHours() * 360000) +
						(c.getMinutes() * 6000) + (c.getSeconds() * 100) + (c.getMilliseconds() / 10));
					this.lChrono += (dChronoStop - this.dChronoStart);
					this.dChronoStart = 0;
				}
			},

			Show: function ()
			{
				this.ho.showSprite();
			},

			Hide: function ()
			{
				this.ho.hideSprite();
			},

			SetPosition: function (pos)
			{
				if (pos.found)
				{
					this.ho.setPosition(pos.x, pos.y);
					this.ho.redraw();
				}
			},

			SetCountdown: function (time)
			{
				this.lCountdownStart = time / 10;
				this.dChronoStart = 0;
				this.lChrono = 0;
				this.ho.redraw();
			},

			StartCountdown: function ()
			{
				if (this.dChronoStart == 0)
				{
					var c = this.getCurrentTime();
					this.dChronoStart = Math.floor(CRunkcclock.months[c.getMonth()] +
						((c.getDate() - 1) * 8640000) + (c.getHours() * 360000) +
						(c.getMinutes() * 6000) + (c.getSeconds() * 100) + (c.getMilliseconds() / 10));
				}
			},

			StopCountdown: function ()
			{
				if (this.dChronoStart != 0)
				{
					var c = this.getCurrentTime();
					var dChronoStop = Math.floor(CRunkcclock.months[c.getMonth()] +
						((c.getDate() - 1) * 8640000) + (c.getHours() * 360000) +
						(c.getMinutes() * 6000) + (c.getSeconds() * 100) + (c.getMilliseconds() / 10));
					this.lChrono += (dChronoStop - this.dChronoStart);
					this.dChronoStart = 0;
				}
			},

			SetXPosition: function (x)
			{
				this.ho.setX(x);
				this.ho.redraw();
			},

			SetYPosition: function (y)
			{
				this.ho.setY(y);
				this.ho.redraw();
			},

			SetXSize: function (w)
			{
				this.ho.setWidth(w);
				this.ho.redraw();
			},

			SetYSize: function (h)
			{
				this.ho.setHeight(h);
				this.ho.redraw();
			},


			expression: function (num)
			{
				switch (num)
				{
					case CRunkcclock.EXP_GETCENTIEMES:
						return this.GetCentiemes();
					case CRunkcclock.EXP_GETSECONDES:
						return this.GetSeconds();
					case CRunkcclock.EXP_GETMINUTES:
						return this.GetMinutes();
					case CRunkcclock.EXP_GETHOURS:
						return this.GetHours();
					case CRunkcclock.EXP_GETDAYOFWEEK:
						return this.GetDayOfWeek();
					case CRunkcclock.EXP_GETDAYOFMONTH:
						return this.GetDayOfMonth();
					case CRunkcclock.EXP_GETMONTH:
						return this.GetMonth();
					case CRunkcclock.EXP_GETYEAR:
						return this.GetYear();
					case CRunkcclock.EXP_GETCHRONO:
						return this.GetChrono();
					case CRunkcclock.EXP_GETCENTERX:
						return this.GetCentreX();
					case CRunkcclock.EXP_GETCENTERY:
						return this.GetCentreY();
					case CRunkcclock.EXP_GETHOURX:
						return this.GetHourX();
					case CRunkcclock.EXP_GETHOURY:
						return this.GetHourY();
					case CRunkcclock.EXP_GETMINUTEX:
						return this.GetMinuteX();
					case CRunkcclock.EXP_GETMINUTEY:
						return this.GetMinuteY();
					case CRunkcclock.EXP_GETSECONDX:
						return this.GetSecondX();
					case CRunkcclock.EXP_GETSECONDY:
						return this.GetSecondY();
					case CRunkcclock.EXP_GETCOUNTDOWN:
						return this.GetCountdown();
					case CRunkcclock.EXP_GETXPOSITION:
						return this.GetXPosition();
					case CRunkcclock.EXP_GETYPOSITION:
						return this.GetYPosition();
					case CRunkcclock.EXP_GETXSIZE:
						return this.GetXSize();
					case CRunkcclock.EXP_GETYSIZE:
						return this.GetYSize();
				}
				return 0;
			},

			GetCentiemes: function ()
			{
				return Math.floor(this.getCurrentTime().getMilliseconds() / 10);
			},

			GetSeconds: function ()
			{
				return this.getCurrentTime().getSeconds();
			},

			GetMinutes: function ()
			{
				return this.getCurrentTime().getMinutes();
			},

			GetHours: function ()
			{
				return this.getCurrentTime().getHours();
			},

			GetDayOfWeek: function ()
			{
				return this.getCurrentTime().getDay();
			},

			GetDayOfMonth: function ()
			{
				return this.getCurrentTime().getDate();
			},

			GetMonth: function ()
			{
				return this.getCurrentTime().getMonth() + 1;
			},

			GetYear: function ()
			{
				return this.getCurrentTime().getFullYear();
			},

			GetChrono: function ()
			{
				if (this.dChronoStart != 0)
				{
					var c = this.getCurrentTime();
					var dChronoStop = Math.floor(CRunkcclock.months[c.getMonth()] +
						((c.getDate() - 1) * 8640000) + (c.getHours() * 360000) +
						(c.getMinutes() * 6000) + (c.getSeconds() * 100) + (c.getMilliseconds() / 10));
					return this.lChrono + (dChronoStop - this.dChronoStart);
				}
				else
				{
					return this.lChrono;
				}
			},

			GetCentreX: function ()
			{
				if (CRunkcclock.ANALOG_CLOCK == this.sType)
				{
					return this.sCenterX + this.rh.rhWindowX;
				}
				else
				{
					return 0;
				}
			},

			GetCentreY: function ()
			{
				if (CRunkcclock.ANALOG_CLOCK == this.sType)
				{
					return this.sCenterY + this.rh.rhWindowY;
				}
				else
				{
					return 0;
				}
			},

			GetHourX: function ()
			{
				if (CRunkcclock.ANALOG_CLOCK == this.sType)
				{
					return this.sHourX + this.rh.rhWindowX;
				}
				else
				{
					return 0;
				}
			},

			GetHourY: function ()
			{
				if (CRunkcclock.ANALOG_CLOCK == this.sType)
				{
					return this.sHourY + this.rh.rhWindowY;
				}
				else
				{
					return 0;
				}
			},

			GetMinuteX: function ()
			{
				if (CRunkcclock.ANALOG_CLOCK == this.sType)
				{
					return this.sMinuteX + this.rh.rhWindowX;
				}
				else
				{
					return 0;
				}
			},

			GetMinuteY: function ()
			{
				if (CRunkcclock.ANALOG_CLOCK == this.sType)
				{
					return this.sMinuteY + this.rh.rhWindowY;
				}
				else
				{
					return 0;
				}
			},

			GetSecondX: function ()
			{
				if (CRunkcclock.ANALOG_CLOCK == this.sType)
				{
					return this.sSecondX + this.rh.rhWindowX;
				}
				else
				{
					return 0;
				}
			},

			GetSecondY: function ()
			{
				if (CRunkcclock.ANALOG_CLOCK == this.sType)
				{
					return this.sSecondY + this.rh.rhWindowY;
				}
				else
				{
					return 0;
				}
			},

			GetCountdown: function ()
			{
				var lCurrentChrono;
				if (this.dChronoStart != 0)
				{
					var c = this.getCurrentTime();
					var dChronoStop = Math.floor(CRunkcclock.months[c.getMonth()] +
						((c.getDate() - 1) * 8640000) + (c.getHours() * 360000) +
						(c.getMinutes() * 6000) + (c.getSeconds() * 100) + (c.getMilliseconds() / 10));
					lCurrentChrono = this.lCountdownStart - (this.lChrono + (dChronoStop - this.dChronoStart));
					if (lCurrentChrono < 0)
					{
						lCurrentChrono = 0;
					}
					return lCurrentChrono;
				}
				else
				{
					lCurrentChrono = this.lCountdownStart - this.lChrono;
					if (lCurrentChrono < 0)
					{
						lCurrentChrono = 0;
					}
					return lCurrentChrono;
				}
			},

			GetXPosition: function ()
			{
				return this.ho.getX();
			},

			GetYPosition: function ()
			{
				return this.ho.getY();
			},

			GetXSize: function ()
			{
				return this.ho.getWidth();
			},

			GetYSize: function ()
			{
				return this.ho.getHeight();
			}

		});


	var dateFormat = function ()
	{
		var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
			timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
			timezoneClip = /[^-+\dA-Z]/g,
			pad = function (val, len)
			{
				val = String(val);
				len = len || 2;
				while (val.length < len) val = "0" + val;
				return val;
			};

		// Regexes and supporting functions are cached through closure
		return function (date, mask, utc)
		{
			var dF = dateFormat;

			// You can't provide utc if you skip other args (use the "UTC:" mask prefix)
			if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date))
			{
				mask = date;
				date = undefined;
			}

			// Passing date through Date applies Date.parse, if necessary
			date = date ? new Date(date) : new Date;
			if (isNaN(date)) throw SyntaxError("invalid date");

			mask = String(dF.masks[mask] || mask || dF.masks["default"]);

			// Allow setting the utc argument via the mask
			if (mask.slice(0, 4) == "UTC:")
			{
				mask = mask.slice(4);
				utc = true;
			}

			var _ = utc ? "getUTC" : "get",
				d = date[_ + "Date"](),
				D = date[_ + "Day"](),
				m = date[_ + "Month"](),
				y = date[_ + "FullYear"](),
				H = date[_ + "Hours"](),
				M = date[_ + "Minutes"](),
				s = date[_ + "Seconds"](),
				L = date[_ + "Milliseconds"](),
				o = utc ? 0 : date.getTimezoneOffset(),
				flags = {
					d:    d,
					dd:   pad(d),
					ddd:  dF.i18n.dayNames[D],
					dddd: dF.i18n.dayNames[D + 7],
					m:    m + 1,
					mm:   pad(m + 1),
					mmm:  dF.i18n.monthNames[m],
					mmmm: dF.i18n.monthNames[m + 12],
					yy:   String(y).slice(2),
					yyyy: y,
					h:    H % 12 || 12,
					hh:   pad(H % 12 || 12),
					H:    H,
					HH:   pad(H),
					M:    M,
					MM:   pad(M),
					s:    s,
					ss:   pad(s),
					l:    pad(L, 3),
					L:    pad(L > 99 ? Math.round(L / 10) : L),
					t:    H < 12 ? "a" : "p",
					tt:   H < 12 ? "am" : "pm",
					T:    H < 12 ? "A" : "P",
					TT:   H < 12 ? "AM" : "PM",
					Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
					o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
					S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
				};

			return mask.replace(token, function ($0)
			{
				return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
			});
		};
	}();

	// Some common format strings
	dateFormat.masks = {
		"default":      "ddd mmm dd yyyy HH:MM:ss",
		shortDate:      "m/d/yy",
		mediumDate:     "mmm d, yyyy",
		longDate:       "mmmm d, yyyy",
		fullDate:       "dddd, mmmm d, yyyy",
		shortTime:      "h:MM TT",
		mediumTime:     "h:MM:ss TT",
		longTime:       "h:MM:ss TT Z",
		isoDate:        "yyyy-mm-dd",
		isoTime:        "HH:MM:ss",
		isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss",
		isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
	};

	// Internationalization strings
	dateFormat.i18n = {
		dayNames:   [
			"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
			"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
		],
		monthNames: [
			"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
			"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
		]
	};

	// For convenience...
	Date.prototype.format = function (mask, utc)
	{
		return dateFormat(this, mask, utc);
	};
	//----------------------------------------------------------------------------------
	//
	// CRUNKCINI : objet INI
	//
	//----------------------------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CRunkcini.INI_FULLPATH = 0x0002;
	CRunkcini.INI_FULLPATHINI_APPFOLDER = 0x0004;
	CRunkcini.INI_FULLPATHINI_UTF8 = 0x0008;
	function CRunkcini()
	{
		this.ini = null;
		this.iniFlags = 0;
		this.iniName = null;
		this.iniCurrentGroup = null;
		this.iniCurrentItem = null;
		this.changeCounter = 0;
	}

	CRunkcini.prototype = CServices.extend(new CRunExtension(),
		{
			getNumberOfConditions: function ()
			{
				return 0;
			},
			createRunObject:       function (file, cob, version)
			{
				this.iniFlags = file.readAShort();
				this.iniName = CServices.parseName(file.readAString());
				if (this.iniName.length == 0)
				{
					this.iniName = "Ini.ini";
				}
				var flags = 0;
				if (this.iniFlags & CRunkcini.INI_FULLPATHINI_UTF8)
					flags |= CIni.INIFLAG_UTF8;
				this.ini = new CIni(this.rh.rhApp, flags);
				this.iniCurrentGroup = "Group";
				this.iniCurrentItem = "Item";
				this.changeCounter = 0;
				return false;
			},
			handleRunObject:       function ()
			{
				if (this.changeCounter > 0)
				{
					this.changeCounter--;
					if (this.changeCounter == 0)
					{
						this.ini.saveIni();
					}
				}
				return 0;
			},
			destroyRunObject:      function (bFast)
			{
				this.ini.saveIni();
			},

			// Actions
			// -------------------------------------------------
			action:                function (num, act)
			{
				switch (num)
				{
					case 0:
						this.SetCurrentGroup(act);
						break;
					case 1:
						this.SetCurrentItem(act);
						break;
					case 2:
						this.SetValue(act);
						break;
					case 3:
						this.SavePosition(act);
						break;
					case 4:
						this.LoadPosition(act);
						break;
					case 5:
						this.SetString(act);
						break;
					case 6:
						this.SetCurrentFile(act);
						break;
					case 7:
						this.SetValueItem(act);
						break;
					case 8:
						this.SetValueGroupItem(act);
						break;
					case 9:
						this.SetStringItem(act);
						break;
					case 10:
						this.SetStringGroupItem(act);
						break;
					case 11:
						this.DeleteItem(act);
						break;
					case 12:
						this.DeleteGroupItem(act);
						break;
					case 13:
						this.DeleteGroup(act);
						break;
				}
			},

			SetCurrentGroup: function (act)
			{
				this.iniCurrentGroup = act.getParamExpString(this.rh, 0);
			},

			SetCurrentItem: function (act)
			{
				this.iniCurrentItem = act.getParamExpString(this.rh, 0);
			},

			SetValue: function (act)
			{
				var value = act.getParamExpression(this.rh, 0);
				var s = value.toString();
				this.ini.writePrivateProfileString(this.iniCurrentGroup, this.iniCurrentItem, s, this.iniName);
				this.changeCounter = 10;
			},

			SavePosition: function (act)
			{
				var hoPtr = act.getParamObject(this.rh, 0);
				var s = hoPtr.hoX.toString() + "," + hoPtr.hoY.toString();
				var item = "pos." + hoPtr.hoOiList.oilName;
				this.ini.writePrivateProfileString(this.iniCurrentGroup, item, s, this.iniName);
				this.changeCounter = 10;
			},

			LoadPosition: function (act)
			{
				var hoPtr = act.getParamObject(this.rh, 0);
				var item = "pos." + hoPtr.hoOiList.oilName;
				var s = this.ini.getPrivateProfileString(this.iniCurrentGroup, item, "X", this.iniName);
				if (s != "X")
				{
					var virgule = s.indexOf(",");
					var left = s.substring(0, virgule);
					var right = s.substring(virgule + 1);
					hoPtr.hoX = parseInt(left, 10);
					if (isNaN(hoPtr.hoX))
						hoPtr.hoX = 0;
					hoPtr.hoY = parseInt(right, 10);
					if (isNaN(hoPtr.hoY))
						hoPtr.hoY = 0;
					hoPtr.roc.rcChanged = true;
					hoPtr.roc.rcCheckCollides = true;
				}
			},

			SetString: function (act)
			{
				var s = act.getParamExpString(this.rh, 0);
				this.ini.writePrivateProfileString(this.iniCurrentGroup, this.iniCurrentItem, s, this.iniName);
				this.changeCounter = 10;
			},

			SetCurrentFile: function (act)
			{
				this.iniName = CServices.parseName(act.getParamExpString(this.rh, 0));
			},

			SetValueItem: function (act)
			{
				var item = act.getParamExpString(this.rh, 0);
				var value = act.getParamExpression(this.rh, 1);
				var s = value.toString();
				this.ini.writePrivateProfileString(this.iniCurrentGroup, item, s, this.iniName);
				this.changeCounter = 10;
			},

			SetValueGroupItem: function (act)
			{
				var group = act.getParamExpString(this.rh, 0);
				var item = act.getParamExpString(this.rh, 1);
				var value = act.getParamExpression(this.rh, 2);
				var s = value.toString();
				this.ini.writePrivateProfileString(group, item, s, this.iniName);
				this.changeCounter = 10;
			},

			SetStringItem: function (act)
			{
				var item = act.getParamExpString(this.rh, 0);
				var s = act.getParamExpString(this.rh, 1);
				this.ini.writePrivateProfileString(this.iniCurrentGroup, item, s, this.iniName);
				this.changeCounter = 10;
			},

			SetStringGroupItem: function (act)
			{
				var group = act.getParamExpString(this.rh, 0);
				var item = act.getParamExpString(this.rh, 1);
				var s = act.getParamExpString(this.rh, 2);
				this.ini.writePrivateProfileString(group, item, s, this.iniName);
				this.changeCounter = 10;
			},

			DeleteItem: function (act)
			{
				this.ini.deleteItem(this.iniCurrentGroup, act.getParamExpString(this.rh, 0), this.iniName);
				this.changeCounter = 10;
			},

			DeleteGroupItem: function (act)
			{
				this.ini.deleteItem(act.getParamExpString(this.rh, 0), act.getParamExpString(this.rh, 1), this.iniName);
				this.changeCounter = 10;
			},

			DeleteGroup: function (act)
			{
				this.ini.deleteGroup(act.getParamExpString(this.rh, 0), this.iniName);
				this.changeCounter = 10;
			},

			// Expressions
			// --------------------------------------------
			expression:  function (num)
			{
				switch (num)
				{
					case 0:
						return this.GetValue();
					case 1:
						return this.GetString();
					case 2:
						return this.GetValueItem();
					case 3:
						return this.GetValueGroupItem();
					case 4:
						return this.GetStringItem();
					case 5:
						return this.GetStringGroupItem();
				}
				return null;
			},

			GetValue: function ()
			{
				var s = this.ini.getPrivateProfileString(this.iniCurrentGroup, this.iniCurrentItem, "", this.iniName);
				var value = 0;
				value = parseInt(s, 10);
				if (isNaN(value))
					value = 0;
				return (value);
			},

			GetString: function ()
			{
				return this.ini.getPrivateProfileString(this.iniCurrentGroup, this.iniCurrentItem, "", this.iniName);
			},

			GetValueItem: function ()
			{
				var item = this.ho.getExpParam();
				var s = this.ini.getPrivateProfileString(this.iniCurrentGroup, item, "", this.iniName);
				var value = parseInt(s, 10);
				if (isNaN(value))
					value = 0;
				return (value);
			},

			GetValueGroupItem: function ()
			{
				var group = this.ho.getExpParam();
				var item = this.ho.getExpParam();
				var s = this.ini.getPrivateProfileString(group, item, "", this.iniName);
				var value = parseInt(s, 10);
				;
				if (isNaN(value))
					value = 0;
				return (value);
			},

			GetStringItem: function ()
			{
				var item = this.ho.getExpParam();
				return this.ini.getPrivateProfileString(this.iniCurrentGroup, item, "", this.iniName);
			},

			GetStringGroupItem: function ()
			{
				var group = this.ho.getExpParam();
				var item = this.ho.getExpParam();
				return this.ini.getPrivateProfileString(group, item, "", this.iniName);
			}
		});


	//----------------------------------------------------------------------------------
	//
	// CRunparser : stringparser
	//
	//----------------------------------------------------------------------------------
	this.parser = CRunparser;

	CRunparser.CASE_INSENSITIVE = 0;
	CRunparser.SEARCH_LITERAL = 0;

	CRunparser.CND_ISURLSAFE = 0;
	CRunparser.ACT_SETSTRING = 0;
	CRunparser.ACT_SAVETOFILE = 1;
	CRunparser.ACT_LOADFROMFILE = 2;
	CRunparser.ACT_APPENDTOFILE = 3;
	CRunparser.ACT_APPENDFROMFILE = 4;
	CRunparser.ACT_RESETDELIMS = 5;
	CRunparser.ACT_ADDDELIM = 6;
	CRunparser.ACT_SETDELIM = 7;
	CRunparser.ACT_DELETEDELIMINDEX = 8;
	CRunparser.ACT_DELETEDELIM = 9;
	CRunparser.ACT_SETDEFDELIMINDEX = 10;
	CRunparser.ACT_SETDEFDELIM = 11;
	CRunparser.ACT_SAVEASCSV = 12;
	CRunparser.ACT_LOADFROMCSV = 13;
	CRunparser.ACT_SAVEASMMFARRAY = 14;
	CRunparser.ACT_LOADFROMMMFARRAY = 15;
	CRunparser.ACT_SAVEASDYNAMICARRAY = 16;
	CRunparser.ACT_LOADFROMDYNAMICARRAY = 17;
	CRunparser.ACT_CASEINSENSITIVE = 18;
	CRunparser.ACT_CASESENSITIVE = 19;
	CRunparser.ACT_SEARCHLITERAL = 20;
	CRunparser.ACT_SEARCHWILDCARDS = 21;
	CRunparser.ACT_SAVEASINI = 22;
	CRunparser.ACT_LOADFROMINI = 23;
	CRunparser.EXP_GETSTRING = 0;
	CRunparser.EXP_GETLENGTH = 1;
	CRunparser.EXP_LEFT = 2;
	CRunparser.EXP_RIGHT = 3;
	CRunparser.EXP_MIDDLE = 4;
	CRunparser.EXP_NUMBEROFSUBS = 5;
	CRunparser.EXP_INDEXOFSUB = 6;
	CRunparser.EXP_INDEXOFFIRSTSUB = 7;
	CRunparser.EXP_INDEXOFLASTSUB = 8;
	CRunparser.EXP_REMOVE = 9;
	CRunparser.EXP_REPLACE = 10;
	CRunparser.EXP_INSERT = 11;
	CRunparser.EXP_REVERSE = 12;
	CRunparser.EXP_UPPERCASE = 13;
	CRunparser.EXP_LOWERCASE = 14;
	CRunparser.EXP_URLENCODE = 15;
	CRunparser.EXP_CHR = 16;
	CRunparser.EXP_ASC = 17;
	CRunparser.EXP_ASCLIST = 18;
	CRunparser.EXP_NUMBEROFDELIMS = 19;
	CRunparser.EXP_GETDELIM = 20;
	CRunparser.EXP_GETDELIMINDEX = 21;
	CRunparser.EXP_GETDEFDELIM = 22;
	CRunparser.EXP_GETDEFDELIMINDEX = 23;
	CRunparser.EXP_LISTCOUNT = 24;
	CRunparser.EXP_LISTSETAT = 25;
	CRunparser.EXP_LISTINSERTAT = 26;
	CRunparser.EXP_LISTAPPEND = 27;
	CRunparser.EXP_LISTPREPEND = 28;
	CRunparser.EXP_LISTGETAT = 29;
	CRunparser.EXP_LISTFIRST = 30;
	CRunparser.EXP_LISTLAST = 31;
	CRunparser.EXP_LISTFIND = 32;
	CRunparser.EXP_LISTCONTAINS = 33;
	CRunparser.EXP_LISTDELETEAT = 34;
	CRunparser.EXP_LISTSWAP = 35;
	CRunparser.EXP_LISTSORTASC = 36;
	CRunparser.EXP_LISTSORTDESC = 37;
	CRunparser.EXP_LISTCHANGEDELIMS = 38;
	CRunparser.EXP_SETSTRING = 39;
	CRunparser.EXP_SETVALUE = 40;
	CRunparser.EXP_GETMD5 = 41;

	function CRunparser()
	{
		this.source = "";
		this.caseSensitive = false;
		this.wildcards = false;
		this.delims = new CArrayList(); //Strings
		this.defaultDelim = "";
		this.tokensE = new CArrayList(); //parserElement
	}

	CRunparser.prototype = CServices.extend(new CRunExtension(),
		{
			getNumberOfConditions: function ()
			{
				return 1;
			},

			fixString: function (input)
			{
				var i;
				for (i = 0; i < input.length; i++)
				{
					if (input.charCodeAt(i) < 10)
					{
						return input.substring(0, i);
					}
				}
				return input;
			},

			createRunObject: function (file, cob, version)
			{
				file.setUnicode(false);
				file.skipBytes(4);
				this.source = this.fixString(file.readAString(1025));
				var nComparison = file.readAShort();
				if (nComparison == CRunparser.CASE_INSENSITIVE)
				{
					this.caseSensitive = false;
				}
				else
				{
					this.caseSensitive = true;
				}
				var nSearchMode = file.readAShort();
				if (nSearchMode == CRunparser.SEARCH_LITERAL)
				{
					this.wildcards = false;
				}
				else
				{
					this.wildcards = true;
				}
				return true;
			},

			redoTokens: function ()
			{
				this.tokensE.clear();
				var sourceToTest = this.source;
				var i;
				if (!sourceToTest == "")
				{
					var lastTokenLocation = 0;
					var work = true;
					while (work)
					{
						var aTokenE = new CArrayList(); //parserElement
						var aDelim = new CArrayList(); //String
						var j;
						for (j = 0; j < this.delims.size(); j++)
						{
							var delim = String(this.delims.get(j));
							var index = this.getSubstringIndex(sourceToTest, delim, 0);
							if (index != -1)
							{
								aTokenE.add(new CRunparserElement(sourceToTest.substring(0, index), lastTokenLocation));
								aDelim.add(delim);
							}
						}
						//pick smallest token
						var smallestC = 1000000;
						var smallest = -1;
						for (j = 0; j < aTokenE.size(); j++)
						{
							if (aTokenE.get(j).text.length < smallestC)
							{
								smallestC = aTokenE.get(j).text.length;
								smallest = j;
							}
						}
						if (smallest != -1)
						{
							this.tokensE.add(aTokenE.get(smallest));
							sourceToTest = sourceToTest.substring(
								((aTokenE.get(smallest))).text.length +
									( (aDelim.get(smallest))).length);
							lastTokenLocation += ( (aTokenE.get(smallest))).text.length +
								( (aDelim.get(smallest))).length;
						}
						else
						{
							//if at end of search, add remainder
							this.tokensE.add(new CRunparserElement(sourceToTest, lastTokenLocation));
							work = false;
						}
					}
					for (i = 0; i < this.tokensE.size(); i++)
					{
						//remove ""
						var e = this.tokensE.get(i);
						if (e.text == "")
						{
							this.tokensE.removeIndex(i);
							i--;
						}
					}
				}
			},

			getSubstringIndex: function (sourceLocal, find, occurance)
			{ //occurance is 0-based
				var theSource = sourceLocal;
				if (theSource.length == 0)
				{
					return -1;
				}
				if (!this.caseSensitive)
				{
					theSource = theSource.toLowerCase();
					find = find.toLowerCase();
				}
				var i, j;
				if (this.wildcards)
				{
					var st = new CTokenizer(find, "*");
					var ct = st.countTokens();
					var asteriskless = new Array(ct);
					for (i = 0; i < ct; i++)
					{
						asteriskless[i] = st.nextToken();
					}
					var lastOccurance = -1;
					var occ;
					for (occ = 0; occ <= occurance; occ++)
					{
						var asterisklessLocation = new Array(ct);
						var asterisk;
						for (asterisk = 0; asterisk < ct; asterisk++)
						{
							for (i = 0; i < theSource.length; i++)
							{
								var findThis = asteriskless[asterisk];
								//replace "?" occurances with chars from sourceLocal
								for (j = 0; j < findThis.length; j++)
								{
									if (findThis.substring(j, j + 1) == "?")
									{
										if (i + j < theSource.length)
										{
											findThis = findThis.substring(0, j) +
												theSource.substring(i + j, i + j + 1) +
												findThis.substring(j + 1);
										}
									}
								}
								if ((asterisk == 0) || (asterisklessLocation[asterisk - 1] == -1))
								{
									asterisklessLocation[asterisk] = theSource.indexOf(findThis, lastOccurance + 1);
								}
								else
								{
									asterisklessLocation[asterisk] = theSource.indexOf(findThis, asterisklessLocation[asterisk - 1]);
								}
								if (asterisklessLocation[asterisk] != -1)
								{
									i = theSource.length; //stop
								}
							}
						}
						//now each int in asterisklessLocation should be in an acsending order (lowest first)
						//if they are not, then the string wasn't found in the sourceLocal
						var last = -1;
						for (i = 0; i < ct; i++)
						{
							if (asterisklessLocation[i] > last)
							{
								last = asterisklessLocation[i];
							}
							else
							{
								lastOccurance = -1;
								i = ct; //stop
							}
						}
						if ((occ == 0) || (lastOccurance != -1))
						{
							if (asterisklessLocation.length > 0)
							{
								lastOccurance = asterisklessLocation[0];
							}
							else
							{
								lastOccurance = -1;
							}
						}
					}
					return lastOccurance;
				}
				else
				{ //no this.wildcards
					var lastIndex = -1;
					for (i = 0; i <= occurance; i++)
					{
						lastIndex = theSource.indexOf(find, lastIndex + 1);
					}
					return lastIndex;
				}
			},

			substringMatches: function (sourceLocal, find)
			{
				var theSource = sourceLocal;
				if (!this.caseSensitive)
				{
					theSource = theSource.toLowerCase();
					find = find.toLowerCase();
				}
				var i, j;
				if (this.wildcards)
				{
					var st = new CTokenizer(find, "*");
					var ct = st.countTokens();
					var asteriskless = new Array(ct);
					for (i = 0; i < ct; i++)
					{
						asteriskless[i] = st.nextToken();
					}
					var asterisklessLocation = new Array(ct);
					var asterisk;
					for (asterisk = 0; asterisk < ct; asterisk++)
					{
						for (i = 0; i < theSource.length; i++)
						{
							var findThis = asteriskless[asterisk];
							//replace "?" occurances with chars from sourceLocal
							for (j = 0; j < findThis.length; j++)
							{
								if (findThis.substring(j, j + 1) == "?")
								{
									if (i + j < theSource.length)
									{
										findThis = findThis.substring(0, j) +
											theSource.substring(i + j, i + j + 1) +
											findThis.substring(j + 1);
									}
								}
							}
							if ((asterisk == 0) || (asterisklessLocation[asterisk - 1] == -1))
							{
								asterisklessLocation[asterisk] = theSource.indexOf(findThis);
							}
							else
							{
								asterisklessLocation[asterisk] = theSource.indexOf(findThis, asterisklessLocation[asterisk - 1]);
							}
							if (asterisklessLocation[asterisk] != -1)
							{
								i = theSource.length; //stop
							}
						}
					}
					//now each int in asterisklessLocation should be in an acsending order (lowest first)
					//if they are not, then the string wasn't found in the sourceLocal
					var last = -1;
					var ok = true;
					for (i = 0; i < ct; i++)
					{
						if (asterisklessLocation[i] > last)
						{
							last = asterisklessLocation[i];
						}
						else
						{
							i = ct; //stop
							ok = false;
						}
					}
					if ((ok) && (find.length > 0) && (asterisklessLocation.length > 0))
					{
						if (this.getSubstringIndex(theSource, find, 1) == -1)
						{ //no other occurances
							if (find.substring(0, 1) == "*")
							{
								if (find.substring(find.length - 1) == "*")
								{
									//if it starts with a * and ends with a *
									return true;
								}
								else
								{
									//if last element is at the end of the sourceLocal
									if (asterisklessLocation[ct - 1] + asteriskless[ct - 1].length == theSource.length)
									{
										return true;
									}
								}
							}
							else
							{
								if (asterisklessLocation[0] == 0)
								{
									if (find.substring(find.length - 1) == "*")
									{
										//if it starts with a * and ends with a *
										return true;
									}
									else
									{
										//if last element is at the end of the sourceLocal
										if (asterisklessLocation[ct - 1] + asteriskless[ct - 1].length == theSource.length)
										{
											return true;
										}
									}
								}
							}
						}
					}
				}
				else
				{ //no this.wildcards
					if ((theSource.length == find.length) && (theSource.indexOf(find, 0) == 0))
					{
						return true;
					}
				}
				return false;
			},

			condition: function (num, cnd)
			{
				if (num == CRunparser.CND_ISURLSAFE)
				{
					var index;
					for (index = 0; index < this.source.length; index++)
					{
						while (!this.isLetterOrDigit(this.source.charCodeAt(index)))
						{
							if (this.source.charCodeAt(index) == 43)
							{
								break;
							}
							else if (this.source.charCodeAt(index) == 37)
							{
								if (this.source.length > index + 2)
								{
									if (this.isLetterOrDigit(this.source.charCodeAt(index + 1)) &&
										this.isLetterOrDigit(this.source.charCodeAt(index + 2)))
									{
										index = index + 2;
									}
									else
									{
										return false;
									}
									break;
								}
								else
								{
									return false;
								}
							}
							else
							{
								return false;
							}
						}
					}
					return true;
				}
				return false;
			},

			action: function (num, act)
			{
				switch (num)
				{
					case CRunparser.ACT_SETSTRING:
						this.source = act.getParamExpString(this.rh, 0);
						this.redoTokens();
						break;
					case CRunparser.ACT_SAVETOFILE:
						break;
					case CRunparser.ACT_LOADFROMFILE:
						break;
					case CRunparser.ACT_APPENDTOFILE:
						break;
					case CRunparser.ACT_APPENDFROMFILE:
						break;
					case CRunparser.ACT_RESETDELIMS:
						this.delims.clear();
						break;
					case CRunparser.ACT_ADDDELIM:
						this.SP_addDelim(act.getParamExpString(this.rh, 0));
						break;
					case CRunparser.ACT_SETDELIM:
						this.SP_setDelim(act.getParamExpString(this.rh, 0), act.getParamExpression(this.rh, 1));
						break;
					case CRunparser.ACT_DELETEDELIMINDEX:
						this.SP_deleteDelimIndex(act.getParamExpression(this.rh, 0));
					case CRunparser.ACT_DELETEDELIM:
						this.SP_deleteDelim(act.getParamExpString(this.rh, 0));
						break;
					case CRunparser.ACT_SETDEFDELIMINDEX:
						this.SP_setDefDelimIndex(act.getParamExpression(this.rh, 0));
						break;
					case CRunparser.ACT_SETDEFDELIM:
						this.SP_setDefDelim(act.getParamExpString(this.rh, 0));
						break;
					case CRunparser.ACT_SAVEASCSV:
						break;
					case CRunparser.ACT_LOADFROMCSV:
						break;
					case CRunparser.ACT_SAVEASMMFARRAY:
						break;
					case CRunparser.ACT_LOADFROMMMFARRAY:
						break;
					case CRunparser.ACT_SAVEASDYNAMICARRAY:
						break;
					case CRunparser.ACT_LOADFROMDYNAMICARRAY:
						break;
					case CRunparser.ACT_CASEINSENSITIVE:
						this.caseSensitive = false;
						this.redoTokens();
						break;
					case CRunparser.ACT_CASESENSITIVE:
						this.caseSensitive = true;
						this.redoTokens();
						break;
					case CRunparser.ACT_SEARCHLITERAL:
						this.wildcards = false;
						this.redoTokens();
						break;
					case CRunparser.ACT_SEARCHWILDCARDS:
						this.wildcards = true;
						this.redoTokens();
						break;
					case CRunparser.ACT_SAVEASINI:
						break;
					case ACT_LOADFROMINI:
						break;
				}
			},

			SP_addDelim: function (delim)
			{
				if (!delim == "")
				{
					var exists = false;
					var i;
					for (i = 0; i < this.delims.size(); i++)
					{
						var thisDelim = (this.delims.get(i));
						if (this.getSubstringIndex(thisDelim, delim, 0) >= 0)
						{
							exists = true;
						}
					}
					if (exists == false)
					{
						this.delims.add(delim);
						this.redoTokens();
						this.defaultDelim = delim;
					}
				}
			},

			SP_setDelim: function (delim, index)
			{
				if (index == this.delims.size())
				{
					this.delims.add(delim);
					this.defaultDelim = delim;
					this.redoTokens();
				}
				else if ((index >= 0) && (index < this.delims.size()))
				{
					this.delims.set(index, delim);
					this.defaultDelim = delim;
					this.redoTokens();
				}
			},

			SP_deleteDelimIndex: function (index)
			{
				if ((index >= 0) && (index < this.delims.size()))
				{
					this.delims.removeIndex(index);
					if (index < this.delims.size())
					{
						this.defaultDelim = (this.delims.get(index));
					}
					else
					{
						this.defaultDelim = null;
					}
					this.redoTokens();
				}
			},

			SP_deleteDelim: function (delim)
			{
				var i;
				for (i = 0; i < this.delims.size(); i++)
				{
					if (( (this.delims.get(i))) == delim)
					{
						this.delims.removeIndex(i);
						if (i < this.delims.size())
						{
							this.defaultDelim = (this.delims.get(i));
						}
						else
						{
							this.defaultDelim = null;
						}
						this.redoTokens();
						return;
					}
				}
			},

			SP_setDefDelimIndex: function (index)
			{
				if ((index >= 0) && (index < this.delims.size()))
				{
					this.defaultDelim = (this.delims.get(index));
				}
			},

			SP_setDefDelim: function (delim)
			{
				var i;
				for (i = 0; i < this.delims.size(); i++)
				{
					if (( (this.delims.get(i))) == delim)
					{
						this.defaultDelim = (this.delims.get(i));
						return;
					}
				}

			    // If the delimiter doesn't exist, add it
				this.delims.add(delim);
				this.defaultDelim = delim;
				this.redoTokens();
			},

			// Expressions
			// ----------------------------------------------------------------------------
			expression:     function (num)
			{
				var ret;
				switch (num)
				{
					case CRunparser.EXP_GETSTRING:
						return this.source;
					case CRunparser.EXP_GETLENGTH:
						return (this.source.length);
					case CRunparser.EXP_LEFT:
						return this.SP_left(this.ho.getExpParam());
					case CRunparser.EXP_RIGHT:
						return this.SP_right(this.ho.getExpParam());
					case CRunparser.EXP_MIDDLE:
						return this.SP_middle(this.ho.getExpParam(), this.ho.getExpParam());
					case CRunparser.EXP_NUMBEROFSUBS:
						return this.SP_numberOfSubs(this.ho.getExpParam());
					case CRunparser.EXP_INDEXOFSUB:
						return this.SP_indexOfSub(this.ho.getExpParam(), this.ho.getExpParam());
					case CRunparser.EXP_INDEXOFFIRSTSUB:
						return this.SP_indexOfFirstSub(this.ho.getExpParam());
					case CRunparser.EXP_INDEXOFLASTSUB:
						return this.SP_indexOfLastSub(this.ho.getExpParam());
					case CRunparser.EXP_REMOVE:
						return this.SP_remove(this.ho.getExpParam());
					case CRunparser.EXP_REPLACE:
						return this.SP_replace(this.ho.getExpParam(), this.ho.getExpParam());
					case CRunparser.EXP_INSERT:
						return this.SP_insert(this.ho.getExpParam(), this.ho.getExpParam());
					case CRunparser.EXP_REVERSE:
						return this.SP_reverse();
					case CRunparser.EXP_UPPERCASE:
						return this.source.toUpperCase();
					case CRunparser.EXP_LOWERCASE:
						return this.source.toLowerCase();
					case CRunparser.EXP_URLENCODE:
						return this.SP_urlEncode();
					case CRunparser.EXP_CHR:
						return this.SP_chr(this.ho.getExpParam());
					case CRunparser.EXP_ASC:
						return this.SP_asc(this.ho.getExpParam());
					case CRunparser.EXP_ASCLIST:
						return this.SP_ascList(this.ho.getExpParam());
					case CRunparser.EXP_NUMBEROFDELIMS:
						return (this.delims.size());
					case CRunparser.EXP_GETDELIM:
						return this.SP_getDelim(this.ho.getExpParam());
					case CRunparser.EXP_GETDELIMINDEX:
						return this.SP_getDelimIndex(this.ho.getExpParam());
					case CRunparser.EXP_GETDEFDELIM:
						return this.SP_getDefDelim();
					case CRunparser.EXP_GETDEFDELIMINDEX:
						return this.SP_getDefDelimIndex();
					case CRunparser.EXP_LISTCOUNT:
						return (this.tokensE.size());
					case CRunparser.EXP_LISTSETAT:
						return this.SP_listSetAt(this.ho.getExpParam(), this.ho.getExpParam());
					case CRunparser.EXP_LISTINSERTAT:
						return this.SP_listInsertAt(this.ho.getExpParam(), this.ho.getExpParam());
					case CRunparser.EXP_LISTAPPEND:
					    return (this.source + ((this.delims.size() > 0 && this.source.length > 0) ? this.delims.get(0) : "") + this.ho.getExpParam());
					case CRunparser.EXP_LISTPREPEND:
					    return (this.ho.getExpParam() + ((this.delims.size() > 0 && this.source.length > 0) ? this.delims.get(0) : "") + this.source);
					case CRunparser.EXP_LISTGETAT:
						return this.SP_listGetAt(this.ho.getExpParam());
					case CRunparser.EXP_LISTFIRST:
						return this.SP_listFirst();
					case CRunparser.EXP_LISTLAST:
						return this.SP_listLast();
					case CRunparser.EXP_LISTFIND: //matching
						return this.SP_listFind(this.ho.getExpParam(), this.ho.getExpParam());
					case CRunparser.EXP_LISTCONTAINS:
						return this.SP_listContains(this.ho.getExpParam(), this.ho.getExpParam());
					case CRunparser.EXP_LISTDELETEAT:
						return this.SP_listDeleteAt(this.ho.getExpParam());
					case CRunparser.EXP_LISTSWAP:
						return this.SP_listSwap(this.ho.getExpParam(), this.ho.getExpParam());
					case CRunparser.EXP_LISTSORTASC:
						return this.SP_listSortAsc();
					case CRunparser.EXP_LISTSORTDESC:
						return this.SP_listSortDesc();
					case CRunparser.EXP_LISTCHANGEDELIMS:
						return this.SP_listChangeDelims(this.ho.getExpParam());
					case CRunparser.EXP_SETSTRING:
						return this.SP_setStringEXP(this.ho.getExpParam());
					case CRunparser.EXP_SETVALUE:
						return this.SP_setValueEXP(this.ho.getExpParam());
					case CRunparser.EXP_GETMD5:
						return this.SP_getMD5();
				}
				return (0);//won't be used
			},

			SP_left: function (i)
			{
				var ret = "";
				if ((i >= 0) && (i <= this.source.length))
				{
					ret = (this.source.substring(0, i));
				}
				return ret;
			},

			SP_right: function (i)
			{
				var ret = "";
				var i;
				if ((i >= 0) && (i <= this.source.length))
				{
					ret = (this.source.substring(this.source.length - i));
				}
				return ret;
			},

			SP_middle: function (i, length)
			{
				var ret = "";
				length = Math.max(0, length);
				var i;
				if ((i >= 0) && (i + length <= this.source.length))
				{
					ret = (this.source.substring(i, i + length));
				}
				return ret;
			},

			SP_numberOfSubs: function (sub)
			{
				var count = 0;
				while (this.getSubstringIndex(this.source, sub, count) != -1)
				{
					count++;
				}
				return (count);
			},

			SP_indexOfSub: function (sub, occurance)
			{ //1-based
				occurance = Math.max(1, occurance);
				return (this.getSubstringIndex(this.source, sub, occurance - 1));
			},

			SP_indexOfFirstSub: function (sub)
			{
				return (this.getSubstringIndex(this.source, sub, 0));
			},

			SP_indexOfLastSub: function (sub)
			{
				var n = Math.max(1, SP_numberOfSubs(sub));
				return (this.getSubstringIndex(this.source, sub, n - 1));
			},

			SP_remove: function (sub)
			{
				var ret = "";
				var count = 0;
				var parts = new CArrayList(); //Integer
				var index = this.getSubstringIndex(this.source, sub, count);
				while (index != -1)
				{
					parts.add(index);
					count++;
					index = this.getSubstringIndex(this.source, sub, count);
				}
				if (parts.size() == 0)
				{
					ret = (this.source);
					return ret;
				}
				var last = 0;
				var r = "";
				var i;
				for (i = 0; i < parts.size(); i++)
				{
					r += this.source.substring(last, (parts.get(i)));
					last = ( (parts.get(i)) ) + sub.length;
					if (i == parts.size() - 1)
					{
						r += this.source.substring(last);
					}
				}
				ret = r;
				return ret;
			},

			SP_replace: function (old, newString)
			{
				var ret = "";

				var count = 0;
				var parts = new CArrayList(); //Integer
				var index = this.getSubstringIndex(this.source, old, count);
				while (index != -1)
				{
					parts.add(index);
					count++;
					index = this.getSubstringIndex(this.source, old, count);
				}
				if (parts.size() == 0)
				{
					ret = (this.source);
					return ret;
				}
				var last = 0;
				var r = "";
				var i;
				for (i = 0; i < parts.size(); i++)
				{
					r += this.source.substring(last, (parts.get(i))) + newString;
					last = (parts.get(i)) + old.length;
					if (i == parts.size() - 1)
					{
						r += this.source.substring(last);
					}
				}
				ret = (r);
				return ret;
			},

			SP_insert: function (insert, index)
			{
				var ret = "";
				if ((index >= 1) && (index <= this.source.length))
				{
					ret = (this.source.substring(0, index - 1) + insert + this.source.substring(index - 1));
				}
				return ret;
			},

			SP_reverse: function ()
			{
				var ret = "";
				var r = "";
				var i;
				for (i = this.source.length - 1; i >= 0; i--)
				{
					r += this.source.substring(i, i + 1);
				}
				ret = (r);
				return ret;
			},

			SP_urlEncode: function ()
			{
				var r = "";
				var i;
				for (i = 0; i < this.source.length; i++)
				{
					if (this.isLetterOrDigit(this.source.charCodeAt(i)))
					{
						r += this.source.substring(i, i + 1);
					}
					else
					{
						if (this.isSpaceChar(this.source.charCodeAt(i)))
						{
							r += "+";
						}
						else if (this.source.charCodeAt(i) == 13)
						{
							r += "+";
							i++;
						}
						else
						{
							r += "%";
							r += (this.source.charCodeAt(i) >> 4).toString(16);
							r += (this.source.charCodeAt(i) % 16).toString(16);
						}
					}
				}
				return r;
			},

			SP_chr: function (value)
			{
				return String.fromCharCode(value);
			},

			SP_asc: function (value)
			{
				if (value.length > 0)
				{
					var r = value.charCodeAt(0);
					return (r);
				}
				return (0);
			},

			SP_ascList: function (delim)
			{
				var r = "";
				var i;
				for (i = 0; i < this.source.length; i++)
				{
					r += (this.source.charCodeAt(i)).toString();
					if (i < this.source.length - 1)
					{
						r += delim;
					}
				}
				return r;
			},

			SP_getDelim: function (i)
			{ //0-based, silly 3ee
				var ret = "";
				if ((i >= 0) && (i < this.delims.size()))
				{
					ret = ( String(this.delims.get(i)) );
				}
				return ret;
			},

			SP_getDelimIndex: function (delim)
			{
				var i;
				for (i = 0; i < this.delims.size(); i++)
				{
					var thisDelim = String(this.delims.get(i));
					if (this.getSubstringIndex(thisDelim, delim, 0) >= 0)
					{
						return (i);
					}
				}
				return (-1);
			},

			SP_getDefDelim: function ()
			{
				var ret = "";
				if (this.defaultDelim != null)
				{
					ret = (this.defaultDelim);
				}
				return ret;
			},

			SP_getDefDelimIndex: function ()
			{
				if (this.defaultDelim != null)
				{
					var i;
					for (i = 0; i < this.delims.size(); i++)
					{
						var thisDelim = String(this.delims.get(i));
						if (this.getSubstringIndex(thisDelim, this.defaultDelim, 0) >= 0)
						{
							return (i);
						}
					}
				}
				return (-1);
			},

			SP_listSetAt: function (replace, index)
			{ //1-based
				var ret = "";
				if ((index >= 1) && (index <= this.tokensE.size()))
				{
					var e = (this.tokensE.get(index - 1));
					var r = this.source.substring(0, e.index) + replace + this.source.substring(e.endIndex);
					ret = (r);
				}
				return ret;
			},

			SP_listInsertAt: function (insert, index)
			{ //1-based
				var ret = (0);
				ret = "";
				if ((index >= 1) && (index <= this.tokensE.size()))
				{
					var e = (this.tokensE.get(index - 1));
					var r = this.source.substring(0, e.index) + insert + this.source.substring(e.index);
					ret = (r);
				}
				return ret;
			},

			SP_listGetAt: function (index)
			{ //1-based
				var ret = "";
				if ((index >= 1) && (index <= this.tokensE.size()))
				{
					var e = (this.tokensE.get(index - 1));
					ret = (e.text);
				}
				return ret;
			},

			SP_listFirst: function ()
			{
				var ret = "";
				if (this.tokensE.size() > 0)
				{
					var e = (this.tokensE.get(0));
					ret = (e.text);
				}
				return ret;
			},

			SP_listLast: function ()
			{
				var ret = "";
				if (this.tokensE.size() > 0)
				{
					var e = (this.tokensE.get(this.tokensE.size() - 1));
					ret = (e.text);
				}
				return ret;
			},

			SP_listFind: function (find, occurance)
			{ //matching //1-based
				if ((occurance > 0) && (find.length > 0))
				{
					var occuranceCount = 0;
					var i;
					for (i = 0; i < this.tokensE.size(); i++)
					{
						var e = (this.tokensE.get(i));
						if (this.substringMatches(e.text, find))
						{
							occuranceCount++;
						}
						if (occuranceCount == occurance)
						{
							return (i + 1);
						}
					}
				}
				return (0);
			},

			SP_listContains: function (find, occurance)
			{ //matching //1-based
				if ((occurance > 0) && (find.length > 0))
				{
					var occuranceCount = 0;
					var i;
					for (i = 0; i < this.tokensE.size(); i++)
					{
						var e = (this.tokensE.get(i));
						if (this.getSubstringIndex(e.text, find, 0) != -1)
						{
							occuranceCount++;
						}
						if (occuranceCount == occurance)
						{
							return (i + 1);
						}
					}
				}
				return (0);
			},

			SP_listDeleteAt: function (index)
			{ //1-based
				var ret = (0);
				ret = "";
				if ((index >= 1) && (index <= this.tokensE.size()))
				{
					var e = (this.tokensE.get(index - 1));
					var r = this.source.substring(0, e.index) + this.source.substring(e.endIndex);
					ret = (r);
				}
				return ret;
			},

			SP_listSwap: function (i1, i2)
			{ //1-based
				var ret = (0);
				ret = "";
				if ((i1 >= 1) && (i2 >= 1) && (i1 <= this.tokensE.size()) && (i2 <= this.tokensE.size()))
				{
					if (i1 == i2)
					{
						ret = (this.source);
						return ret;
					}
					var e1 = (this.tokensE.get(i1 - 1));
					var e2 = (this.tokensE.get(i2 - 1));
					var r = "";
					if (i1 > i2)
					{
						//e2 comes sooner
						r += this.source.substring(0, e2.index); //string leading up to e2
						r += this.source.substring(e1.index, e1.endIndex); //e1
						r += this.source.substring(e2.endIndex, e1.index); //string between e2 and e1
						r += this.source.substring(e2.index, e2.endIndex); //e2
						r += this.source.substring(e1.endIndex); //string from end of e1 to end
					}
					else
					{ //i1 < i2
						//e1 comes sooner
						r += this.source.substring(0, e1.index); //string leading up to e1
						r += this.source.substring(e2.index, e2.endIndex); //e2
						r += this.source.substring(e1.endIndex, e2.index); //string between e1 and e2
						r += this.source.substring(e1.index, e1.endIndex); //e1
						r += this.source.substring(e2.endIndex); //string from end of e2 to end
					}
					ret = (r);
				}
				return ret;
			},

			SP_listSortAsc: function ()
			{
				var e;
				var sorted = new CArrayList(); //parserElement
				var i;
				for (i = 0; i < this.tokensE.size(); i++)
				{
					e = (this.tokensE.get(i));
					if (sorted.size() == 0)
					{
						sorted.add(e);
					}
					else
					{
						var index = 0;
						var j;
						for (j = 0; j < sorted.size(); j++)
						{
							var element = (sorted.get(j));
							if (this.caseSensitive)
							{
								if (this.compareStrings(e.text, element.text) >= 0)
								{
									index = j;
								}
							}
							else
							{
								if (CServices.compareStringsIgnoreCase(e.text, element.text))
								{
									index = j;
								}
							}
						}
						sorted.insert(index, e);
					}
				}
				var r = "";
				for (i = 0; i < sorted.size(); i++)
				{
					e = (sorted.get(i));
					var oe = (this.tokensE.get(i));
					if (i == 0)
					{
						r += this.source.substring(0, oe.index);
					}
					else
					{
						var lastOrigE = (this.tokensE.get(i - 1));
						r += this.source.substring(lastOrigE.endIndex, oe.index);
					}
					r += this.source.substring(e.index, e.endIndex);
					if (i == sorted.size() - 1)
					{
						r += this.source.substring(oe.endIndex);
					}
				}
				return r;
			},

			SP_listSortDesc: function ()
			{
				var sorted = new CArrayList(); //parserElement
				var i;
				var e;
				for (i = 0; i < this.tokensE.size(); i++)
				{
					e = (this.tokensE.get(i));
					if (sorted.size() == 0)
					{
						sorted.add(e);
					}
					else
					{
						var index = sorted.size();
						var j;
						for (j = sorted.size() - 1; j >= 0; j--)
						{
							var element = (sorted.get(j));
							if (this.caseSensitive)
							{
								if (this.compareStrings(e.text, element.text) >= 0)
								{
									index = j;
								}
							}
							else
							{
								if (CServices.compareStringsIgnoreCase(e.text, element.text))
								{
									index = j;
								}
							}
						}
						sorted.insert(index, e);
					}
				}
				var r = "";
				for (i = 0; i < sorted.size(); i++)
				{
					e = (sorted.get(i));
					var oe = (this.tokensE.get(i));
					if (i == 0)
					{
						r += this.source.substring(0, oe.index);
					}
					else
					{
						var lastOrigE = (this.tokensE.get(i - 1));
						r += this.source.substring(lastOrigE.endIndex, oe.index);
					}
					r += this.source.substring(e.index, e.endIndex);
					if (i == sorted.size() - 1)
					{
						r += this.source.substring(oe.endIndex);
					}
				}
				return r;
			},

			SP_listChangeDelims: function (changeDelim)
			{
				var ret = "";
				if (this.defaultDelim != null)
				{
					var r = "";
					var i;
					for (i = 0; i < this.tokensE.size(); i++)
					{
						var e = (this.tokensE.get(i));
						var here = e.index - this.defaultDelim.length;
						if ((here >= 0) && this.source.substring(here, e.index) == this.defaultDelim)
						{
							r += changeDelim;
						}
						else
						{
							if (i == 0)
							{
								r += this.source.substring(0, e.index);
							}
							else
							{
								var lastOrigE = (this.tokensE.get(i - 1));
								r += this.source.substring(lastOrigE.endIndex, e.index);
							}
						}
						r += this.source.substring(e.index, e.endIndex);
						if (i == this.tokensE.size() - 1)
						{
							if (this.source.substring(e.endIndex) == this.defaultDelim)
							{
								r += changeDelim;
							}
							else
							{
								r += this.source.substring(e.endIndex);
							}
						}
					}
					ret = (r);
				}
				return ret;
			},

			SP_setStringEXP: function (newSource)
			{
				this.source = newSource;
				this.redoTokens();
				return "";
			},

			SP_setValueEXP: function (newSource)
			{
				this.source = newSource;
				this.redoTokens();
				return (0);
			},

			SP_getMD5: function ()
			{
				return this.MD5(this.source);
			},

			MD5:             function (string)
			{

				function RotateLeft(lValue, iShiftBits)
				{
					return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
				}

				function AddUnsigned(lX, lY)
				{
					var lX4, lY4, lX8, lY8, lResult;
					lX8 = (lX & 0x80000000);
					lY8 = (lY & 0x80000000);
					lX4 = (lX & 0x40000000);
					lY4 = (lY & 0x40000000);
					lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
					if (lX4 & lY4)
					{
						return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
					}
					if (lX4 | lY4)
					{
						if (lResult & 0x40000000)
						{
							return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
						}
						else
						{
							return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
						}
					}
					else
					{
						return (lResult ^ lX8 ^ lY8);
					}
				}

				function F(x, y, z)
				{
					return (x & y) | ((~x) & z);
				}

				function G(x, y, z)
				{
					return (x & z) | (y & (~z));
				}

				function H(x, y, z)
				{
					return (x ^ y ^ z);
				}

				function I(x, y, z)
				{
					return (y ^ (x | (~z)));
				}

				function FF(a, b, c, d, x, s, ac)
				{
					a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
					return AddUnsigned(RotateLeft(a, s), b);
				}

				function GG(a, b, c, d, x, s, ac)
				{
					a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
					return AddUnsigned(RotateLeft(a, s), b);
				}

				function HH(a, b, c, d, x, s, ac)
				{
					a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
					return AddUnsigned(RotateLeft(a, s), b);
				}

				function II(a, b, c, d, x, s, ac)
				{
					a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
					return AddUnsigned(RotateLeft(a, s), b);
				}

				function ConvertToWordArray(string)
				{
					var lWordCount;
					var lMessageLength = string.length;
					var lNumberOfWords_temp1 = lMessageLength + 8;
					var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
					var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
					var lWordArray = new Array(lNumberOfWords - 1);
					var lBytePosition = 0;
					var lByteCount = 0;
					while (lByteCount < lMessageLength)
					{
						lWordCount = (lByteCount - (lByteCount % 4)) / 4;
						lBytePosition = (lByteCount % 4) * 8;
						lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition));
						lByteCount++;
					}
					lWordCount = (lByteCount - (lByteCount % 4)) / 4;
					lBytePosition = (lByteCount % 4) * 8;
					lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
					lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
					lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
					return lWordArray;
				}

				function WordToHex(lValue)
				{
					var WordToHexValue = "", WordToHexValue_temp = "", lByte, lCount;
					for (lCount = 0; lCount <= 3; lCount++)
					{
						lByte = (lValue >>> (lCount * 8)) & 255;
						WordToHexValue_temp = "0" + lByte.toString(16);
						WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
					}
					return WordToHexValue;
				}

				function Utf8Encode(string)
				{

					var utftext = "";

					for (var n = 0; n < string.length; n++)
					{

						var c = string.charCodeAt(n);

						if (c < 128)
						{
							utftext += String.fromCharCode(c);
						}
						else if ((c > 127) && (c < 2048))
						{
							utftext += String.fromCharCode((c >> 6) | 192);
							utftext += String.fromCharCode((c & 63) | 128);
						}
						else
						{
							utftext += String.fromCharCode((c >> 12) | 224);
							utftext += String.fromCharCode(((c >> 6) & 63) | 128);
							utftext += String.fromCharCode((c & 63) | 128);
						}

					}

					return utftext;
				}

				var x;
				var k, AA, BB, CC, DD, a, b, c, d;
				var S11 = 7, S12 = 12, S13 = 17, S14 = 22;
				var S21 = 5, S22 = 9 , S23 = 14, S24 = 20;
				var S31 = 4, S32 = 11, S33 = 16, S34 = 23;
				var S41 = 6, S42 = 10, S43 = 15, S44 = 21;

				string = Utf8Encode(string);

				x = ConvertToWordArray(string);

				a = 0x67452301;
				b = 0xEFCDAB89;
				c = 0x98BADCFE;
				d = 0x10325476;

				for (k = 0; k < x.length; k += 16)
				{
					AA = a;
					BB = b;
					CC = c;
					DD = d;
					a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
					d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
					c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
					b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
					a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
					d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
					c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
					b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
					a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
					d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
					c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
					b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
					a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
					d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
					c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
					b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
					a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
					d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
					c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
					b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
					a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
					d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);
					c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
					b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
					a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
					d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
					c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
					b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
					a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
					d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
					c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
					b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
					a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
					d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
					c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
					b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
					a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
					d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
					c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
					b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
					a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
					d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
					c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
					b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
					a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
					d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
					c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
					b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
					a = II(a, b, c, d, x[k + 0], S41, 0xF4292244);
					d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
					c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
					b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
					a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
					d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
					c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
					b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
					a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
					d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
					c = II(c, d, a, b, x[k + 6], S43, 0xA3014314);
					b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
					a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
					d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
					c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
					b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
					a = AddUnsigned(a, AA);
					b = AddUnsigned(b, BB);
					c = AddUnsigned(c, CC);
					d = AddUnsigned(d, DD);
				}

				var temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d);
				return temp.toLowerCase();
			},
			isLetterOrDigit: function (c)
			{
				if (c >= 48 && c <= 57)
				{
					return true;
				}
				if (c >= 61 && c <= 122)
				{
					return true;
				}
				if (c >= 65 && c <= 90)
				{
					return true;
				}
				return false;
			},
			isSpaceChar:     function (c)
			{
				return c == 32;
			},
			compareStrings:  function (s1, s2)
			{
				var nCommon = Math.min(s1.length, s2.length);
				var n;
				var c1, c2;
				for (n = 0; n < nCommon; n++)
				{
					c1 = s1.charCodeAt(n);
					c2 = s2.charCodeAt(n);
					if (c1 < c2)
					{
						return -1;
					}
					if (c1 > c2)
					{
						return 1;
					}
				}
				if (s1.length < s2.length)
				{
					return -1;
				}
				if (s1.length > s2.length)
				{
					return 1;
				}
				return 0;
			}
		});

	function CRunparserElement(t, i)
	{
		this.text = t;
		this.index = i;
		this.endIndex = this.index + this.text.length;
	}

		
	//----------------------------------------------------------------------------------
	//
	// CRUNBOX2DFAN
	//
	//----------------------------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	CRunBox2DParticules.PATYPE_POINT = 0;
	CRunBox2DParticules.PATYPE_ZONE = 1;
	CRunBox2DParticules.PAFLAG_CREATEATSTART = 0x0001;
	CRunBox2DParticules.PAFLAG_LOOP = 0x0002;
	CRunBox2DParticules.PAFLAG_DESTROYANIM = 0x0004;
	CRunBox2DParticules.ANGLENONE = 5666565;

	CRunBox2DParticules.CND_ONEACH = 0;
	CRunBox2DParticules.CND_PARTICULECOLLISION = 1;
	CRunBox2DParticules.CND_PARTICULEOUTLEFT = 2;
	CRunBox2DParticules.CND_PARTICULEOUTRIGHT = 3;
	CRunBox2DParticules.CND_PARTICULEOUTTOP = 4;
	CRunBox2DParticules.CND_PARTICULEOUTBOTTOM = 5;
	CRunBox2DParticules.CND_PARTICULESCOLLISION = 6;
	CRunBox2DParticules.CND_PARTICULECOLLISIONBACKDROP = 7;
	CRunBox2DParticules.CND_LAST = 8;

	CRunBox2DParticules.ACT_CREATEPARTICULES = 0;
	CRunBox2DParticules.ACT_STOPPARTICULE = 1;
	CRunBox2DParticules.ACT_FOREACH = 2;
	CRunBox2DParticules.ACT_SETSPEED = 3;
	CRunBox2DParticules.ACT_SETROTATION = 4;
	CRunBox2DParticules.ACT_SETINTERVAL = 5;
	CRunBox2DParticules.ACT_SETANGLE = 6;
	CRunBox2DParticules.ACT_DESTROYPARTICULE = 7;
	CRunBox2DParticules.ACT_DESTROYPARTICULES = 8;
	CRunBox2DParticules.ACT_SETSPEEDINTERVAL = 9;
	CRunBox2DParticules.ACT_SETCREATIONSPEED = 10;
	CRunBox2DParticules.ACT_SETCREATIONON = 11;
	CRunBox2DParticules.ACT_STOPLOOP = 12;
	CRunBox2DParticules.ACT_SETAPPLYFORCE = 13;
	CRunBox2DParticules.ACT_SETAPPLYTORQUE = 14;
	CRunBox2DParticules.ACT_SETASPEED = 15;
	CRunBox2DParticules.ACT_SETALOOP = 16;
	CRunBox2DParticules.ACT_SETSCALE = 17;
	CRunBox2DParticules.ACT_SETFRICTION = 18;
	CRunBox2DParticules.ACT_SETELASTICITY = 19;
	CRunBox2DParticules.ACT_SETDENSITY = 20;
	CRunBox2DParticules.ACT_SETGRAVITY = 21;
	CRunBox2DParticules.ACT_SETDESTROYDISTANCE = 22;
	CRunBox2DParticules.ACT_SETDESTROYANIM = 23;

	CRunBox2DParticules.EXP_PARTICULENUMBER = 0;
	CRunBox2DParticules.EXP_GETPARTICULEX = 1;
	CRunBox2DParticules.EXP_GETPARTICULEY = 2;
	CRunBox2DParticules.EXP_GETPARTICULEANGLE = 3;
	CRunBox2DParticules.EXP_GETSPEED = 4;
	CRunBox2DParticules.EXP_GETSPEEDINTERVAL = 5;
	CRunBox2DParticules.EXP_GETANGLE = 6;
	CRunBox2DParticules.EXP_GETANGLEINTERVAL = 7;
	CRunBox2DParticules.EXP_GETROTATION = 8;
	CRunBox2DParticules.EXP_GETLOOPINDEX = 9;
	CRunBox2DParticules.EXP_GETAPPLIEDFORCE = 10;
	CRunBox2DParticules.EXP_GETAPPLIEDTORQUE = 11;

	CRunBox2DParticules.APPLYFORCE_MULT = 5.0;
	CRunBox2DParticules.APPLYTORQUE_MULT = 0.1;
	CRunBox2DParticules.ROTATION_MULT = 20;

	function CRunBox2DParticules()
	{
		this.type = 0;
		this.flags = 0;
		this.number = 0;
		this.animationSpeed = 0;
		this.angleDWORD = 0;
		this.speed = 0;
		this.speedInterval = 0;
		this.friction = 0;
		this.restitution = 0;
		this.density = 0;
		this.angleInterval = 0;
		this.identifier = 0;
		this.gravity = 0;
		this.rotation = 0;
		this.nImages = 0;
		this.images = null;
		this.particules = null;
		this.toDestroy = null;
		this.creationSpeed = 0;
		this.creationSpeedCounter = 0;
		this.angle = CRunBox2DParticules.ANGLENONE;
		this.currentParticule1 = null;
		this.currentParticule2 = null;
		this.stopped = false;
		this.speedInterval = 0;
		this.stopLoop = false;
		this.loopIndex = 0;
		this.applyForce = 0;
		this.applyRotations = 0;
		this.scale = 0;
		this.destroyDistance = 0;
		this.loopName = 0;
		this.stopped = false;
		this.collidingHO = null;
	}

	CRunBox2DParticules.prototype = CServices.extend(new CRunExtension(),
		{
			GetBase: function ()
			{
				var pOL = 0;
				var nObjects = 0;
				for (nObjects = 0; nObjects < this.rh.rhNObjects; pOL++, nObjects++)
				{
					while (this.rh.rhObjectList[pOL] == null) pOL++;
					var pBase = this.rh.rhObjectList[pOL];
					if (pBase.hoType >= 32)
					{
						if (pBase.hoCommon.ocIdentifier == CRun.BASEIDENTIFIER)
						{
							if (pBase.ext.identifier == this.identifier)
							{
								return pBase.ext;
							}
						}
					}
				}
				return null;
			},

			rStartObject: function ()
			{
				if (this.base == null)
				{
					this.base = this.GetBase();
					if (this.base == null)
					{
						if (!bAlerted)
						{
							alert("Please drop a Physics - Engine object in the frame.");
							bAlerted = true;
						}
					}
					return this.base != null;
				}
				return this.base.started;
			},

			getNumberOfConditions: function ()
			{
				return CRunBox2DParticules.CND_LAST;
			},

			createRunObject: function (file, cob, version)
			{
				this.ho.hoImgWidth = file.readAInt();
				this.ho.hoImgHeight = file.readAInt();
				this.type = file.readAShort();
				this.flags = file.readAInt();
				this.creationSpeed = file.readAInt();
				this.number = file.readAInt();
				this.animationSpeed = file.readAInt();
				this.angleDWORD = file.readAInt();
				this.speed = file.readAInt();
				this.speedInterval = file.readAInt();
				this.friction = file.readAInt() / 100.0;
				this.restitution = file.readAInt() / 100.0;
				this.density = file.readAInt() / 100.0;
				this.angleInterval = file.readAInt();
				this.identifier = file.readAInt();
				this.gravity = file.readAInt() / 100.0;
				this.rotation = file.readAInt() / 100.0 * CRunBox2DParticules.ROTATION_MULT;
				this.applyForce = file.readAInt() / 100 * CRunBox2DParticules.APPLYFORCE_MULT;
				this.applyTorque = file.readAInt() / 100 * CRunBox2DParticules.APPLYTORQUE_MULT;
				this.scaleSpeed = file.readAInt() / 400;
				this.destroyDistance = file.readAInt();
				this.nImages = file.readAShort();
				var n;
				this.images = new Array();
				for (n = 0; n < this.nImages; n++)
					this.images.push(file.readAShort());
				this.ho.loadImageList(this.images);
				this.particules = new CArrayList();
				this.toDestroy = new CArrayList();

				return 0;
			},

			destroyRunObject: function ()
			{
				var pBase = this.GetBase();
				var n;
				for (n = 0; n < this.particules.size(); n++)
				{
					var particule = this.particules.get(n);
					particule.destroy(pBase);
				}
				return 0;
			},

			DirAtStart: function (dirAtStart)
			{
				var dir;

				// Compte le nombre de directions demandees
				var cpt = 0;
				var das = dirAtStart;
				var das2;
				for (var n = 0; n < 32; n++)
				{
					das2 = das;
					das >>= 1;
					if (das2 & 1) cpt++;
				}

				// Une ou zero direction?
				if (cpt == 0)
				{
					dir = 0;
				}
				else
				{
					// Appelle le hasard pour trouver le bit
					cpt = this.rh.random(cpt);
					das = dirAtStart;
					for (dir = 0; ; dir++)
					{
						das2 = das;
						das >>= 1;
						if (das2 & 1)
						{
							cpt--;
							if (cpt < 0) break;
						}
					}
				}
				return dir;
			},

			handleRunObject: function ()
			{
			    if (!this.rStartObject() || this.base.isPaused())
					return 0;

				var n;
				var particule;
				if (this.flags & CRunBox2DParticules.PAFLAG_CREATEATSTART)
				{
					this.creationSpeedCounter += this.creationSpeed;
					if (this.creationSpeedCounter >= 100)
					{
						this.creationSpeedCounter -= 100;
						this.createParticules(this.number);
					}
				}

				for (n = 0; n < this.toDestroy.size(); n++)
				{
					particule = this.toDestroy.get(n);
					this.destroyParticule(particule);
					this.toDestroy.removeIndex(n);
					n--;
				}

				for (n = 0; n < this.particules.size(); n++)
				{
					particule = this.particules.get(n);
					var o = {};
					this.base.rGetBodyPosition(particule.m_body, o);
					if (o.x < this.rh.rh3XMinimumKill || o.x > this.rh.rh3XMaximumKill
						|| o.y < this.rh.rh3YMinimumKill || o.y > this.rh.rh3YMaximumKill)
					{
						particule.bDestroyed = true;
						this.toDestroy.add(particule);
					}
					else
					{
						particule.setPosition(o.x, o.y, o.angle);
						particule.animate();
					}
				}
				return 0;
			},

			createParticules: function (number)
			{
			    if (this.base == null)
			        this.base = this.GetBase();
			    if (this.base == null)
			        return;
			    var n;
				var particule;
				for (n = 0; n < number; n++)
				{
					var x, y;
					if (this.type == CRunBox2DParticules.PATYPE_POINT)
					{
						x = this.ho.hoX;
						y = this.ho.hoY;
					}
					else
					{
						x = this.ho.hoX + this.rh.random(this.ho.hoImgWidth);
						y = this.ho.hoY + this.rh.random(this.ho.hoImgHeight);
					}

					var angle, interval;
					if (this.angle == CRunBox2DParticules.ANGLENONE)
						angle = this.DirAtStart(this.angleDWORD) * 11.25;
					else
						angle = this.angle;
					if (this.angleInterval > 0)
					{
						interval = this.rh.random(this.angleInterval * 2);
						angle += interval - this.angleInterval;
					}

					particule = new CParticule(this, x, y);
					particule.InitBase(this.ho, CRunMBase.MTYPE_PARTICULE);
					particule.setAnimation(this.images, this.nImages, this.animationSpeed, this.flags);
					particule.setScale(this.scaleSpeed);

					var image = this.rh.rhApp.imageBank.getImageFromHandle(this.images[0]);
					particule.m_body = this.base.rCreateBody(Box2D.Dynamics.b2Body.b2_dynamicBody, x, y, angle, this.gravity, particule, 0, 0);
					particule.fixture = this.base.rBodyCreateCircleFixture(particule.m_body, particule, x, y, Math.round((image.width + image.height + 1) / 4), this.density, this.friction, this.restitution);

					var mass = particule.m_body.GetMass();
					interval = this.rh.random(this.speedInterval * 2);
					var speed = this.speed + interval - this.speedInterval;
					speed = Math.max(speed, 1);
					speed = speed / 100.0 * 20.0;
					this.base.rBodyApplyImpulse(particule.m_body, Math.max(1.0, speed * mass), angle);
					this.base.rBodyApplyAngularImpulse(particule.m_body, this.rotation)
	//				this.base.rBodyApplyForce(particule.m_body, this.applyForce, angle);
	//				this.base.rBodyApplyTorque(particule.m_body, this.applyTorque);

					this.particules.add(particule);
				}
			},

			destroyParticule: function (particule)
			{
				particule.destroy(this.base);
				this.particules.removeObject(particule);
			},

			// Conditions
			// -------------------------------------------------
			condition:        function (num, cnd)
			{
				switch (num)
				{
					case CRunBox2DParticules.CND_ONEACH:
						var name = cnd.getParamExpression(this.rh, 0);
						return CServices.compareStringsIgnoreCase(name, this.loopName);
					case CRunBox2DParticules.CND_PARTICULECOLLISION:
						var param = cnd.getParamObject(this.rh, 0);
						if (param.oi == this.rh.rhEvtProg.rhCurParam0)
						{
							this.rh.rhEvtProg.evt_AddCurrentObject(this.collidingHO);
							return true;
						}
						else
						{
							var oil = param.oiList;
							if ((oil & 0x8000) != 0)
							{
								var pq = this.rh.rhEvtProg.qualToOiList[oil & 0x7FFF];
								numOi = 0;
								while (numOi < pq.qoiList.length)
								{
									if (pq.qoiList[numOi] == this.rh.rhEvtProg.rhCurParam0)
									{
										this.rh.rhEvtProg.evt_AddCurrentObject(this.collidingHO);
										return true;
									}
									numOi += 2;
								}
							}
						}
						break;
					case CRunBox2DParticules.CND_PARTICULECOLLISIONBACKDROP:
					case CRunBox2DParticules.CND_PARTICULEOUTLEFT:
					case CRunBox2DParticules.CND_PARTICULEOUTRIGHT:
					case CRunBox2DParticules.CND_PARTICULEOUTTOP:
					case CRunBox2DParticules.CND_PARTICULEOUTBOTTOM:
					case CRunBox2DParticules.CND_PARTICULESCOLLISION:
						return true;
					default:
						break;
				}
				return false;
			},

			// Actions
			// -------------------------------------------------
			action:           function (num, act)
			{
				switch (num)
				{
					case CRunBox2DParticules.ACT_CREATEPARTICULES:
						var number = act.getParamExpression(this.rh, 0);
						this.createParticules(number);
						break;
					case CRunBox2DParticules.ACT_STOPPARTICULE:
						this.stopped = true;
						break;
					case CRunBox2DParticules.ACT_FOREACH:
						this.loopName = act.getParamExpression(this.rh, 0);
						var n;
						this.stopLoop = false;
						for (n = 0; n < this.particules.size(); n++)
						{
							if (this.stopLoop)
								break;
							var particule = this.particules.get(n);
							this.currentParticule1 = particule;
							this.loopIndex = n;
							this.ho.generateEvent(CRunBox2DParticules.CND_ONEACH, 0);
						}
						break;
					case CRunBox2DParticules.ACT_STOPLOOP:
						this.stopLoop = true;
						break;
					case CRunBox2DParticules.ACT_SETSPEED:
						this.speed = Math.min(act.getParamExpression(this.rh, 0), 250);
						this.speed = Math.max(this.speed, 0);
						break;
					case CRunBox2DParticules.ACT_SETSPEEDINTERVAL:
						this.speedInterval = Math.max(act.getParamExpression(this.rh, 0), 0);
						break;
					case CRunBox2DParticules.ACT_SETANGLE:
						this.angle = act.getParamExpression(this.rh, 0);
						break;
					case CRunBox2DParticules.ACT_SETINTERVAL:
						this.angleInterval = Math.min(act.getParamExpression(this.rh, 0), 360);
						this.angleInterval = Math.max(this.angleInterval, 0);
						break;
					case CRunBox2DParticules.ACT_SETROTATION:
						this.rotation = Math.min(act.getParamExpression(this.rh, 0), 250);
						this.rotation = Math.max(this.rotation, -250);
						break;
					case CRunBox2DParticules.ACT_DESTROYPARTICULE:
						if (this.currentParticule1)
						{
							if (!this.currentParticule1.bDestroyed && this.particules.indexOf(this.currentParticule1) >= 0)
								this.toDestroy.add(this.currentParticule1);
						}
						break;
					case CRunBox2DParticules.ACT_DESTROYPARTICULES:
						if (this.currentParticule1)
							if (!this.currentParticule1.bDestroyed && this.particules.indexOf(this.currentParticule1) >= 0)
								this.toDestroy.add(this.currentParticule1);
						if (this.currentParticule2)
							if (!this.currentParticule2.bDestroyed && this.particules.indexOf(this.currentParticule2) >= 0)
								this.toDestroy.add(this.currentParticule2);
						break;
					case CRunBox2DParticules.ACT_SETCREATIONSPEED:
						this.creationSpeed = Math.min(act.getParamExpression(this.rh, 0), 100);
						this.creationSpeed = Math.max(this.creationSpeed, 0);
						break;
					case CRunBox2DParticules.ACT_SETCREATIONON:
						if (act.getParamExpression(this.rh, 0))
							this.flags |= CRunBox2DParticules.PAFLAG_CREATEATSTART;
						else
							this.flags &= ~CRunBox2DParticules.PAFLAG_CREATEATSTART;
						break;
					case CRunBox2DParticules.ACT_SETAPPLYFORCE:
						this.applyForce = act.getParamExpression(this.rh, 0) / 100 * CRunBox2DParticules.APPLYFORCE_MULT;
						break;
					case CRunBox2DParticules.ACT_SETAPPLYTORQUE:
						this.applyTorque = act.getParamExpression(this.rh, 0) / 100 * CRunBox2DParticules.APPLYTORQUE_MULT;
						break;
					case CRunBox2DParticules.ACT_SETASPEED:
						this.animationSpeed = act.getParamExpression(this.rh, 0);
						break;
					case CRunBox2DParticules.ACT_SETALOOP:
						this.flags &= ~CRunBox2DParticules.PAFLAG_LOOP;
						if (act.getParamExpression(this.rh, 0))
							this.flags |= CRunBox2DParticules.PAFLAG_LOOP;
						break;
					case CRunBox2DParticules.ACT_SETSCALE:
						this.scaleSpeed = act.getParamExpression(this.rh, 0) / 400;
						break;
					case CRunBox2DParticules.ACT_SETFRICTION:
						this.friction = act.getParamExpression(this.rh, 0) / 100;
						break;
					case CRunBox2DParticules.ACT_SETELASTICITY:
						this.restitution = act.getParamExpression(this.rh, 0) / 100;
						break;
					case CRunBox2DParticules.ACT_SETDENSITY:
						this.density = act.getParamExpression(this.rh, 0) / 100;
						break;
					case CRunBox2DParticules.ACT_SETGRAVITY:
						this.gravity = act.getParamExpression(this.rh, 0) / 100;
						break;
					case CRunBox2DParticules.ACT_SETDESTROYDISTANCE:
						this.destroyDistance = act.getParamExpression(this.rh, 0);
						break;
					case CRunBox2DParticules.ACT_SETDESTROYANIM:
						if (act.getParamExpression(this.rh, 0))
							this.flags |= CRunBox2DParticules.PAFLAG_DESTROYANIM;
						else
							this.flags &= ~CRunBox2DParticules.PAFLAG_DESTROYANIM;
						break;
				}
			},

			// Expressions
			// --------------------------------------------
			expression:       function (num)
			{
				switch (num)
				{
					case CRunBox2DParticules.EXP_PARTICULENUMBER:
						return this.particules.size();
					case CRunBox2DParticules.EXP_GETPARTICULEX:
						if (this.currentParticule1)
							return this.currentParticule1.x;
						return 0;
					case CRunBox2DParticules.EXP_GETPARTICULEY:
						if (this.currentParticule1)
							return this.currentParticule1.y;
						return 0;
					case CRunBox2DParticules.EXP_GETPARTICULEANGLE:
						if (this.currentParticule1)
							return this.currentParticule1.angle;
						return 0;
					case CRunBox2DParticules.EXP_GETSPEED:
						return this.speed;
					case CRunBox2DParticules.EXP_GETSPEEDINTERVAL:
						return this.speedInterval;
					case CRunBox2DParticules.EXP_GETANGLE:
						return this.angle;
					case CRunBox2DParticules.EXP_GETANGLEINTERVAL:
						return this.angleInterval;
					case CRunBox2DParticules.EXP_GETROTATION:
						return this.rotation;
					case CRunBox2DParticules.EXP_GETLOOPINDEX:
						return this.loopIndex;
					case CRunBox2DParticules.EXP_GETAPPLIEDFORCE:
						return this.applyForce * 100 / CRunBox2DParticules.APPLYFORCE_MULT;
					case CRunBox2DParticules.EXP_GETAPPLIEDTORQUE:
						return this.applyTorque * 100 / CRunBox2DParticules.APPLYTORQUE_MULT;
					default:
						break;
				}
				return 0;
			}

		});

	// PARTICULE OBJECT
	////////////////////////////////////////////////////////////////////////
	function CParticule(parent, x, y)
	{
		this.m_type = CRunBox2DBase.MTYPE_PARTICULE;
		this.parent = parent;
		this.nLayer = parent.ho.ros.rsLayer;
		this.pLayer = parent.rh.rhFrame.layers[this.nLayer];
		this.pLayer.planeSprites.addChild(this);
		this.initialX = x;
		this.initialY = y;
		this.x = 0;
		this.y = 0;
		this.angle = 0;
		this.nImages = 0;
		this.images = null;
		this.image = 0;
		this.animationSpeed = 0;
		this.animationSpeedCounter = 0;
		this.bDestroyed = false;
		this.m_addVFlag = 0;
		this.m_addVX = 0;
		this.m_addVY = 0;
		this.oldWidth = 0;
		this.oldHeight = 0;
		this.fixture = null;
		this.scaleSpeed = 0;
		this.scale = 0;
		this.rc = new CRect();
	}
	CParticule.prototype = CServices.extend(new CRunMBase(),
		{
			destroy:      function (pBase)
			{
				this.pLayer.planeSprites.removeChild(this);
				if (pBase != null)
					pBase.rDestroyBody(this.m_body);
			},
			setAnimation: function (images, nImages, animationSpeed, flags)
			{
				this.images = images;
				this.nImages = nImages;
				this.animationSpeed = animationSpeed;
				this.animationSpeedCounter = 0;
				this.flags = flags;
				this.stopped = false;

				var image = this.parent.rh.rhApp.imageBank.getImageFromHandle(this.images[0]);
				this.oldWidth = image.width * this.scale;
				this.oldHeight = image.height * this.scale;
			},
			setScale:     function (scaleSpeed)
			{
				this.scaleSpeed = scaleSpeed;
				this.scale = 1;
			},
			animate:      function ()
			{
				if (!this.stopped)
				{
					this.animationSpeedCounter += this.animationSpeed * this.parent.rh.rh4MvtTimerCoef;
					while (this.animationSpeedCounter >= 100)
					{
						this.animationSpeedCounter -= 100;
						this.image++;
						if (this.image >= this.nImages)
						{
							if (this.flags & CRunBox2DParticules.PAFLAG_LOOP)
							{
								this.image = 0;
							}
							else
							{
								this.image--;
								this.stopped = true;
								if (this.flags & CRunBox2DParticules.PAFLAG_DESTROYANIM)
								{
									if (!this.bDestroyed)
									{
										this.bDestroyed = true;
										this.parent.toDestroy.add(this);
									}
								}
							}
						}
					}
				}
				var oldScale = this.scale;
				this.scale += this.scaleSpeed;

				var image = this.parent.rh.rhApp.imageBank.getImageFromHandle(this.images[this.image]);
				if(!image) return;
				var width = image.width * this.scale;
				var height = image.height * this.scale;
				if (width < 1 || height < 1)
				{
					if (!this.bDestroyed)
					{
						this.parent.toDestroy.add(this);
						this.bDestroyed = true;
					}
					this.scale = oldScale;
				}
				else
				{
					if (width != this.oldWidth || height != this.oldHeight)
					{
						this.oldWidth = width;
						this.oldHeight = height;
						this.m_body.DestroyFixture(this.fixture);
						this.fixture = this.parent.base.rBodyCreateCircleFixture(this.m_body, this, this.x, this.y, Math.round((width + height + 1) / 4), this.parent.density, this.parent.friction, this.parent.restitution);
					}
				}

				this.parent.base.rBodyAddVelocity(this.m_body, this.m_addVX, this.m_addVY);
				if (this.m_addVFlag)
					this.m_addVFlag = false;
				else
				{
					this.m_addVX = 0;
					this.m_addVY = 0;
				}
			},
			AddVelocity:  function (vx, vy)
			{
				this.m_addVX = vx;
				this.m_addVY = vy;
				this.m_addVFlag = true;
			},
			SetVelocity:  function (vx, vy)
			{
				var angle = this.m_body.GetAngle();
				var position = this.m_body.GetPosition();
				position.x += vx / 2.56;
				position.y += vy / 2.56;
				this.parent.base.rBodySetTransform(this.m_body, position, angle);
			},
			setPosition:  function (x, y, angle)
			{
				this.x = x;
				this.y = y;
				this.angle = angle;
				var dx = this.x - this.initialX;
				var dy = this.y - this.initialY;
				var distance = Math.sqrt(dx * dx + dy * dy);
				if (distance > this.parent.destroyDistance)
				{
					if (!this.bDestroyed)
					{
						this.bDestroyed = true;
						this.parent.toDestroy.add(this);
					}
				}
			},
			draw:         function (context, xx, yy)
			{
				if (this.parent.ho.ros.rsFlags & CRSpr.RSFLAG_VISIBLE)
				{
					var image = this.parent.rh.rhApp.imageBank.getImageFromHandle(this.images[this.image]);
					if (image)
					{
						image.xSpot = image.width / 2;
						image.ySpot = image.height / 2;
						context.renderImage(image, xx + this.x - this.parent.rh.rhWindowX + this.pLayer.x,
							yy + this.y - this.parent.rh.rhWindowY + this.pLayer.y,
							this.angle, this.scale, this.scale,
							0, 0);
					}
				}
			}
		});
	//----------------------------------------------------------------------------------
	//
	// CRUNBOX2DBASE : objet Physics - Engine
	//
	//----------------------------------------------------------------------------------
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 * 
	 * Permission is hereby granted to any person obtaining a legal copy 
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for 
	 * debugging, optimizing, or customizing applications created with 
	 * Clickteam Multimedia Fusion 2. 
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */

	CRunBox2DBase.FANIDENTIFIER = 0x42324641;
	CRunBox2DBase.TREADMILLIDENTIFIER = 0x4232544D;
	CRunBox2DBase.MAGNETIDENTIFIER = 0x42369856;
	CRunBox2DBase.GROUNDIDENTIFIER = 0x42324E4F;
	CRunBox2DBase.ROPEANDCHAINIDENTIFIER = 0x4232EFFA;
	CRunBox2DBase.CBFLAG_FIXEDROTATION = 0x0001;
	CRunBox2DBase.CBFLAG_BULLET = 0x0002;
	CRunBox2DBase.CBFLAG_DAMPING = 0x0004;
	CRunBox2DBase.POSDEFAULT = 0x56586532;
	CRunBox2DBase.DIRECTION_LEFTTORIGHT = 0;
	CRunBox2DBase.DIRECTION_RIGHTTOLEFT = 1;
	CRunBox2DBase.DIRECTION_TOPTOBOTTOM = 2;
	CRunBox2DBase.DIRECTION_BOTTOMTOTOP = 3;
	CRunBox2DBase.OBSTACLE_OBSTACLE = 0;
	CRunBox2DBase.OBSTACLE_PLATFORM = 1;
	CRunBox2DBase.B2FLAG_ADDBACKDROPS = 0x0001;
	CRunBox2DBase.B2FLAG_BULLETCREATE = 0x0002;
	CRunBox2DBase.B2FLAG_ADDOBJECTS = 0x0004;
	CRunBox2DBase.TYPE_ALL = 0;
	CRunBox2DBase.TYPE_DISTANCE = 1;
	CRunBox2DBase.TYPE_REVOLUTE = 2;
	CRunBox2DBase.TYPE_PRISMATIC = 3;
	CRunBox2DBase.TYPE_PULLEY = 4;
	CRunBox2DBase.TYPE_GEAR = 5;
	CRunBox2DBase.TYPE_MOUSE = 6;
	CRunBox2DBase.TYPE_WHEEL = 7;
	CRunBox2DBase.RMOTORTORQUEMULT = 20.0;
	CRunBox2DBase.RMOTORSPEEDMULT = 10.0;
	CRunBox2DBase.PJOINTMOTORFORCEMULT = 20.0;
	CRunBox2DBase.PJOINTMOTORSPEEDMULT = 10.0;
	CRunBox2DBase.APPLYIMPULSE_MULT = 19.0;
	CRunBox2DBase.APPLYANGULARIMPULSE_MULT = 0.1;
	CRunBox2DBase.APPLYFORCE_MULT = 5.0;
	CRunBox2DBase.APPLYTORQUE_MULT = 1.0;
	CRunBox2DBase.SETVELOCITY_MULT = 20.5;
	CRunBox2DBase.SETANGULARVELOCITY_MULT = 15.0;
	CRunBox2DBase.JTYPE_NONE = 0;
	CRunBox2DBase.JTYPE_REVOLUTE = 1;
	CRunBox2DBase.JTYPE_DISTANCE = 2;
	CRunBox2DBase.JTYPE_PRISMATIC = 3;
	CRunBox2DBase.JANCHOR_HOTSPOT = 0;
	CRunBox2DBase.JANCHOR_ACTIONPOINT = 1;
	CRunBox2DBase.MAX_JOINTNAME = 24;
	CRunBox2DBase.MAX_JOINTOBJECT = 24;

	CRunBox2DBase.ACTION_SETGRAVITYFORCE = 0;
	CRunBox2DBase.ACTION_SETGRAVITYANGLE = 1;
	//null  2
	//null  3
	//null  4
	//null  5
	//null  6
	//null  7
	CRunBox2DBase.ACTION_DJOINTHOTSPOT = 8;
	CRunBox2DBase.ACTION_DJOINTACTIONPOINT = 9;
	CRunBox2DBase.ACTION_DJOINTPOSITION = 10;
	CRunBox2DBase.ACTION_RJOINTHOTSPOT = 11;
	CRunBox2DBase.ACTION_RJOINTACTIONPOINT = 12;
	CRunBox2DBase.ACTION_RJOINTPOSITION = 13;
	CRunBox2DBase.ACTION_PJOINTHOTSPOT = 14;
	CRunBox2DBase.ACTION_PJOINTACTIONPOINT = 15;
	CRunBox2DBase.ACTION_PJOINTPOSITION = 16;
	// ACTION_GJOINTHOTSPOT		17
	// ACTION_GJOINTACTIONPOINT	18
	// ACTION_GJOINTPOSITION		19
	// ACTION_WJOINTHOTSPOT		20
	// ACTION_WJOINTACTIONPOINT	21
	// ACTION_WJOINTPOSITION		22
	CRunBox2DBase.ACTION_ADDOBJECT = 23;
	CRunBox2DBase.ACTION_SUBOBJECT = 24;
	CRunBox2DBase.ACTION_SETDENSITY = 25;
	CRunBox2DBase.ACTION_SETFRICTION = 26;
	CRunBox2DBase.ACTION_SETELASTICITY = 27;
	CRunBox2DBase.ACTION_SETGRAVITY = 28;
	CRunBox2DBase.ACTION_DJOINTSETELASTICITY = 29;
	CRunBox2DBase.ACTION_RJOINTSETLIMITS = 30;
	CRunBox2DBase.ACTION_RJOINTSETMOTOR = 31;
	CRunBox2DBase.ACTION_PJOINTSETLIMITS = 32;
	CRunBox2DBase.ACTION_PJOINTSETMOTOR = 33;
	CRunBox2DBase.ACTION_PUJOINTHOTSPOT = 34;
	CRunBox2DBase.ACTION_PUJOINTACTIONPOINT = 35;
	// ACTION_WJOINTSETMOTOR		36
	// ACTION_WJOINTSETELASTICITY	37
	CRunBox2DBase.ACTION_DESTROYJOINT = 38;
	CRunBox2DBase.ACTION_SETITERATIONS = 39;
	CRunBox2DBase.ACTION_PAUSE = 40;
	CRunBox2DBase.ACTION_RESUME = 41;

	CRunBox2DBase.EXPRESSION_GRAVITYSTRENGTH = 0;
	CRunBox2DBase.EXPRESSION_GRAVITYANGLE = 1;
	CRunBox2DBase.EXPRESSION_VELOCITYITERATIONS = 2;
	CRunBox2DBase.EXPRESSION_POSITIONITERATIONS = 3;
	CRunBox2DBase.EXPRESSION_ELASTICITYFREQUENCY = 4;
	CRunBox2DBase.EXPRESSION_ELASTICITYDAMPING = 5;
	CRunBox2DBase.EXPRESSION_LOWERANGLELIMIT = 6;
	CRunBox2DBase.EXPRESSION_UPPERANGLELIMIT = 7;
	CRunBox2DBase.EXPRESSION_MOTORSTRENGTH = 8;
	CRunBox2DBase.EXPRESSION_MOTORSPEED = 9;
	CRunBox2DBase.EXPRESSION_LOWERTRANSLATION = 10;
	CRunBox2DBase.EXPRESSION_UPPERTRANSLATION = 11;
	CRunBox2DBase.EXPRESSION_PMOTORSTRENGTH = 12;
	CRunBox2DBase.EXPRESSION_PMOTORSPEED = 13;

	function CRunBox2DBase()
	{
		this.flags = 0;
		this.world = null;
		this.gravity = 0;
		this.factor = 0;
		this.angle = 0;
		this.angleBase = 0;
		this.xBase = 0;
		this.yBase = 0;
		this.velocityIterations = 0;
		this.positionIterations = 0;
		this.friction = 0;
		this.restitution = 0;
		this.contactListener = null;
		this.started = false;
		this.fans = new CArrayList();
		this.treadmills = new CArrayList();
		this.magnets = new CArrayList();
		this.ropes = new CArrayList();
		this.bulletGravity = 0;
		this.bulletDensity = 0;
		this.bulletRestitution = 0;
		this.bulletFriction = 0;
		this.objects = new CArrayList();
		this.objectIDs = new CArrayList();
		this.joints = new CArrayList();
		this.npDensity = 0;
		this.npFriction = 0;
		this.bodiesToDestroy = new CArrayList();
		this.bListener = false;
		this.bPaused = false;
	}

	CRunBox2DBase.prototype = CServices.extend(new CRunExtension,
		{
			GetObjects:    function ()
			{
				var rhPtr = this.ho.hoAdRunHeader;
				var pOL = 0;
				var nObjects;
				for (nObjects = 0; nObjects < rhPtr.rhNObjects; pOL++, nObjects++)
				{
					while (rhPtr.rhObjectList[pOL] == null) pOL++;
					var pObject = rhPtr.rhObjectList[pOL];
					if (pObject.hoType >= 32)
					{
						if (pObject.hoCommon.ocIdentifier == CRunBox2DBase.FANIDENTIFIER)
						{
							if (pObject.ext.identifier == this.identifier)
								this.fans.add(pObject.ext);
						}
						if (pObject.hoCommon.ocIdentifier == CRunBox2DBase.MAGNETIDENTIFIER)
						{
							if (pObject.ext.identifier == this.identifier)
								this.magnets.add(pObject.ext);
						}
						if (pObject.hoCommon.ocIdentifier == CRunBox2DBase.TREADMILLIDENTIFIER)
						{
							if (pObject.ext.identifier == this.identifier)
								this.treadmills.add(pObject.ext);
						}
						if (pObject.hoCommon.ocIdentifier == CRunBox2DBase.ROPEANDCHAINIDENTIFIER) {
						    if (pObject.ext.identifier == this.identifier)
						        this.ropes.add(pObject.ext);
						}
	                }
				}
				return null;
			},
			rWorldToFrame: function (pVec)
			{
				pVec.x = (pVec.x * this.factor) - this.xBase;
				pVec.y = this.yBase - (pVec.y * this.factor);
			},
			rFrameToWorld: function (pVec)
			{
				pVec.x = (this.xBase + pVec.x) / this.factor;
				pVec.y = (this.yBase - pVec.y) / this.factor;
			},

			rRJointSetLimits: function (pJoint, angle1, angle2)
			{
				var lAngle = angle1 * Box2D.Common.b2Settings.b2_pi / 180.0;
				var uAngle = angle2 * Box2D.Common.b2Settings.b2_pi / 180.0;
				if (lAngle > uAngle)
				{
					pJoint.EnableLimit(false);
				}
				else
				{
					pJoint.EnableLimit(true);
					pJoint.SetLimits(lAngle, uAngle);
				}
			},

			rRJointSetMotor:           function (pJoint, t, s)
			{
				var torque = t / 100.0 * CRunBox2DBase.RMOTORTORQUEMULT;
				var speed = s / 100.0 * CRunBox2DBase.RMOTORSPEEDMULT;
				var flag = true;
				if (torque == 0 && speed == 0)
					flag = false;
				pJoint.EnableMotor(flag);
				pJoint.SetMaxMotorTorque(torque);
				pJoint.SetMotorSpeed(speed);
			},
			rWorldCreateRevoluteJoint: function (jointDef, body1, body2, position)
			{
				jointDef.Initialize(body1, body2, position);
				return this.world.CreateJoint(jointDef);
			},
			rJointCreate:              function (pMBase1, jointType, jointAnchor, jointName, jointObject, param1, param2)
			{
				if (jointType == CRunBox2DBase.JTYPE_NONE)
					return null;

				var pOL = 0;
				var nObjects = 0;
				var pMBase2 = null;
				var distance = 10000000;
				for (nObjects = 0; nObjects < this.rh.rhNObjects; pOL++, nObjects++)
				{
					while (this.rh.rhObjectList[pOL] == null) pOL++;
					var pObject = this.rh.rhObjectList[pOL];
					if (CServices.compareStringsIgnoreCase(pObject.hoOiList.oilName, jointObject))
					{
						var pMBaseObject = this.GetMBase(pObject);
						if (pMBaseObject != null)
						{
							var deltaX = pMBaseObject.m_pHo.hoX - pMBase1.m_pHo.hoX;
							var deltaY = pMBaseObject.m_pHo.hoY - pMBase1.m_pHo.hoY;
							var d = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
							if (d <= distance)
							{
								distance = d;
								pMBase2 = pMBaseObject;
							}
						}
					}
				}
				if (pMBase2 != null)
				{
					var pJoint = this.CreateJoint(jointName);
					if (pJoint != null)
					{
						switch (jointType)
						{
							case CRunBox2DBase.JTYPE_REVOLUTE:
							{
								var jointDef = new Box2D.Dynamics.Joints.b2RevoluteJointDef();
								jointDef.collideConnected = true;
								if (param1 > param2)
									jointDef.enableLimit = false;
								else
								{
									jointDef.enableLimit = true;
									jointDef.lowerAngle = param1;
									jointDef.upperAngle = param2;
								}
								var position;
								switch (jointAnchor)
								{
									case CRunBox2DBase.JANCHOR_HOTSPOT:
										position = pMBase1.m_body.GetPosition();
										break;
									case CRunBox2DBase.JANCHOR_ACTIONPOINT:
										position = this.GetActionPointPosition(pMBase1);
										break;
								}
								jointDef.Initialize(pMBase1.m_body, pMBase2.m_body, position);
								pJoint.SetJoint(CRunBox2DBase.TYPE_REVOLUTE, this.world.CreateJoint(jointDef));
								return pJoint.m_joint;
							}
							case CRunBox2DBase.JTYPE_DISTANCE:
							{
								var jointDef = new Box2D.Dynamics.Joints.b2DistanceJointDef();
								jointDef.collideConnected = true;
								jointDef.frequencyHz = param1;
								jointDef.dampingRatio = param2;
								var position1, position2;
								switch (jointAnchor)
								{
									case CRunBox2DBase.JANCHOR_HOTSPOT:
										position1 = pMBase1.m_body.GetPosition();
										position2 = pMBase2.m_body.GetPosition();
										break;
									case CRunBox2DBase.JANCHOR_ACTIONPOINT:
										position1 = this.GetActionPointPosition(pMBase1);
										position2 = this.GetActionPointPosition(pMBase2);
										break;
								}
								jointDef.Initialize(pMBase1.m_body, pMBase2.m_body, position1, position2);
								pJoint.SetJoint(CRunBox2DBase.TYPE_DISTANCE, this.world.CreateJoint(jointDef));
								return pJoint.m_joint;
							}
								break;
							case CRunBox2DBase.JTYPE_PRISMATIC:
							{
								var jointDef = new Box2D.Dynamics.Joints.b2PrismaticJointDef();
								jointDef.collideConnected = true;
								if (param1 > param2)
									jointDef.enableLimit = false;
								else
								{
									jointDef.enableLimit = true;
									jointDef.lowerTranslation = param1 / this.factor;
									jointDef.upperTranslation = param2 / this.factor;
								}
								var position1, position2;
								switch (jointAnchor)
								{
									case CRunBox2DBase.JANCHOR_HOTSPOT:
										position1 = pMBase1.m_body.GetPosition();
										position2 = pMBase2.m_body.GetPosition();
										break;
									case CRunBox2DBase.JANCHOR_ACTIONPOINT:
										position1 = this.GetActionPointPosition(pMBase1);
										position2 = this.GetActionPointPosition(pMBase2);
										break;
								}
								var axis = new Box2D.Common.Math.b2Vec2(position2.x - position1.x, position2.y - position1.y);
								jointDef.Initialize(pMBase1.m_body, pMBase2.m_body, position1, axis);
								pJoint.SetJoint(CRunBox2DBase.TYPE_PRISMATIC, this.world.CreateJoint(jointDef));
								return pJoint.m_joint;
							}
								break;
						}
					}
				}
				return null;
			},

			rCreateBody:                function (type, x, y, angle, gravity, pMBase, flags, deceleration)
			{
				if (pMBase != null && type != Box2D.Dynamics.b2Body.b2_staticBody && pMBase.m_type != CRunMBase.MTYPE_PLATFORM && pMBase.m_type != CRunMBase.MTYPE_OBSTACLE)
				{
					var n;
					for (n = 0; n < this.fans.size(); n++)
						this.fans.get(n).rAddObject(pMBase);
					for (n = 0; n < this.magnets.size(); n++)
						this.magnets.get(n).rAddObject(pMBase);
					for (n = 0; n < this.treadmills.size(); n++)
						this.treadmills.get(n).rAddObject(pMBase);
				}
				var bodyDef = new Box2D.Dynamics.b2BodyDef();
				bodyDef.type = type;
				bodyDef.position.Set((this.xBase + x) / this.factor, (this.yBase - y) / this.factor);
				bodyDef.angle = ((angle * Box2D.Common.b2Settings.b2_pi) / 180.0);
				bodyDef.gravityScale = gravity;
				bodyDef.userData = pMBase;
				if (flags & CRunBox2DBase.CBFLAG_FIXEDROTATION)
					bodyDef.fixedRotation = true;
				if (flags & CRunBox2DBase.CBFLAG_BULLET)
					bodyDef.bullet = true;
				if (flags & CRunBox2DBase.CBFLAG_DAMPING)
					bodyDef.linearDamping = deceleration;
				var pBody = this.world.CreateBody(bodyDef);
				return pBody;
			},
			rDestroyBody:               function (pBody)
			{
			    if (!this.bListener)
			        this.world.SetContactListener(this.contactListener);
			    if (this.contactListener.bWorking)
				{
					this.bodiesToDestroy.add(pBody);
					return;
				}

				var pMBase = pBody.GetUserData();
				if (pMBase != null) {
				    if (pMBase.m_type != CRunMBase.MTYPE_PLATFORM && pMBase.m_type != CRunMBase.MTYPE_OBSTACLE) {
				        var n;
				        for (n = 0; n < this.fans.size() ; n++)
				            this.fans.get(n).rRemoveObject(pMBase);
				        for (n = 0; n < this.magnets.size() ; n++)
				            this.magnets.get(n).rRemoveObject(pMBase);
				        for (n = 0; n < this.treadmills.size() ; n++)
				            this.treadmills.get(n).rRemoveObject(pMBase);
				        for (n = 0; n < this.ropes.size() ; n++)
				            this.ropes.get(n).rRemoveObject(pMBase);
				    }
				    pBody.SetUserData(null);
				}
				this.destroyJointWithBody(pBody);
				this.world.DestroyBody(pBody);
				if (!this.bListener)
				    this.world.SetContactListener(null);
			},
			rBodyDestroyFixture:        function (body, fixture)
			{
				body.DestroyFixture(fixture);
			},
			rBodyCreateBoxFixture:      function (pBody, pMBase, x, y, sx, sy, density, friction, restitution)
			{
				sx -= 1;
				sy -= 1;
				if (pMBase != null)
				{
					pMBase.rc.left = -sx / 2;
					pMBase.rc.right = sx / 2;
					pMBase.rc.top = -sy / 2;
					pMBase.rc.bottom = sy / 2;
				}

				var box = new Box2D.Collision.Shapes.b2PolygonShape();
				var vect = new Box2D.Common.Math.b2Vec2((this.xBase + x) / this.factor, (this.yBase - (y)) / this.factor);
				box.SetAsBox(sx / 2.0 / this.factor, sy / 2.0 / this.factor, pBody.GetLocalPoint(vect), 0);

				var fixtureDef = new Box2D.Dynamics.b2FixtureDef();
				fixtureDef.shape = box;
				fixtureDef.density = density;
				fixtureDef.friction = friction;
				fixtureDef.restitution = restitution;
				fixtureDef.userData = this;
				return pBody.CreateFixture(fixtureDef);
			},
			rBodyCreateCircleFixture:   function (pBody, pMBase, x, y, radius, density, friction, restitution)
			{
				if (pMBase != null)
				{
					pMBase.rc.left = -radius;
					pMBase.rc.right = radius;
					pMBase.rc.top = -radius;
					pMBase.rc.bottom = radius;
				}

				var circle = new Box2D.Collision.Shapes.b2CircleShape();
				circle.m_radius = radius / this.factor;
				var vect = new Box2D.Common.Math.b2Vec2((this.xBase + x) / this.factor, (this.yBase - y) / this.factor);
				var local = pBody.GetLocalPoint(vect);
				circle.m_p.Set(local.x, local.y);

				var fixtureDef = new Box2D.Dynamics.b2FixtureDef();
				fixtureDef.shape = circle;
				fixtureDef.density = density;
				fixtureDef.friction = friction;
				fixtureDef.restitution = restitution;
				fixtureDef.userData = this;
				return pBody.CreateFixture(fixtureDef);
			},
			rCreateDistanceJoint:       function (pBody1, pBody2, dampingRatio, frequency, x, y)
			{
				var position1 = new Box2D.Common.Math.b2Vec2(pBody1.GetPosition().x, pBody1.GetPosition().y);
				position1.x += x / this.factor;
				position1.y += y / this.factor;
				var position2 = new Box2D.Common.Math.b2Vec2(pBody2.GetPosition().x, pBody2.GetPosition().y);
				var JointDef = new Box2D.Dynamics.Joints.b2DistanceJointDef();
				JointDef.collideConnected = false;
				JointDef.frequencyHz = frequency;
				JointDef.dampingRatio = dampingRatio;
				JointDef.Initialize(pBody1, pBody2, position1, position2);
				this.world.CreateJoint(JointDef);
			},
			rBodyApplyForce:            function (pBody, force, angle)
			{
				var position = new Box2D.Common.Math.b2Vec2(pBody.GetPosition().x, pBody.GetPosition().y);
				var f = new Box2D.Common.Math.b2Vec2(force * Math.cos(angle * Box2D.Common.b2Settings.b2_pi / 180.0), force * Math.sin(angle * Box2D.Common.b2Settings.b2_pi / 180.0));
				pBody.ApplyForce(f, position);
			},
			rBodyStopForce:             function (pBody)
			{
				pBody.ResetForce();
			},
			rBodyApplyAngularImpulse:   function (pBody, torque)
			{
				pBody.ApplyTorque(torque);
				//pBody.SetAngularVelocity(torque * 100);
			},
			rBodyApplyTorque:           function (pBody, torque)
			{
				pBody.ApplyTorque(torque);
			},
			rBodyStopTorque:            function (pBody)
			{
				pBody.ResetTorque();
			},
			rBodySetAngularVelocity:    function (pBody, torque)
			{
				pBody.SetAngularVelocity(torque);
			},
			rBodyAddVelocity:           function (pBody, vx, vy)
			{
				var velocity = pBody.GetLinearVelocity();
				velocity.x += vx;
				velocity.y += vy;
				pBody.SetLinearVelocity(velocity);
			},
			rBodyApplyMMFImpulse:       function (pBody, force, angle)
			{
				var velocity = pBody.GetLinearVelocity();
				if (angle > 360)
					angle -= 360;
				var f = new Box2D.Common.Math.b2Vec2(force * Math.cos(angle * Box2D.Common.b2Settings.b2_pi / 180.0), force * Math.sin(angle * Box2D.Common.b2Settings.b2_pi / 180.0));
				velocity.x += f.x / pBody.GetMass();
				velocity.y += f.y / pBody.GetMass();
				pBody.SetLinearVelocity(velocity);
			},
			rBodyApplyImpulse:          function (pBody, force, angle)
			{
				var position = new Box2D.Common.Math.b2Vec2(pBody.GetPosition().x, pBody.GetPosition().y);
				var f = new Box2D.Common.Math.b2Vec2(force * Math.cos(angle * Box2D.Common.b2Settings.b2_pi / 180.0), force * Math.sin(angle * Box2D.Common.b2Settings.b2_pi / 180.0));
				pBody.ApplyImpulse(f, position);
			},
			rBodyGetAngle:              function (body)
			{
				return body.GetAngle() * 180.0 / Box2D.Common.b2Settings.b2_pi;
			},
			rBodySetPosition:           function (pBody, x, y)
			{
				var angle = pBody.GetAngle();
				var position = new Box2D.Common.Math.b2Vec2(pBody.GetPosition().x, pBody.GetPosition().y);
				if (x != CRunBox2DBase.POSDEFAULT)
					position.x = (this.xBase + x) / this.factor;
				if (y != CRunBox2DBase.POSDEFAULT)
					position.y = (this.yBase - y) / this.factor;
				pBody.SetPositionAndAngle(position, angle);
			},
			rBodySetAngle:              function (pBody, angle)
			{
				var position = new Box2D.Common.Math.b2Vec2(pBody.GetPosition().x, pBody.GetPosition().y);
				pBody.SetPositionAndAngle(position, angle * Box2D.Common.b2Settings.b2_pi / 180.0);
			},
			rBodySetLinearVelocity:     function (pBody, force, angle)
			{
				var f = new Box2D.Common.Math.b2Vec2(force * Math.cos(angle * Box2D.Common.b2Settings.b2_pi / 180.0), force * Math.sin(angle * Box2D.Common.b2Settings.b2_pi / 180.0));
				pBody.SetLinearVelocity(f);
			},
			rBodyAddLinearVelocity:     function (pBody, speed, angle)
			{
				var v = new Box2D.Common.Math.b2Vec2(speed * Math.cos(angle * Box2D.Common.b2Settings.b2_pi / 180.0), speed * Math.sin(angle * Box2D.Common.b2Settings.b2_pi / 180.0));
				var velocity = pBody.GetLinearVelocity();
				velocity.x += v.x;
				velocity.y += v.y;
				pBody.SetLinearVelocity(velocity);
			},
			rBodySetLinearVelocityAdd:  function (pBody, force, angle, vx, vy)
			{
				var f = new Box2D.Common.Math.b2Vec2(force * Math.cos(angle * Box2D.Common.b2Settings.b2_pi / 180.0) + vx, force * Math.sin(angle * Box2D.Common.b2Settings.b2_pi / 180.0) + vy);
				pBody.SetLinearVelocity(f);
			},
			isPoint:                    function (pMask, x, y)
			{
				var offset = (y * pMask.lineWidth) + Math.floor(x / 16);
				var m = (0x8000) >>> (x & 15);
				return (pMask.mask[offset] & m) != 0;
			},
			PointOK:                    function (xNew, yNew, xOld, yOld, angle)
			{
				var deltaX = xNew - xOld;
				var deltaY = yNew - yOld;
				var a = angle.angle;
				angle.angle = (Math.atan2(deltaY, deltaX) * 57.2957795);
				if (a == angle.angle)
					return false;
				return true;
			},
			rBodyCreateShapeFixture:    function (pBody, pMBase, xp, yp, img, density, friction, restitution, scaleX, scaleY)
			{
				var box = new Box2D.Collision.Shapes.b2PolygonShape();
				var image = this.rh.rhApp.imageBank.getImageFromHandle(img);
				var pMask = image.getMask(0, 0, 1.0, 1.0);
				var width = pMask.width;
				var height = pMask.height;
				var x, y, xPrevious, yPrevious;
				var xArray = new Array();
				var yArray = new Array();
				var xPos, yPos;
				var angle;
				var count = 0;
				var scaleError = 1.0;       // (height - 2.0) / height;

				if (pMBase != null)
				{
					pMBase.rc.left = -width / 2 * scaleX;
					pMBase.rc.right = width / 2 * scaleX;
					pMBase.rc.top = -height / 2 * scaleY;
					pMBase.rc.bottom = height / 2 * scaleY;
				}

				var bBackground = false;
				if (density < 0)
				{
					bBackground = true;
					density = 0;
				}

				// Right - bottom
				for (y = height - 1, xPos = -1; y >= 0; y--)
				{
					for (x = width - 1; x >= 0; x--)
					{
						if (this.isPoint(pMask, x, y))
						{
							if (x > xPos)
							{
								xPos = x;
								yPos = y;
							}
							break;
						}
					}
				}
				if (xPos < 0)
				{
					return this.rBodyCreateBoxFixture(pBody, pMBase, xp, yp, pMask.width, pMask.height, density, friction, restitution);
				}
				xPrevious = xArray[count] = xPos;
				yPrevious = yArray[count] = yPos;
				count++;

				// Right - top
				for (y = 0, xPos = -1; y < height; y++)
				{
					for (x = width - 1; x >= 0; x--)
					{
						if (this.isPoint(pMask, x, y))
						{
							if (x > xPos)
							{
								xPos = x;
								yPos = y;
							}
							break;
						}
					}
				}
				angle = {};
				angle.angle = 1000;
				var c;
				if (this.PointOK(xPos, yPos, xPrevious, yPrevious, angle))
				{
					for (c = 0; c < count; c++)
					{
						if (xArray[c] == xPos && yArray[c] == yPos)
							break;
					}
					if (c == count)
					{
						xPrevious = xArray[count] = xPos;
						yPrevious = yArray[count++] = yPos;
					}
				}

				// Top - right
				for (x = width - 1, yPos = 10000; x >= 0; x--)
				{
					for (y = 0; y < height; y++)
					{
						if (this.isPoint(pMask, x, y))
						{
							if (y < yPos)
							{
								xPos = x;
								yPos = y;
							}
							break;
						}
					}
				}
				for (c = 0; c < count; c++)
				{
					if (xArray[c] == xPos && yArray[c] == yPos)
						break;
				}
				if (c == count)
				{
					if (!this.PointOK(xPos, yPos, xPrevious, yPrevious, angle))
						count--;
					xPrevious = xArray[count] = xPos;
					yPrevious = yArray[count++] = yPos;
				}

				// Top - left
				for (x = 0, yPos = 10000; x < width; x++)
				{
					for (y = 0; y < height; y++)
					{
						if (this.isPoint(pMask, x, y))
						{
							if (y < yPos)
							{
								xPos = x;
								yPos = y;
							}
							break;
						}
					}
				}
				for (c = 0; c < count; c++)
				{
					if (xArray[c] == xPos && yArray[c] == yPos)
						break;
				}
				if (c == count)
				{
					if (!this.PointOK(xPos, yPos, xPrevious, yPrevious, angle))
						count--;
					xPrevious = xArray[count] = xPos;
					yPrevious = yArray[count++] = yPos;
				}

				// Left - top
				for (y = 0, xPos = 10000; y < height; y++)
				{
					for (x = 0; x < width; x++)
					{
						if (this.isPoint(pMask, x, y))
						{
							if (x < xPos)
							{
								xPos = x;
								yPos = y;
							}
							break;
						}
					}
				}
				for (c = 0; c < count; c++)
				{
					if (xArray[c] == xPos && yArray[c] == yPos)
						break;
				}
				if (c == count)
				{
					if (!this.PointOK(xPos, yPos, xPrevious, yPrevious, angle))
						count--;
					xPrevious = xArray[count] = xPos;
					yPrevious = yArray[count++] = yPos;
				}

				// Left - bottom
				for (y = height - 1, xPos = 10000; y >= 0; y--)
				{
					for (x = 0; x < width; x++)
					{
						if (this.isPoint(pMask, x, y))
						{
							if (x < xPos)
							{
								xPos = x;
								yPos = y;
							}
							break;
						}
					}
				}
				for (c = 0; c < count; c++)
				{
					if (xArray[c] == xPos && yArray[c] == yPos)
						break;
				}
				if (c == count)
				{
					if (!this.PointOK(xPos, yPos, xPrevious, yPrevious, angle))
						count--;
					xPrevious = xArray[count] = xPos;
					yPrevious = yArray[count++] = yPos;
				}

				// Bottom - left
				for (x = 0, yPos = -1; x < width; x++)
				{
					for (y = height - 1; y >= 0; y--)
					{
						if (this.isPoint(pMask, x, y))
						{
							if (y > yPos)
							{
								xPos = x;
								yPos = y;
							}
							break;
						}
					}
				}
				for (c = 0; c < count; c++)
				{
					if (xArray[c] == xPos && yArray[c] == yPos)
						break;
				}
				if (c == count)
				{
					if (!this.PointOK(xPos, yPos, xPrevious, yPrevious, angle))
						count--;
					xPrevious = xArray[count] = xPos;
					yPrevious = yArray[count++] = yPos;
				}

				// Bottom - right
				for (x = width - 1, yPos = -1; x >= 0; x--)
				{
					for (y = height - 1; y >= 0; y--)
					{
						if (this.isPoint(pMask, x, y))
						{
							if (y > yPos)
							{
								xPos = x;
								yPos = y;
							}
							break;
						}
					}
				}
				for (c = 0; c < count; c++)
				{
					if (xArray[c] == xPos && yArray[c] == yPos)
						break;
				}
				if (c == count)
				{
					if (!this.PointOK(xPos, yPos, xPrevious, yPrevious, angle))
						count--;
					xArray[count] = xPos;
					yArray[count++] = yPos;
				}

				if (count <= 1)
					return this.rBodyCreateBoxFixture(pBody, pMBase, xp, yp, pMask.width, pMask.height, density, friction, restitution);

				if (count == 2)
				{
					var xTemp = new Array();
					var yTemp = new Array();
					if (xArray[0] != xArray[1])
					{
						xTemp[0] = xArray[0];
						yTemp[0] = yArray[0] + 1;
						xTemp[1] = xArray[0];
						yTemp[1] = yArray[0];
						xTemp[2] = xArray[1];
						yTemp[2] = yArray[1];
						xTemp[3] = xArray[1];
						yTemp[3] = yArray[1] + 1;
					}
					else
					{
						xTemp[0] = xArray[0];
						yTemp[0] = yArray[0];
						xTemp[1] = xArray[1];
						yTemp[1] = yArray[1];
						xTemp[2] = xArray[1] - 1;
						yTemp[2] = yArray[1];
						xTemp[3] = xArray[0] - 1;
						yTemp[3] = yArray[0];
					}
					xArray = xTemp;
					yArray = yTemp;
					count = 4;
				}

				var xMiddle = 0;
				var yMiddle = 0;
				if (!bBackground)
				{
					var n;
					for (n = 0; n < count; n++)
					{
						xMiddle += xArray[n];
						yMiddle += yArray[n];
					}
					xMiddle /= count;
					yMiddle /= count;
				}
				else
				{
					xMiddle = width / 2;
					yMiddle = height / 2;
				}

				var vertices = new Array();
				for (n = 0; n < count; n++)
				{
					vertices[n] = new Box2D.Common.Math.b2Vec2(0, 0);
					var fx = ((xArray[n] - xMiddle) / this.factor * scaleX * scaleError);
					var fy = ((yMiddle - yArray[n]) / this.factor * scaleY * scaleError);
					vertices[n].Set(fx, fy);
				}

				var polygon;
				var fixtureDef = new Box2D.Dynamics.b2FixtureDef();
				polygon = new Box2D.Collision.Shapes.b2PolygonShape();
				polygon.SetAsArray(vertices, count);

				fixtureDef.shape = polygon;
				fixtureDef.density = density;
				fixtureDef.friction = friction;
				fixtureDef.restitution = restitution;
				fixtureDef.userData = this;
				return pBody.CreateFixture(fixtureDef);
			},
			rCreateBullet:              function (angle, speed, pMBase)
			{
				if ((this.flags & CRunBox2DBase.B2FLAG_BULLETCREATE) == 0)
					return null;

				var hoPtr = pMBase.m_pHo;

				var bodyDef = new Box2D.Dynamics.b2BodyDef();
				bodyDef.type = Box2D.Dynamics.b2Body.b2_dynamicBody;
				bodyDef.position.Set((this.xBase + hoPtr.hoX) / this.factor, (this.yBase - hoPtr.hoY) / this.factor);
				bodyDef.angle = ((angle * Box2D.Common.b2Settings.b2_pi) / 180.0);
				bodyDef.gravityScale = this.bulletGravity;
				bodyDef.userData = pMBase;
				pBody = this.world.CreateBody(bodyDef);

				this.rBodyCreateShapeFixture(pBody, pMBase, hoPtr.hoX, hoPtr.hoY, hoPtr.roc.rcImage, this.bulletDensity, this.bulletFriction, this.bulletRestitution, hoPtr.roc.rcScaleX, hoPtr.roc.rcScaleY);

				var velocity = new Box2D.Common.Math.b2Vec2(speed * Math.cos(angle * Box2D.Common.b2Settings.b2_pi / 180.0), speed * Math.sin(angle * Box2D.Common.b2Settings.b2_pi / 180.0));
				pBody.SetLinearVelocity(velocity);

				return pBody;
			},
			rBodyResetMassData:         function (pBody)
			{
				pBody.ResetMassData();
			},
			rBodySetTransform:          function (pBody, position, angle)
			{
				pBody.SetPositionAndAngle(position, angle);
			},
			rGetBodyPosition:           function (pBody, o)
			{
				var vect = pBody.GetPosition();
				var position = new Box2D.Common.Math.b2Vec2(vect.x, vect.y);
				this.rWorldToFrame(position);
				o.x = CServices.floatToInt(position.x);
				o.y = CServices.floatToInt(position.y);
				o.angle = CServices.floatToInt(((pBody.GetAngle() * 180) / Box2D.Common.b2Settings.b2_pi));
			},
			rGetImageDimensions:        function (img, o)
			{
				var image = this.rh.rhApp.imageBank.getImageFromHandle(img);
				var pMask = image.getMask(0, 0, 1.0, 1.0);

				var xx, yy, previousX = -1, previousY = -1;
				var count = 1;
				o.y1 = 0, o.y2 = pMask.height - 1;
				var quit = false;
				for (yy = 0, quit = false; yy < pMask.height; yy++)
				{
					for (xx = 0; xx < pMask.width; xx++)
					{
						if (this.isPoint(pMask, xx, yy))
						{
							o.y1 = yy;
							quit = true;
							break;
						}
					}
					if (quit) break;
				}
				for (yy = pMask.height - 1, quit = false; yy >= 0; yy--)
				{
					for (xx = 0; xx < pMask.width; xx++)
					{
						if (this.isPoint(pMask, xx, yy))
						{
							o.y2 = yy;
							quit = true;
							break;
						}
					}
					if (quit) break;
				}
				o.x1 = 0, o.x2 = pMask.width - 1;
				for (xx = 0, quit = false; xx < pMask.width; xx++)
				{
					for (yy = 0; yy < pMask.height; yy++)
					{
						if (this.isPoint(pMask, xx, yy))
						{
							o.x1 = xx;
							quit = true;
							break;
						}
					}
					if (quit) break;
				}
				for (xx = pMask.width - 1, quit = false; xx >= 0; xx--)
				{
					for (yy = pMask.height - 1; yy >= 0; yy--)
					{
						if (this.isPoint(pMask, xx, yy))
						{
							o.x2 = xx;
							quit = true;
							break;
						}
					}
					if (quit) break;
				}
			},
			rBodyCreatePlatformFixture: function (pBody, pMBase, img, vertical, dummy, density, friction, restitution, o, scaleX, scaleY, maskWidth)
			{
				var dims = {};
				this.rGetImageDimensions(img, dims);
				dims.x1 *= scaleX;
				dims.x2 *= scaleX;
				dims.y1 *= scaleY;
				dims.y2 *= scaleY;
				maskWidth = Math.max(maskWidth, 0.1);
				var image = this.rh.rhApp.imageBank.getImageFromHandle(img);
				var pMask = image.getMask(0, 0, 1.0, 1.0);
				var xx, yy;

				var vertices = new Array();
				var n;
				for (n = 0; n < 6; n++)
					vertices[n] = new Box2D.Common.Math.b2Vec2(0, 0);

				var sx = dims.x2 - dims.x1;
				var middleX = (dims.x1 + dims.x2) / 2;
				var middleY = 0;	//(y1+y2)/2; // 0
				var sy = (dims.y1 + dims.y2) / 2;

				xx = -sx / 4 * maskWidth;
				yy = middleY;
				vertices[0].Set(xx / this.factor, yy / this.factor);
				xx = sx / 4 * maskWidth;
				vertices[1].Set(xx / this.factor, yy / this.factor);

				xx = sx / 2 * maskWidth;
				yy = middleY + sy / 8;
				vertices[2].Set(xx / this.factor, yy / this.factor);

				xx = sx / 2 * maskWidth;
				yy = middleY + sy * 2;
				vertices[3].Set(xx / this.factor, yy / this.factor);
				xx = -sx / 2 * maskWidth;
				vertices[4].Set(xx / this.factor, yy / this.factor);

				xx = -sx / 2 * maskWidth;
				yy = middleY + sy / 8;
				vertices[5].Set(xx / this.factor, yy / this.factor);

				o.offsetX = sx;
				o.offsetY = sy;
				pMBase.rc.left = -middleX * maskWidth;
				pMBase.rc.right = middleX * maskWidth;
				pMBase.rc.top = -sy;
				pMBase.rc.bottom = sy;

				var polygon = new Box2D.Collision.Shapes.b2PolygonShape();
				polygon.SetAsArray(vertices, 6);
				var fixtureDef = new Box2D.Dynamics.b2FixtureDef();
				fixtureDef.shape = polygon;
				fixtureDef.density = density;
				fixtureDef.friction = friction;
				fixtureDef.restitution = restitution;
				fixtureDef.userData = this;
				o.pFixture = pBody.CreateFixture(fixtureDef);
			},

			computeGroundObjects: function ()
			{
				var rhPtr = this.ho.hoAdRunHeader;
				var pOL = 0;
				var ocGrounds = new CArrayList();
				var ocGround;
				for (var nObjects = 0; nObjects < rhPtr.rhNObjects; nObjects++)
				{
					while (rhPtr.rhObjectList[pOL] == null) pOL++;
					var pHo = rhPtr.rhObjectList[pOL];
					pOL++;
					if (pHo.hoType >= 32)
					{
						if (pHo.hoCommon.ocIdentifier == CRunBox2DBase.GROUNDIDENTIFIER)
						{
							var pGround = pHo.ext;
							if (pGround.identifier == this.identifier)
							{
								var n;
								for (n = 0; n < ocGrounds.size(); n++)
								{
									if (ocGrounds.get(n) == pHo.hoCommon)
										break;
								}
								if (n == ocGrounds.size())
								{
									ocGrounds.add(pHo.hoCommon);
									ocGround = pHo.hoCommon;
									var obstacle = pGround.obstacle;
									var direction = pGround.direction;
									var pOL2 = pOL;
									var list = new CArrayList();
									list.add(pGround);
									for (var nObjects2 = nObjects + 1; nObjects2 < rhPtr.rhNObjects; nObjects2++)
									{
										while (rhPtr.rhObjectList[pOL2] == 0) pOL2++;
										pHo = rhPtr.rhObjectList[pOL2];
										pOL2++;

										if (pHo.hoType >= 32)
										{
											if (pHo.hoCommon.ocIdentifier == CRunBox2DBase.GROUNDIDENTIFIER && pHo.hoCommon == ocGround)
											{
												var pGround2 = pHo.ext;
												if (pGround2.identifier == this.identifier && pGround2.obstacle == obstacle && pGround2.direction == direction)
												{
													list.add(pGround2);
												}
											}
										}
									}
									if (list.size() > 1)
									{
										var pos;
										var flag;
										do
										{
											flag = false;
											pos = 0;
											do
											{
												var pSort1 = list.get(pos);
												var pSort2 = list.get(pos + 1);
												var temp;
												var x1 = pSort1.ho.hoX + 8;
												var x2 = pSort2.ho.hoX + 8;
												var y1 = pSort1.ho.hoY + 8;
												var y2 = pSort2.ho.hoY + 8;
												switch (direction)
												{
													case CRunBox2DBase.DIRECTION_LEFTTORIGHT:
														if (x2 < x1)
														{
															temp = pSort1;
															list.set(pos, pSort2);
															list.set(pos + 1, temp);
															flag = true;
														}
														break;
													case CRunBox2DBase.DIRECTION_RIGHTTOLEFT:
														if (x2 > x1)
														{
															temp = pSort1;
															list.set(pos, pSort2);
															list.set(pos + 1, temp);
															flag = true;
														}
														break;
													case CRunBox2DBase.DIRECTION_TOPTOBOTTOM:
														if (y2 < y1)
														{
															temp = pSort1;
															list.set(pos, pSort2);
															list.set(pos + 1, temp);
															flag = true;
														}
														break;
													case CRunBox2DBase.DIRECTION_BOTTOMTOTOP:
														if (y2 > y1)
														{
															temp = pSort1;
															list.set(pos, pSort2);
															list.set(pos + 1, temp);
															flag = true;
														}
														break;
												}
												pos++;
											} while (pos < list.size() - 1);
										} while (flag);

										for (pos = 0; pos < list.size() - 1; pos++)
										{
											var pSort1 = list.get(pos);
											var pSort2 = list.get(pos + 1);
											var x1 = pSort1.ho.hoX + 8;
											var x2 = pSort2.ho.hoX + 8;
											var y1 = pSort1.ho.hoY + 8;
											var y2 = pSort2.ho.hoY + 8;

											var width = x2 - x1;
											var height = Math.abs(y2 - y1);
											var middleX = (x1 + x2) / 2;
											var middleY = (y1 + y2) / 2;

											var pBase = new CRunMBase();
											pBase.InitBase(null, (obstacle == CRunBox2DBase.OBSTACLE_OBSTACLE) ? CRunMBase.MTYPE_OBSTACLE : CRunMBase.MTYPE_PLATFORM);
											pBase.m_body = this.rCreateBody(Box2D.Dynamics.b2Body.b2_staticBody, middleX, middleY, 0, 0, pBase, 0);

											pBase.rc.left = -width;
											pBase.rc.right = width;
											pBase.rc.top = -height;
											pBase.rc.bottom = height;

											var vertices = new Array();
											var n;
											for (n = 0; n < 4; n++)
												vertices[n] = new Box2D.Common.Math.b2Vec2(0, 0);

											vertices[0].Set((x1 - middleX) / this.factor, (middleY - y1) / this.factor);
											vertices[1].Set((x1 - middleX) / this.factor, (middleY - y1 - 8) / this.factor);
											vertices[2].Set((x2 - middleX) / this.factor, (middleY - y2 - 8) / this.factor);
											vertices[3].Set((x2 - middleX) / this.factor, (middleY - y2) / this.factor);

											var polygon = new Box2D.Collision.Shapes.b2PolygonShape();
											polygon.SetAsArray(vertices, 4);
											var fixtureDef = new Box2D.Dynamics.b2FixtureDef();
											fixtureDef.shape = polygon;
											fixtureDef.density = 1.0;
											fixtureDef.friction = pGround.friction;
											fixtureDef.restitution = pGround.restitution;
											fixtureDef.userData = this;
											pBase.m_body.CreateFixture(fixtureDef);
										}
									}
								}
							}
						}
					}
				}
			},

			createBorders: function ()
			{
				var pBase = new CRunMBase();
				pBase.InitBase(null, CRunMBase.MTYPE_BORDERBOTTOM);
				pBase.m_body = this.rCreateBody(Box2D.Dynamics.b2Body.b2_staticBody, this.rh.rhLevelSx / 2, this.rh.rhLevelSy + 8, 0, 0, pBase, 0, 0);
				this.rBodyCreateBoxFixture(pBase.m_body, pBase, this.rh.rhLevelSx / 2, this.rh.rhLevelSy + 8, this.rh.rhLevelSx, 16, 0, 1, 0);

				pBase = new CRunMBase();
				pBase.InitBase(null, CRunMBase.MTYPE_BORDERLEFT);
				pBase.m_body = this.rCreateBody(Box2D.Dynamics.b2Body.b2_staticBody, -8, this.rh.rhLevelSy / 2, 0, 0, pBase, 0, 0);
				this.rBodyCreateBoxFixture(pBase.m_body, pBase, -8, this.rh.rhLevelSy / 2, 16, this.rh.rhLevelSy, 0, 1, 0);

				pBase = new CRunMBase();
				pBase.InitBase(null, CRunMBase.MTYPE_BORDERRIGHT);
				pBase.m_body = this.rCreateBody(Box2D.Dynamics.b2Body.b2_staticBody, this.rh.rhLevelSx + 8, this.rh.rhLevelSy / 2, 0, 0, pBase, 0, 0);
				this.rBodyCreateBoxFixture(pBase.m_body, pBase, this.rh.rhLevelSx + 8, this.rh.rhLevelSy / 2, 16, this.rh.rhLevelSy, 0, 1, 0);

				pBase = new CRunMBase();
				pBase.InitBase(null, CRunMBase.MTYPE_BORDERTOP);
				pBase.m_body = this.rCreateBody(Box2D.Dynamics.b2Body.b2_staticBody, this.rh.rhLevelSx / 2, -8, 0, 0, pBase, 0, 0);
				this.rBodyCreateBoxFixture(pBase.m_body, pBase, this.rh.rhLevelSx / 2, -8, this.rh.rhLevelSx, 16, 0, 1, 0);
			},

			Find_HeaderObject: function (hlo, rhPtr)
			{
				var pOL = 0;
				for (var nObjects = 0; nObjects < rhPtr.rhNObjects; nObjects++)
				{
					while (rhPtr.rhObjectList[pOL] == null)
						pOL++;
					var pHo = rhPtr.rhObjectList[pOL];
					if (hlo == pHo.hoHFII)
						return pHo;
					pOL++;
				}
				return null;
			},

			computeBackdropObjects: function ()
			{
				var rhPtr = this.rh;
				var pCurFrame = rhPtr.rhFrame;
				var pCurApp = rhPtr.rhApp;

				var nLayer, i;
				var plo;
				var hoPtr;
				var poi;
				var poc;

				for (nLayer = 0; nLayer < pCurFrame.layers.length; nLayer++)
				{
					var pLayer = pCurFrame.layers[nLayer];

					// Invisible layer? continue
					if ((pLayer.dwOptions & CLayer.FLOPT_VISIBLE) == 0)
					{
						continue;
					}

					var cpt;
					for (i = pLayer.nFirstLOIndex, cpt = 0; cpt < pLayer.nBkdLOs; i++, cpt++)
					{
						var plo = this.rh.rhFrame.LOList.list[i];
						var x, y;
						var typeObj = plo.loType;
						var width, height, obstacle;
						var box;

						if (typeObj >= COI.OBJ_SPR)
							continue;

						x = plo.loX;
						y = plo.loY;
						poi = pCurApp.OIList.getOIFromHandle(plo.loOiHandle);
						if (poi == null || poi.oiOC == null)
							continue;
						poc = poi.oiOC;

						width = poc.ocCx;
						height = poc.ocCy;
						obstacle = poc.ocObstacleType;
						box = poc.ocColMode;

						if (obstacle == COC.OBSTACLE_SOLID || obstacle == COC.OBSTACLE_PLATFORM)
						{
							var pBase = new CRunMBase();
							pBase.InitBase(null, ((obstacle == COC.OBSTACLE_SOLID) ? CRunMBase.MTYPE_OBSTACLE : CRunMBase.MTYPE_PLATFORM));
							pBase.m_body = this.rCreateBody(Box2D.Dynamics.b2Body.b2_staticBody, x + width / 2, y + height / 2, 0, 0, pBase, 0, 0);
							if (typeObj == COI.OBJ_BOX)
								this.rBodyCreateBoxFixture(pBase.m_body, pBase, x + width / 2, y + height / 2, width, height, 0.0, this.friction, this.restitution);
							else
							{
								var img = poc.ocImage;
								this.rBodyCreateShapeFixture(pBase.m_body, pBase, x + width / 2, y + height / 2, img, -1, this.friction, this.restitution, 1.0, 1.0);
							}
						}
					}
				}
			},

			getNumberOfConditions: function ()
			{
				return 0;
			},

			CheckOtherEngines: function ()
			{
				var pOL = 0;
				var nObjects = 0;
				for (nObjects = 0; nObjects < this.rh.rhNObjects; pOL++, nObjects++)
				{
					while (this.rh.rhObjectList[pOL] == null) pOL++;
					var pBase = this.rh.rhObjectList[pOL];
					if (pBase.hoType >= 32)
					{
						if (pBase.hoCommon.ocIdentifier == CRun.BASEIDENTIFIER && pBase != this.ho)
						{
							if (pBase.ext.identifier == this.identifier)
							{
								return true;
							}
						}
					}
				}
				return false;
			},

			isPaused: function () {
			    return this.bPaused;
			},

			rStartObject:    function ()
			{
				if (this.started == false)
				{
					this.started = true;

					this.GetObjects();
					this.computeGroundObjects();
					if (this.flags & CRunBox2DBase.B2FLAG_ADDBACKDROPS)
					{
						this.computeBackdropObjects(this);
					}
				}
				return false;
			},
			createRunObject: function (file, cob, version)
			{
				this.xBase = 0;
				this.yBase = this.rh.rhApp.gaCyWin;

				this.flags = file.readAInt();
				this.velocityIterations = file.readAInt();
				this.positionIterations = file.readAInt();
				file.skipBytes(4);
				this.angle = file.readAInt() * Box2D.Common.b2Settings.b2_pi / 16.0;
				this.factor = file.readAInt();
				this.friction = file.readAInt() / 100.0;
				this.restitution = file.readAInt() / 100.0;
				this.bulletFriction = file.readAInt() / 100.0;
				this.bulletRestitution = file.readAInt() / 100.0;
				this.bulletGravity = file.readAInt() / 100.0;
				this.bulletDensity = file.readAInt() / 100.0;
				this.gravity = file.readAFloat();
				this.identifier = file.readAInt();
				this.npDensity = file.readAInt() / 100.0;
				this.npFriction = file.readAInt() / 100.0;

				var gravity = new Box2D.Common.Math.b2Vec2(this.gravity * Math.cos(this.angle), this.gravity * Math.sin(this.angle));
				this.world = new Box2D.Dynamics.b2World(gravity, false);
				this.contactListener = new ContactListener();
				this.world.SetContactListener(this.contactListener);
				this.started = false;
				this.bListener = true;
				this.bPaused = false;

				// If another engine exists with the same identifier -> set identifier to random value
				if (this.CheckOtherEngines())
					this.identifier = 1000 + this.ho.hoNumber;

				this.createBorders();

				// No errors
				return 0;
			},

			destroyRunObject: function (fast)
			{
				this.world = null;
			},

			GetHO: function (fixedValue)
			{
				var hoPtr = this.rh.rhObjectList[fixedValue & 0xFFFF];
				if (hoPtr != null && hoPtr.hoCreationId == fixedValue >> 16)
					return hoPtr;
				return null;
			},

			getAnimDir: function (pHo, dir)
			{
				var raPtr = pHo.roa;

				var adPtr = raPtr.raAnimOffset.anDirs[dir];
				if (adPtr != null)
					return dir;

				if ((raPtr.raAnimOffset.anAntiTrigo[dir] & 0x40) != 0)
					dir = raPtr.raAnimOffset.anAntiTrigo[dir] & 0x3F;
				else if ((raPtr.raAnimOffset.anTrigo[dir] & 0x40) != 0)
					dir = raPtr.raAnimOffset.anTrigo[dir] & 0x3F;
				else
				{
					var offset = dir;
					if (raPtr.raAnimPreviousDir < 0)
						dir = raPtr.raAnimOffset.anTrigo[dir] & 0x3F;
					else
					{
						dir -= raPtr.raAnimPreviousDir;
						dir &= 31;
						if (dir > 15)
							dir = raPtr.raAnimOffset.anTrigo[offset] & 0x3F;
						else
							dir = raPtr.raAnimOffset.anAntiTrigo[offset] & 0x3F;
					}
				}
				return dir;
			},

			handleRunObject: function ()
			{
				this.rStartObject(this);

				if (this.bPaused) {
				    if (this.bListener)
				        this.world.SetContactListener(null); // this will set contact listener to null, then no more collision detect
				    this.bListener = false;
				    return 0;
				}
				else {
				    if (!this.bListener)
				        this.world.SetContactListener(this.contactListener); // restore the listener to continue detect collisions
				    this.bListener = true;
				}

				var i;
				for (i = 0; i < this.objectIDs.size(); i++)
				{
					var value = this.objectIDs.get(i);
					var pHo = this.GetHO(value);
					var pBase = this.objects.get(i);
					if (pHo != null && pBase.m_pHo != pHo)
					{
						pHo = null;
					}
					if (pHo == null)
					{
						this.rDestroyBody(pBase.m_body);
						this.objectIDs.removeIndex(i);
						this.objects.removeIndex(i);
						i--;
					}
					else
					{
						var position = new Box2D.Common.Math.b2Vec2((this.xBase + pHo.hoX) / this.factor, (this.yBase - pHo.hoY) / this.factor);
						var angle = this.getAnimDir(pHo, pHo.roc.rcDir) * Box2D.Common.b2Settings.b2_pi / 16.0;
						pBase.m_body.SetPositionAndAngle(position, angle);
					}
				}
				if (this.world != null)
				{
					var timeStep = 1.0 / this.rh.rhApp.gaFrameRate;
					this.world.Step(timeStep, this.velocityIterations, this.positionIterations);
				}
				var n;
				if (this.bodiesToDestroy.size() > 0)
				{
					for (n = 0; n < this.bodiesToDestroy.size(); n++)
					{
						this.rDestroyBody(this.bodiesToDestroy.get(n));
					}
					this.bodiesToDestroy.clear();
				}
				return 0;
			},

			// Actions
			// -------------------------------------------------

			GetMBase: function (pHo)
			{
				if (pHo == null)
					return null;
				if (pHo.rom == null || (pHo.hoFlags & CObject.HOF_DESTROYED) != 0)
					return null;
				if (pHo.roc.rcMovementType == CMoveDef.MVTYPE_EXT)
				{
	                var mvPtr = (pHo.hoCommon.ocMovements.moveList[pHo.rom.rmMvtNum]);
	                if (mvPtr.isPhysics)
					{
						var pBase = pHo.rom.rmMovement.movement;
						if (pBase.m_identifier == this.identifier)
						{
							return pBase;
						}
					}
				}
				return null;
			},

			RACTION_SETDENSITY:    function (act)
			{
				var pHo = act.getParamObject(this.rh, 0);
				var pmBase = this.GetMBase(pHo);
				if (pmBase != null)
				{
					var value = act.getParamExpression(this.rh, 1);
					pmBase.SetDensity(value);
				}
			},
			RACTION_SETFRICTION:   function (act)
			{
				var pHo = act.getParamObject(this.rh, 0);
				var pmBase = this.GetMBase(pHo);
				if (pmBase != null)
				{
					var value = act.getParamExpression(this.rh, 1);
					pmBase.SetFriction(value);
				}
			},
			RACTION_SETELASTICITY: function (act)
			{
				var pHo = act.getParamObject(this.rh, 0);
				var pmBase = this.GetMBase(pHo);
				if (pmBase != null)
				{
					var value = act.getParamExpression(this.rh, 1);
					pmBase.SetRestitution(value);
				}
			},
			RACTION_SETGRAVITY:    function (act)
			{
				var pHo = act.getParamObject(this.rh, 0);
				var pmBase = this.GetMBase(pHo);
				if (pmBase != null)
				{
					var value = act.getParamExpression(this.rh, 1);
					pmBase.SetGravity(value);
				}
			},

			RACTION_PAUSE: function (act) {
			    this.bPaused = true;
			},
			RACTION_RESUME: function (act) {
			    this.bPaused = false;
			},
			RACTION_SETITERATIONS: function (act)
			{
				this.velocityIterations = act.getParamExpression(this.rh, 0);
				this.positionIterations = act.getParamExpression(this.rh, 1);
			},
			RACTION_SETGRAVITYFORCE: function (act)
			{
				this.gravity = act.getParamExpDouble(this.rh, 0);
				var gravity = new Box2D.Common.Math.b2Vec2(this.gravity * Math.cos(this.angle), this.gravity * Math.sin(this.angle));
				this.world.SetGravity(gravity);
			},
			RACTION_SETGRAVITYANGLE: function (act)
			{
				this.angleBase = act.getParamExpression(this.rh, 0);
				this.angle = this.angleBase * Box2D.Common.b2Settings.b2_pi / 180.0;
				var gravity = new Box2D.Common.Math.b2Vec2(this.gravity * Math.cos(this.angle), this.gravity * Math.sin(this.angle));
				this.world.SetGravity(gravity);
			},
			CreateJoint:             function (name)
			{
				var n;
				var pJoint = new CJoint(this, name);
				this.joints.add(pJoint);
				return pJoint;
			},
			GetJoint:                function (sJoint, name, type)
			{
				var n;
				var pJoint;
				var index = 0;
				if (sJoint != null)
				{
					index = this.joints.indexOf(sJoint);
					if (index < 0)
						return null;
					index++;
				}
				for (n = index; n < this.joints.size(); n++)
				{
					pJoint = this.joints.get(n);
					if (CServices.compareStringsIgnoreCase(pJoint.m_name, name))
					{
						break;
					}
				}
				if (n < this.joints.size())
				{
					if (type == CRunBox2DBase.TYPE_ALL || type == pJoint.m_type)
					{
						return pJoint;
					}
				}
				return null;
			},
			GetActionPointPosition:  function (pBase)
			{
				var pHo = pBase.m_pHo;
				var rhPtr = this.rh;
				var x = pHo.hoX;
				var y = pHo.hoY;
				if (pBase.m_image != -1)
				{
					var angle = pHo.roc.rcAngle;
					var image = this.rh.rhApp.imageBank.getImageFromHandle(pBase.m_image);
					angle *= Box2D.Common.b2Settings.b2_pi / 180.0;
					var deltaX = image.xAP - image.xSpot;
					var deltaY = image.yAP - image.ySpot;
					x += (deltaX * Math.cos(angle) - deltaY * Math.sin(angle));
					y += (deltaX * Math.sin(angle) + deltaY * Math.cos(angle));
				}
				return new Box2D.Common.Math.b2Vec2((this.xBase + x) / this.factor, (this.yBase - y) / this.factor);
			},

			RACTION_DJOINTHOTSPOT:       function (act)
			{
				var name = act.getParamExpString(this.rh, 0);
				var pBase1 = this.GetMBase(act.getParamObject(this.rh, 1));
				var pBase2 = this.GetMBase(act.getParamObject(this.rh, 2));
				if (pBase1 != null && pBase2 != null)
				{
					var pJoint = this.CreateJoint(name);
					var JointDef = new Box2D.Dynamics.Joints.b2DistanceJointDef();
					JointDef.collideConnected = true;
					var position1 = new Box2D.Common.Math.b2Vec2(pBase1.m_body.GetPosition().x, pBase1.m_body.GetPosition().y);
					var position2 = new Box2D.Common.Math.b2Vec2(pBase2.m_body.GetPosition().x, pBase2.m_body.GetPosition().y);
					JointDef.Initialize(pBase1.m_body, pBase2.m_body, position1, position2);
					pJoint.SetJoint(CRunBox2DBase.TYPE_DISTANCE, this.world.CreateJoint(JointDef));
				}
				return true;
			},
			RACTION_DJOINTACTIONPOINT:   function (act)
			{
				var name = act.getParamExpString(this.rh, 0);
				var pBase1 = this.GetMBase(act.getParamObject(this.rh, 1));
				var pBase2 = this.GetMBase(act.getParamObject(this.rh, 2));
				if (pBase1 != null && pBase2 != null)
				{
					var pJoint = this.CreateJoint(name);
					var JointDef = new Box2D.Dynamics.Joints.b2DistanceJointDef();
					JointDef.collideConnected = true;
					JointDef.frequencyHz = 0;
					JointDef.dampingRatio = 0;
					var position1 = this.GetActionPointPosition(pBase1);
					var position2 = this.GetActionPointPosition(pBase2);
					JointDef.Initialize(pBase1.m_body, pBase2.m_body, position1, position2);
					pJoint.SetJoint(CRunBox2DBase.TYPE_DISTANCE, this.world.CreateJoint(JointDef));
				}
			},
			RACTION_DJOINTSETELASTICITY: function (act)
			{
				var pName = act.getParamExpString(this.rh, 0);
				var frequency = act.getParamExpDouble(this.rh, 1);
				var damping = act.getParamExpression(this.rh, 2) / 100.0;
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_DISTANCE);
				while (pJoint != null)
				{
					var pdJoint = pJoint.m_joint;
					pdJoint.SetFrequency(frequency);
					pdJoint.SetDampingRatio(damping);
					pJoint = this.GetJoint(pJoint, pName, CRunBox2DBase.TYPE_DISTANCE);
				}
			},
			GetImagePosition:            function (pBase, x1, y1)
			{
				var position = pBase.m_body.GetPosition();
				position.x += x1 / this.factor;
				position.y -= y1 / this.factor;
				return position;
			},
			RACTION_DJOINTPOSITION:      function (act)
			{
				var name = act.getParamExpString(this.rh, 0);
				var pBase1 = this.GetMBase(act.getParamObject(this.rh, 1));
				var x1 = act.getParamExpression(this.rh, 2);
				var y1 = act.getParamExpression(this.rh, 3);
				var pBase2 = this.GetMBase(act.getParamObject(this.rh, 4));
				var x2 = act.getParamExpression(this.rh, 5);
				var y2 = act.getParamExpression(this.rh, 6);
				if (pBase1 != null && pBase2 != null)
				{
					var pJoint = this.CreateJoint(name);
					var position1 = this.GetImagePosition(pBase1, x1, y1);
					var position2 = this.GetImagePosition(pBase2, x2, y2);
					var JointDef = new Box2D.Dynamics.Joints.b2DistanceJointDef();
					JointDef.collideConnected = true;
					JointDef.Initialize(pBase1.m_body, pBase2.m_body, position1, position2);
					pJoint.SetJoint(CRunBox2DBase.TYPE_DISTANCE, this.world.CreateJoint(JointDef));
				}
			},
			RACTION_RJOINTHOTSPOT:       function (act)
			{
				var name = act.getParamExpString(this.rh, 0);
				var pBase1 = this.GetMBase(act.getParamObject(this.rh, 1));
				var pBase2 = this.GetMBase(act.getParamObject(this.rh, 2));
				if (pBase1 != null && pBase2 != null)
				{
					var pJoint = this.CreateJoint(name);
					var JointDef = new Box2D.Dynamics.Joints.b2RevoluteJointDef();
					JointDef.collideConnected = true;
					var position = pBase1.m_body.GetPosition();
					JointDef.Initialize(pBase1.m_body, pBase2.m_body, position);
					pJoint.SetJoint(CRunBox2DBase.TYPE_REVOLUTE, this.world.CreateJoint(JointDef));
				}
			},
			RACTION_RJOINTACTIONPOINT:   function (act)
			{
				var name = act.getParamExpString(this.rh, 0);
				var pBase1 = this.GetMBase(act.getParamObject(this.rh, 1));
				var pBase2 = this.GetMBase(act.getParamObject(this.rh, 2));
				if (pBase1 != null && pBase2 != null)
				{
					var pJoint = this.CreateJoint(name);
					var JointDef = new Box2D.Dynamics.Joints.b2RevoluteJointDef();
					JointDef.collideConnected = true;
					var position = this.GetActionPointPosition(pBase1);
					JointDef.Initialize(pBase1.m_body, pBase2.m_body, position);
					pJoint.SetJoint(CRunBox2DBase.TYPE_REVOLUTE, this.world.CreateJoint(JointDef));
				}
			},
			RACTION_RJOINTPOSITION:      function (act)
			{
				var name = act.getParamExpString(this.rh, 0);
				var pBase1 = this.GetMBase(act.getParamObject(this.rh, 1));
				var x1 = act.getParamExpression(this.rh, 2);
				var y1 = act.getParamExpression(this.rh, 3);
				var pBase2 = this.GetMBase(act.getParamObject(this.rh, 4));
				if (pBase1 != null && pBase2 != null)
				{
					var pJoint = this.CreateJoint(name);
					var JointDef = new Box2D.Dynamics.Joints.b2RevoluteJointDef();
					JointDef.collideConnected = true;
					var position = this.GetImagePosition(pBase1, x1, y1);
					JointDef.Initialize(pBase1.m_body, pBase2.m_body, position);
					pJoint.SetJoint(CRunBox2DBase.TYPE_REVOLUTE, this.world.CreateJoint(JointDef));
				}
			},
			RACTION_RJOINTSETLIMITS:     function (act)
			{
				var pName = act.getParamExpString(this.rh, 0);
				var lAngle = act.getParamExpression(this.rh, 1) * Box2D.Common.b2Settings.b2_pi / 180.0;
				var uAngle = act.getParamExpression(this.rh, 2) * Box2D.Common.b2Settings.b2_pi / 180.0;
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_REVOLUTE);
				while (pJoint != null)
				{
					var prJoint = pJoint.m_joint;
					var flag = true;
					if (lAngle > uAngle)
						prJoint.EnableLimit(false);
					else
					{
						prJoint.EnableLimit(true);
						prJoint.SetLimits(lAngle, uAngle);
					}
					pJoint = this.GetJoint(pJoint, pName, CRunBox2DBase.TYPE_REVOLUTE);
				}
			},
			RACTION_RJOINTSETMOTOR:      function (act)
			{
				var pName = act.getParamExpString(this.rh, 0);
				var torque = act.getParamExpression(this.rh, 1) / 100.0 * CRunBox2DBase.RMOTORTORQUEMULT;
				var speed = act.getParamExpression(this.rh, 2) / 100.0 * CRunBox2DBase.RMOTORSPEEDMULT;
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_REVOLUTE);
				while (pJoint != null)
				{
					var prJoint = pJoint.m_joint;
					var flag = true;
					if (torque == 0 && speed == 0)
						flag = false;
					prJoint.EnableMotor(flag);
					prJoint.SetMaxMotorTorque(torque);
					prJoint.SetMotorSpeed(-speed);
					pJoint = this.GetJoint(pJoint, pName, CRunBox2DBase.TYPE_REVOLUTE);
				}
			},
			RACTION_PJOINTHOTSPOT:       function (act)
			{
				var name = act.getParamExpString(this.rh, 0);
				var pBase1 = this.GetMBase(act.getParamObject(this.rh, 1));
				var pBase2 = this.GetMBase(act.getParamObject(this.rh, 2));
				if (pBase1 != null && pBase2 != null)
				{
					var pJoint = this.CreateJoint(name);
					var JointDef = new Box2D.Dynamics.Joints.b2PrismaticJointDef();
					JointDef.collideConnected = true;
					var position1 = pBase1.m_body.GetPosition();
					var position2 = pBase2.m_body.GetPosition();
					var axis = new Box2D.Common.Math.b2Vec2(position2.x - position1.x, position2.y - position1.y);
					JointDef.Initialize(pBase1.m_body, pBase2.m_body, position1, axis);
					pJoint.SetJoint(CRunBox2DBase.TYPE_PRISMATIC, this.world.CreateJoint(JointDef));
				}
			},
			RACTION_PJOINTACTIONPOINT:   function (act)
			{
				var name = act.getParamExpString(this.rh, 0);
				var pBase1 = this.GetMBase(act.getParamObject(this.rh, 1));
				var pBase2 = this.GetMBase(act.getParamObject(this.rh, 2));
				if (pBase1 != null && pBase2 != null)
				{
					var pJoint = this.CreateJoint(name);
					var JointDef = new Box2D.Dynamics.Joints.b2PrismaticJointDef();
					JointDef.collideConnected = true;
					var position1 = this.GetActionPointPosition(pBase1);
					var position2 = this.GetActionPointPosition(pBase2);
					var axis = new Box2D.Common.Math.b2Vec2(position2.x - position1.x, position2.y - position1.y);
					JointDef.Initialize(pBase1.m_body, pBase2.m_body, position1, axis);
					pJoint.SetJoint(CRunBox2DBase.TYPE_PRISMATIC, this.world.CreateJoint(JointDef));
				}
			},
			RACTION_PJOINTPOSITION:      function (act)
			{
				var name = act.getParamExpString(this.rh, 0);
				var pBase1 = this.GetMBase(act.getParamObject(this.rh, 1));
				var x1 = act.getParamExpression(this.rh, 2);
				var y1 = act.getParamExpression(this.rh, 3);
				var pBase2 = this.GetMBase(act.getParamObject(this.rh, 4));
				var x2 = act.getParamExpression(this.rh, 5);
				var y2 = act.getParamExpression(this.rh, 6);
				if (pBase1 != null && pBase2 != null)
				{
					var pJoint = this.CreateJoint(name);
					var JointDef = new Box2D.Dynamics.Joints.b2PrismaticJointDef();
					JointDef.collideConnected = true;
					var position1 = this.GetImagePosition(pBase1, x1, y1);
					var position2 = this.GetImagePosition(pBase1, x2, y2);
					var axis = new Box2D.Common.Math.b2Vec2(position2.x - position1.x, position2.y - position1.y);
					JointDef.Initialize(pBase1.m_body, pBase2.m_body, position1, axis);
					pJoint.SetJoint(CRunBox2DBase.TYPE_PRISMATIC, this.world.CreateJoint(JointDef));
				}
			},
			RACTION_PJOINTSETLIMITS:     function (act)
			{
				var pName = act.getParamExpString(this.rh, 0);
				var lLimit = act.getParamExpression(this.rh, 1) / this.factor;
				var uLimit = act.getParamExpression(this.rh, 2) / this.factor;
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_PRISMATIC);
				while (pJoint != null)
				{
					var prJoint = pJoint.m_joint;
					var flag = true;
					if (lLimit > uLimit)
						flag = false;
					prJoint.EnableLimit(flag);
					prJoint.SetLimits(lLimit, uLimit);
					pJoint = this.GetJoint(pJoint, pName, CRunBox2DBase.TYPE_PRISMATIC);
				}
			},
			RACTION_PJOINTSETMOTOR:      function (act)
			{
				var pName = act.getParamExpString(this.rh, 0);
				var force = act.getParamExpression(this.rh, 1) / 100.0 * CRunBox2DBase.PJOINTMOTORFORCEMULT;
				var speed = act.getParamExpression(this.rh, 2) / 100.0 * CRunBox2DBase.PJOINTMOTORSPEEDMULT;
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_PRISMATIC);
				while (pJoint != null)
				{
					var prJoint = pJoint.m_joint;
					var flag = true;
					if (force == 0 && speed == 0)
						flag = false;
					prJoint.EnableMotor(flag);
					prJoint.SetMaxMotorForce(force);
					prJoint.SetMotorSpeed(speed);
					pJoint = this.GetJoint(pJoint, pName, CRunBox2DBase.TYPE_PRISMATIC);
				}
			},
			RACTION_PUJOINTHOTSPOT:      function (act)
			{
				var name = act.getParamExpString(this.rh, 0);
				var pBase1 = this.GetMBase(act.getParamObject(this.rh, 1));
				var pBase2 = this.GetMBase(act.getParamObject(this.rh, 2));
				if (pBase1 != null && pBase2 != null)
				{
					var pJoint = this.CreateJoint(name);
					var JointDef = new Box2D.Dynamics.Joints.b2PulleyJointDef();
					JointDef.collideConnected = true;
					var position1 = pBase1.m_body.GetPosition();
					var position2 = pBase2.m_body.GetPosition();
					var length1 = act.getParamExpression(this.rh, 3) / this.factor;
					var angle1 = act.getParamExpression(this.rh, 4) * Box2D.Common.b2Settings.b2_pi / 180.0;
					var length2 = act.getParamExpression(this.rh, 5) / this.factor;
					var angle2 = act.getParamExpression(this.rh, 6) * Box2D.Common.b2Settings.b2_pi / 180.0;
					var ratio = act.getParamExpression(this.rh, 7) / 100.0;
					var rope1 = new Box2D.Common.Math.b2Vec2(position1.x + length1 * Math.cos(angle1), position1.y + length1 * Math.sin(angle1));
					var rope2 = new Box2D.Common.Math.b2Vec2(position2.x + length2 * Math.cos(angle2), position2.y + length2 * Math.sin(angle2));
					JointDef.Initialize(pBase1.m_body, pBase2.m_body, rope1, rope2, position1, position2, ratio);
					pJoint.SetJoint(CRunBox2DBase.TYPE_PULLEY, this.world.CreateJoint(JointDef));
				}
			},
			RACTION_PUJOINTACTIONPOINT:  function (act)
			{
				var name = act.getParamExpString(this.rh, 0);
				var pBase1 = this.GetMBase(act.getParamObject(this.rh, 1));
				var pBase2 = this.GetMBase(act.getParamObject(this.rh, 2));
				if (pBase1 != null && pBase2 != null)
				{
					var pJoint = this.CreateJoint(name);
					var JointDef = new Box2D.Dynamics.Joints.b2PulleyJointDef();
					JointDef.collideConnected = true;
					var position1 = this.GetActionPointPosition(pBase1);
					var position2 = this.GetActionPointPosition(pBase2);
					var length1 = act.getParamExpression(this.rh, 3) / this.factor;
					var angle1 = act.getParamExpression(this.rh, 4) * Box2D.Common.b2Settings.b2_pi / 180.0;
					var length2 = act.getParamExpression(this.rh, 5) / this.factor;
					var angle2 = act.getParamExpression(this.rh, 6) * Box2D.Common.b2Settings.b2_pi / 180.0;
					var ratio = act.getParamExpression(this.rh, 7) / 100.0;
					var rope1 = new Box2D.Common.Math.b2Vec2(position1.x + length1 * Math.cos(angle1), position1.y + length1 * Math.sin(angle1));
					var rope2 = new Box2D.Common.Math.b2Vec2(position2.x + length2 * Math.cos(angle2), position2.y + length2 * Math.sin(angle2));
					JointDef.Initialize(pBase1.m_body, pBase2.m_body, rope1, rope2, position1, position2, ratio);
					pJoint.SetJoint(CRunBox2DBase.TYPE_PULLEY, this.world.CreateJoint(JointDef));
				}
			},

			RACTION_DESTROYJOINT: function (act)
			{
				var n;
				var name = act.getParamExpString(this.rh, 0);
				for (n = 0; n < this.joints.size(); n++)
				{
					var pJoint = this.joints.get(n);
					if (CServices.compareStringsIgnoreCase(pJoint.m_name, name))
					{
						this.world.DestroyJoint(pJoint.m_joint);
						this.joints.removeIndex(n);
						n--;
					}
				}
			},

			destroyJointWithBody: function (body)
			{
				var n;
				for (n = 0; n < this.joints.size(); n++)
				{
					var pJoint = this.joints.get(n);
					if (pJoint.m_joint.GetBodyA() == body || pJoint.m_joint.GetBodyB() == body)
					{
						this.joints.removeIndex(n);
						n--;
					}
				}
			},

			rDestroyJoint: function (joint)
			{
				this.world.DestroyJoint(joint);
			},

			rAddNormalObject: function (pHo)
			{
				if (this.flags & CRunBox2DBase.B2FLAG_ADDOBJECTS)
				{
					if (this.objects.indexOf(pHo) < 0)
					{
						if (pHo.hoType == 2 && this.GetMBase(pHo) == null)
						{
							var pBase = new CRunMBase();
							pBase.InitBase(pHo, CRunMBase.MTYPE_FAKEOBJECT);
							var angle = this.getAnimDir(pHo, pHo.roc.rcDir) * 11.25;
							pBase.m_body = this.rCreateBody(Box2D.Dynamics.b2Body.b2_staticBody, pHo.hoX, pHo.hoY, angle, 0, pBase, 0, 0);
							this.rBodyCreateShapeFixture(pBase.m_body, pBase, pHo.hoX, pHo.hoY, pHo.roc.rcImage, this.npDensity, this.npFriction, 0, pHo.roc.rcScaleX, pHo.roc.rcScaleY);
							this.objects.add(pBase);
							this.objectIDs.add((pHo.hoCreationId << 16) | (pHo.hoNumber & 0xFFFF));
						}
					}
				}
			},

			rAddABackdrop: function (x, y, img, obstacle)
			{
				if (this.flags & CRunBox2DBase.B2FLAG_ADDBACKDROPS)
				{
					var image = this.rh.rhApp.imageBank.getImageFromHandle(img);
					var pBase = new CRunMBase();
					pBase.InitBase(null, ((obstacle == COC.OBSTACLE_SOLID) ? CRunMBase.MTYPE_OBSTACLE : CRunMBase.MTYPE_PLATFORM));
					pBase.m_body = this.rCreateBody(Box2D.Dynamics.b2Body.b2_staticBody, x + image.width / 2, y + image.height / 2, 0, 0, pBase, 0, 0);
					this.rBodyCreateShapeFixture(pBase.m_body, pBase, x + image.width / 2, y + image.height / 2, img, -1, this.friction, this.restitution, 1.0, 1.0);
					return pBase.m_body;
				}
				return null;
			},

			rSubABackdrop: function (body)
			{
				this.world.DestroyBody(body);
			},

			RACTION_ADDOBJECT: function (act)
			{
				var pHo = act.getParamObject(this.rh, 0);
				if (this.objects.indexOf(pHo) < 0)
				{
					if (pHo.rom != null && pHo.roa != null && this.GetMBase(pHo) == null)
					{
						var pBase = new CRunMBase();
						pBase.InitBase(pHo, CRunMBase.MTYPE_FAKEOBJECT);
						var angle = this.getAnimDir(pHo, pHo.roc.rcDir) * 11.25;
						var density = act.getParamExpression(this.rh, 1) / 100.0;
						var friction = act.getParamExpression(this.rh, 2) / 100.0;
						var shape = act.getParamExpression(this.rh, 3);
						;
						pBase.m_body = this.rCreateBody(Box2D.Dynamics.b2Body.b2_staticBody, pHo.hoX, pHo.hoY, angle, 0, pBase, 0, 0);
						switch (shape)
						{
							case 0:
								this.rBodyCreateBoxFixture(pBase.m_body, pBase, pHo.hoX, pHo.hoY, pHo.hoImgWidth, pHo.hoImgHeight, density, friction, 0);
								break;
							case 1:
								this.rBodyCreateCircleFixture(pBase.m_body, pBase, pHo.hoX, pHo.hoY, pHo.hoImgWidth / 4, density, friction, 0);
								break;
							default:
								this.rBodyCreateShapeFixture(pBase.m_body, pBase, pHo.hoX, pHo.hoY, pHo.roc.rcImage, density, friction, 0, pHo.roc.rcScaleX, pHo.roc.rcScaleY);
								break;
						}
						this.objects.add(pBase);
						this.objectIDs.add((pHo.hoCreationId << 16) | (pHo.hoNumber & 0xFFFF));
					}
				}
			},
			RACTION_SUBOBJECT: function (act)
			{
				var pHo = act.getParamObject(this.rh, 0);
				var n = this.objects.indexOf(pHo);
				if (n >= 0)
				{
					var mBase = this.objects.get(n);
					this.rDestroyBody(mBase.m_body);
					this.objects.removeIndex(n);
					this.objectIDs.removeIndex(n);
	            }
			},

			action:                          function (num, act)
			{
				switch (num)
				{
					case CRunBox2DBase.ACTION_SETGRAVITYFORCE:
						this.RACTION_SETGRAVITYFORCE(act);
						break;
					case CRunBox2DBase.ACTION_SETGRAVITYANGLE:
						this.RACTION_SETGRAVITYANGLE(act);
						break;
					case CRunBox2DBase.ACTION_DJOINTHOTSPOT:
						this.RACTION_DJOINTHOTSPOT(act);
						break;
					case CRunBox2DBase.ACTION_DJOINTACTIONPOINT:
						this.RACTION_DJOINTACTIONPOINT(act);
						break;
					case CRunBox2DBase.ACTION_DJOINTPOSITION:
						this.RACTION_DJOINTPOSITION(act);
						break;
					case CRunBox2DBase.ACTION_RJOINTHOTSPOT:
						this.RACTION_RJOINTHOTSPOT(act);
						break;
					case CRunBox2DBase.ACTION_RJOINTACTIONPOINT:
						this.RACTION_RJOINTACTIONPOINT(act);
						break;
					case CRunBox2DBase.ACTION_RJOINTPOSITION:
						this.RACTION_RJOINTPOSITION(act);
						break;
					case CRunBox2DBase.ACTION_PJOINTHOTSPOT:
						this.RACTION_PJOINTHOTSPOT(act);
						break;
					case CRunBox2DBase.ACTION_PJOINTACTIONPOINT:
						this.RACTION_PJOINTACTIONPOINT(act);
						break;
					case CRunBox2DBase.ACTION_PJOINTPOSITION:
						this.RACTION_PJOINTPOSITION(act);
						break;
					case CRunBox2DBase.ACTION_ADDOBJECT:
						this.RACTION_ADDOBJECT(act);
						break;
					case CRunBox2DBase.ACTION_SUBOBJECT:
						this.RACTION_SUBOBJECT(act);
						break;
					case CRunBox2DBase.ACTION_DJOINTSETELASTICITY:
						this.RACTION_DJOINTSETELASTICITY(act);
						break;
					case CRunBox2DBase.ACTION_RJOINTSETLIMITS:
						this.RACTION_RJOINTSETLIMITS(act);
						break;
					case CRunBox2DBase.ACTION_RJOINTSETMOTOR:
						this.RACTION_RJOINTSETMOTOR(act);
						break;
					case CRunBox2DBase.ACTION_PJOINTSETLIMITS:
						this.RACTION_PJOINTSETLIMITS(act);
						break;
					case CRunBox2DBase.ACTION_PJOINTSETMOTOR:
						this.RACTION_PJOINTSETMOTOR(act);
						break;
					case CRunBox2DBase.ACTION_PUJOINTHOTSPOT:
						this.RACTION_PUJOINTHOTSPOT(act);
						break;
					case CRunBox2DBase.ACTION_PUJOINTACTIONPOINT:
						this.RACTION_PUJOINTACTIONPOINT(act);
						break;
					case CRunBox2DBase.ACTION_DESTROYJOINT:
						this.RACTION_DESTROYJOINT(act);
						break;
					case CRunBox2DBase.ACTION_SETITERATIONS:
						this.RACTION_SETITERATIONS(act);
						break;
					case CRunBox2DBase.ACTION_SETDENSITY:
						this.RACTION_SETDENSITY(act);
						break;
					case CRunBox2DBase.ACTION_SETFRICTION:
						this.RACTION_SETFRICTION(act);
						break;
					case CRunBox2DBase.ACTION_SETELASTICITY:
						this.RACTION_SETELASTICITY(act);
						break;
					case CRunBox2DBase.ACTION_SETGRAVITY:
						this.RACTION_SETGRAVITY(act);
						break;
				    case CRunBox2DBase.ACTION_PAUSE:
				        this.RACTION_PAUSE(act);
				        break;
				    case CRunBox2DBase.ACTION_RESUME:
				        this.RACTION_RESUME(act);
				        break;
				}
			},

			// Expressions
			// -------------------------------------------
			REXPRESSION_GRAVITYSTRENGTH:     function ()
			{
				return this.gravity;
			},
			REXPRESSION_GRAVITYANGLE:        function ()
			{
				return this.angleBase;
			},
			REXPRESSION_VELOCITYITERATIONS:  function ()
			{
				return this.velocityIterations;
			},
			REXPRESSION_POSITIONITERATIONS:  function ()
			{
				return this.positionIterations;
			},
			REXPRESSION_ELASTICITYFREQUENCY: function ()
			{
				var pName = this.ho.getExpParam();
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_DISTANCE);
				if (pJoint != null)
				{
					return pJoint.m_joint.GetFrequency();
				}
				return 0;
			},
			REXPRESSION_ELASTICITYDAMPING:   function ()
			{
				var pName = this.ho.getExpParam();
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_DISTANCE);
				if (pJoint != null)
				{
					return pJoint.m_joint.GetDampingRatio() * 100;
				}
				return 0;
			},
			REXPRESSION_LOWERANGLELIMIT:     function ()
			{
				var pName = this.ho.getExpParam();
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_REVOLUTE);
				if (pJoint != null)
				{
					return pJoint.m_joint.GetLowerLimit() * 180 / Box2D.Common.b2Settings.b2_pi;
				}
			},
			REXPRESSION_UPPERANGLELIMIT:     function ()
			{
				var pName = this.ho.getExpParam();
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_REVOLUTE);
				if (pJoint != null)
				{
					return pJoint.m_joint.GetUpperLimit() * 180 / Box2D.Common.b2Settings.b2_pi;
				}
				return 0;
			},
			REXPRESSION_MOTORSTRENGTH:       function ()
			{
				var pName = this.ho.getExpParam();
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_REVOLUTE);
				if (pJoint != null)
				{
					return pJoint.m_joint.GetMaxMotorTorque() * 100 / CRunBox2DBase.RMOTORTORQUEMULT;
				}
				return 0;
			},
			REXPRESSION_MOTORSPEED:          function ()
			{
				var pName = this.ho.getExpParam();
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_REVOLUTE);
				if (pJoint != null)
				{
					return pJoint.m_joint.GetMotorSpeed() * 100 / CRunBox2DBase.RMOTORSPEEDMULT;
				}
				return 0;
			},
			REXPRESSION_LOWERTRANSLATION:    function ()
			{
				var pName = this.ho.getExpParam();
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_PRISMATIC);
				if (pJoint != null)
				{
					return pJoint.m_joint.GetLowerLimit() * this.factor;
				}
				return 0;
			},
			REXPRESSION_UPPERTRANSLATION:    function ()
			{
				var pName = this.ho.getExpParam();
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_PRISMATIC);
				if (pJoint != null)
				{
					return pJoint.m_joint.GetUpperLimit() * this.factor;
				}
				return 0;
			},
			REXPRESSION_PMOTORSTRENGTH:      function ()
			{
				var pName = this.ho.getExpParam();
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_PRISMATIC);
				if (pJoint != null)
				{
					return pJoint.m_joint.GetMaxMotorForce() * 100 / CRunBox2DBase.PJOINTMOTORFORCEMULT;
				}
				return 0;
			},
			REXPRESSION_PMOTORSPEED:         function ()
			{
				var pName = this.ho.getExpParam();
				var pJoint = this.GetJoint(null, pName, CRunBox2DBase.TYPE_PRISMATIC);
				if (pJoint != null)
				{
					return pJoint.m_joint.GetMotorSpeed() * 100 / CRunBox2DBase.PJOINTMOTORSPEEDMULT;
				}
				return 0;
			},

			expression: function (num)
			{
				switch (num)
				{
					case CRunBox2DBase.EXPRESSION_GRAVITYSTRENGTH:
						return this.REXPRESSION_GRAVITYSTRENGTH();
					case CRunBox2DBase.EXPRESSION_GRAVITYANGLE:
						return this.REXPRESSION_GRAVITYANGLE();
					case CRunBox2DBase.EXPRESSION_VELOCITYITERATIONS:
						return this.REXPRESSION_VELOCITYITERATIONS();
					case CRunBox2DBase.EXPRESSION_POSITIONITERATIONS:
						return this.REXPRESSION_POSITIONITERATIONS();
					case CRunBox2DBase.EXPRESSION_ELASTICITYFREQUENCY:
						return this.REXPRESSION_ELASTICITYFREQUENCY();
					case CRunBox2DBase.EXPRESSION_ELASTICITYDAMPING:
						return this.REXPRESSION_ELASTICITYDAMPING();
					case CRunBox2DBase.EXPRESSION_LOWERANGLELIMIT:
						return this.REXPRESSION_LOWERANGLELIMIT();
					case CRunBox2DBase.EXPRESSION_UPPERANGLELIMIT:
						return this.REXPRESSION_UPPERANGLELIMIT();
					case CRunBox2DBase.EXPRESSION_MOTORSTRENGTH:
						return this.REXPRESSION_MOTORSTRENGTH();
					case CRunBox2DBase.EXPRESSION_MOTORSPEED:
						return this.REXPRESSION_MOTORSPEED();
					case CRunBox2DBase.EXPRESSION_LOWERTRANSLATION:
						return this.REXPRESSION_LOWERTRANSLATION();
					case CRunBox2DBase.EXPRESSION_UPPERTRANSLATION:
						return this.REXPRESSION_UPPERTRANSLATION();
					case CRunBox2DBase.EXPRESSION_PMOTORSTRENGTH:
						return this.REXPRESSION_PMOTORSTRENGTH();
					case CRunBox2DBase.EXPRESSION_PMOTORSPEED:
						return this.REXPRESSION_PMOTORSPEED();
				}
				return 0;
			}
		});


	// CONTACT LISTENER
	////////////////////////////////////////////////////////////////////
	ContactListener.CNDL_EXTCOLLISION = (-14 << 16);
	ContactListener.CNDL_EXTCOLBACK = (-13 << 16);
	ContactListener.BORDER_LEFT = 1;
	ContactListener.BORDER_RIGHT = 2;
	ContactListener.BORDER_TOP = 4;
	ContactListener.BORDER_BOTTOM = 8;
	ContactListener.CNDL_EXTOUTPLAYFIELD = (-12 << 16);
	ContactListener.MAGIC = 0x12345678;
	ContactListener.CND_PARTICULECOLLISION = 1;
	ContactListener.CND_PARTICULEOUTLEFT = 2;
	ContactListener.CND_PARTICULEOUTRIGHT = 3;
	ContactListener.CND_PARTICULEOUTTOP = 4;
	ContactListener.CND_PARTICULEOUTBOTTOM = 5;
	ContactListener.CND_PARTICULESCOLLISION = 6;
	ContactListener.CND_PARTICULECOLLISIONBACKDROP = 7;
	ContactListener.CND_ELEMENTSCOLLISION = 1;

	function ContactListener()
	{
		this.bWorking = false;
	}
	ContactListener.prototype =
	{
		PreSolve:     function (contact, oldManifold)
		{
			this.bWorking = true;

			var worldManifold = new Box2D.Collision.b2WorldManifold();
			contact.GetWorldManifold(worldManifold);
			var bodyA = contact.GetFixtureA().GetBody();
			var bodyB = contact.GetFixtureB().GetBody();
			var rdPtr = contact.GetFixtureA().GetUserData();
			var rhPtr = rdPtr.ho.hoAdRunHeader;

			var movement1 = bodyA.GetUserData();
			var movement2 = bodyB.GetUserData();
			var movement;
			var movementB;

			var pHo;
			var particule, element, parent, rope;
			if (movement1 == null || movement2 == null)
			{
				contact.SetEnabled(false);
			}
			else if (movement1.m_type == CRunMBase.MTYPE_BORDERLEFT || movement2.m_type == CRunMBase.MTYPE_BORDERLEFT)
			{
				if (movement1.m_type == CRunMBase.MTYPE_BORDERLEFT)
				{
					movement = movement2;
					movementB = movement1;
				}
				else
				{
					movement = movement1;
					movementB = movement2;
				}
				pHo = movement.m_pHo;
				switch (movement.m_type)
				{
					case CRunMBase.MTYPE_OBJECT:
						movement.PrepareCondition();
						movement.SetCollidingObject(movementB);
						pHo = movement.m_pHo;
						rhPtr.rhEvtProg.rhCurParam0 = ContactListener.BORDER_LEFT;
						rhPtr.rhEvtProg.handle_Event(pHo, ContactListener.CNDL_EXTOUTPLAYFIELD);
						if (!movement.IsStop())
							contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_FAKEOBJECT:
						contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_PARTICULE:
						particule = movement;
						parent = particule.parent;
						parent.currentParticule1 = particule;
						parent.currentParticule2 = null;
						parent.stopped = false;
						pHo.generateEvent(ContactListener.CND_PARTICULEOUTLEFT, 0);
						if (!parent.stopped)
							contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_ELEMENT:
						element = movement;
						parent = element.parent;
						parent.currentElement = element;
						parent.stopped = false;
						pHo.generateEvent(ContactListener.CND_PARTICULEOUTLEFT, 0);
						if (!parent.stopped)
							contact.SetEnabled(false);
						break;
				}
			}
			else if (movement1.m_type == CRunMBase.MTYPE_BORDERRIGHT || movement2.m_type == CRunMBase.MTYPE_BORDERRIGHT)
			{
				if (movement1.m_type == CRunMBase.MTYPE_BORDERRIGHT)
				{
					movement = movement2;
					movementB = movement1;
				}
				else
				{
					movement = movement1;
					movementB = movement2;
				}
				pHo = movement.m_pHo;
				switch (movement.m_type)
				{
					case CRunMBase.MTYPE_OBJECT:
						movement.PrepareCondition();
						movement.SetCollidingObject(movementB);
						pHo = movement.m_pHo;
						rhPtr.rhEvtProg.rhCurParam0 = ContactListener.BORDER_RIGHT;
						rhPtr.rhEvtProg.handle_Event(pHo, ContactListener.CNDL_EXTOUTPLAYFIELD);
						if (!movement.IsStop())
							contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_FAKEOBJECT:
						contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_PARTICULE:
						particule = movement;
						parent = particule.parent;
						parent.currentParticule1 = particule;
						parent.currentParticule2 = null;
						parent.stopped = false;
						pHo.generateEvent(ContactListener.CND_PARTICULEOUTRIGHT, 0);
						if (!parent.stopped)
							contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_ELEMENT:
						element = movement;
						parent = element.parent;
						parent.currentElement = element;
						parent.stopped = false;
						pHo.generateEvent(ContactListener.CND_PARTICULEOUTRIGHT, 0);
						if (!parent.stopped)
							contact.SetEnabled(false);
						break;
				}
			}
			else if (movement1.m_type == CRunMBase.MTYPE_BORDERTOP || movement2.m_type == CRunMBase.MTYPE_BORDERTOP)
			{
				if (movement1.m_type == CRunMBase.MTYPE_BORDERTOP)
				{
					movement = movement2;
					movementB = movement1;
				}
				else
				{
					movement = movement1;
					movementB = movement2;
				}
				pHo = movement.m_pHo;
				switch (movement.m_type)
				{
					case CRunMBase.MTYPE_OBJECT:
						movement.PrepareCondition();
						movement.SetCollidingObject(movementB);
						pHo = movement.m_pHo;
						rhPtr.rhEvtProg.rhCurParam0 = ContactListener.BORDER_TOP;
						rhPtr.rhEvtProg.handle_Event(pHo, ContactListener.CNDL_EXTOUTPLAYFIELD);
						if (!movement.IsStop())
							contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_FAKEOBJECT:
						contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_PARTICULE:
						particule = movement;
						parent = particule.parent;
						parent.currentParticule1 = particule;
						parent.currentParticule2 = null;
						parent.stopped = false;
						pHo.generateEvent(ContactListener.CND_PARTICULEOUTTOP, 0);
						if (!parent.stopped)
							contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_ELEMENT:
						element = movement;
						parent = element.parent;
						parent.currentElement = element;
						parent.stopped = false;
						pHo.generateEvent(ContactListener.CND_PARTICULEOUTTOP, 0);
						if (!parent.stopped)
							contact.SetEnabled(false);
						break;
				}
			}
			else if (movement1.m_type == CRunMBase.MTYPE_BORDERBOTTOM || movement2.m_type == CRunMBase.MTYPE_BORDERBOTTOM)
			{
				if (movement1.m_type == CRunMBase.MTYPE_BORDERBOTTOM)
				{
					movement = movement2;
					movementB = movement1;
				}
				else
				{
					movement = movement1;
					movementB = movement2;
				}
				pHo = movement.m_pHo;
				switch (movement.m_type)
				{
					case CRunMBase.MTYPE_OBJECT:
						movement.PrepareCondition();
						movement.SetCollidingObject(movementB);
						pHo = movement.m_pHo;
						rhPtr.rhEvtProg.rhCurParam0 = ContactListener.BORDER_BOTTOM;
						rhPtr.rhEvtProg.handle_Event(pHo, ContactListener.CNDL_EXTOUTPLAYFIELD);
						if (!movement.IsStop())
							contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_FAKEOBJECT:
						contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_PARTICULE:
						particule = movement;
						parent = particule.parent;
						parent.currentParticule1 = particule;
						parent.currentParticule2 = null;
						parent.stopped = false;
						pHo.generateEvent(ContactListener.CND_PARTICULEOUTBOTTOM, 0);
						if (!parent.stopped)
							contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_ELEMENT:
						element = movement;
						parent = element.parent;
						parent.currentElement = element;
						parent.stopped = false;
						pHo.generateEvent(ContactListener.CND_PARTICULEOUTBOTTOM, 0);
						if (!parent.stopped)
							contact.SetEnabled(false);
						break;
				}
			}
			else if (movement1.m_type == CRunMBase.MTYPE_OBSTACLE || movement2.m_type == CRunMBase.MTYPE_OBSTACLE)
			{
				if (movement1.m_type == CRunMBase.MTYPE_OBSTACLE)
				{
					movement = movement2;
					movementB = movement1;
				}
				else
				{
					movement = movement1;
					movementB = movement2;
				}
				pHo = movement.m_pHo;
				switch (movement.m_type)
				{
					case CRunMBase.MTYPE_OBJECT:
						movement.PrepareCondition();
						movement.SetCollidingObject(movementB);
						pHo = movement.m_pHo;
						rhPtr.rhEvtProg.handle_Event(pHo, ContactListener.CNDL_EXTCOLBACK);
						if (!movement.IsStop())
							contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_FAKEOBJECT:
						contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_PARTICULE:
						particule = movement;
						parent = particule.parent;
						parent.currentParticule1 = particule;
						parent.currentParticule2 = null;
						parent.stopped = false;
						pHo.generateEvent(ContactListener.CND_PARTICULECOLLISIONBACKDROP, 0);
						if (!parent.stopped)
							contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_ELEMENT:
						element = movement;
						parent = element.parent;
						parent.currentElement = element;
						parent.stopped = false;
						pHo.generateEvent(ContactListener.CND_PARTICULECOLLISIONBACKDROP, 0);
						if (!parent.stopped)
							contact.SetEnabled(false);
						break;
				}
			}
			else if (movement1.m_type == CRunMBase.MTYPE_PLATFORM || movement2.m_type == CRunMBase.MTYPE_PLATFORM)
			{
				var velocity;
				if (movement1.m_type == CRunMBase.MTYPE_PLATFORM)
				{
					movement = movement2;
					movementB = movement1;
					velocity = bodyB.GetLinearVelocity();
				}
				else
				{
					movement = movement1;
					movementB = movement2;
					velocity = bodyA.GetLinearVelocity();
				}
				pHo = movement.m_pHo;
				switch (movement.m_type)
				{
					case CRunMBase.MTYPE_OBJECT:
						movement.PrepareCondition();
						movement.SetCollidingObject(movementB);
						rhPtr.rhEvtProg.handle_Event(pHo, ContactListener.CNDL_EXTCOLBACK);
						if (!movement.IsStop())
						{
							contact.SetEnabled(false);
						}
						else
						{
						    // Build 286.0: don't disable the contact if the platform is under the feet of the object
						    var bPlatformUnder = false;
						    if ( movement.m_base != null )
						    {
						        var o = {};
						        movement.m_base.rGetBodyPosition(movementB.m_body, o);
						        var left = o.x + movementB.rc.left;
						        var right = o.x + movementB.rc.right;
						        var top = o.y + movementB.rc.top;
						        var bottom = o.y + movementB.rc.bottom;
						        if (pHo.hoX >= left && pHo.hoX <= right && pHo.hoY <= bottom)	// platform under the feet of the object?
						            bPlatformUnder = true;
						    }
						    if ( !bPlatformUnder )
						    {
						        if (velocity.y >= 0)
						        {
						            contact.SetEnabled(false);
						        }
						    }
						}
						break;
					case CRunMBase.MTYPE_FAKEOBJECT:
						contact.SetEnabled(false);
						break;
					case CRunMBase.MTYPE_PARTICULE:
						particule = movement;
						parent = particule.parent;
						parent.currentParticule1 = particule;
						parent.currentParticule2 = null;
						parent.stopped = false;
						velocity = particule.m_body.GetLinearVelocity();
						pHo.generateEvent(ContactListener.CND_PARTICULECOLLISIONBACKDROP, 0);
						if (!parent.stopped)
							contact.SetEnabled(false);
						else
						{
							if (velocity.y >= 0)
								contact.SetEnabled(false);
						}
						break;
					case CRunMBase.MTYPE_ELEMENT:
						element = movement;
						parent = element.parent;
						parent.currentElement = element;
						parent.stopped = false;
						velocity = element.m_body.GetLinearVelocity();
						pHo.generateEvent(ContactListener.CND_PARTICULECOLLISIONBACKDROP, 0);
						if (!parent.stopped)
							contact.SetEnabled(false);
						else
						{
							if (velocity.y >= 0)
								contact.SetEnabled(false);
						}
						break;
				}
			}
			else
			{
				movement = movement1;
				obstacle = movement;
				switch (movement.m_type)
				{
					case CRunMBase.MTYPE_OBJECT:
						switch (movement2.m_type)
						{
							case CRunMBase.MTYPE_OBJECT:
								if (movement.m_background)
								{
									var temp = movement;
									movement = movement2;
									movement2 = temp;
								}
								movement.SetCollidingObject(movement2);
								movement2.SetCollidingObject(movement);
								movement.PrepareCondition();
								movement2.PrepareCondition();
								pHo = movement.m_pHo;
								var pHo2 = movement2.m_pHo;
								rhPtr.rhEvtProg.rh1stObjectNumber = pHo2.hoNumber;
								rhPtr.rhEvtProg.handle_Event(pHo, ContactListener.CNDL_EXTCOLLISION);
								if (!movement.IsStop() && !movement2.IsStop())
									contact.SetEnabled(false);
								break;
							case CRunMBase.MTYPE_FAKEOBJECT:
								movement.PrepareCondition();
								movement.SetCollidingObject(movement2);
								pHo = movement.m_pHo;
								var pHo2 = movement2.m_pHo;
								rhPtr.rhEvtProg.rh1stObjectNumber = pHo2.hoNumber;
								rhPtr.rhEvtProg.handle_Event(pHo, ContactListener.CNDL_EXTCOLLISION);
								if (!movement.IsStop())
									contact.SetEnabled(false);
								break;
							case CRunMBase.MTYPE_PARTICULE:
								particule = movement2;
								parent = particule.parent;
								parent.currentParticule1 = particule;
								parent.currentParticule2 = null;
								parent.stopped = false;
								parent.collidingHO = movement.m_pHo;
								movement.PrepareCondition();
								movement.SetCollidingObject(movement2);
								particule.m_pHo.generateEvent(ContactListener.CND_PARTICULECOLLISION, obstacle.m_pHo.hoOi);
								if (!parent.stopped)
									contact.SetEnabled(false);
								break;
							case CRunMBase.MTYPE_ELEMENT:
								element = movement2;
								rope = element.parent;
								rope.currentObject = obstacle;
								rope.currentElement = element;
								rope.stopped = false;
								rope.collidingHO = movement.m_pHo;
								movement.PrepareCondition();
								movement.SetCollidingObject(movement2);
								element.m_pHo.generateEvent(ContactListener.CND_ELEMENTSCOLLISION, obstacle.m_pHo.hoOi);
								if (!movement.IsStop() && !rope.stopped)
									contact.SetEnabled(false);
								break;
						}
						break;
					case CRunMBase.MTYPE_FAKEOBJECT:
						switch (movement2.m_type)
						{
							case CRunMBase.MTYPE_OBJECT:
								movement2.PrepareCondition();
								movement2.SetCollidingObject(movement);
								rhPtr.rhEvtProg.rh1stObjectNumber = movement.m_pHo.hoNumber;
								rhPtr.rhEvtProg.handle_Event(movement2.m_pHo, ContactListener.CNDL_EXTCOLLISION);
								if (!movement2.IsStop())
									contact.SetEnabled(false);
								break;
							case CRunMBase.MTYPE_FAKEOBJECT:
								//                          rhPtr.rhEvtProg.rh1stObjectNumber = movement2.m_pHo.hoNumber;
								//                          rhPtr.rhEvtProg.handle_Event(movement.m_pHo, ContactListener.CNDL_EXTCOLLISION);
								contact.SetEnabled(false);
								break;
							case CRunMBase.MTYPE_PARTICULE:
								particule = movement2;
								parent = particule.parent;
								parent.currentParticule1 = particule;
								parent.currentParticule2 = null;
								parent.stopped = false;
								parent.collidingHO = movement.m_pHo;
								movement.PrepareCondition();
								particule.m_pHo.generateEvent(ContactListener.CND_PARTICULECOLLISION, obstacle.m_pHo.hoOi);
								if (!parent.stopped)
									contact.SetEnabled(false);
								break;
							case CRunMBase.MTYPE_ELEMENT:
								element = movement2;
								rope = element.parent;
								rope.currentObject = obstacle;
								rope.currentElement = element;
								rope.stopped = false;
								rope.collidingHO = movement.m_pHo;
								movement.PrepareCondition();
								element.m_pHo.generateEvent(ContactListener.CND_ELEMENTSCOLLISION, obstacle.m_pHo.hoOi);
								if (!rope.stopped)
									contact.SetEnabled(false);
								break;
						}
						break;
					case CRunMBase.MTYPE_PARTICULE:
						switch (movement2.m_type)
						{
							case CRunMBase.MTYPE_OBJECT:
								particule = movement;
								parent = particule.parent;
								parent.currentParticule1 = particule;
								parent.currentParticule2 = null;
								parent.stopped = false;
								parent.collidingHO = movement2.m_pHo;
								movement2.PrepareCondition();
								movement2.SetCollidingObject(movement);
								movement.m_pHo.generateEvent(ContactListener.CND_PARTICULECOLLISION, movement2.m_pHo.hoOi);
								if (!parent.stopped)
									contact.SetEnabled(false);
								break;
							case CRunMBase.MTYPE_FAKEOBJECT:
								particule = movement;
								parent = particule.parent;
								parent.currentParticule1 = particule;
								parent.currentParticule2 = null;
								parent.stopped = false;
								movement2.PrepareCondition();
								movement.m_pHo.generateEvent(ContactListener.CND_PARTICULECOLLISION, movement2.m_pHo.hoOi);
								if (!parent.stopped)
									contact.SetEnabled(false);
								break;
							case CRunMBase.MTYPE_PARTICULE:
								var parent = movement.parent;
								parent.currentParticule1 = movement1;
								parent.currentParticule2 = movement2;
								parent.stopped = false;
								movement.m_pHo.generateEvent(ContactListener.CND_PARTICULESCOLLISION, 0);
								if (!parent.stopped)
									contact.SetEnabled(false);
								break;
							case CRunMBase.MTYPE_ELEMENT:
								contact.SetEnabled(false);
								break;
							/*                          particule = movement;
							 parent = particule.parent;
							 parent.currentParticule1 = particule;
							 parent.currentParticule2 = null;
							 parent.stopped = false;
							 var rope = movement2.parent;
							 rope.currentElement = movement2;
							 rope.stopped = false;
							 movement.m_pHo.generateEvent(ContactListener.CND_PARTICULESCOLLISION, 0);
							 movement2.m_pHo.generateEvent(ContactListener.CND_ELEMENTSCOLLISION, 0);
							 if (!parent.stopped && !rope.stopped)
							 contact.SetEnabled(false);
							 break;
							 */
						}
						break;
					case CRunMBase.MTYPE_ELEMENT:
						switch (movement2.m_type)
						{
							case CRunMBase.MTYPE_OBJECT:
								element = movement;
								parent = element.parent;
								parent.currentElement = element;
								parent.stopped = false;
								parent.collidingHO = movement2.m_pHo;
								movement2.PrepareCondition();
								movement2.SetCollidingObject(movement);
								movement1.m_pHo.generateEvent(ContactListener.CND_ELEMENTSCOLLISION, movement2.m_pHo.hoOi);
								if (!movement2.IsStop() && !parent.stopped)
									contact.SetEnabled(false);
								break;
							case CRunMBase.MTYPE_FAKEOBJECT:
								element = movement;
								parent = element.parent;
								parent.currentElement = element;
								parent.stopped = false;
								movement2.PrepareCondition();
								movement1.m_pHo.generateEvent(ContactListener.CND_ELEMENTSCOLLISION, movement2.m_pHo.hoOi);
								if (!movement2.IsStop() && !parent.stopped)
									contact.SetEnabled(false);
								break;
							case CRunMBase.MTYPE_PARTICULE:
								contact.SetEnabled(false);
								break;
							/*                          particule = movement2;
							 parent = particule.parent;
							 parent.currentParticule1 = particule;
							 parent.currentParticule2 = null;
							 parent.stopped = false;
							 var rope = movement1.parent;
							 rope.currentElement = movement1;
							 rope.stopped = false;
							 movement2.m_pHo.generateEvent(ContactListener.CND_PARTICULESCOLLISION, 0);
							 movement1.m_pHo.generateEvent(ContactListener.CND_ELEMENTSCOLLISION, 0);
							 if (!parent.stopped && !rope.stopped)
							 contact.SetEnabled(false);
							 break;
							 */
							case CRunMBase.MTYPE_ELEMENT:
								contact.SetEnabled(false);
								break;
						}
						break;
				}
			}
			this.bWorking = false;
		},
		BeginContact: function ()
		{
		},
		EndContact:   function ()
		{
		},
		PostSolve:    function ()
		{
		}
	}


	// Joint class
	//////////////////////////////////////////////////////////////////////
	function CJoint(rdPtr, name)
	{
		this.m_rdPtr = rdPtr;
		this.m_name = name;
		this.m_type = 0;
		this.m_joint = null;
	}
	CJoint.prototype =
	{
		DestroyJoint: function ()
		{
			if (this.m_joint != null)
				this.m_rdPtr.world.DestroyJoint(this.m_joint);
		},
		SetJoint:     function (type, joint)
		{
			this.m_type = type;
			this.m_joint = joint;
		}
	}


	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////

	/*
	 * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty.  In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 * 1. The origin of this software must not be misrepresented; you must not
	 * claim that you wrote the original software. If you use this software
	 * in a product, an acknowledgment in the product documentation would be
	 * appreciated but is not required.
	 * 2. Altered source versions must be plainly marked as such, and must not be
	 * misrepresented as being the original software.
	 * 3. This notice may not be removed or altered from any source distribution.
	 */
	var Box2D = {};

	(function (a2j, undefined)
	{

		if (!(Object.prototype.defineProperty instanceof Function)
			&& Object.prototype.__defineGetter__ instanceof Function
			&& Object.prototype.__defineSetter__ instanceof Function)
		{
			Object.defineProperty = function (obj, p, cfg)
			{
				if (cfg.get instanceof Function)
					obj.__defineGetter__(p, cfg.get);
				if (cfg.set instanceof Function)
					obj.__defineSetter__(p, cfg.set);
			}
		}

		function emptyFn()
		{
		};
		a2j.inherit = function (cls, base)
		{
			var tmpCtr = cls;
			emptyFn.prototype = base.prototype;
			cls.prototype = new emptyFn;
			cls.prototype.constructor = tmpCtr;
		};

		a2j.generateCallback = function generateCallback(context, cb)
		{
			return function ()
			{
				cb.apply(context, arguments);
			};
		};

		a2j.NVector = function NVector(length)
		{
			if (length === undefined) length = 0;
			var tmp = new Array(length || 0);
			for (var i = 0; i < length; ++i)
				tmp[i] = 0;
			return tmp;
		};

		a2j.is = function is(o1, o2)
		{
			if (o1 === null) return false;
			if ((o2 instanceof Function) && (o1 instanceof o2)) return true;
			if ((o1.constructor.__implements != undefined) && (o1.constructor.__implements[o2])) return true;
			return false;
		};

		a2j.parseUInt = function (v)
		{
			return Math.abs(parseInt(v));
		}

	})(Box2D);

	//#TODO remove assignments from global namespace
	var Vector = Array;
	var Vector_a2j_Number = Box2D.NVector;
	//package structure
	if (typeof(Box2D) === "undefined") Box2D = {};
	if (typeof(Box2D.Collision) === "undefined") Box2D.Collision = {};
	if (typeof(Box2D.Collision.Shapes) === "undefined") Box2D.Collision.Shapes = {};
	if (typeof(Box2D.Common) === "undefined") Box2D.Common = {};
	if (typeof(Box2D.Common.Math) === "undefined") Box2D.Common.Math = {};
	if (typeof(Box2D.Dynamics) === "undefined") Box2D.Dynamics = {};
	if (typeof(Box2D.Dynamics.Contacts) === "undefined") Box2D.Dynamics.Contacts = {};
	if (typeof(Box2D.Dynamics.Controllers) === "undefined") Box2D.Dynamics.Controllers = {};
	if (typeof(Box2D.Dynamics.Joints) === "undefined") Box2D.Dynamics.Joints = {};
	//pre-definitions
	(function ()
	{
		Box2D.Collision.IBroadPhase = 'Box2D.Collision.IBroadPhase';

		function b2AABB()
		{
			b2AABB.b2AABB.apply(this, arguments);
		};
		Box2D.Collision.b2AABB = b2AABB;

		function b2Bound()
		{
			b2Bound.b2Bound.apply(this, arguments);
		};
		Box2D.Collision.b2Bound = b2Bound;

		function b2BoundValues()
		{
			b2BoundValues.b2BoundValues.apply(this, arguments);
			if (this.constructor === b2BoundValues) this.b2BoundValues.apply(this, arguments);
		};
		Box2D.Collision.b2BoundValues = b2BoundValues;

		function b2Collision()
		{
			b2Collision.b2Collision.apply(this, arguments);
		};
		Box2D.Collision.b2Collision = b2Collision;

		function b2ContactID()
		{
			b2ContactID.b2ContactID.apply(this, arguments);
			if (this.constructor === b2ContactID) this.b2ContactID.apply(this, arguments);
		};
		Box2D.Collision.b2ContactID = b2ContactID;

		function b2ContactPoint()
		{
			b2ContactPoint.b2ContactPoint.apply(this, arguments);
		};
		Box2D.Collision.b2ContactPoint = b2ContactPoint;

		function b2Distance()
		{
			b2Distance.b2Distance.apply(this, arguments);
		};
		Box2D.Collision.b2Distance = b2Distance;

		function b2DistanceInput()
		{
			b2DistanceInput.b2DistanceInput.apply(this, arguments);
		};
		Box2D.Collision.b2DistanceInput = b2DistanceInput;

		function b2DistanceOutput()
		{
			b2DistanceOutput.b2DistanceOutput.apply(this, arguments);
		};
		Box2D.Collision.b2DistanceOutput = b2DistanceOutput;

		function b2DistanceProxy()
		{
			b2DistanceProxy.b2DistanceProxy.apply(this, arguments);
		};
		Box2D.Collision.b2DistanceProxy = b2DistanceProxy;

		function b2DynamicTree()
		{
			b2DynamicTree.b2DynamicTree.apply(this, arguments);
			if (this.constructor === b2DynamicTree) this.b2DynamicTree.apply(this, arguments);
		};
		Box2D.Collision.b2DynamicTree = b2DynamicTree;

		function b2DynamicTreeBroadPhase()
		{
			b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase.apply(this, arguments);
		};
		Box2D.Collision.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;

		function b2DynamicTreeNode()
		{
			b2DynamicTreeNode.b2DynamicTreeNode.apply(this, arguments);
		};
		Box2D.Collision.b2DynamicTreeNode = b2DynamicTreeNode;

		function b2DynamicTreePair()
		{
			b2DynamicTreePair.b2DynamicTreePair.apply(this, arguments);
		};
		Box2D.Collision.b2DynamicTreePair = b2DynamicTreePair;

		function b2Manifold()
		{
			b2Manifold.b2Manifold.apply(this, arguments);
			if (this.constructor === b2Manifold) this.b2Manifold.apply(this, arguments);
		};
		Box2D.Collision.b2Manifold = b2Manifold;

		function b2ManifoldPoint()
		{
			b2ManifoldPoint.b2ManifoldPoint.apply(this, arguments);
			if (this.constructor === b2ManifoldPoint) this.b2ManifoldPoint.apply(this, arguments);
		};
		Box2D.Collision.b2ManifoldPoint = b2ManifoldPoint;

		function b2Point()
		{
			b2Point.b2Point.apply(this, arguments);
		};
		Box2D.Collision.b2Point = b2Point;

		function b2RayCastInput()
		{
			b2RayCastInput.b2RayCastInput.apply(this, arguments);
			if (this.constructor === b2RayCastInput) this.b2RayCastInput.apply(this, arguments);
		};
		Box2D.Collision.b2RayCastInput = b2RayCastInput;

		function b2RayCastOutput()
		{
			b2RayCastOutput.b2RayCastOutput.apply(this, arguments);
		};
		Box2D.Collision.b2RayCastOutput = b2RayCastOutput;

		function b2Segment()
		{
			b2Segment.b2Segment.apply(this, arguments);
		};
		Box2D.Collision.b2Segment = b2Segment;

		function b2SeparationFunction()
		{
			b2SeparationFunction.b2SeparationFunction.apply(this, arguments);
		};
		Box2D.Collision.b2SeparationFunction = b2SeparationFunction;

		function b2Simplex()
		{
			b2Simplex.b2Simplex.apply(this, arguments);
			if (this.constructor === b2Simplex) this.b2Simplex.apply(this, arguments);
		};
		Box2D.Collision.b2Simplex = b2Simplex;

		function b2SimplexCache()
		{
			b2SimplexCache.b2SimplexCache.apply(this, arguments);
		};
		Box2D.Collision.b2SimplexCache = b2SimplexCache;

		function b2SimplexVertex()
		{
			b2SimplexVertex.b2SimplexVertex.apply(this, arguments);
		};
		Box2D.Collision.b2SimplexVertex = b2SimplexVertex;

		function b2TimeOfImpact()
		{
			b2TimeOfImpact.b2TimeOfImpact.apply(this, arguments);
		};
		Box2D.Collision.b2TimeOfImpact = b2TimeOfImpact;

		function b2TOIInput()
		{
			b2TOIInput.b2TOIInput.apply(this, arguments);
		};
		Box2D.Collision.b2TOIInput = b2TOIInput;

		function b2WorldManifold()
		{
			b2WorldManifold.b2WorldManifold.apply(this, arguments);
			if (this.constructor === b2WorldManifold) this.b2WorldManifold.apply(this, arguments);
		};
		Box2D.Collision.b2WorldManifold = b2WorldManifold;

		function ClipVertex()
		{
			ClipVertex.ClipVertex.apply(this, arguments);
		};
		Box2D.Collision.ClipVertex = ClipVertex;

		function Features()
		{
			Features.Features.apply(this, arguments);
		};
		Box2D.Collision.Features = Features;

		function b2CircleShape()
		{
			b2CircleShape.b2CircleShape.apply(this, arguments);
			if (this.constructor === b2CircleShape) this.b2CircleShape.apply(this, arguments);
		};
		Box2D.Collision.Shapes.b2CircleShape = b2CircleShape;

		function b2EdgeChainDef()
		{
			b2EdgeChainDef.b2EdgeChainDef.apply(this, arguments);
			if (this.constructor === b2EdgeChainDef) this.b2EdgeChainDef.apply(this, arguments);
		};
		Box2D.Collision.Shapes.b2EdgeChainDef = b2EdgeChainDef;

		function b2EdgeShape()
		{
			b2EdgeShape.b2EdgeShape.apply(this, arguments);
			if (this.constructor === b2EdgeShape) this.b2EdgeShape.apply(this, arguments);
		};
		Box2D.Collision.Shapes.b2EdgeShape = b2EdgeShape;

		function b2MassData()
		{
			b2MassData.b2MassData.apply(this, arguments);
		};
		Box2D.Collision.Shapes.b2MassData = b2MassData;

		function b2PolygonShape()
		{
			b2PolygonShape.b2PolygonShape.apply(this, arguments);
			if (this.constructor === b2PolygonShape) this.b2PolygonShape.apply(this, arguments);
		};
		Box2D.Collision.Shapes.b2PolygonShape = b2PolygonShape;

		function b2Shape()
		{
			b2Shape.b2Shape.apply(this, arguments);
			if (this.constructor === b2Shape) this.b2Shape.apply(this, arguments);
		};
		Box2D.Collision.Shapes.b2Shape = b2Shape;
		Box2D.Common.b2internal = 'Box2D.Common.b2internal';

		function b2Color()
		{
			b2Color.b2Color.apply(this, arguments);
			if (this.constructor === b2Color) this.b2Color.apply(this, arguments);
		};
		Box2D.Common.b2Color = b2Color;

		function b2Settings()
		{
			b2Settings.b2Settings.apply(this, arguments);
		};
		Box2D.Common.b2Settings = b2Settings;

		function b2Mat22()
		{
			b2Mat22.b2Mat22.apply(this, arguments);
			if (this.constructor === b2Mat22) this.b2Mat22.apply(this, arguments);
		};
		Box2D.Common.Math.b2Mat22 = b2Mat22;

		function b2Mat33()
		{
			b2Mat33.b2Mat33.apply(this, arguments);
			if (this.constructor === b2Mat33) this.b2Mat33.apply(this, arguments);
		};
		Box2D.Common.Math.b2Mat33 = b2Mat33;

		function b2Math()
		{
			b2Math.b2Math.apply(this, arguments);
		};
		Box2D.Common.Math.b2Math = b2Math;

		function b2Sweep()
		{
			b2Sweep.b2Sweep.apply(this, arguments);
		};
		Box2D.Common.Math.b2Sweep = b2Sweep;

		function b2Transform()
		{
			b2Transform.b2Transform.apply(this, arguments);
			if (this.constructor === b2Transform) this.b2Transform.apply(this, arguments);
		};
		Box2D.Common.Math.b2Transform = b2Transform;

		function b2Vec2()
		{
			b2Vec2.b2Vec2.apply(this, arguments);
			if (this.constructor === b2Vec2) this.b2Vec2.apply(this, arguments);
		};
		Box2D.Common.Math.b2Vec2 = b2Vec2;

		function b2Vec3()
		{
			b2Vec3.b2Vec3.apply(this, arguments);
			if (this.constructor === b2Vec3) this.b2Vec3.apply(this, arguments);
		};
		Box2D.Common.Math.b2Vec3 = b2Vec3;

		function b2Body()
		{
			b2Body.b2Body.apply(this, arguments);
			if (this.constructor === b2Body) this.b2Body.apply(this, arguments);
		};
		Box2D.Dynamics.b2Body = b2Body;

		function b2BodyDef()
		{
			b2BodyDef.b2BodyDef.apply(this, arguments);
			if (this.constructor === b2BodyDef) this.b2BodyDef.apply(this, arguments);
		};
		Box2D.Dynamics.b2BodyDef = b2BodyDef;

		function b2ContactFilter()
		{
			b2ContactFilter.b2ContactFilter.apply(this, arguments);
		};
		Box2D.Dynamics.b2ContactFilter = b2ContactFilter;

		function b2ContactImpulse()
		{
			b2ContactImpulse.b2ContactImpulse.apply(this, arguments);
		};
		Box2D.Dynamics.b2ContactImpulse = b2ContactImpulse;

		function b2ContactListener()
		{
			b2ContactListener.b2ContactListener.apply(this, arguments);
		};
		Box2D.Dynamics.b2ContactListener = b2ContactListener;

		function b2ContactManager()
		{
			b2ContactManager.b2ContactManager.apply(this, arguments);
			if (this.constructor === b2ContactManager) this.b2ContactManager.apply(this, arguments);
		};
		Box2D.Dynamics.b2ContactManager = b2ContactManager;

		function b2DebugDraw()
		{
			b2DebugDraw.b2DebugDraw.apply(this, arguments);
			if (this.constructor === b2DebugDraw) this.b2DebugDraw.apply(this, arguments);
		};
		Box2D.Dynamics.b2DebugDraw = b2DebugDraw;

		function b2DestructionListener()
		{
			b2DestructionListener.b2DestructionListener.apply(this, arguments);
		};
		Box2D.Dynamics.b2DestructionListener = b2DestructionListener;

		function b2FilterData()
		{
			b2FilterData.b2FilterData.apply(this, arguments);
		};
		Box2D.Dynamics.b2FilterData = b2FilterData;

		function b2Fixture()
		{
			b2Fixture.b2Fixture.apply(this, arguments);
			if (this.constructor === b2Fixture) this.b2Fixture.apply(this, arguments);
		};
		Box2D.Dynamics.b2Fixture = b2Fixture;

		function b2FixtureDef()
		{
			b2FixtureDef.b2FixtureDef.apply(this, arguments);
			if (this.constructor === b2FixtureDef) this.b2FixtureDef.apply(this, arguments);
		};
		Box2D.Dynamics.b2FixtureDef = b2FixtureDef;

		function b2Island()
		{
			b2Island.b2Island.apply(this, arguments);
			if (this.constructor === b2Island) this.b2Island.apply(this, arguments);
		};
		Box2D.Dynamics.b2Island = b2Island;

		function b2TimeStep()
		{
			b2TimeStep.b2TimeStep.apply(this, arguments);
		};
		Box2D.Dynamics.b2TimeStep = b2TimeStep;

		function b2World()
		{
			b2World.b2World.apply(this, arguments);
			if (this.constructor === b2World) this.b2World.apply(this, arguments);
		};
		Box2D.Dynamics.b2World = b2World;

		function b2CircleContact()
		{
			b2CircleContact.b2CircleContact.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2CircleContact = b2CircleContact;

		function b2Contact()
		{
			b2Contact.b2Contact.apply(this, arguments);
			if (this.constructor === b2Contact) this.b2Contact.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2Contact = b2Contact;

		function b2ContactConstraint()
		{
			b2ContactConstraint.b2ContactConstraint.apply(this, arguments);
			if (this.constructor === b2ContactConstraint) this.b2ContactConstraint.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2ContactConstraint = b2ContactConstraint;

		function b2ContactConstraintPoint()
		{
			b2ContactConstraintPoint.b2ContactConstraintPoint.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2ContactConstraintPoint = b2ContactConstraintPoint;

		function b2ContactEdge()
		{
			b2ContactEdge.b2ContactEdge.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2ContactEdge = b2ContactEdge;

		function b2ContactFactory()
		{
			b2ContactFactory.b2ContactFactory.apply(this, arguments);
			if (this.constructor === b2ContactFactory) this.b2ContactFactory.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2ContactFactory = b2ContactFactory;

		function b2ContactRegister()
		{
			b2ContactRegister.b2ContactRegister.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2ContactRegister = b2ContactRegister;

		function b2ContactResult()
		{
			b2ContactResult.b2ContactResult.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2ContactResult = b2ContactResult;

		function b2ContactSolver()
		{
			b2ContactSolver.b2ContactSolver.apply(this, arguments);
			if (this.constructor === b2ContactSolver) this.b2ContactSolver.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2ContactSolver = b2ContactSolver;

		function b2EdgeAndCircleContact()
		{
			b2EdgeAndCircleContact.b2EdgeAndCircleContact.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = b2EdgeAndCircleContact;

		function b2NullContact()
		{
			b2NullContact.b2NullContact.apply(this, arguments);
			if (this.constructor === b2NullContact) this.b2NullContact.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2NullContact = b2NullContact;

		function b2PolyAndCircleContact()
		{
			b2PolyAndCircleContact.b2PolyAndCircleContact.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2PolyAndCircleContact = b2PolyAndCircleContact;

		function b2PolyAndEdgeContact()
		{
			b2PolyAndEdgeContact.b2PolyAndEdgeContact.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = b2PolyAndEdgeContact;

		function b2PolygonContact()
		{
			b2PolygonContact.b2PolygonContact.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2PolygonContact = b2PolygonContact;

		function b2PositionSolverManifold()
		{
			b2PositionSolverManifold.b2PositionSolverManifold.apply(this, arguments);
			if (this.constructor === b2PositionSolverManifold) this.b2PositionSolverManifold.apply(this, arguments);
		};
		Box2D.Dynamics.Contacts.b2PositionSolverManifold = b2PositionSolverManifold;

		function b2BuoyancyController()
		{
			b2BuoyancyController.b2BuoyancyController.apply(this, arguments);
		};
		Box2D.Dynamics.Controllers.b2BuoyancyController = b2BuoyancyController;

		function b2ConstantAccelController()
		{
			b2ConstantAccelController.b2ConstantAccelController.apply(this, arguments);
		};
		Box2D.Dynamics.Controllers.b2ConstantAccelController = b2ConstantAccelController;

		function b2ConstantForceController()
		{
			b2ConstantForceController.b2ConstantForceController.apply(this, arguments);
		};
		Box2D.Dynamics.Controllers.b2ConstantForceController = b2ConstantForceController;

		function b2Controller()
		{
			b2Controller.b2Controller.apply(this, arguments);
		};
		Box2D.Dynamics.Controllers.b2Controller = b2Controller;

		function b2ControllerEdge()
		{
			b2ControllerEdge.b2ControllerEdge.apply(this, arguments);
		};
		Box2D.Dynamics.Controllers.b2ControllerEdge = b2ControllerEdge;

		function b2GravityController()
		{
			b2GravityController.b2GravityController.apply(this, arguments);
		};
		Box2D.Dynamics.Controllers.b2GravityController = b2GravityController;

		function b2TensorDampingController()
		{
			b2TensorDampingController.b2TensorDampingController.apply(this, arguments);
		};
		Box2D.Dynamics.Controllers.b2TensorDampingController = b2TensorDampingController;

		function b2DistanceJoint()
		{
			b2DistanceJoint.b2DistanceJoint.apply(this, arguments);
			if (this.constructor === b2DistanceJoint) this.b2DistanceJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2DistanceJoint = b2DistanceJoint;

		function b2DistanceJointDef()
		{
			b2DistanceJointDef.b2DistanceJointDef.apply(this, arguments);
			if (this.constructor === b2DistanceJointDef) this.b2DistanceJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2DistanceJointDef = b2DistanceJointDef;

		function b2FrictionJoint()
		{
			b2FrictionJoint.b2FrictionJoint.apply(this, arguments);
			if (this.constructor === b2FrictionJoint) this.b2FrictionJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2FrictionJoint = b2FrictionJoint;

		function b2FrictionJointDef()
		{
			b2FrictionJointDef.b2FrictionJointDef.apply(this, arguments);
			if (this.constructor === b2FrictionJointDef) this.b2FrictionJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2FrictionJointDef = b2FrictionJointDef;

		function b2GearJoint()
		{
			b2GearJoint.b2GearJoint.apply(this, arguments);
			if (this.constructor === b2GearJoint) this.b2GearJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2GearJoint = b2GearJoint;

		function b2GearJointDef()
		{
			b2GearJointDef.b2GearJointDef.apply(this, arguments);
			if (this.constructor === b2GearJointDef) this.b2GearJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2GearJointDef = b2GearJointDef;

		function b2Jacobian()
		{
			b2Jacobian.b2Jacobian.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2Jacobian = b2Jacobian;

		function b2Joint()
		{
			b2Joint.b2Joint.apply(this, arguments);
			if (this.constructor === b2Joint) this.b2Joint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2Joint = b2Joint;

		function b2JointDef()
		{
			b2JointDef.b2JointDef.apply(this, arguments);
			if (this.constructor === b2JointDef) this.b2JointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2JointDef = b2JointDef;

		function b2JointEdge()
		{
			b2JointEdge.b2JointEdge.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2JointEdge = b2JointEdge;

		function b2LineJoint()
		{
			b2LineJoint.b2LineJoint.apply(this, arguments);
			if (this.constructor === b2LineJoint) this.b2LineJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2LineJoint = b2LineJoint;

		function b2LineJointDef()
		{
			b2LineJointDef.b2LineJointDef.apply(this, arguments);
			if (this.constructor === b2LineJointDef) this.b2LineJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2LineJointDef = b2LineJointDef;

		function b2MouseJoint()
		{
			b2MouseJoint.b2MouseJoint.apply(this, arguments);
			if (this.constructor === b2MouseJoint) this.b2MouseJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2MouseJoint = b2MouseJoint;

		function b2MouseJointDef()
		{
			b2MouseJointDef.b2MouseJointDef.apply(this, arguments);
			if (this.constructor === b2MouseJointDef) this.b2MouseJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2MouseJointDef = b2MouseJointDef;

		function b2PrismaticJoint()
		{
			b2PrismaticJoint.b2PrismaticJoint.apply(this, arguments);
			if (this.constructor === b2PrismaticJoint) this.b2PrismaticJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2PrismaticJoint = b2PrismaticJoint;

		function b2PrismaticJointDef()
		{
			b2PrismaticJointDef.b2PrismaticJointDef.apply(this, arguments);
			if (this.constructor === b2PrismaticJointDef) this.b2PrismaticJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2PrismaticJointDef = b2PrismaticJointDef;

		function b2PulleyJoint()
		{
			b2PulleyJoint.b2PulleyJoint.apply(this, arguments);
			if (this.constructor === b2PulleyJoint) this.b2PulleyJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2PulleyJoint = b2PulleyJoint;

		function b2PulleyJointDef()
		{
			b2PulleyJointDef.b2PulleyJointDef.apply(this, arguments);
			if (this.constructor === b2PulleyJointDef) this.b2PulleyJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2PulleyJointDef = b2PulleyJointDef;

		function b2RevoluteJoint()
		{
			b2RevoluteJoint.b2RevoluteJoint.apply(this, arguments);
			if (this.constructor === b2RevoluteJoint) this.b2RevoluteJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2RevoluteJoint = b2RevoluteJoint;

		function b2RevoluteJointDef()
		{
			b2RevoluteJointDef.b2RevoluteJointDef.apply(this, arguments);
			if (this.constructor === b2RevoluteJointDef) this.b2RevoluteJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2RevoluteJointDef = b2RevoluteJointDef;

		function b2WeldJoint()
		{
			b2WeldJoint.b2WeldJoint.apply(this, arguments);
			if (this.constructor === b2WeldJoint) this.b2WeldJoint.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2WeldJoint = b2WeldJoint;

		function b2WeldJointDef()
		{
			b2WeldJointDef.b2WeldJointDef.apply(this, arguments);
			if (this.constructor === b2WeldJointDef) this.b2WeldJointDef.apply(this, arguments);
		};
		Box2D.Dynamics.Joints.b2WeldJointDef = b2WeldJointDef;
	})(); //definitions
	Box2D.postDefs = [];
	(function ()
	{
		var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
			b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
			b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
			b2MassData = Box2D.Collision.Shapes.b2MassData,
			b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
			b2Shape = Box2D.Collision.Shapes.b2Shape,
			b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3,
			b2AABB = Box2D.Collision.b2AABB,
			b2Bound = Box2D.Collision.b2Bound,
			b2BoundValues = Box2D.Collision.b2BoundValues,
			b2Collision = Box2D.Collision.b2Collision,
			b2ContactID = Box2D.Collision.b2ContactID,
			b2ContactPoint = Box2D.Collision.b2ContactPoint,
			b2Distance = Box2D.Collision.b2Distance,
			b2DistanceInput = Box2D.Collision.b2DistanceInput,
			b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
			b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
			b2DynamicTree = Box2D.Collision.b2DynamicTree,
			b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
			b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
			b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
			b2Manifold = Box2D.Collision.b2Manifold,
			b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
			b2Point = Box2D.Collision.b2Point,
			b2RayCastInput = Box2D.Collision.b2RayCastInput,
			b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
			b2Segment = Box2D.Collision.b2Segment,
			b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
			b2Simplex = Box2D.Collision.b2Simplex,
			b2SimplexCache = Box2D.Collision.b2SimplexCache,
			b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
			b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
			b2TOIInput = Box2D.Collision.b2TOIInput,
			b2WorldManifold = Box2D.Collision.b2WorldManifold,
			ClipVertex = Box2D.Collision.ClipVertex,
			Features = Box2D.Collision.Features,
			IBroadPhase = Box2D.Collision.IBroadPhase;

		b2AABB.b2AABB = function ()
		{
			this.lowerBound = new b2Vec2();
			this.upperBound = new b2Vec2();
		};
		b2AABB.prototype.IsValid = function ()
		{
			var dX = this.upperBound.x - this.lowerBound.x;
			var dY = this.upperBound.y - this.lowerBound.y;
			var valid = dX >= 0.0 && dY >= 0.0;
			valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
			return valid;
		}
		b2AABB.prototype.GetCenter = function ()
		{
			return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
		}
		b2AABB.prototype.GetExtents = function ()
		{
			return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
		}
		b2AABB.prototype.Contains = function (aabb)
		{
			var result = true;
			result = result && this.lowerBound.x <= aabb.lowerBound.x;
			result = result && this.lowerBound.y <= aabb.lowerBound.y;
			result = result && aabb.upperBound.x <= this.upperBound.x;
			result = result && aabb.upperBound.y <= this.upperBound.y;
			return result;
		}
		b2AABB.prototype.RayCast = function (output, input)
		{
			var tmin = (-Number.MAX_VALUE);
			var tmax = Number.MAX_VALUE;
			var pX = input.p1.x;
			var pY = input.p1.y;
			var dX = input.p2.x - input.p1.x;
			var dY = input.p2.y - input.p1.y;
			var absDX = Math.abs(dX);
			var absDY = Math.abs(dY);
			var normal = output.normal;
			var inv_d = 0;
			var t1 = 0;
			var t2 = 0;
			var t3 = 0;
			var s = 0;
			{
				if (absDX < Number.MIN_VALUE)
				{
					if (pX < this.lowerBound.x || this.upperBound.x < pX) return false;
				}
				else
				{
					inv_d = 1.0 / dX;
					t1 = (this.lowerBound.x - pX) * inv_d;
					t2 = (this.upperBound.x - pX) * inv_d;
					s = (-1.0);
					if (t1 > t2)
					{
						t3 = t1;
						t1 = t2;
						t2 = t3;
						s = 1.0;
					}
					if (t1 > tmin)
					{
						normal.x = s;
						normal.y = 0;
						tmin = t1;
					}
					tmax = Math.min(tmax, t2);
					if (tmin > tmax) return false;
				}
			}
			{
				if (absDY < Number.MIN_VALUE)
				{
					if (pY < this.lowerBound.y || this.upperBound.y < pY) return false;
				}
				else
				{
					inv_d = 1.0 / dY;
					t1 = (this.lowerBound.y - pY) * inv_d;
					t2 = (this.upperBound.y - pY) * inv_d;
					s = (-1.0);
					if (t1 > t2)
					{
						t3 = t1;
						t1 = t2;
						t2 = t3;
						s = 1.0;
					}
					if (t1 > tmin)
					{
						normal.y = s;
						normal.x = 0;
						tmin = t1;
					}
					tmax = Math.min(tmax, t2);
					if (tmin > tmax) return false;
				}
			}
			output.fraction = tmin;
			return true;
		}
		b2AABB.prototype.TestOverlap = function (other)
		{
			var d1X = other.lowerBound.x - this.upperBound.x;
			var d1Y = other.lowerBound.y - this.upperBound.y;
			var d2X = this.lowerBound.x - other.upperBound.x;
			var d2Y = this.lowerBound.y - other.upperBound.y;
			if (d1X > 0.0 || d1Y > 0.0) return false;
			if (d2X > 0.0 || d2Y > 0.0) return false;
			return true;
		}
		b2AABB.Combine = function (aabb1, aabb2)
		{
			var aabb = new b2AABB();
			aabb.Combine(aabb1, aabb2);
			return aabb;
		}
		b2AABB.prototype.Combine = function (aabb1, aabb2)
		{
			this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
			this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
			this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
			this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y);
		}
		b2Bound.b2Bound = function ()
		{
		};
		b2Bound.prototype.IsLower = function ()
		{
			return (this.value & 1) == 0;
		}
		b2Bound.prototype.IsUpper = function ()
		{
			return (this.value & 1) == 1;
		}
		b2Bound.prototype.Swap = function (b)
		{
			var tempValue = this.value;
			var tempProxy = this.proxy;
			var tempStabbingCount = this.stabbingCount;
			this.value = b.value;
			this.proxy = b.proxy;
			this.stabbingCount = b.stabbingCount;
			b.value = tempValue;
			b.proxy = tempProxy;
			b.stabbingCount = tempStabbingCount;
		}
		b2BoundValues.b2BoundValues = function ()
		{
		};
		b2BoundValues.prototype.b2BoundValues = function ()
		{
			this.lowerValues = new Vector_a2j_Number();
			this.lowerValues[0] = 0.0;
			this.lowerValues[1] = 0.0;
			this.upperValues = new Vector_a2j_Number();
			this.upperValues[0] = 0.0;
			this.upperValues[1] = 0.0;
		}
		b2Collision.b2Collision = function ()
		{
		};
		b2Collision.ClipSegmentToLine = function (vOut, vIn, normal, offset)
		{
			if (offset === undefined) offset = 0;
			var cv;
			var numOut = 0;
			cv = vIn[0];
			var vIn0 = cv.v;
			cv = vIn[1];
			var vIn1 = cv.v;
			var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
			var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
			if (distance0 <= 0.0) vOut[numOut++].Set(vIn[0]);
			if (distance1 <= 0.0) vOut[numOut++].Set(vIn[1]);
			if (distance0 * distance1 < 0.0)
			{
				var interp = distance0 / (distance0 - distance1);
				cv = vOut[numOut];
				var tVec = cv.v;
				tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
				tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
				cv = vOut[numOut];
				var cv2;
				if (distance0 > 0.0)
				{
					cv2 = vIn[0];
					cv.id = cv2.id;
				}
				else
				{
					cv2 = vIn[1];
					cv.id = cv2.id;
				}
				++numOut;
			}
			return numOut;
		}
		b2Collision.EdgeSeparation = function (poly1, xf1, edge1, poly2, xf2)
		{
			if (edge1 === undefined) edge1 = 0;
			var count1 = parseInt(poly1.m_vertexCount);
			var vertices1 = poly1.m_vertices;
			var normals1 = poly1.m_normals;
			var count2 = parseInt(poly2.m_vertexCount);
			var vertices2 = poly2.m_vertices;
			var tMat;
			var tVec;
			tMat = xf1.R;
			tVec = normals1[edge1];
			var normal1WorldX = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var normal1WorldY = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			tMat = xf2.R;
			var normal1X = (tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY);
			var normal1Y = (tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY);
			var index = 0;
			var minDot = Number.MAX_VALUE;
			for (var i = 0; i < count2; ++i)
			{
				tVec = vertices2[i];
				var dot = tVec.x * normal1X + tVec.y * normal1Y;
				if (dot < minDot)
				{
					minDot = dot;
					index = i;
				}
			}
			tVec = vertices1[edge1];
			tMat = xf1.R;
			var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			tVec = vertices2[index];
			tMat = xf2.R;
			var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			v2X -= v1X;
			v2Y -= v1Y;
			var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
			return separation;
		}
		b2Collision.FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2)
		{
			var count1 = parseInt(poly1.m_vertexCount);
			var normals1 = poly1.m_normals;
			var tVec;
			var tMat;
			tMat = xf2.R;
			tVec = poly2.m_centroid;
			var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			tMat = xf1.R;
			tVec = poly1.m_centroid;
			dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			var dLocal1X = (dX * xf1.R.col1.x + dY * xf1.R.col1.y);
			var dLocal1Y = (dX * xf1.R.col2.x + dY * xf1.R.col2.y);
			var edge = 0;
			var maxDot = (-Number.MAX_VALUE);
			for (var i = 0; i < count1; ++i)
			{
				tVec = normals1[i];
				var dot = (tVec.x * dLocal1X + tVec.y * dLocal1Y);
				if (dot > maxDot)
				{
					maxDot = dot;
					edge = i;
				}
			}
			var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
			var prevEdge = parseInt(edge - 1 >= 0 ? edge - 1 : count1 - 1);
			var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
			var nextEdge = parseInt(edge + 1 < count1 ? edge + 1 : 0);
			var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
			var bestEdge = 0;
			var bestSeparation = 0;
			var increment = 0;
			if (sPrev > s && sPrev > sNext)
			{
				increment = (-1);
				bestEdge = prevEdge;
				bestSeparation = sPrev;
			}
			else if (sNext > s)
			{
				increment = 1;
				bestEdge = nextEdge;
				bestSeparation = sNext;
			}
			else
			{
				edgeIndex[0] = edge;
				return s;
			}
			while (true)
			{
				if (increment == (-1)) edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
				else edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;
				s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
				if (s > bestSeparation)
				{
					bestEdge = edge;
					bestSeparation = s;
				}
				else
				{
					break;
				}
			}
			edgeIndex[0] = bestEdge;
			return bestSeparation;
		}
		b2Collision.FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2)
		{
			if (edge1 === undefined) edge1 = 0;
			var count1 = parseInt(poly1.m_vertexCount);
			var normals1 = poly1.m_normals;
			var count2 = parseInt(poly2.m_vertexCount);
			var vertices2 = poly2.m_vertices;
			var normals2 = poly2.m_normals;
			var tMat;
			var tVec;
			tMat = xf1.R;
			tVec = normals1[edge1];
			var normal1X = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var normal1Y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			tMat = xf2.R;
			var tX = (tMat.col1.x * normal1X + tMat.col1.y * normal1Y);
			normal1Y = (tMat.col2.x * normal1X + tMat.col2.y * normal1Y);
			normal1X = tX;
			var index = 0;
			var minDot = Number.MAX_VALUE;
			for (var i = 0; i < count2; ++i)
			{
				tVec = normals2[i];
				var dot = (normal1X * tVec.x + normal1Y * tVec.y);
				if (dot < minDot)
				{
					minDot = dot;
					index = i;
				}
			}
			var tClip;
			var i1 = parseInt(index);
			var i2 = parseInt(i1 + 1 < count2 ? i1 + 1 : 0);
			tClip = c[0];
			tVec = vertices2[i1];
			tMat = xf2.R;
			tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			tClip.id.features.referenceEdge = edge1;
			tClip.id.features.incidentEdge = i1;
			tClip.id.features.incidentVertex = 0;
			tClip = c[1];
			tVec = vertices2[i2];
			tMat = xf2.R;
			tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			tClip.id.features.referenceEdge = edge1;
			tClip.id.features.incidentEdge = i2;
			tClip.id.features.incidentVertex = 1;
		}
		b2Collision.MakeClipPointVector = function ()
		{
			var r = new Vector(2);
			r[0] = new ClipVertex();
			r[1] = new ClipVertex();
			return r;
		}
		b2Collision.CollidePolygons = function (manifold, polyA, xfA, polyB, xfB)
		{
			var cv;
			manifold.m_pointCount = 0;
			var totalRadius = polyA.m_radius + polyB.m_radius;
			var edgeA = 0;
			b2Collision.s_edgeAO[0] = edgeA;
			var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
			edgeA = b2Collision.s_edgeAO[0];
			if (separationA > totalRadius) return;
			var edgeB = 0;
			b2Collision.s_edgeBO[0] = edgeB;
			var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
			edgeB = b2Collision.s_edgeBO[0];
			if (separationB > totalRadius) return;
			var poly1;
			var poly2;
			var xf1;
			var xf2;
			var edge1 = 0;
			var flip = 0;
			var k_relativeTol = 0.98;
			var k_absoluteTol = 0.001;
			var tMat;
			if (separationB > k_relativeTol * separationA + k_absoluteTol)
			{
				poly1 = polyB;
				poly2 = polyA;
				xf1 = xfB;
				xf2 = xfA;
				edge1 = edgeB;
				manifold.m_type = b2Manifold.e_faceB;
				flip = 1;
			}
			else
			{
				poly1 = polyA;
				poly2 = polyB;
				xf1 = xfA;
				xf2 = xfB;
				edge1 = edgeA;
				manifold.m_type = b2Manifold.e_faceA;
				flip = 0;
			}
			var incidentEdge = b2Collision.s_incidentEdge;
			b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
			var count1 = parseInt(poly1.m_vertexCount);
			var vertices1 = poly1.m_vertices;
			var local_v11 = vertices1[edge1];
			var local_v12;
			if (edge1 + 1 < count1)
			{
				local_v12 = vertices1[parseInt(edge1 + 1)];
			}
			else
			{
				local_v12 = vertices1[0];
			}
			var localTangent = b2Collision.s_localTangent;
			localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
			localTangent.Normalize();
			var localNormal = b2Collision.s_localNormal;
			localNormal.x = localTangent.y;
			localNormal.y = (-localTangent.x);
			var planePoint = b2Collision.s_planePoint;
			planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
			var tangent = b2Collision.s_tangent;
			tMat = xf1.R;
			tangent.x = (tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y);
			tangent.y = (tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y);
			var tangent2 = b2Collision.s_tangent2;
			tangent2.x = (-tangent.x);
			tangent2.y = (-tangent.y);
			var normal = b2Collision.s_normal;
			normal.x = tangent.y;
			normal.y = (-tangent.x);
			var v11 = b2Collision.s_v11;
			var v12 = b2Collision.s_v12;
			v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
			v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
			v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
			v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
			var frontOffset = normal.x * v11.x + normal.y * v11.y;
			var sideOffset1 = (-tangent.x * v11.x) - tangent.y * v11.y + totalRadius;
			var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
			var clipPoints1 = b2Collision.s_clipPoints1;
			var clipPoints2 = b2Collision.s_clipPoints2;
			var np = 0;
			np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
			if (np < 2) return;
			np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
			if (np < 2) return;
			manifold.m_localPlaneNormal.SetV(localNormal);
			manifold.m_localPoint.SetV(planePoint);
			var pointCount = 0;
			for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i)
			{
				cv = clipPoints2[i];
				var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
				if (separation <= totalRadius)
				{
					var cp = manifold.m_points[pointCount];
					tMat = xf2.R;
					var tX = cv.v.x - xf2.position.x;
					var tY = cv.v.y - xf2.position.y;
					cp.m_localPoint.x = (tX * tMat.col1.x + tY * tMat.col1.y);
					cp.m_localPoint.y = (tX * tMat.col2.x + tY * tMat.col2.y);
					cp.m_id.Set(cv.id);
					cp.m_id.features.flip = flip;
					++pointCount;
				}
			}
			manifold.m_pointCount = pointCount;
		}
		b2Collision.CollideCircles = function (manifold, circle1, xf1, circle2, xf2)
		{
			manifold.m_pointCount = 0;
			var tMat;
			var tVec;
			tMat = xf1.R;
			tVec = circle1.m_p;
			var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			tMat = xf2.R;
			tVec = circle2.m_p;
			var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			var dX = p2X - p1X;
			var dY = p2Y - p1Y;
			var distSqr = dX * dX + dY * dY;
			var radius = circle1.m_radius + circle2.m_radius;
			if (distSqr > radius * radius)
			{
				return;
			}
			manifold.m_type = b2Manifold.e_circles;
			manifold.m_localPoint.SetV(circle1.m_p);
			manifold.m_localPlaneNormal.SetZero();
			manifold.m_pointCount = 1;
			manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
			manifold.m_points[0].m_id.key = 0;
		}
		b2Collision.CollidePolygonAndCircle = function (manifold, polygon, xf1, circle, xf2)
		{
			manifold.m_pointCount = 0;
			var tPoint;
			var dX = 0;
			var dY = 0;
			var positionX = 0;
			var positionY = 0;
			var tVec;
			var tMat;
			tMat = xf2.R;
			tVec = circle.m_p;
			var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			dX = cX - xf1.position.x;
			dY = cY - xf1.position.y;
			tMat = xf1.R;
			var cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
			var cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
			var dist = 0;
			var normalIndex = 0;
			var separation = (-Number.MAX_VALUE);
			var radius = polygon.m_radius + circle.m_radius;
			var vertexCount = parseInt(polygon.m_vertexCount);
			var vertices = polygon.m_vertices;
			var normals = polygon.m_normals;
			for (var i = 0; i < vertexCount; ++i)
			{
				tVec = vertices[i];
				dX = cLocalX - tVec.x;
				dY = cLocalY - tVec.y;
				tVec = normals[i];
				var s = tVec.x * dX + tVec.y * dY;
				if (s > radius)
				{
					return;
				}
				if (s > separation)
				{
					separation = s;
					normalIndex = i;
				}
			}
			var vertIndex1 = parseInt(normalIndex);
			var vertIndex2 = parseInt(vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0);
			var v1 = vertices[vertIndex1];
			var v2 = vertices[vertIndex2];
			if (separation < Number.MIN_VALUE)
			{
				manifold.m_pointCount = 1;
				manifold.m_type = b2Manifold.e_faceA;
				manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
				manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
				manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
				manifold.m_points[0].m_localPoint.SetV(circle.m_p);
				manifold.m_points[0].m_id.key = 0;
				return;
			}
			var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
			var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
			if (u1 <= 0.0)
			{
				if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
				manifold.m_pointCount = 1;
				manifold.m_type = b2Manifold.e_faceA;
				manifold.m_localPlaneNormal.x = cLocalX - v1.x;
				manifold.m_localPlaneNormal.y = cLocalY - v1.y;
				manifold.m_localPlaneNormal.Normalize();
				manifold.m_localPoint.SetV(v1);
				manifold.m_points[0].m_localPoint.SetV(circle.m_p);
				manifold.m_points[0].m_id.key = 0;
			}
			else if (u2 <= 0)
			{
				if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
				manifold.m_pointCount = 1;
				manifold.m_type = b2Manifold.e_faceA;
				manifold.m_localPlaneNormal.x = cLocalX - v2.x;
				manifold.m_localPlaneNormal.y = cLocalY - v2.y;
				manifold.m_localPlaneNormal.Normalize();
				manifold.m_localPoint.SetV(v2);
				manifold.m_points[0].m_localPoint.SetV(circle.m_p);
				manifold.m_points[0].m_id.key = 0;
			}
			else
			{
				var faceCenterX = 0.5 * (v1.x + v2.x);
				var faceCenterY = 0.5 * (v1.y + v2.y);
				separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
				if (separation > radius) return;
				manifold.m_pointCount = 1;
				manifold.m_type = b2Manifold.e_faceA;
				manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
				manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
				manifold.m_localPlaneNormal.Normalize();
				manifold.m_localPoint.Set(faceCenterX, faceCenterY);
				manifold.m_points[0].m_localPoint.SetV(circle.m_p);
				manifold.m_points[0].m_id.key = 0;
			}
		}
		b2Collision.TestOverlap = function (a, b)
		{
			var t1 = b.lowerBound;
			var t2 = a.upperBound;
			var d1X = t1.x - t2.x;
			var d1Y = t1.y - t2.y;
			t1 = a.lowerBound;
			t2 = b.upperBound;
			var d2X = t1.x - t2.x;
			var d2Y = t1.y - t2.y;
			if (d1X > 0.0 || d1Y > 0.0) return false;
			if (d2X > 0.0 || d2Y > 0.0) return false;
			return true;
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Collision.b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
			Box2D.Collision.b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
			Box2D.Collision.b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
			Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
			Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
			Box2D.Collision.b2Collision.s_localTangent = new b2Vec2();
			Box2D.Collision.b2Collision.s_localNormal = new b2Vec2();
			Box2D.Collision.b2Collision.s_planePoint = new b2Vec2();
			Box2D.Collision.b2Collision.s_normal = new b2Vec2();
			Box2D.Collision.b2Collision.s_tangent = new b2Vec2();
			Box2D.Collision.b2Collision.s_tangent2 = new b2Vec2();
			Box2D.Collision.b2Collision.s_v11 = new b2Vec2();
			Box2D.Collision.b2Collision.s_v12 = new b2Vec2();
			Box2D.Collision.b2Collision.b2CollidePolyTempVec = new b2Vec2();
			Box2D.Collision.b2Collision.b2_nullFeature = 0x000000ff;
		});
		b2ContactID.b2ContactID = function ()
		{
			this.features = new Features();
		};
		b2ContactID.prototype.b2ContactID = function ()
		{
			this.features._m_id = this;
		}
		b2ContactID.prototype.Set = function (id)
		{
			this.key = id._key;
		}
		b2ContactID.prototype.Copy = function ()
		{
			var id = new b2ContactID();
			id.key = this.key;
			return id;
		}
		Object.defineProperty(b2ContactID.prototype, 'key', {
			enumerable:   false,
			configurable: true,
			get:          function ()
			{
				return this._key;
			}
		});
		Object.defineProperty(b2ContactID.prototype, 'key', {
			enumerable:   false,
			configurable: true,
			set:          function (value)
			{
				if (value === undefined) value = 0;
				this._key = value;
				this.features._referenceEdge = this._key & 0x000000ff;
				this.features._incidentEdge = ((this._key & 0x0000ff00) >> 8) & 0x000000ff;
				this.features._incidentVertex = ((this._key & 0x00ff0000) >> 16) & 0x000000ff;
				this.features._flip = ((this._key & 0xff000000) >> 24) & 0x000000ff;
			}
		});
		b2ContactPoint.b2ContactPoint = function ()
		{
			this.position = new b2Vec2();
			this.velocity = new b2Vec2();
			this.normal = new b2Vec2();
			this.id = new b2ContactID();
		};
		b2Distance.b2Distance = function ()
		{
		};
		b2Distance.Distance = function (output, cache, input)
		{
			++b2Distance.b2_gjkCalls;
			var proxyA = input.proxyA;
			var proxyB = input.proxyB;
			var transformA = input.transformA;
			var transformB = input.transformB;
			var simplex = b2Distance.s_simplex;
			simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
			var vertices = simplex.m_vertices;
			var k_maxIters = 20;
			var saveA = b2Distance.s_saveA;
			var saveB = b2Distance.s_saveB;
			var saveCount = 0;
			var closestPoint = simplex.GetClosestPoint();
			var distanceSqr1 = closestPoint.LengthSquared();
			var distanceSqr2 = distanceSqr1;
			var i = 0;
			var p;
			var iter = 0;
			while (iter < k_maxIters)
			{
				saveCount = simplex.m_count;
				for (i = 0;
				     i < saveCount; i++)
				{
					saveA[i] = vertices[i].indexA;
					saveB[i] = vertices[i].indexB;
				}
				switch (simplex.m_count)
				{
					case 1:
						break;
					case 2:
						simplex.Solve2();
						break;
					case 3:
						simplex.Solve3();
						break;
					default:
						b2Settings.b2Assert(false);
				}
				if (simplex.m_count == 3)
				{
					break;
				}
				p = simplex.GetClosestPoint();
				distanceSqr2 = p.LengthSquared();
				if (distanceSqr2 > distanceSqr1)
				{
				}
				distanceSqr1 = distanceSqr2;
				var d = simplex.GetSearchDirection();
				if (d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE)
				{
					break;
				}
				var vertex = vertices[simplex.m_count];
				vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
				vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
				vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
				vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
				vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
				++iter;
				++b2Distance.b2_gjkIters;
				var duplicate = false;
				for (i = 0;
				     i < saveCount; i++)
				{
					if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i])
					{
						duplicate = true;
						break;
					}
				}
				if (duplicate)
				{
					break;
				}
				++simplex.m_count;
			}
			b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
			simplex.GetWitnessPoints(output.pointA, output.pointB);
			output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
			output.iterations = iter;
			simplex.WriteCache(cache);
			if (input.useRadii)
			{
				var rA = proxyA.m_radius;
				var rB = proxyB.m_radius;
				if (output.distance > rA + rB && output.distance > Number.MIN_VALUE)
				{
					output.distance -= rA + rB;
					var normal = b2Math.SubtractVV(output.pointB, output.pointA);
					normal.Normalize();
					output.pointA.x += rA * normal.x;
					output.pointA.y += rA * normal.y;
					output.pointB.x -= rB * normal.x;
					output.pointB.y -= rB * normal.y;
				}
				else
				{
					p = new b2Vec2();
					p.x = .5 * (output.pointA.x + output.pointB.x);
					p.y = .5 * (output.pointA.y + output.pointB.y);
					output.pointA.x = output.pointB.x = p.x;
					output.pointA.y = output.pointB.y = p.y;
					output.distance = 0.0;
				}
			}
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Collision.b2Distance.s_simplex = new b2Simplex();
			Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
			Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3);
		});
		b2DistanceInput.b2DistanceInput = function ()
		{
		};
		b2DistanceOutput.b2DistanceOutput = function ()
		{
			this.pointA = new b2Vec2();
			this.pointB = new b2Vec2();
		};
		b2DistanceProxy.b2DistanceProxy = function ()
		{
		};
		b2DistanceProxy.prototype.Set = function (shape)
		{
			switch (shape.GetType())
			{
				case b2Shape.e_circleShape:
				{
					var circle = (shape instanceof b2CircleShape ? shape : null);
					this.m_vertices = new Vector(1, true);
					this.m_vertices[0] = circle.m_p;
					this.m_count = 1;
					this.m_radius = circle.m_radius;
				}
					break;
				case b2Shape.e_polygonShape:
				{
					var polygon = (shape instanceof b2PolygonShape ? shape : null);
					this.m_vertices = polygon.m_vertices;
					this.m_count = polygon.m_vertexCount;
					this.m_radius = polygon.m_radius;
				}
					break;
				default:
					b2Settings.b2Assert(false);
			}
		}
		b2DistanceProxy.prototype.GetSupport = function (d)
		{
			var bestIndex = 0;
			var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
			for (var i = 1; i < this.m_count; ++i)
			{
				var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
				if (value > bestValue)
				{
					bestIndex = i;
					bestValue = value;
				}
			}
			return bestIndex;
		}
		b2DistanceProxy.prototype.GetSupportVertex = function (d)
		{
			var bestIndex = 0;
			var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
			for (var i = 1; i < this.m_count; ++i)
			{
				var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
				if (value > bestValue)
				{
					bestIndex = i;
					bestValue = value;
				}
			}
			return this.m_vertices[bestIndex];
		}
		b2DistanceProxy.prototype.GetVertexCount = function ()
		{
			return this.m_count;
		}
		b2DistanceProxy.prototype.GetVertex = function (index)
		{
			if (index === undefined) index = 0;
			b2Settings.b2Assert(0 <= index && index < this.m_count);
			return this.m_vertices[index];
		}
		b2DynamicTree.b2DynamicTree = function ()
		{
		};
		b2DynamicTree.prototype.b2DynamicTree = function ()
		{
			this.m_root = null;
			this.m_freeList = null;
			this.m_path = 0;
			this.m_insertionCount = 0;
		}
		b2DynamicTree.prototype.CreateProxy = function (aabb, userData)
		{
			var node = this.AllocateNode();
			var extendX = b2Settings.b2_aabbExtension;
			var extendY = b2Settings.b2_aabbExtension;
			node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
			node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
			node.aabb.upperBound.x = aabb.upperBound.x + extendX;
			node.aabb.upperBound.y = aabb.upperBound.y + extendY;
			node.userData = userData;
			this.InsertLeaf(node);
			return node;
		}
		b2DynamicTree.prototype.DestroyProxy = function (proxy)
		{
			this.RemoveLeaf(proxy);
			this.FreeNode(proxy);
		}
		b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement)
		{
			b2Settings.b2Assert(proxy.IsLeaf());
			if (proxy.aabb.Contains(aabb))
			{
				return false;
			}
			this.RemoveLeaf(proxy);
			var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : (-displacement.x));
			var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : (-displacement.y));
			proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
			proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
			proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
			proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
			this.InsertLeaf(proxy);
			return true;
		}
		b2DynamicTree.prototype.Rebalance = function (iterations)
		{
			if (iterations === undefined) iterations = 0;
			if (this.m_root == null) return;
			for (var i = 0; i < iterations; i++)
			{
				var node = this.m_root;
				var bit = 0;
				while (node.IsLeaf() == false)
				{
					node = (this.m_path >> bit) & 1 ? node.child2 : node.child1;
					bit = (bit + 1) & 31;
				}
				++this.m_path;
				this.RemoveLeaf(node);
				this.InsertLeaf(node);
			}
		}
		b2DynamicTree.prototype.GetFatAABB = function (proxy)
		{
			return proxy.aabb;
		}
		b2DynamicTree.prototype.GetUserData = function (proxy)
		{
			return proxy.userData;
		}
		b2DynamicTree.prototype.Query = function (callback, aabb)
		{
			if (this.m_root == null) return;
			var stack = new Vector();
			var count = 0;
			stack[count++] = this.m_root;
			while (count > 0)
			{
				var node = stack[--count];
				if (node.aabb.TestOverlap(aabb))
				{
					if (node.IsLeaf())
					{
						var proceed = callback(node);
						if (!proceed) return;
					}
					else
					{
						stack[count++] = node.child1;
						stack[count++] = node.child2;
					}
				}
			}
		}
		b2DynamicTree.prototype.RayCast = function (callback, input)
		{
			if (this.m_root == null) return;
			var p1 = input.p1;
			var p2 = input.p2;
			var r = b2Math.SubtractVV(p1, p2);
			r.Normalize();
			var v = b2Math.CrossFV(1.0, r);
			var abs_v = b2Math.AbsV(v);
			var maxFraction = input.maxFraction;
			var segmentAABB = new b2AABB();
			var tX = 0;
			var tY = 0;
			{
				tX = p1.x + maxFraction * (p2.x - p1.x);
				tY = p1.y + maxFraction * (p2.y - p1.y);
				segmentAABB.lowerBound.x = Math.min(p1.x, tX);
				segmentAABB.lowerBound.y = Math.min(p1.y, tY);
				segmentAABB.upperBound.x = Math.max(p1.x, tX);
				segmentAABB.upperBound.y = Math.max(p1.y, tY);
			}
			var stack = new Vector();
			var count = 0;
			stack[count++] = this.m_root;
			while (count > 0)
			{
				var node = stack[--count];
				if (node.aabb.TestOverlap(segmentAABB) == false)
				{
					continue;
				}
				var c = node.aabb.GetCenter();
				var h = node.aabb.GetExtents();
				var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
				if (separation > 0.0) continue;
				if (node.IsLeaf())
				{
					var subInput = new b2RayCastInput();
					subInput.p1 = input.p1;
					subInput.p2 = input.p2;
					subInput.maxFraction = input.maxFraction;
					maxFraction = callback(subInput, node);
					if (maxFraction == 0.0) return;
					if (maxFraction > 0.0)
					{
						tX = p1.x + maxFraction * (p2.x - p1.x);
						tY = p1.y + maxFraction * (p2.y - p1.y);
						segmentAABB.lowerBound.x = Math.min(p1.x, tX);
						segmentAABB.lowerBound.y = Math.min(p1.y, tY);
						segmentAABB.upperBound.x = Math.max(p1.x, tX);
						segmentAABB.upperBound.y = Math.max(p1.y, tY);
					}
				}
				else
				{
					stack[count++] = node.child1;
					stack[count++] = node.child2;
				}
			}
		}
		b2DynamicTree.prototype.AllocateNode = function ()
		{
			if (this.m_freeList)
			{
				var node = this.m_freeList;
				this.m_freeList = node.parent;
				node.parent = null;
				node.child1 = null;
				node.child2 = null;
				return node;
			}
			return new b2DynamicTreeNode();
		}
		b2DynamicTree.prototype.FreeNode = function (node)
		{
			node.parent = this.m_freeList;
			this.m_freeList = node;
		}
		b2DynamicTree.prototype.InsertLeaf = function (leaf)
		{
			++this.m_insertionCount;
			if (this.m_root == null)
			{
				this.m_root = leaf;
				this.m_root.parent = null;
				return;
			}
			var center = leaf.aabb.GetCenter();
			var sibling = this.m_root;
			if (sibling.IsLeaf() == false)
			{
				do {
					var child1 = sibling.child1;
					var child2 = sibling.child2;
					var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
					var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
					if (norm1 < norm2)
					{
						sibling = child1;
					}
					else
					{
						sibling = child2;
					}
				}
				while (sibling.IsLeaf() == false)
			}
			var node1 = sibling.parent;
			var node2 = this.AllocateNode();
			node2.parent = node1;
			node2.userData = null;
			node2.aabb.Combine(leaf.aabb, sibling.aabb);
			if (node1)
			{
				if (sibling.parent.child1 == sibling)
				{
					node1.child1 = node2;
				}
				else
				{
					node1.child2 = node2;
				}
				node2.child1 = sibling;
				node2.child2 = leaf;
				sibling.parent = node2;
				leaf.parent = node2;
				do {
					if (node1.aabb.Contains(node2.aabb)) break;
					node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
					node2 = node1;
					node1 = node1.parent;
				}
				while (node1)
			}
			else
			{
				node2.child1 = sibling;
				node2.child2 = leaf;
				sibling.parent = node2;
				leaf.parent = node2;
				this.m_root = node2;
			}
		}
		b2DynamicTree.prototype.RemoveLeaf = function (leaf)
		{
			if (leaf == this.m_root)
			{
				this.m_root = null;
				return;
			}
			var node2 = leaf.parent;
			var node1 = node2.parent;
			var sibling;
			if (node2.child1 == leaf)
			{
				sibling = node2.child2;
			}
			else
			{
				sibling = node2.child1;
			}
			if (node1)
			{
				if (node1.child1 == node2)
				{
					node1.child1 = sibling;
				}
				else
				{
					node1.child2 = sibling;
				}
				sibling.parent = node1;
				this.FreeNode(node2);
				while (node1)
				{
					var oldAABB = node1.aabb;
					node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
					if (oldAABB.Contains(node1.aabb)) break;
					node1 = node1.parent;
				}
			}
			else
			{
				this.m_root = sibling;
				sibling.parent = null;
				this.FreeNode(node2);
			}
		}
		b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase = function ()
		{
			this.m_tree = new b2DynamicTree();
			this.m_moveBuffer = new Vector();
			this.m_pairBuffer = new Vector();
			this.m_pairCount = 0;
		};
		b2DynamicTreeBroadPhase.prototype.CreateProxy = function (aabb, userData)
		{
			var proxy = this.m_tree.CreateProxy(aabb, userData);
			++this.m_proxyCount;
			this.BufferMove(proxy);
			return proxy;
		}
		b2DynamicTreeBroadPhase.prototype.DestroyProxy = function (proxy)
		{
			this.UnBufferMove(proxy);
			--this.m_proxyCount;
			this.m_tree.DestroyProxy(proxy);
		}
		b2DynamicTreeBroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement)
		{
			var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
			if (buffer)
			{
				this.BufferMove(proxy);
			}
		}
		b2DynamicTreeBroadPhase.prototype.TestOverlap = function (proxyA, proxyB)
		{
			var aabbA = this.m_tree.GetFatAABB(proxyA);
			var aabbB = this.m_tree.GetFatAABB(proxyB);
			return aabbA.TestOverlap(aabbB);
		}
		b2DynamicTreeBroadPhase.prototype.GetUserData = function (proxy)
		{
			return this.m_tree.GetUserData(proxy);
		}
		b2DynamicTreeBroadPhase.prototype.GetFatAABB = function (proxy)
		{
			return this.m_tree.GetFatAABB(proxy);
		}
		b2DynamicTreeBroadPhase.prototype.GetProxyCount = function ()
		{
			return this.m_proxyCount;
		}
		b2DynamicTreeBroadPhase.prototype.UpdatePairs = function (callback)
		{
			var __this = this;
			__this.m_pairCount = 0;
			var i = 0,
				queryProxy;
			for (i = 0;
			     i < __this.m_moveBuffer.length; ++i)
			{
				queryProxy = __this.m_moveBuffer[i];

				function QueryCallback(proxy)
				{
					if (proxy == queryProxy) return true;
					if (__this.m_pairCount == __this.m_pairBuffer.length)
					{
						__this.m_pairBuffer[__this.m_pairCount] = new b2DynamicTreePair();
					}
					var pair = __this.m_pairBuffer[__this.m_pairCount];
					pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
					pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;
					++__this.m_pairCount;
					return true;
				};
				var fatAABB = __this.m_tree.GetFatAABB(queryProxy);
				__this.m_tree.Query(QueryCallback, fatAABB);
			}
			__this.m_moveBuffer.length = 0;
			for (var i = 0; i < __this.m_pairCount;)
			{
				var primaryPair = __this.m_pairBuffer[i];
				var userDataA = __this.m_tree.GetUserData(primaryPair.proxyA);
				var userDataB = __this.m_tree.GetUserData(primaryPair.proxyB);
				callback(userDataA, userDataB);
				++i;
				while (i < __this.m_pairCount)
				{
					var pair = __this.m_pairBuffer[i];
					if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB)
					{
						break;
					}
					++i;
				}
			}
		}
		b2DynamicTreeBroadPhase.prototype.Query = function (callback, aabb)
		{
			this.m_tree.Query(callback, aabb);
		}
		b2DynamicTreeBroadPhase.prototype.RayCast = function (callback, input)
		{
			this.m_tree.RayCast(callback, input);
		}
		b2DynamicTreeBroadPhase.prototype.Validate = function ()
		{
		}
		b2DynamicTreeBroadPhase.prototype.Rebalance = function (iterations)
		{
			if (iterations === undefined) iterations = 0;
			this.m_tree.Rebalance(iterations);
		}
		b2DynamicTreeBroadPhase.prototype.BufferMove = function (proxy)
		{
			this.m_moveBuffer[this.m_moveBuffer.length] = proxy;
		}
		b2DynamicTreeBroadPhase.prototype.UnBufferMove = function (proxy)
		{
			var i = parseInt(this.m_moveBuffer.indexOf(proxy));
			this.m_moveBuffer.splice(i, 1);
		}
		b2DynamicTreeBroadPhase.prototype.ComparePairs = function (pair1, pair2)
		{
			return 0;
		}
		b2DynamicTreeBroadPhase.__implements = {};
		b2DynamicTreeBroadPhase.__implements[IBroadPhase] = true;
		b2DynamicTreeNode.b2DynamicTreeNode = function ()
		{
			this.aabb = new b2AABB();
		};
		b2DynamicTreeNode.prototype.IsLeaf = function ()
		{
			return this.child1 == null;
		}
		b2DynamicTreePair.b2DynamicTreePair = function ()
		{
		};
		b2Manifold.b2Manifold = function ()
		{
			this.m_pointCount = 0;
		};
		b2Manifold.prototype.b2Manifold = function ()
		{
			this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
			for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++)
			{
				this.m_points[i] = new b2ManifoldPoint();
			}
			this.m_localPlaneNormal = new b2Vec2();
			this.m_localPoint = new b2Vec2();
		}
		b2Manifold.prototype.Reset = function ()
		{
			for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++)
			{
				((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Reset();
			}
			this.m_localPlaneNormal.SetZero();
			this.m_localPoint.SetZero();
			this.m_type = 0;
			this.m_pointCount = 0;
		}
		b2Manifold.prototype.Set = function (m)
		{
			this.m_pointCount = m.m_pointCount;
			for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++)
			{
				((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Set(m.m_points[i]);
			}
			this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
			this.m_localPoint.SetV(m.m_localPoint);
			this.m_type = m.m_type;
		}
		b2Manifold.prototype.Copy = function ()
		{
			var copy = new b2Manifold();
			copy.Set(this);
			return copy;
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Collision.b2Manifold.e_circles = 0x0001;
			Box2D.Collision.b2Manifold.e_faceA = 0x0002;
			Box2D.Collision.b2Manifold.e_faceB = 0x0004;
		});
		b2ManifoldPoint.b2ManifoldPoint = function ()
		{
			this.m_localPoint = new b2Vec2();
			this.m_id = new b2ContactID();
		};
		b2ManifoldPoint.prototype.b2ManifoldPoint = function ()
		{
			this.Reset();
		}
		b2ManifoldPoint.prototype.Reset = function ()
		{
			this.m_localPoint.SetZero();
			this.m_normalImpulse = 0.0;
			this.m_tangentImpulse = 0.0;
			this.m_id.key = 0;
		}
		b2ManifoldPoint.prototype.Set = function (m)
		{
			this.m_localPoint.SetV(m.m_localPoint);
			this.m_normalImpulse = m.m_normalImpulse;
			this.m_tangentImpulse = m.m_tangentImpulse;
			this.m_id.Set(m.m_id);
		}
		b2Point.b2Point = function ()
		{
			this.p = new b2Vec2();
		};
		b2Point.prototype.Support = function (xf, vX, vY)
		{
			if (vX === undefined) vX = 0;
			if (vY === undefined) vY = 0;
			return this.p;
		}
		b2Point.prototype.GetFirstVertex = function (xf)
		{
			return this.p;
		}
		b2RayCastInput.b2RayCastInput = function ()
		{
			this.p1 = new b2Vec2();
			this.p2 = new b2Vec2();
		};
		b2RayCastInput.prototype.b2RayCastInput = function (p1, p2, maxFraction)
		{
			if (p1 === undefined) p1 = null;
			if (p2 === undefined) p2 = null;
			if (maxFraction === undefined) maxFraction = 1;
			if (p1) this.p1.SetV(p1);
			if (p2) this.p2.SetV(p2);
			this.maxFraction = maxFraction;
		}
		b2RayCastOutput.b2RayCastOutput = function ()
		{
			this.normal = new b2Vec2();
		};
		b2Segment.b2Segment = function ()
		{
			this.p1 = new b2Vec2();
			this.p2 = new b2Vec2();
		};
		b2Segment.prototype.TestSegment = function (lambda, normal, segment, maxLambda)
		{
			if (maxLambda === undefined) maxLambda = 0;
			var s = segment.p1;
			var rX = segment.p2.x - s.x;
			var rY = segment.p2.y - s.y;
			var dX = this.p2.x - this.p1.x;
			var dY = this.p2.y - this.p1.y;
			var nX = dY;
			var nY = (-dX);
			var k_slop = 100.0 * Number.MIN_VALUE;
			var denom = (-(rX * nX + rY * nY));
			if (denom > k_slop)
			{
				var bX = s.x - this.p1.x;
				var bY = s.y - this.p1.y;
				var a = (bX * nX + bY * nY);
				if (0.0 <= a && a <= maxLambda * denom)
				{
					var mu2 = (-rX * bY) + rY * bX;
					if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop))
					{
						a /= denom;
						var nLen = Math.sqrt(nX * nX + nY * nY);
						nX /= nLen;
						nY /= nLen;
						lambda[0] = a;
						normal.Set(nX, nY);
						return true;
					}
				}
			}
			return false;
		}
		b2Segment.prototype.Extend = function (aabb)
		{
			this.ExtendForward(aabb);
			this.ExtendBackward(aabb);
		}
		b2Segment.prototype.ExtendForward = function (aabb)
		{
			var dX = this.p2.x - this.p1.x;
			var dY = this.p2.y - this.p1.y;
			var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY,
				dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
			this.p2.x = this.p1.x + dX * lambda;
			this.p2.y = this.p1.y + dY * lambda;
		}
		b2Segment.prototype.ExtendBackward = function (aabb)
		{
			var dX = (-this.p2.x) + this.p1.x;
			var dY = (-this.p2.y) + this.p1.y;
			var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY,
				dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
			this.p1.x = this.p2.x + dX * lambda;
			this.p1.y = this.p2.y + dY * lambda;
		}
		b2SeparationFunction.b2SeparationFunction = function ()
		{
			this.m_localPoint = new b2Vec2();
			this.m_axis = new b2Vec2();
		};
		b2SeparationFunction.prototype.Initialize = function (cache, proxyA, transformA, proxyB, transformB)
		{
			this.m_proxyA = proxyA;
			this.m_proxyB = proxyB;
			var count = parseInt(cache.count);
			b2Settings.b2Assert(0 < count && count < 3);
			var localPointA;
			var localPointA1;
			var localPointA2;
			var localPointB;
			var localPointB1;
			var localPointB2;
			var pointAX = 0;
			var pointAY = 0;
			var pointBX = 0;
			var pointBY = 0;
			var normalX = 0;
			var normalY = 0;
			var tMat;
			var tVec;
			var s = 0;
			var sgn = 0;
			if (count == 1)
			{
				this.m_type = b2SeparationFunction.e_points;
				localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
				localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
				tVec = localPointA;
				tMat = transformA.R;
				pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				tVec = localPointB;
				tMat = transformB.R;
				pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				this.m_axis.x = pointBX - pointAX;
				this.m_axis.y = pointBY - pointAY;
				this.m_axis.Normalize();
			}
			else if (cache.indexB[0] == cache.indexB[1])
			{
				this.m_type = b2SeparationFunction.e_faceA;
				localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
				localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
				localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
				this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
				this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
				this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
				this.m_axis.Normalize();
				tVec = this.m_axis;
				tMat = transformA.R;
				normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
				normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
				tVec = this.m_localPoint;
				tMat = transformA.R;
				pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				tVec = localPointB;
				tMat = transformB.R;
				pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
				if (s < 0.0)
				{
					this.m_axis.NegativeSelf();
				}
			}
			else if (cache.indexA[0] == cache.indexA[0])
			{
				this.m_type = b2SeparationFunction.e_faceB;
				localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
				localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
				localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
				this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
				this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
				this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
				this.m_axis.Normalize();
				tVec = this.m_axis;
				tMat = transformB.R;
				normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
				normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
				tVec = this.m_localPoint;
				tMat = transformB.R;
				pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				tVec = localPointA;
				tMat = transformA.R;
				pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
				if (s < 0.0)
				{
					this.m_axis.NegativeSelf();
				}
			}
			else
			{
				localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
				localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
				localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
				localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
				var pA = b2Math.MulX(transformA, localPointA);
				var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
				var pB = b2Math.MulX(transformB, localPointB);
				var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
				var a = dA.x * dA.x + dA.y * dA.y;
				var e = dB.x * dB.x + dB.y * dB.y;
				var r = b2Math.SubtractVV(dB, dA);
				var c = dA.x * r.x + dA.y * r.y;
				var f = dB.x * r.x + dB.y * r.y;
				var b = dA.x * dB.x + dA.y * dB.y;
				var denom = a * e - b * b;
				s = 0.0;
				if (denom != 0.0)
				{
					s = b2Math.Clamp((b * f - c * e) / denom, 0.0, 1.0);
				}
				var t = (b * s + f) / e;
				if (t < 0.0)
				{
					t = 0.0;
					s = b2Math.Clamp((b - c) / a, 0.0, 1.0);
				}
				localPointA = new b2Vec2();
				localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
				localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
				localPointB = new b2Vec2();
				localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
				localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
				if (s == 0.0 || s == 1.0)
				{
					this.m_type = b2SeparationFunction.e_faceB;
					this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
					this.m_axis.Normalize();
					this.m_localPoint = localPointB;
					tVec = this.m_axis;
					tMat = transformB.R;
					normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					tVec = this.m_localPoint;
					tMat = transformB.R;
					pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					tVec = localPointA;
					tMat = transformA.R;
					pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
					if (s < 0.0)
					{
						this.m_axis.NegativeSelf();
					}
				}
				else
				{
					this.m_type = b2SeparationFunction.e_faceA;
					this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
					this.m_localPoint = localPointA;
					tVec = this.m_axis;
					tMat = transformA.R;
					normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					tVec = this.m_localPoint;
					tMat = transformA.R;
					pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					tVec = localPointB;
					tMat = transformB.R;
					pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
					if (s < 0.0)
					{
						this.m_axis.NegativeSelf();
					}
				}
			}
		}
		b2SeparationFunction.prototype.Evaluate = function (transformA, transformB)
		{
			var axisA;
			var axisB;
			var localPointA;
			var localPointB;
			var pointA;
			var pointB;
			var seperation = 0;
			var normal;
			switch (this.m_type)
			{
				case b2SeparationFunction.e_points:
				{
					axisA = b2Math.MulTMV(transformA.R, this.m_axis);
					axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
					localPointA = this.m_proxyA.GetSupportVertex(axisA);
					localPointB = this.m_proxyB.GetSupportVertex(axisB);
					pointA = b2Math.MulX(transformA, localPointA);
					pointB = b2Math.MulX(transformB, localPointB);
					seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
					return seperation;
				}
				case b2SeparationFunction.e_faceA:
				{
					normal = b2Math.MulMV(transformA.R, this.m_axis);
					pointA = b2Math.MulX(transformA, this.m_localPoint);
					axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
					localPointB = this.m_proxyB.GetSupportVertex(axisB);
					pointB = b2Math.MulX(transformB, localPointB);
					seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
					return seperation;
				}
				case b2SeparationFunction.e_faceB:
				{
					normal = b2Math.MulMV(transformB.R, this.m_axis);
					pointB = b2Math.MulX(transformB, this.m_localPoint);
					axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
					localPointA = this.m_proxyA.GetSupportVertex(axisA);
					pointA = b2Math.MulX(transformA, localPointA);
					seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
					return seperation;
				}
				default:
					b2Settings.b2Assert(false);
					return 0.0;
			}
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Collision.b2SeparationFunction.e_points = 0x01;
			Box2D.Collision.b2SeparationFunction.e_faceA = 0x02;
			Box2D.Collision.b2SeparationFunction.e_faceB = 0x04;
		});
		b2Simplex.b2Simplex = function ()
		{
			this.m_v1 = new b2SimplexVertex();
			this.m_v2 = new b2SimplexVertex();
			this.m_v3 = new b2SimplexVertex();
			this.m_vertices = new Vector(3);
		};
		b2Simplex.prototype.b2Simplex = function ()
		{
			this.m_vertices[0] = this.m_v1;
			this.m_vertices[1] = this.m_v2;
			this.m_vertices[2] = this.m_v3;
		}
		b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB)
		{
			b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
			var wALocal;
			var wBLocal;
			this.m_count = cache.count;
			var vertices = this.m_vertices;
			for (var i = 0; i < this.m_count; i++)
			{
				var v = vertices[i];
				v.indexA = cache.indexA[i];
				v.indexB = cache.indexB[i];
				wALocal = proxyA.GetVertex(v.indexA);
				wBLocal = proxyB.GetVertex(v.indexB);
				v.wA = b2Math.MulX(transformA, wALocal);
				v.wB = b2Math.MulX(transformB, wBLocal);
				v.w = b2Math.SubtractVV(v.wB, v.wA);
				v.a = 0;
			}
			if (this.m_count > 1)
			{
				var metric1 = cache.metric;
				var metric2 = this.GetMetric();
				if (metric2 < .5 * metric1 || 2.0 * metric1 < metric2 || metric2 < Number.MIN_VALUE)
				{
					this.m_count = 0;
				}
			}
			if (this.m_count == 0)
			{
				v = vertices[0];
				v.indexA = 0;
				v.indexB = 0;
				wALocal = proxyA.GetVertex(0);
				wBLocal = proxyB.GetVertex(0);
				v.wA = b2Math.MulX(transformA, wALocal);
				v.wB = b2Math.MulX(transformB, wBLocal);
				v.w = b2Math.SubtractVV(v.wB, v.wA);
				this.m_count = 1;
			}
		}
		b2Simplex.prototype.WriteCache = function (cache)
		{
			cache.metric = this.GetMetric();
			cache.count = Box2D.parseUInt(this.m_count);
			var vertices = this.m_vertices;
			for (var i = 0; i < this.m_count; i++)
			{
				cache.indexA[i] = Box2D.parseUInt(vertices[i].indexA);
				cache.indexB[i] = Box2D.parseUInt(vertices[i].indexB);
			}
		}
		b2Simplex.prototype.GetSearchDirection = function ()
		{
			switch (this.m_count)
			{
				case 1:
					return this.m_v1.w.GetNegative();
				case 2:
				{
					var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
					var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
					if (sgn > 0.0)
					{
						return b2Math.CrossFV(1.0, e12);
					}
					else
					{
						return b2Math.CrossVF(e12, 1.0);
					}
				}
				default:
					b2Settings.b2Assert(false);
					return new b2Vec2();
			}
		}
		b2Simplex.prototype.GetClosestPoint = function ()
		{
			switch (this.m_count)
			{
				case 0:
					b2Settings.b2Assert(false);
					return new b2Vec2();
				case 1:
					return this.m_v1.w;
				case 2:
					return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
				default:
					b2Settings.b2Assert(false);
					return new b2Vec2();
			}
		}
		b2Simplex.prototype.GetWitnessPoints = function (pA, pB)
		{
			switch (this.m_count)
			{
				case 0:
					b2Settings.b2Assert(false);
					break;
				case 1:
					pA.SetV(this.m_v1.wA);
					pB.SetV(this.m_v1.wB);
					break;
				case 2:
					pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
					pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
					pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
					pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
					break;
				case 3:
					pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
					pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
					break;
				default:
					b2Settings.b2Assert(false);
					break;
			}
		}
		b2Simplex.prototype.GetMetric = function ()
		{
			switch (this.m_count)
			{
				case 0:
					b2Settings.b2Assert(false);
					return 0.0;
				case 1:
					return 0.0;
				case 2:
					return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
				case 3:
					return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
				default:
					b2Settings.b2Assert(false);
					return 0.0;
			}
		}
		b2Simplex.prototype.Solve2 = function ()
		{
			var w1 = this.m_v1.w;
			var w2 = this.m_v2.w;
			var e12 = b2Math.SubtractVV(w2, w1);
			var d12_2 = (-(w1.x * e12.x + w1.y * e12.y));
			if (d12_2 <= 0.0)
			{
				this.m_v1.a = 1.0;
				this.m_count = 1;
				return;
			}
			var d12_1 = (w2.x * e12.x + w2.y * e12.y);
			if (d12_1 <= 0.0)
			{
				this.m_v2.a = 1.0;
				this.m_count = 1;
				this.m_v1.Set(this.m_v2);
				return;
			}
			var inv_d12 = 1.0 / (d12_1 + d12_2);
			this.m_v1.a = d12_1 * inv_d12;
			this.m_v2.a = d12_2 * inv_d12;
			this.m_count = 2;
		}
		b2Simplex.prototype.Solve3 = function ()
		{
			var w1 = this.m_v1.w;
			var w2 = this.m_v2.w;
			var w3 = this.m_v3.w;
			var e12 = b2Math.SubtractVV(w2, w1);
			var w1e12 = b2Math.Dot(w1, e12);
			var w2e12 = b2Math.Dot(w2, e12);
			var d12_1 = w2e12;
			var d12_2 = (-w1e12);
			var e13 = b2Math.SubtractVV(w3, w1);
			var w1e13 = b2Math.Dot(w1, e13);
			var w3e13 = b2Math.Dot(w3, e13);
			var d13_1 = w3e13;
			var d13_2 = (-w1e13);
			var e23 = b2Math.SubtractVV(w3, w2);
			var w2e23 = b2Math.Dot(w2, e23);
			var w3e23 = b2Math.Dot(w3, e23);
			var d23_1 = w3e23;
			var d23_2 = (-w2e23);
			var n123 = b2Math.CrossVV(e12, e13);
			var d123_1 = n123 * b2Math.CrossVV(w2, w3);
			var d123_2 = n123 * b2Math.CrossVV(w3, w1);
			var d123_3 = n123 * b2Math.CrossVV(w1, w2);
			if (d12_2 <= 0.0 && d13_2 <= 0.0)
			{
				this.m_v1.a = 1.0;
				this.m_count = 1;
				return;
			}
			if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0)
			{
				var inv_d12 = 1.0 / (d12_1 + d12_2);
				this.m_v1.a = d12_1 * inv_d12;
				this.m_v2.a = d12_2 * inv_d12;
				this.m_count = 2;
				return;
			}
			if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0)
			{
				var inv_d13 = 1.0 / (d13_1 + d13_2);
				this.m_v1.a = d13_1 * inv_d13;
				this.m_v3.a = d13_2 * inv_d13;
				this.m_count = 2;
				this.m_v2.Set(this.m_v3);
				return;
			}
			if (d12_1 <= 0.0 && d23_2 <= 0.0)
			{
				this.m_v2.a = 1.0;
				this.m_count = 1;
				this.m_v1.Set(this.m_v2);
				return;
			}
			if (d13_1 <= 0.0 && d23_1 <= 0.0)
			{
				this.m_v3.a = 1.0;
				this.m_count = 1;
				this.m_v1.Set(this.m_v3);
				return;
			}
			if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0)
			{
				var inv_d23 = 1.0 / (d23_1 + d23_2);
				this.m_v2.a = d23_1 * inv_d23;
				this.m_v3.a = d23_2 * inv_d23;
				this.m_count = 2;
				this.m_v1.Set(this.m_v3);
				return;
			}
			var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
			this.m_v1.a = d123_1 * inv_d123;
			this.m_v2.a = d123_2 * inv_d123;
			this.m_v3.a = d123_3 * inv_d123;
			this.m_count = 3;
		}
		b2SimplexCache.b2SimplexCache = function ()
		{
			this.indexA = new Vector_a2j_Number(3);
			this.indexB = new Vector_a2j_Number(3);
		};
		b2SimplexVertex.b2SimplexVertex = function ()
		{
		};
		b2SimplexVertex.prototype.Set = function (other)
		{
			this.wA.SetV(other.wA);
			this.wB.SetV(other.wB);
			this.w.SetV(other.w);
			this.a = other.a;
			this.indexA = other.indexA;
			this.indexB = other.indexB;
		}
		b2TimeOfImpact.b2TimeOfImpact = function ()
		{
		};
		b2TimeOfImpact.TimeOfImpact = function (input)
		{
			++b2TimeOfImpact.b2_toiCalls;
			var proxyA = input.proxyA;
			var proxyB = input.proxyB;
			var sweepA = input.sweepA;
			var sweepB = input.sweepB;
			b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
			b2Settings.b2Assert(1.0 - sweepA.t0 > Number.MIN_VALUE);
			var radius = proxyA.m_radius + proxyB.m_radius;
			var tolerance = input.tolerance;
			var alpha = 0.0;
			var k_maxIterations = 1000;
			var iter = 0;
			var target = 0.0;
			b2TimeOfImpact.s_cache.count = 0;
			b2TimeOfImpact.s_distanceInput.useRadii = false;
			for (; ;)
			{
				sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
				sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
				b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
				b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
				b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
				b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
				b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
				if (b2TimeOfImpact.s_distanceOutput.distance <= 0.0)
				{
					alpha = 1.0;
					break;
				}
				b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
				var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
				if (separation <= 0.0)
				{
					alpha = 1.0;
					break;
				}
				if (iter == 0)
				{
					if (separation > radius)
					{
						target = b2Math.Max(radius - tolerance, 0.75 * radius);
					}
					else
					{
						target = b2Math.Max(separation - tolerance, 0.02 * radius);
					}
				}
				if (separation - target < 0.5 * tolerance)
				{
					if (iter == 0)
					{
						alpha = 1.0;
						break;
					}
					break;
				}
				var newAlpha = alpha;
				{
					var x1 = alpha;
					var x2 = 1.0;
					var f1 = separation;
					sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
					sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
					var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
					if (f2 >= target)
					{
						alpha = 1.0;
						break;
					}
					var rootIterCount = 0;
					for (; ;)
					{
						var x = 0;
						if (rootIterCount & 1)
						{
							x = x1 + (target - f1) * (x2 - x1) / (f2 - f1);
						}
						else
						{
							x = 0.5 * (x1 + x2);
						}
						sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
						sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
						var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
						if (b2Math.Abs(f - target) < 0.025 * tolerance)
						{
							newAlpha = x;
							break;
						}
						if (f > target)
						{
							x1 = x;
							f1 = f;
						}
						else
						{
							x2 = x;
							f2 = f;
						}
						++rootIterCount;
						++b2TimeOfImpact.b2_toiRootIters;
						if (rootIterCount == 50)
						{
							break;
						}
					}
					b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
				}
				if (newAlpha < (1.0 + 100.0 * Number.MIN_VALUE) * alpha)
				{
					break;
				}
				alpha = newAlpha;
				iter++;
				++b2TimeOfImpact.b2_toiIters;
				if (iter == k_maxIterations)
				{
					break;
				}
			}
			b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
			return alpha;
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
			Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0;
			Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
			Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
			Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
			Box2D.Collision.b2TimeOfImpact.s_cache = new b2SimplexCache();
			Box2D.Collision.b2TimeOfImpact.s_distanceInput = new b2DistanceInput();
			Box2D.Collision.b2TimeOfImpact.s_xfA = new b2Transform();
			Box2D.Collision.b2TimeOfImpact.s_xfB = new b2Transform();
			Box2D.Collision.b2TimeOfImpact.s_fcn = new b2SeparationFunction();
			Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput();
		});
		b2TOIInput.b2TOIInput = function ()
		{
			this.proxyA = new b2DistanceProxy();
			this.proxyB = new b2DistanceProxy();
			this.sweepA = new b2Sweep();
			this.sweepB = new b2Sweep();
		};
		b2WorldManifold.b2WorldManifold = function ()
		{
			this.m_normal = new b2Vec2();
		};
		b2WorldManifold.prototype.b2WorldManifold = function ()
		{
			this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
			for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++)
			{
				this.m_points[i] = new b2Vec2();
			}
		}
		b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB)
		{
			if (radiusA === undefined) radiusA = 0;
			if (radiusB === undefined) radiusB = 0;
			if (manifold.m_pointCount == 0)
			{
				return;
			}
			var i = 0;
			var tVec;
			var tMat;
			var normalX = 0;
			var normalY = 0;
			var planePointX = 0;
			var planePointY = 0;
			var clipPointX = 0;
			var clipPointY = 0;
			switch (manifold.m_type)
			{
				case b2Manifold.e_circles:
				{
					tMat = xfA.R;
					tVec = manifold.m_localPoint;
					var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					tMat = xfB.R;
					tVec = manifold.m_points[0].m_localPoint;
					var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					var dX = pointBX - pointAX;
					var dY = pointBY - pointAY;
					var d2 = dX * dX + dY * dY;
					if (d2 > Number.MIN_VALUE * Number.MIN_VALUE)
					{
						var d = Math.sqrt(d2);
						this.m_normal.x = dX / d;
						this.m_normal.y = dY / d;
					}
					else
					{
						this.m_normal.x = 1;
						this.m_normal.y = 0;
					}
					var cAX = pointAX + radiusA * this.m_normal.x;
					var cAY = pointAY + radiusA * this.m_normal.y;
					var cBX = pointBX - radiusB * this.m_normal.x;
					var cBY = pointBY - radiusB * this.m_normal.y;
					this.m_points[0].x = 0.5 * (cAX + cBX);
					this.m_points[0].y = 0.5 * (cAY + cBY);
				}
					break;
				case b2Manifold.e_faceA:
				{
					tMat = xfA.R;
					tVec = manifold.m_localPlaneNormal;
					normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					tMat = xfA.R;
					tVec = manifold.m_localPoint;
					planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					this.m_normal.x = normalX;
					this.m_normal.y = normalY;
					for (i = 0;
					     i < manifold.m_pointCount; i++)
					{
						tMat = xfB.R;
						tVec = manifold.m_points[i].m_localPoint;
						clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
						clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
						this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
						this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY;
					}
				}
					break;
				case b2Manifold.e_faceB:
				{
					tMat = xfB.R;
					tVec = manifold.m_localPlaneNormal;
					normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					tMat = xfB.R;
					tVec = manifold.m_localPoint;
					planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					this.m_normal.x = (-normalX);
					this.m_normal.y = (-normalY);
					for (i = 0;
					     i < manifold.m_pointCount; i++)
					{
						tMat = xfA.R;
						tVec = manifold.m_points[i].m_localPoint;
						clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
						clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
						this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
						this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY;
					}
				}
					break;
			}
		}
		ClipVertex.ClipVertex = function ()
		{
			this.v = new b2Vec2();
			this.id = new b2ContactID();
		};
		ClipVertex.prototype.Set = function (other)
		{
			this.v.SetV(other.v);
			this.id.Set(other.id);
		}
		Features.Features = function ()
		{
		};
		Object.defineProperty(Features.prototype, 'referenceEdge', {
			enumerable:   false,
			configurable: true,
			get:          function ()
			{
				return this._referenceEdge;
			}
		});
		Object.defineProperty(Features.prototype, 'referenceEdge', {
			enumerable:   false,
			configurable: true,
			set:          function (value)
			{
				if (value === undefined) value = 0;
				this._referenceEdge = value;
				this._m_id._key = (this._m_id._key & 0xffffff00) | (this._referenceEdge & 0x000000ff);
			}
		});
		Object.defineProperty(Features.prototype, 'incidentEdge', {
			enumerable:   false,
			configurable: true,
			get:          function ()
			{
				return this._incidentEdge;
			}
		});
		Object.defineProperty(Features.prototype, 'incidentEdge', {
			enumerable:   false,
			configurable: true,
			set:          function (value)
			{
				if (value === undefined) value = 0;
				this._incidentEdge = value;
				this._m_id._key = (this._m_id._key & 0xffff00ff) | ((this._incidentEdge << 8) & 0x0000ff00);
			}
		});
		Object.defineProperty(Features.prototype, 'incidentVertex', {
			enumerable:   false,
			configurable: true,
			get:          function ()
			{
				return this._incidentVertex;
			}
		});
		Object.defineProperty(Features.prototype, 'incidentVertex', {
			enumerable:   false,
			configurable: true,
			set:          function (value)
			{
				if (value === undefined) value = 0;
				this._incidentVertex = value;
				this._m_id._key = (this._m_id._key & 0xff00ffff) | ((this._incidentVertex << 16) & 0x00ff0000);
			}
		});
		Object.defineProperty(Features.prototype, 'flip', {
			enumerable:   false,
			configurable: true,
			get:          function ()
			{
				return this._flip;
			}
		});
		Object.defineProperty(Features.prototype, 'flip', {
			enumerable:   false,
			configurable: true,
			set:          function (value)
			{
				if (value === undefined) value = 0;
				this._flip = value;
				this._m_id._key = (this._m_id._key & 0x00ffffff) | ((this._flip << 24) & 0xff000000);
			}
		});
	})();
	(function ()
	{
		var b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
			b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
			b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
			b2MassData = Box2D.Collision.Shapes.b2MassData,
			b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
			b2Shape = Box2D.Collision.Shapes.b2Shape,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3,
			b2Body = Box2D.Dynamics.b2Body,
			b2BodyDef = Box2D.Dynamics.b2BodyDef,
			b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
			b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
			b2ContactListener = Box2D.Dynamics.b2ContactListener,
			b2ContactManager = Box2D.Dynamics.b2ContactManager,
			b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
			b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
			b2FilterData = Box2D.Dynamics.b2FilterData,
			b2Fixture = Box2D.Dynamics.b2Fixture,
			b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
			b2Island = Box2D.Dynamics.b2Island,
			b2TimeStep = Box2D.Dynamics.b2TimeStep,
			b2World = Box2D.Dynamics.b2World,
			b2AABB = Box2D.Collision.b2AABB,
			b2Bound = Box2D.Collision.b2Bound,
			b2BoundValues = Box2D.Collision.b2BoundValues,
			b2Collision = Box2D.Collision.b2Collision,
			b2ContactID = Box2D.Collision.b2ContactID,
			b2ContactPoint = Box2D.Collision.b2ContactPoint,
			b2Distance = Box2D.Collision.b2Distance,
			b2DistanceInput = Box2D.Collision.b2DistanceInput,
			b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
			b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
			b2DynamicTree = Box2D.Collision.b2DynamicTree,
			b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
			b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
			b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
			b2Manifold = Box2D.Collision.b2Manifold,
			b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
			b2Point = Box2D.Collision.b2Point,
			b2RayCastInput = Box2D.Collision.b2RayCastInput,
			b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
			b2Segment = Box2D.Collision.b2Segment,
			b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
			b2Simplex = Box2D.Collision.b2Simplex,
			b2SimplexCache = Box2D.Collision.b2SimplexCache,
			b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
			b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
			b2TOIInput = Box2D.Collision.b2TOIInput,
			b2WorldManifold = Box2D.Collision.b2WorldManifold,
			ClipVertex = Box2D.Collision.ClipVertex,
			Features = Box2D.Collision.Features,
			IBroadPhase = Box2D.Collision.IBroadPhase;

		Box2D.inherit(b2CircleShape, Box2D.Collision.Shapes.b2Shape);
		b2CircleShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
		b2CircleShape.b2CircleShape = function ()
		{
			Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
			this.m_p = new b2Vec2();
		};
		b2CircleShape.prototype.Copy = function ()
		{
			var s = new b2CircleShape();
			s.Set(this);
			return s;
		}
		b2CircleShape.prototype.Set = function (other)
		{
			this.__super.Set.call(this, other);
			if (Box2D.is(other, b2CircleShape))
			{
				var other2 = (other instanceof b2CircleShape ? other : null);
				this.m_p.SetV(other2.m_p);
			}
		}
		b2CircleShape.prototype.TestPoint = function (transform, p)
		{
			var tMat = transform.R;
			var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
			var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
			dX = p.x - dX;
			dY = p.y - dY;
			return (dX * dX + dY * dY) <= this.m_radius * this.m_radius;
		}
		b2CircleShape.prototype.RayCast = function (output, input, transform)
		{
			var tMat = transform.R;
			var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
			var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
			var sX = input.p1.x - positionX;
			var sY = input.p1.y - positionY;
			var b = (sX * sX + sY * sY) - this.m_radius * this.m_radius;
			var rX = input.p2.x - input.p1.x;
			var rY = input.p2.y - input.p1.y;
			var c = (sX * rX + sY * rY);
			var rr = (rX * rX + rY * rY);
			var sigma = c * c - rr * b;
			if (sigma < 0.0 || rr < Number.MIN_VALUE)
			{
				return false;
			}
			var a = (-(c + Math.sqrt(sigma)));
			if (0.0 <= a && a <= input.maxFraction * rr)
			{
				a /= rr;
				output.fraction = a;
				output.normal.x = sX + a * rX;
				output.normal.y = sY + a * rY;
				output.normal.Normalize();
				return true;
			}
			return false;
		}
		b2CircleShape.prototype.ComputeAABB = function (aabb, transform)
		{
			var tMat = transform.R;
			var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
			var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
			aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
			aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius);
		}
		b2CircleShape.prototype.ComputeMass = function (massData, density)
		{
			if (density === undefined) density = 0;
			massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
			massData.center.SetV(this.m_p);
			massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
		}
		b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c)
		{
			if (offset === undefined) offset = 0;
			var p = b2Math.MulX(xf, this.m_p);
			var l = (-(b2Math.Dot(normal, p) - offset));
			if (l < (-this.m_radius) + Number.MIN_VALUE)
			{
				return 0;
			}
			if (l > this.m_radius)
			{
				c.SetV(p);
				return Math.PI * this.m_radius * this.m_radius;
			}
			var r2 = this.m_radius * this.m_radius;
			var l2 = l * l;
			var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
			var com = (-2 / 3 * Math.pow(r2 - l2, 1.5) / area);
			c.x = p.x + normal.x * com;
			c.y = p.y + normal.y * com;
			return area;
		}
		b2CircleShape.prototype.GetLocalPosition = function ()
		{
			return this.m_p;
		}
		b2CircleShape.prototype.SetLocalPosition = function (position)
		{
			this.m_p.SetV(position);
		}
		b2CircleShape.prototype.GetRadius = function ()
		{
			return this.m_radius;
		}
		b2CircleShape.prototype.SetRadius = function (radius)
		{
			if (radius === undefined) radius = 0;
			this.m_radius = radius;
		}
		b2CircleShape.prototype.b2CircleShape = function (radius)
		{
			if (radius === undefined) radius = 0;
			this.__super.b2Shape.call(this);
			this.m_type = b2Shape.e_circleShape;
			this.m_radius = radius;
		}
		b2EdgeChainDef.b2EdgeChainDef = function ()
		{
		};
		b2EdgeChainDef.prototype.b2EdgeChainDef = function ()
		{
			this.vertexCount = 0;
			this.isALoop = true;
			this.vertices = [];
		}
		Box2D.inherit(b2EdgeShape, Box2D.Collision.Shapes.b2Shape);
		b2EdgeShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
		b2EdgeShape.b2EdgeShape = function ()
		{
			Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
			this.s_supportVec = new b2Vec2();
			this.m_v1 = new b2Vec2();
			this.m_v2 = new b2Vec2();
			this.m_coreV1 = new b2Vec2();
			this.m_coreV2 = new b2Vec2();
			this.m_normal = new b2Vec2();
			this.m_direction = new b2Vec2();
			this.m_cornerDir1 = new b2Vec2();
			this.m_cornerDir2 = new b2Vec2();
		};
		b2EdgeShape.prototype.TestPoint = function (transform, p)
		{
			return false;
		}
		b2EdgeShape.prototype.RayCast = function (output, input, transform)
		{
			var tMat;
			var rX = input.p2.x - input.p1.x;
			var rY = input.p2.y - input.p1.y;
			tMat = transform.R;
			var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
			var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
			var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
			var nY = (-(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X));
			var k_slop = 100.0 * Number.MIN_VALUE;
			var denom = (-(rX * nX + rY * nY));
			if (denom > k_slop)
			{
				var bX = input.p1.x - v1X;
				var bY = input.p1.y - v1Y;
				var a = (bX * nX + bY * nY);
				if (0.0 <= a && a <= input.maxFraction * denom)
				{
					var mu2 = (-rX * bY) + rY * bX;
					if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop))
					{
						a /= denom;
						output.fraction = a;
						var nLen = Math.sqrt(nX * nX + nY * nY);
						output.normal.x = nX / nLen;
						output.normal.y = nY / nLen;
						return true;
					}
				}
			}
			return false;
		}
		b2EdgeShape.prototype.ComputeAABB = function (aabb, transform)
		{
			var tMat = transform.R;
			var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
			var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
			var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
			var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
			if (v1X < v2X)
			{
				aabb.lowerBound.x = v1X;
				aabb.upperBound.x = v2X;
			}
			else
			{
				aabb.lowerBound.x = v2X;
				aabb.upperBound.x = v1X;
			}
			if (v1Y < v2Y)
			{
				aabb.lowerBound.y = v1Y;
				aabb.upperBound.y = v2Y;
			}
			else
			{
				aabb.lowerBound.y = v2Y;
				aabb.upperBound.y = v1Y;
			}
		}
		b2EdgeShape.prototype.ComputeMass = function (massData, density)
		{
			if (density === undefined) density = 0;
			massData.mass = 0;
			massData.center.SetV(this.m_v1);
			massData.I = 0;
		}
		b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c)
		{
			if (offset === undefined) offset = 0;
			var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
			var v1 = b2Math.MulX(xf, this.m_v1);
			var v2 = b2Math.MulX(xf, this.m_v2);
			var d1 = b2Math.Dot(normal, v1) - offset;
			var d2 = b2Math.Dot(normal, v2) - offset;
			if (d1 > 0)
			{
				if (d2 > 0)
				{
					return 0;
				}
				else
				{
					v1.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
					v1.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
				}
			}
			else
			{
				if (d2 > 0)
				{
					v2.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
					v2.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
				}
				else
				{
				}
			}
			c.x = (v0.x + v1.x + v2.x) / 3;
			c.y = (v0.y + v1.y + v2.y) / 3;
			return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x));
		}
		b2EdgeShape.prototype.GetLength = function ()
		{
			return this.m_length;
		}
		b2EdgeShape.prototype.GetVertex1 = function ()
		{
			return this.m_v1;
		}
		b2EdgeShape.prototype.GetVertex2 = function ()
		{
			return this.m_v2;
		}
		b2EdgeShape.prototype.GetCoreVertex1 = function ()
		{
			return this.m_coreV1;
		}
		b2EdgeShape.prototype.GetCoreVertex2 = function ()
		{
			return this.m_coreV2;
		}
		b2EdgeShape.prototype.GetNormalVector = function ()
		{
			return this.m_normal;
		}
		b2EdgeShape.prototype.GetDirectionVector = function ()
		{
			return this.m_direction;
		}
		b2EdgeShape.prototype.GetCorner1Vector = function ()
		{
			return this.m_cornerDir1;
		}
		b2EdgeShape.prototype.GetCorner2Vector = function ()
		{
			return this.m_cornerDir2;
		}
		b2EdgeShape.prototype.Corner1IsConvex = function ()
		{
			return this.m_cornerConvex1;
		}
		b2EdgeShape.prototype.Corner2IsConvex = function ()
		{
			return this.m_cornerConvex2;
		}
		b2EdgeShape.prototype.GetFirstVertex = function (xf)
		{
			var tMat = xf.R;
			return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y));
		}
		b2EdgeShape.prototype.GetNextEdge = function ()
		{
			return this.m_nextEdge;
		}
		b2EdgeShape.prototype.GetPrevEdge = function ()
		{
			return this.m_prevEdge;
		}
		b2EdgeShape.prototype.Support = function (xf, dX, dY)
		{
			if (dX === undefined) dX = 0;
			if (dY === undefined) dY = 0;
			var tMat = xf.R;
			var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
			var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
			var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
			var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
			if ((v1X * dX + v1Y * dY) > (v2X * dX + v2Y * dY))
			{
				this.s_supportVec.x = v1X;
				this.s_supportVec.y = v1Y;
			}
			else
			{
				this.s_supportVec.x = v2X;
				this.s_supportVec.y = v2Y;
			}
			return this.s_supportVec;
		}
		b2EdgeShape.prototype.b2EdgeShape = function (v1, v2)
		{
			this.__super.b2Shape.call(this);
			this.m_type = b2Shape.e_edgeShape;
			this.m_prevEdge = null;
			this.m_nextEdge = null;
			this.m_v1 = v1;
			this.m_v2 = v2;
			this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
			this.m_length = this.m_direction.Normalize();
			this.m_normal.Set(this.m_direction.y, (-this.m_direction.x));
			this.m_coreV1.Set((-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x)) + this.m_v1.x, (-b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y)) + this.m_v1.y);
			this.m_coreV2.Set((-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x)) + this.m_v2.x, (-b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y)) + this.m_v2.y);
			this.m_cornerDir1 = this.m_normal;
			this.m_cornerDir2.Set((-this.m_normal.x), (-this.m_normal.y));
		}
		b2EdgeShape.prototype.SetPrevEdge = function (edge, core, cornerDir, convex)
		{
			this.m_prevEdge = edge;
			this.m_coreV1 = core;
			this.m_cornerDir1 = cornerDir;
			this.m_cornerConvex1 = convex;
		}
		b2EdgeShape.prototype.SetNextEdge = function (edge, core, cornerDir, convex)
		{
			this.m_nextEdge = edge;
			this.m_coreV2 = core;
			this.m_cornerDir2 = cornerDir;
			this.m_cornerConvex2 = convex;
		}
		b2MassData.b2MassData = function ()
		{
			this.mass = 0.0;
			this.center = new b2Vec2(0, 0);
			this.I = 0.0;
		};
		Box2D.inherit(b2PolygonShape, Box2D.Collision.Shapes.b2Shape);
		b2PolygonShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
		b2PolygonShape.b2PolygonShape = function ()
		{
			Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
		};
		b2PolygonShape.prototype.Copy = function ()
		{
			var s = new b2PolygonShape();
			s.Set(this);
			return s;
		}
		b2PolygonShape.prototype.Set = function (other)
		{
			this.__super.Set.call(this, other);
			if (Box2D.is(other, b2PolygonShape))
			{
				var other2 = (other instanceof b2PolygonShape ? other : null);
				this.m_centroid.SetV(other2.m_centroid);
				this.m_vertexCount = other2.m_vertexCount;
				this.Reserve(this.m_vertexCount);
				for (var i = 0; i < this.m_vertexCount; i++)
				{
					this.m_vertices[i].SetV(other2.m_vertices[i]);
					this.m_normals[i].SetV(other2.m_normals[i]);
				}
			}
		}
		b2PolygonShape.prototype.SetAsArray = function (vertices, vertexCount)
		{
			if (vertexCount === undefined) vertexCount = 0;
			var v = new Vector();
			var i = 0,
				tVec;
			for (i = 0;
			     i < vertices.length; ++i)
			{
				tVec = vertices[i];
				v.push(tVec);
			}
			this.SetAsVector(v, vertexCount);
		}
		b2PolygonShape.AsArray = function (vertices, vertexCount)
		{
			if (vertexCount === undefined) vertexCount = 0;
			var polygonShape = new b2PolygonShape();
			polygonShape.SetAsArray(vertices, vertexCount);
			return polygonShape;
		}
		b2PolygonShape.prototype.SetAsVector = function (vertices, vertexCount)
		{
			if (vertexCount === undefined) vertexCount = 0;
			if (vertexCount == 0) vertexCount = vertices.length;
			b2Settings.b2Assert(2 <= vertexCount);
			this.m_vertexCount = vertexCount;
			this.Reserve(vertexCount);
			var i = 0;
			for (i = 0;
			     i < this.m_vertexCount; i++)
			{
				this.m_vertices[i].SetV(vertices[i]);
			}
			for (i = 0;
			     i < this.m_vertexCount; ++i)
			{
				var i1 = parseInt(i);
				var i2 = parseInt(i + 1 < this.m_vertexCount ? i + 1 : 0);
				var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
				b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
				this.m_normals[i].SetV(b2Math.CrossVF(edge, 1.0));
				this.m_normals[i].Normalize();
			}
			this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount);
		}
		b2PolygonShape.AsVector = function (vertices, vertexCount)
		{
			if (vertexCount === undefined) vertexCount = 0;
			var polygonShape = new b2PolygonShape();
			polygonShape.SetAsVector(vertices, vertexCount);
			return polygonShape;
		}
		b2PolygonShape.prototype.SetAsBox = function (hx, hy)
		{
			if (hx === undefined) hx = 0;
			if (hy === undefined) hy = 0;
			this.m_vertexCount = 4;
			this.Reserve(4);
			this.m_vertices[0].Set((-hx), (-hy));
			this.m_vertices[1].Set(hx, (-hy));
			this.m_vertices[2].Set(hx, hy);
			this.m_vertices[3].Set((-hx), hy);
			this.m_normals[0].Set(0.0, (-1.0));
			this.m_normals[1].Set(1.0, 0.0);
			this.m_normals[2].Set(0.0, 1.0);
			this.m_normals[3].Set((-1.0), 0.0);
			this.m_centroid.SetZero();
		}
		b2PolygonShape.AsBox = function (hx, hy)
		{
			if (hx === undefined) hx = 0;
			if (hy === undefined) hy = 0;
			var polygonShape = new b2PolygonShape();
			polygonShape.SetAsBox(hx, hy);
			return polygonShape;
		}
		b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle)
		{
			if (hx === undefined) hx = 0;
			if (hy === undefined) hy = 0;
			if (center === undefined) center = null;
			if (angle === undefined) angle = 0.0;
			this.m_vertexCount = 4;
			this.Reserve(4);
			this.m_vertices[0].Set((-hx), (-hy));
			this.m_vertices[1].Set(hx, (-hy));
			this.m_vertices[2].Set(hx, hy);
			this.m_vertices[3].Set((-hx), hy);
			this.m_normals[0].Set(0.0, (-1.0));
			this.m_normals[1].Set(1.0, 0.0);
			this.m_normals[2].Set(0.0, 1.0);
			this.m_normals[3].Set((-1.0), 0.0);
			this.m_centroid = center;
			var xf = new b2Transform();
			xf.position = center;
			xf.R.Set(angle);
			for (var i = 0; i < this.m_vertexCount; ++i)
			{
				this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
				this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i]);
			}
		}
		b2PolygonShape.AsOrientedBox = function (hx, hy, center, angle)
		{
			if (hx === undefined) hx = 0;
			if (hy === undefined) hy = 0;
			if (center === undefined) center = null;
			if (angle === undefined) angle = 0.0;
			var polygonShape = new b2PolygonShape();
			polygonShape.SetAsOrientedBox(hx, hy, center, angle);
			return polygonShape;
		}
		b2PolygonShape.prototype.SetAsEdge = function (v1, v2)
		{
			this.m_vertexCount = 2;
			this.Reserve(2);
			this.m_vertices[0].SetV(v1);
			this.m_vertices[1].SetV(v2);
			this.m_centroid.x = 0.5 * (v1.x + v2.x);
			this.m_centroid.y = 0.5 * (v1.y + v2.y);
			this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1.0);
			this.m_normals[0].Normalize();
			this.m_normals[1].x = (-this.m_normals[0].x);
			this.m_normals[1].y = (-this.m_normals[0].y);
		}
		b2PolygonShape.AsEdge = function (v1, v2)
		{
			var polygonShape = new b2PolygonShape();
			polygonShape.SetAsEdge(v1, v2);
			return polygonShape;
		}
		b2PolygonShape.prototype.TestPoint = function (xf, p)
		{
			var tVec;
			var tMat = xf.R;
			var tX = p.x - xf.position.x;
			var tY = p.y - xf.position.y;
			var pLocalX = (tX * tMat.col1.x + tY * tMat.col1.y);
			var pLocalY = (tX * tMat.col2.x + tY * tMat.col2.y);
			for (var i = 0; i < this.m_vertexCount; ++i)
			{
				tVec = this.m_vertices[i];
				tX = pLocalX - tVec.x;
				tY = pLocalY - tVec.y;
				tVec = this.m_normals[i];
				var dot = (tVec.x * tX + tVec.y * tY);
				if (dot > 0.0)
				{
					return false;
				}
			}
			return true;
		}
		b2PolygonShape.prototype.RayCast = function (output, input, transform)
		{
			var lower = 0.0;
			var upper = input.maxFraction;
			var tX = 0;
			var tY = 0;
			var tMat;
			var tVec;
			tX = input.p1.x - transform.position.x;
			tY = input.p1.y - transform.position.y;
			tMat = transform.R;
			var p1X = (tX * tMat.col1.x + tY * tMat.col1.y);
			var p1Y = (tX * tMat.col2.x + tY * tMat.col2.y);
			tX = input.p2.x - transform.position.x;
			tY = input.p2.y - transform.position.y;
			tMat = transform.R;
			var p2X = (tX * tMat.col1.x + tY * tMat.col1.y);
			var p2Y = (tX * tMat.col2.x + tY * tMat.col2.y);
			var dX = p2X - p1X;
			var dY = p2Y - p1Y;
			var index = parseInt((-1));
			for (var i = 0; i < this.m_vertexCount; ++i)
			{
				tVec = this.m_vertices[i];
				tX = tVec.x - p1X;
				tY = tVec.y - p1Y;
				tVec = this.m_normals[i];
				var numerator = (tVec.x * tX + tVec.y * tY);
				var denominator = (tVec.x * dX + tVec.y * dY);
				if (denominator == 0.0)
				{
					if (numerator < 0.0)
					{
						return false;
					}
				}
				else
				{
					if (denominator < 0.0 && numerator < lower * denominator)
					{
						lower = numerator / denominator;
						index = i;
					}
					else if (denominator > 0.0 && numerator < upper * denominator)
					{
						upper = numerator / denominator;
					}
				}
				if (upper < lower - Number.MIN_VALUE)
				{
					return false;
				}
			}
			if (index >= 0)
			{
				output.fraction = lower;
				tMat = transform.R;
				tVec = this.m_normals[index];
				output.normal.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				output.normal.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				return true;
			}
			return false;
		}
		b2PolygonShape.prototype.ComputeAABB = function (aabb, xf)
		{
			var tMat = xf.R;
			var tVec = this.m_vertices[0];
			var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			var upperX = lowerX;
			var upperY = lowerY;
			for (var i = 1; i < this.m_vertexCount; ++i)
			{
				tVec = this.m_vertices[i];
				var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
				var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
				lowerX = lowerX < vX ? lowerX : vX;
				lowerY = lowerY < vY ? lowerY : vY;
				upperX = upperX > vX ? upperX : vX;
				upperY = upperY > vY ? upperY : vY;
			}
			aabb.lowerBound.x = lowerX - this.m_radius;
			aabb.lowerBound.y = lowerY - this.m_radius;
			aabb.upperBound.x = upperX + this.m_radius;
			aabb.upperBound.y = upperY + this.m_radius;
		}
		b2PolygonShape.prototype.ComputeMass = function (massData, density)
		{
			if (density === undefined) density = 0;
			if (this.m_vertexCount == 2)
			{
				massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
				massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
				massData.mass = 0.0;
				massData.I = 0.0;
				return;
			}
			var centerX = 0.0;
			var centerY = 0.0;
			var area = 0.0;
			var I = 0.0;
			var p1X = 0.0;
			var p1Y = 0.0;
			var k_inv3 = 1.0 / 3.0;
			for (var i = 0; i < this.m_vertexCount; ++i)
			{
				var p2 = this.m_vertices[i];
				var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
				var e1X = p2.x - p1X;
				var e1Y = p2.y - p1Y;
				var e2X = p3.x - p1X;
				var e2Y = p3.y - p1Y;
				var D = e1X * e2Y - e1Y * e2X;
				var triangleArea = 0.5 * D;
				area += triangleArea;
				centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
				centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
				var px = p1X;
				var py = p1Y;
				var ex1 = e1X;
				var ey1 = e1Y;
				var ex2 = e2X;
				var ey2 = e2Y;
				var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
				var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;
				I += D * (intx2 + inty2);
			}
			massData.mass = density * area;
			centerX *= 1.0 / area;
			centerY *= 1.0 / area;
			massData.center.Set(centerX, centerY);
			massData.I = density * I;
		}
		b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c)
		{
			if (offset === undefined) offset = 0;
			var normalL = b2Math.MulTMV(xf.R, normal);
			var offsetL = offset - b2Math.Dot(normal, xf.position);
			var depths = new Vector_a2j_Number();
			var diveCount = 0;
			var intoIndex = parseInt((-1));
			var outoIndex = parseInt((-1));
			var lastSubmerged = false;
			var i = 0;
			for (i = 0;
			     i < this.m_vertexCount; ++i)
			{
				depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
				var isSubmerged = depths[i] < (-Number.MIN_VALUE);
				if (i > 0)
				{
					if (isSubmerged)
					{
						if (!lastSubmerged)
						{
							intoIndex = i - 1;
							diveCount++;
						}
					}
					else
					{
						if (lastSubmerged)
						{
							outoIndex = i - 1;
							diveCount++;
						}
					}
				}
				lastSubmerged = isSubmerged;
			}
			switch (diveCount)
			{
				case 0:
					if (lastSubmerged)
					{
						var md = new b2MassData();
						this.ComputeMass(md, 1);
						c.SetV(b2Math.MulX(xf, md.center));
						return md.mass;
					}
					else
					{
						return 0;
					}
					break;
				case 1:
					if (intoIndex == (-1))
					{
						intoIndex = this.m_vertexCount - 1;
					}
					else
					{
						outoIndex = this.m_vertexCount - 1;
					}
					break;
			}
			var intoIndex2 = parseInt((intoIndex + 1) % this.m_vertexCount);
			var outoIndex2 = parseInt((outoIndex + 1) % this.m_vertexCount);
			var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
			var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
			var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
			var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
			var area = 0;
			var center = new b2Vec2();
			var p2 = this.m_vertices[intoIndex2];
			var p3;
			i = intoIndex2;
			while (i != outoIndex2)
			{
				i = (i + 1) % this.m_vertexCount;
				if (i == outoIndex2) p3 = outoVec;
				else p3 = this.m_vertices[i];
				var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
				area += triangleArea;
				center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
				center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
				p2 = p3;
			}
			center.Multiply(1 / area);
			c.SetV(b2Math.MulX(xf, center));
			return area;
		}
		b2PolygonShape.prototype.GetVertexCount = function ()
		{
			return this.m_vertexCount;
		}
		b2PolygonShape.prototype.GetVertices = function ()
		{
			return this.m_vertices;
		}
		b2PolygonShape.prototype.GetNormals = function ()
		{
			return this.m_normals;
		}
		b2PolygonShape.prototype.GetSupport = function (d)
		{
			var bestIndex = 0;
			var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
			for (var i = 1; i < this.m_vertexCount; ++i)
			{
				var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
				if (value > bestValue)
				{
					bestIndex = i;
					bestValue = value;
				}
			}
			return bestIndex;
		}
		b2PolygonShape.prototype.GetSupportVertex = function (d)
		{
			var bestIndex = 0;
			var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
			for (var i = 1; i < this.m_vertexCount; ++i)
			{
				var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
				if (value > bestValue)
				{
					bestIndex = i;
					bestValue = value;
				}
			}
			return this.m_vertices[bestIndex];
		}
		b2PolygonShape.prototype.Validate = function ()
		{
			return false;
		}
		b2PolygonShape.prototype.b2PolygonShape = function ()
		{
			this.__super.b2Shape.call(this);
			this.m_type = b2Shape.e_polygonShape;
			this.m_centroid = new b2Vec2();
			this.m_vertices = new Vector();
			this.m_normals = new Vector();
		}
		b2PolygonShape.prototype.Reserve = function (count)
		{
			if (count === undefined) count = 0;
			for (var i = parseInt(this.m_vertices.length); i < count; i++)
			{
				this.m_vertices[i] = new b2Vec2();
				this.m_normals[i] = new b2Vec2();
			}
		}
		b2PolygonShape.ComputeCentroid = function (vs, count)
		{
			if (count === undefined) count = 0;
			var c = new b2Vec2();
			var area = 0.0;
			var p1X = 0.0;
			var p1Y = 0.0;
			var inv3 = 1.0 / 3.0;
			for (var i = 0; i < count; ++i)
			{
				var p2 = vs[i];
				var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
				var e1X = p2.x - p1X;
				var e1Y = p2.y - p1Y;
				var e2X = p3.x - p1X;
				var e2Y = p3.y - p1Y;
				var D = (e1X * e2Y - e1Y * e2X);
				var triangleArea = 0.5 * D;
				area += triangleArea;
				c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
				c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y);
			}
			c.x *= 1.0 / area;
			c.y *= 1.0 / area;
			return c;
		}
		b2PolygonShape.ComputeOBB = function (obb, vs, count)
		{
			if (count === undefined) count = 0;
			var i = 0;
			var p = new Vector(count + 1);
			for (i = 0;
			     i < count; ++i)
			{
				p[i] = vs[i];
			}
			p[count] = p[0];
			var minArea = Number.MAX_VALUE;
			for (i = 1;
			     i <= count; ++i)
			{
				var root = p[parseInt(i - 1)];
				var uxX = p[i].x - root.x;
				var uxY = p[i].y - root.y;
				var length = Math.sqrt(uxX * uxX + uxY * uxY);
				uxX /= length;
				uxY /= length;
				var uyX = (-uxY);
				var uyY = uxX;
				var lowerX = Number.MAX_VALUE;
				var lowerY = Number.MAX_VALUE;
				var upperX = (-Number.MAX_VALUE);
				var upperY = (-Number.MAX_VALUE);
				for (var j = 0; j < count; ++j)
				{
					var dX = p[j].x - root.x;
					var dY = p[j].y - root.y;
					var rX = (uxX * dX + uxY * dY);
					var rY = (uyX * dX + uyY * dY);
					if (rX < lowerX) lowerX = rX;
					if (rY < lowerY) lowerY = rY;
					if (rX > upperX) upperX = rX;
					if (rY > upperY) upperY = rY;
				}
				var area = (upperX - lowerX) * (upperY - lowerY);
				if (area < 0.95 * minArea)
				{
					minArea = area;
					obb.R.col1.x = uxX;
					obb.R.col1.y = uxY;
					obb.R.col2.x = uyX;
					obb.R.col2.y = uyY;
					var centerX = 0.5 * (lowerX + upperX);
					var centerY = 0.5 * (lowerY + upperY);
					var tMat = obb.R;
					obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
					obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
					obb.extents.x = 0.5 * (upperX - lowerX);
					obb.extents.y = 0.5 * (upperY - lowerY);
				}
			}
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Collision.Shapes.b2PolygonShape.s_mat = new b2Mat22();
		});
		b2Shape.b2Shape = function ()
		{
		};
		b2Shape.prototype.Copy = function ()
		{
			return null;
		}
		b2Shape.prototype.Set = function (other)
		{
			this.m_radius = other.m_radius;
		}
		b2Shape.prototype.GetType = function ()
		{
			return this.m_type;
		}
		b2Shape.prototype.TestPoint = function (xf, p)
		{
			return false;
		}
		b2Shape.prototype.RayCast = function (output, input, transform)
		{
			return false;
		}
		b2Shape.prototype.ComputeAABB = function (aabb, xf)
		{
		}
		b2Shape.prototype.ComputeMass = function (massData, density)
		{
			if (density === undefined) density = 0;
		}
		b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c)
		{
			if (offset === undefined) offset = 0;
			return 0;
		}
		b2Shape.TestOverlap = function (shape1, transform1, shape2, transform2)
		{
			var input = new b2DistanceInput();
			input.proxyA = new b2DistanceProxy();
			input.proxyA.Set(shape1);
			input.proxyB = new b2DistanceProxy();
			input.proxyB.Set(shape2);
			input.transformA = transform1;
			input.transformB = transform2;
			input.useRadii = true;
			var simplexCache = new b2SimplexCache();
			simplexCache.count = 0;
			var output = new b2DistanceOutput();
			b2Distance.Distance(output, simplexCache, input);
			return output.distance < 10.0 * Number.MIN_VALUE;
		}
		b2Shape.prototype.b2Shape = function ()
		{
			this.m_type = b2Shape.e_unknownShape;
			this.m_radius = b2Settings.b2_linearSlop;
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt((-1));
			Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
			Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1;
			Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2;
			Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
			Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
			Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
			Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt((-1));
		});
	})();
	(function ()
	{
		var b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3;

		b2Color.b2Color = function ()
		{
			this._r = 0;
			this._g = 0;
			this._b = 0;
		};
		b2Color.prototype.b2Color = function (rr, gg, bb)
		{
			if (rr === undefined) rr = 0;
			if (gg === undefined) gg = 0;
			if (bb === undefined) bb = 0;
			this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
			this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
			this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
		}
		b2Color.prototype.Set = function (rr, gg, bb)
		{
			if (rr === undefined) rr = 0;
			if (gg === undefined) gg = 0;
			if (bb === undefined) bb = 0;
			this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
			this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
			this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
		}
		Object.defineProperty(b2Color.prototype, 'r', {
			enumerable:   false,
			configurable: true,
			set:          function (rr)
			{
				if (rr === undefined) rr = 0;
				this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
			}
		});
		Object.defineProperty(b2Color.prototype, 'g', {
			enumerable:   false,
			configurable: true,
			set:          function (gg)
			{
				if (gg === undefined) gg = 0;
				this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
			}
		});
		Object.defineProperty(b2Color.prototype, 'b', {
			enumerable:   false,
			configurable: true,
			set:          function (bb)
			{
				if (bb === undefined) bb = 0;
				this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
			}
		});
		Object.defineProperty(b2Color.prototype, 'color', {
			enumerable:   false,
			configurable: true,
			get:          function ()
			{
				return (this._r << 16) | (this._g << 8) | (this._b);
			}
		});
		b2Settings.b2Settings = function ()
		{
		};
		b2Settings.b2MixFriction = function (friction1, friction2)
		{
			if (friction1 === undefined) friction1 = 0;
			if (friction2 === undefined) friction2 = 0;
			return Math.sqrt(friction1 * friction2);
		}
		b2Settings.b2MixRestitution = function (restitution1, restitution2)
		{
			if (restitution1 === undefined) restitution1 = 0;
			if (restitution2 === undefined) restitution2 = 0;
			return restitution1 > restitution2 ? restitution1 : restitution2;
		}
		b2Settings.b2Assert = function (a)
		{
			//      if (!a) {
			//         throw "Assertion Failed";
			//      }
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Common.b2Settings.VERSION = "2.1alpha";
			Box2D.Common.b2Settings.USHRT_MAX = 0x0000ffff;
			Box2D.Common.b2Settings.b2_pi = Math.PI;
			Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
			Box2D.Common.b2Settings.b2_aabbExtension = 0.1;
			Box2D.Common.b2Settings.b2_aabbMultiplier = 2.0;
			Box2D.Common.b2Settings.b2_polygonRadius = 2.0 * b2Settings.b2_linearSlop;
			Box2D.Common.b2Settings.b2_linearSlop = 0.005;
			Box2D.Common.b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi;
			Box2D.Common.b2Settings.b2_toiSlop = 8.0 * b2Settings.b2_linearSlop;
			Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
			Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
			Box2D.Common.b2Settings.b2_velocityThreshold = 1.0;
			Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;
			Box2D.Common.b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi;
			Box2D.Common.b2Settings.b2_maxTranslation = 2.0;
			Box2D.Common.b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
			Box2D.Common.b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
			Box2D.Common.b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
			Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2;
			Box2D.Common.b2Settings.b2_timeToSleep = 0.5;
			Box2D.Common.b2Settings.b2_linearSleepTolerance = 0.01;
			Box2D.Common.b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 * b2Settings.b2_pi;
		});
	})();
	(function ()
	{
		var b2AABB = Box2D.Collision.b2AABB,
			b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3;

		b2Mat22.b2Mat22 = function ()
		{
			this.col1 = new b2Vec2();
			this.col2 = new b2Vec2();
		};
		b2Mat22.prototype.b2Mat22 = function ()
		{
			this.SetIdentity();
		}
		b2Mat22.FromAngle = function (angle)
		{
			if (angle === undefined) angle = 0;
			var mat = new b2Mat22();
			mat.Set(angle);
			return mat;
		}
		b2Mat22.FromVV = function (c1, c2)
		{
			var mat = new b2Mat22();
			mat.SetVV(c1, c2);
			return mat;
		}
		b2Mat22.prototype.Set = function (angle)
		{
			if (angle === undefined) angle = 0;
			var c = Math.cos(angle);
			var s = Math.sin(angle);
			this.col1.x = c;
			this.col2.x = (-s);
			this.col1.y = s;
			this.col2.y = c;
		}
		b2Mat22.prototype.SetVV = function (c1, c2)
		{
			this.col1.SetV(c1);
			this.col2.SetV(c2);
		}
		b2Mat22.prototype.Copy = function ()
		{
			var mat = new b2Mat22();
			mat.SetM(this);
			return mat;
		}
		b2Mat22.prototype.SetM = function (m)
		{
			this.col1.SetV(m.col1);
			this.col2.SetV(m.col2);
		}
		b2Mat22.prototype.AddM = function (m)
		{
			this.col1.x += m.col1.x;
			this.col1.y += m.col1.y;
			this.col2.x += m.col2.x;
			this.col2.y += m.col2.y;
		}
		b2Mat22.prototype.SetIdentity = function ()
		{
			this.col1.x = 1.0;
			this.col2.x = 0.0;
			this.col1.y = 0.0;
			this.col2.y = 1.0;
		}
		b2Mat22.prototype.SetZero = function ()
		{
			this.col1.x = 0.0;
			this.col2.x = 0.0;
			this.col1.y = 0.0;
			this.col2.y = 0.0;
		}
		b2Mat22.prototype.GetAngle = function ()
		{
			return Math.atan2(this.col1.y, this.col1.x);
		}
		b2Mat22.prototype.GetInverse = function (out)
		{
			var a = this.col1.x;
			var b = this.col2.x;
			var c = this.col1.y;
			var d = this.col2.y;
			var det = a * d - b * c;
			if (det != 0.0)
			{
				det = 1.0 / det;
			}
			out.col1.x = det * d;
			out.col2.x = (-det * b);
			out.col1.y = (-det * c);
			out.col2.y = det * a;
			return out;
		}
		b2Mat22.prototype.Solve = function (out, bX, bY)
		{
			if (bX === undefined) bX = 0;
			if (bY === undefined) bY = 0;
			var a11 = this.col1.x;
			var a12 = this.col2.x;
			var a21 = this.col1.y;
			var a22 = this.col2.y;
			var det = a11 * a22 - a12 * a21;
			if (det != 0.0)
			{
				det = 1.0 / det;
			}
			out.x = det * (a22 * bX - a12 * bY);
			out.y = det * (a11 * bY - a21 * bX);
			return out;
		}
		b2Mat22.prototype.Abs = function ()
		{
			this.col1.Abs();
			this.col2.Abs();
		}
		b2Mat33.b2Mat33 = function ()
		{
			this.col1 = new b2Vec3();
			this.col2 = new b2Vec3();
			this.col3 = new b2Vec3();
		};
		b2Mat33.prototype.b2Mat33 = function (c1, c2, c3)
		{
			if (c1 === undefined) c1 = null;
			if (c2 === undefined) c2 = null;
			if (c3 === undefined) c3 = null;
			if (!c1 && !c2 && !c3)
			{
				this.col1.SetZero();
				this.col2.SetZero();
				this.col3.SetZero();
			}
			else
			{
				this.col1.SetV(c1);
				this.col2.SetV(c2);
				this.col3.SetV(c3);
			}
		}
		b2Mat33.prototype.SetVVV = function (c1, c2, c3)
		{
			this.col1.SetV(c1);
			this.col2.SetV(c2);
			this.col3.SetV(c3);
		}
		b2Mat33.prototype.Copy = function ()
		{
			return new b2Mat33(this.col1, this.col2, this.col3);
		}
		b2Mat33.prototype.SetM = function (m)
		{
			this.col1.SetV(m.col1);
			this.col2.SetV(m.col2);
			this.col3.SetV(m.col3);
		}
		b2Mat33.prototype.AddM = function (m)
		{
			this.col1.x += m.col1.x;
			this.col1.y += m.col1.y;
			this.col1.z += m.col1.z;
			this.col2.x += m.col2.x;
			this.col2.y += m.col2.y;
			this.col2.z += m.col2.z;
			this.col3.x += m.col3.x;
			this.col3.y += m.col3.y;
			this.col3.z += m.col3.z;
		}
		b2Mat33.prototype.SetIdentity = function ()
		{
			this.col1.x = 1.0;
			this.col2.x = 0.0;
			this.col3.x = 0.0;
			this.col1.y = 0.0;
			this.col2.y = 1.0;
			this.col3.y = 0.0;
			this.col1.z = 0.0;
			this.col2.z = 0.0;
			this.col3.z = 1.0;
		}
		b2Mat33.prototype.SetZero = function ()
		{
			this.col1.x = 0.0;
			this.col2.x = 0.0;
			this.col3.x = 0.0;
			this.col1.y = 0.0;
			this.col2.y = 0.0;
			this.col3.y = 0.0;
			this.col1.z = 0.0;
			this.col2.z = 0.0;
			this.col3.z = 0.0;
		}
		b2Mat33.prototype.Solve22 = function (out, bX, bY)
		{
			if (bX === undefined) bX = 0;
			if (bY === undefined) bY = 0;
			var a11 = this.col1.x;
			var a12 = this.col2.x;
			var a21 = this.col1.y;
			var a22 = this.col2.y;
			var det = a11 * a22 - a12 * a21;
			if (det != 0.0)
			{
				det = 1.0 / det;
			}
			out.x = det * (a22 * bX - a12 * bY);
			out.y = det * (a11 * bY - a21 * bX);
			return out;
		}
		b2Mat33.prototype.Solve33 = function (out, bX, bY, bZ)
		{
			if (bX === undefined) bX = 0;
			if (bY === undefined) bY = 0;
			if (bZ === undefined) bZ = 0;
			var a11 = this.col1.x;
			var a21 = this.col1.y;
			var a31 = this.col1.z;
			var a12 = this.col2.x;
			var a22 = this.col2.y;
			var a32 = this.col2.z;
			var a13 = this.col3.x;
			var a23 = this.col3.y;
			var a33 = this.col3.z;
			var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
			if (det != 0.0)
			{
				det = 1.0 / det;
			}
			out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
			out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
			out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
			return out;
		}
		b2Math.b2Math = function ()
		{
		};
		b2Math.IsValid = function (x)
		{
			if (x === undefined) x = 0;
			return isFinite(x);
		}
		b2Math.Dot = function (a, b)
		{
			return a.x * b.x + a.y * b.y;
		}
		b2Math.CrossVV = function (a, b)
		{
			return a.x * b.y - a.y * b.x;
		}
		b2Math.CrossVF = function (a, s)
		{
			if (s === undefined) s = 0;
			var v = new b2Vec2(s * a.y, (-s * a.x));
			return v;
		}
		b2Math.CrossFV = function (s, a)
		{
			if (s === undefined) s = 0;
			var v = new b2Vec2((-s * a.y), s * a.x);
			return v;
		}
		b2Math.MulMV = function (A, v)
		{
			var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
			return u;
		}
		b2Math.MulTMV = function (A, v)
		{
			var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
			return u;
		}
		b2Math.MulX = function (T, v)
		{
			var a = b2Math.MulMV(T.R, v);
			a.x += T.position.x;
			a.y += T.position.y;
			return a;
		}
		b2Math.MulXT = function (T, v)
		{
			var a = b2Math.SubtractVV(v, T.position);
			var tX = (a.x * T.R.col1.x + a.y * T.R.col1.y);
			a.y = (a.x * T.R.col2.x + a.y * T.R.col2.y);
			a.x = tX;
			return a;
		}
		b2Math.AddVV = function (a, b)
		{
			var v = new b2Vec2(a.x + b.x, a.y + b.y);
			return v;
		}
		b2Math.SubtractVV = function (a, b)
		{
			var v = new b2Vec2(a.x - b.x, a.y - b.y);
			return v;
		}
		b2Math.Distance = function (a, b)
		{
			var cX = a.x - b.x;
			var cY = a.y - b.y;
			return Math.sqrt(cX * cX + cY * cY);
		}
		b2Math.DistanceSquared = function (a, b)
		{
			var cX = a.x - b.x;
			var cY = a.y - b.y;
			return (cX * cX + cY * cY);
		}
		b2Math.MulFV = function (s, a)
		{
			if (s === undefined) s = 0;
			var v = new b2Vec2(s * a.x, s * a.y);
			return v;
		}
		b2Math.AddMM = function (A, B)
		{
			var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
			return C;
		}
		b2Math.MulMM = function (A, B)
		{
			var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
			return C;
		}
		b2Math.MulTMM = function (A, B)
		{
			var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
			var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
			var C = b2Mat22.FromVV(c1, c2);
			return C;
		}
		b2Math.Abs = function (a)
		{
			if (a === undefined) a = 0;
			return a > 0.0 ? a : (-a);
		}
		b2Math.AbsV = function (a)
		{
			var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
			return b;
		}
		b2Math.AbsM = function (A)
		{
			var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
			return B;
		}
		b2Math.Min = function (a, b)
		{
			if (a === undefined) a = 0;
			if (b === undefined) b = 0;
			return a < b ? a : b;
		}
		b2Math.MinV = function (a, b)
		{
			var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
			return c;
		}
		b2Math.Max = function (a, b)
		{
			if (a === undefined) a = 0;
			if (b === undefined) b = 0;
			return a > b ? a : b;
		}
		b2Math.MaxV = function (a, b)
		{
			var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
			return c;
		}
		b2Math.Clamp = function (a, low, high)
		{
			if (a === undefined) a = 0;
			if (low === undefined) low = 0;
			if (high === undefined) high = 0;
			return a < low ? low : a > high ? high : a;
		}
		b2Math.ClampV = function (a, low, high)
		{
			return b2Math.MaxV(low, b2Math.MinV(a, high));
		}
		b2Math.Swap = function (a, b)
		{
			var tmp = a[0];
			a[0] = b[0];
			b[0] = tmp;
		}
		b2Math.Random = function ()
		{
			return Math.random() * 2 - 1;
		}
		b2Math.RandomRange = function (lo, hi)
		{
			if (lo === undefined) lo = 0;
			if (hi === undefined) hi = 0;
			var r = Math.random();
			r = (hi - lo) * r + lo;
			return r;
		}
		b2Math.NextPowerOfTwo = function (x)
		{
			if (x === undefined) x = 0;
			x |= (x >> 1) & 0x7FFFFFFF;
			x |= (x >> 2) & 0x3FFFFFFF;
			x |= (x >> 4) & 0x0FFFFFFF;
			x |= (x >> 8) & 0x00FFFFFF;
			x |= (x >> 16) & 0x0000FFFF;
			return x + 1;
		}
		b2Math.IsPowerOfTwo = function (x)
		{
			if (x === undefined) x = 0;
			var result = x > 0 && (x & (x - 1)) == 0;
			return result;
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Common.Math.b2Math.b2Vec2_zero = new b2Vec2(0.0, 0.0);
			Box2D.Common.Math.b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1.0, 0.0), new b2Vec2(0.0, 1.0));
			Box2D.Common.Math.b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);
		});
		b2Sweep.b2Sweep = function ()
		{
			this.localCenter = new b2Vec2();
			this.c0 = new b2Vec2;
			this.c = new b2Vec2();
		};
		b2Sweep.prototype.Set = function (other)
		{
			this.localCenter.SetV(other.localCenter);
			this.c0.SetV(other.c0);
			this.c.SetV(other.c);
			this.a0 = other.a0;
			this.a = other.a;
			this.t0 = other.t0;
		}
		b2Sweep.prototype.Copy = function ()
		{
			var copy = new b2Sweep();
			copy.localCenter.SetV(this.localCenter);
			copy.c0.SetV(this.c0);
			copy.c.SetV(this.c);
			copy.a0 = this.a0;
			copy.a = this.a;
			copy.t0 = this.t0;
			return copy;
		}
		b2Sweep.prototype.GetTransform = function (xf, alpha)
		{
			if (alpha === undefined) alpha = 0;
			xf.position.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
			xf.position.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
			var angle = (1.0 - alpha) * this.a0 + alpha * this.a;
			xf.R.Set(angle);
			var tMat = xf.R;
			xf.position.x -= (tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y);
			xf.position.y -= (tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y);
		}
		b2Sweep.prototype.Advance = function (t)
		{
			if (t === undefined) t = 0;
			if (this.t0 < t && 1.0 - this.t0 > Number.MIN_VALUE)
			{
				var alpha = (t - this.t0) / (1.0 - this.t0);
				this.c0.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
				this.c0.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
				this.a0 = (1.0 - alpha) * this.a0 + alpha * this.a;
				this.t0 = t;
			}
		}
		b2Transform.b2Transform = function ()
		{
			this.position = new b2Vec2;
			this.R = new b2Mat22();
		};
		b2Transform.prototype.b2Transform = function (pos, r)
		{
			if (pos === undefined) pos = null;
			if (r === undefined) r = null;
			if (pos)
			{
				this.position.SetV(pos);
				this.R.SetM(r);
			}
		}
		b2Transform.prototype.Initialize = function (pos, r)
		{
			this.position.SetV(pos);
			this.R.SetM(r);
		}
		b2Transform.prototype.SetIdentity = function ()
		{
			this.position.SetZero();
			this.R.SetIdentity();
		}
		b2Transform.prototype.Set = function (x)
		{
			this.position.SetV(x.position);
			this.R.SetM(x.R);
		}
		b2Transform.prototype.GetAngle = function ()
		{
			return Math.atan2(this.R.col1.y, this.R.col1.x);
		}
		b2Vec2.b2Vec2 = function ()
		{
		};
		b2Vec2.prototype.b2Vec2 = function (x_, y_)
		{
			if (x_ === undefined) x_ = 0;
			if (y_ === undefined) y_ = 0;
			this.x = x_;
			this.y = y_;
		}
		b2Vec2.prototype.SetZero = function ()
		{
			this.x = 0.0;
			this.y = 0.0;
		}
		b2Vec2.prototype.Set = function (x_, y_)
		{
			if (x_ === undefined) x_ = 0;
			if (y_ === undefined) y_ = 0;
			this.x = x_;
			this.y = y_;
		}
		b2Vec2.prototype.SetV = function (v)
		{
			this.x = v.x;
			this.y = v.y;
		}
		b2Vec2.prototype.GetNegative = function ()
		{
			return new b2Vec2((-this.x), (-this.y));
		}
		b2Vec2.prototype.NegativeSelf = function ()
		{
			this.x = (-this.x);
			this.y = (-this.y);
		}
		b2Vec2.Make = function (x_, y_)
		{
			if (x_ === undefined) x_ = 0;
			if (y_ === undefined) y_ = 0;
			return new b2Vec2(x_, y_);
		}
		b2Vec2.prototype.Copy = function ()
		{
			return new b2Vec2(this.x, this.y);
		}
		b2Vec2.prototype.Add = function (v)
		{
			this.x += v.x;
			this.y += v.y;
		}
		b2Vec2.prototype.Subtract = function (v)
		{
			this.x -= v.x;
			this.y -= v.y;
		}
		b2Vec2.prototype.Multiply = function (a)
		{
			if (a === undefined) a = 0;
			this.x *= a;
			this.y *= a;
		}
		b2Vec2.prototype.MulM = function (A)
		{
			var tX = this.x;
			this.x = A.col1.x * tX + A.col2.x * this.y;
			this.y = A.col1.y * tX + A.col2.y * this.y;
		}
		b2Vec2.prototype.MulTM = function (A)
		{
			var tX = b2Math.Dot(this, A.col1);
			this.y = b2Math.Dot(this, A.col2);
			this.x = tX;
		}
		b2Vec2.prototype.CrossVF = function (s)
		{
			if (s === undefined) s = 0;
			var tX = this.x;
			this.x = s * this.y;
			this.y = (-s * tX);
		}
		b2Vec2.prototype.CrossFV = function (s)
		{
			if (s === undefined) s = 0;
			var tX = this.x;
			this.x = (-s * this.y);
			this.y = s * tX;
		}
		b2Vec2.prototype.MinV = function (b)
		{
			this.x = this.x < b.x ? this.x : b.x;
			this.y = this.y < b.y ? this.y : b.y;
		}
		b2Vec2.prototype.MaxV = function (b)
		{
			this.x = this.x > b.x ? this.x : b.x;
			this.y = this.y > b.y ? this.y : b.y;
		}
		b2Vec2.prototype.Abs = function ()
		{
			if (this.x < 0) this.x = (-this.x);
			if (this.y < 0) this.y = (-this.y);
		}
		b2Vec2.prototype.Length = function ()
		{
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}
		b2Vec2.prototype.LengthSquared = function ()
		{
			return (this.x * this.x + this.y * this.y);
		}
		b2Vec2.prototype.Normalize = function ()
		{
			var length = Math.sqrt(this.x * this.x + this.y * this.y);
			if (length < Number.MIN_VALUE)
			{
				return 0.0;
			}
			var invLength = 1.0 / length;
			this.x *= invLength;
			this.y *= invLength;
			return length;
		}
		b2Vec2.prototype.IsValid = function ()
		{
			return b2Math.IsValid(this.x) && b2Math.IsValid(this.y);
		}
		b2Vec3.b2Vec3 = function ()
		{
		};
		b2Vec3.prototype.b2Vec3 = function (x, y, z)
		{
			if (x === undefined) x = 0;
			if (y === undefined) y = 0;
			if (z === undefined) z = 0;
			this.x = x;
			this.y = y;
			this.z = z;
		}
		b2Vec3.prototype.SetZero = function ()
		{
			this.x = this.y = this.z = 0.0;
		}
		b2Vec3.prototype.Set = function (x, y, z)
		{
			if (x === undefined) x = 0;
			if (y === undefined) y = 0;
			if (z === undefined) z = 0;
			this.x = x;
			this.y = y;
			this.z = z;
		}
		b2Vec3.prototype.SetV = function (v)
		{
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
		}
		b2Vec3.prototype.GetNegative = function ()
		{
			return new b2Vec3((-this.x), (-this.y), (-this.z));
		}
		b2Vec3.prototype.NegativeSelf = function ()
		{
			this.x = (-this.x);
			this.y = (-this.y);
			this.z = (-this.z);
		}
		b2Vec3.prototype.Copy = function ()
		{
			return new b2Vec3(this.x, this.y, this.z);
		}
		b2Vec3.prototype.Add = function (v)
		{
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
		}
		b2Vec3.prototype.Subtract = function (v)
		{
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
		}
		b2Vec3.prototype.Multiply = function (a)
		{
			if (a === undefined) a = 0;
			this.x *= a;
			this.y *= a;
			this.z *= a;
		}
	})();
	(function ()
	{
		var b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3,
			b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2AABB = Box2D.Collision.b2AABB,
			b2Bound = Box2D.Collision.b2Bound,
			b2BoundValues = Box2D.Collision.b2BoundValues,
			b2Collision = Box2D.Collision.b2Collision,
			b2ContactID = Box2D.Collision.b2ContactID,
			b2ContactPoint = Box2D.Collision.b2ContactPoint,
			b2Distance = Box2D.Collision.b2Distance,
			b2DistanceInput = Box2D.Collision.b2DistanceInput,
			b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
			b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
			b2DynamicTree = Box2D.Collision.b2DynamicTree,
			b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
			b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
			b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
			b2Manifold = Box2D.Collision.b2Manifold,
			b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
			b2Point = Box2D.Collision.b2Point,
			b2RayCastInput = Box2D.Collision.b2RayCastInput,
			b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
			b2Segment = Box2D.Collision.b2Segment,
			b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
			b2Simplex = Box2D.Collision.b2Simplex,
			b2SimplexCache = Box2D.Collision.b2SimplexCache,
			b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
			b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
			b2TOIInput = Box2D.Collision.b2TOIInput,
			b2WorldManifold = Box2D.Collision.b2WorldManifold,
			ClipVertex = Box2D.Collision.ClipVertex,
			Features = Box2D.Collision.Features,
			IBroadPhase = Box2D.Collision.IBroadPhase,
			b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
			b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
			b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
			b2MassData = Box2D.Collision.Shapes.b2MassData,
			b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
			b2Shape = Box2D.Collision.Shapes.b2Shape,
			b2Body = Box2D.Dynamics.b2Body,
			b2BodyDef = Box2D.Dynamics.b2BodyDef,
			b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
			b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
			b2ContactListener = Box2D.Dynamics.b2ContactListener,
			b2ContactManager = Box2D.Dynamics.b2ContactManager,
			b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
			b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
			b2FilterData = Box2D.Dynamics.b2FilterData,
			b2Fixture = Box2D.Dynamics.b2Fixture,
			b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
			b2Island = Box2D.Dynamics.b2Island,
			b2TimeStep = Box2D.Dynamics.b2TimeStep,
			b2World = Box2D.Dynamics.b2World,
			b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
			b2Contact = Box2D.Dynamics.Contacts.b2Contact,
			b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
			b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
			b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
			b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
			b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
			b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
			b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
			b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
			b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
			b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
			b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
			b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
			b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
			b2Controller = Box2D.Dynamics.Controllers.b2Controller,
			b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
			b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
			b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
			b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
			b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
			b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
			b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
			b2Joint = Box2D.Dynamics.Joints.b2Joint,
			b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
			b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
			b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
			b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
			b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
			b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
			b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
			b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
			b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
			b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
			b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
			b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
			b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
			b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;

		b2Body.b2Body = function ()
		{
			this.m_xf = new b2Transform();
			this.m_sweep = new b2Sweep();
			this.m_linearVelocity = new b2Vec2();
			this.m_force = new b2Vec2();
		};
		b2Body.prototype.connectEdges = function (s1, s2, angle1)
		{
			if (angle1 === undefined) angle1 = 0;
			var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
			var coreOffset = Math.tan((angle2 - angle1) * 0.5);
			var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
			core = b2Math.SubtractVV(core, s2.GetNormalVector());
			core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
			core = b2Math.AddVV(core, s2.GetVertex1());
			var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
			cornerDir.Normalize();
			var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0;
			s1.SetNextEdge(s2, core, cornerDir, convex);
			s2.SetPrevEdge(s1, core, cornerDir, convex);
			return angle2;
		}
		b2Body.prototype.CreateFixture = function (def)
		{
			if (this.m_world.IsLocked() == true)
			{
				return null;
			}
			var fixture = new b2Fixture();
			fixture.Create(this, this.m_xf, def);
			if (this.m_flags & b2Body.e_activeFlag)
			{
				var broadPhase = this.m_world.m_contactManager.m_broadPhase;
				fixture.CreateProxy(broadPhase, this.m_xf);
			}
			fixture.m_next = this.m_fixtureList;
			this.m_fixtureList = fixture;
			++this.m_fixtureCount;
			fixture.m_body = this;
			if (fixture.m_density > 0.0)
			{
				this.ResetMassData();
			}
			this.m_world.m_flags |= b2World.e_newFixture;
			return fixture;
		}
		b2Body.prototype.CreateFixture2 = function (shape, density)
		{
			if (density === undefined) density = 0.0;
			var def = new b2FixtureDef();
			def.shape = shape;
			def.density = density;
			return this.CreateFixture(def);
		}
		b2Body.prototype.DestroyFixture = function (fixture)
		{
			if (this.m_world.IsLocked() == true)
			{
				return;
			}
			var node = this.m_fixtureList;
			var ppF = null;
			var found = false;
			while (node != null)
			{
				if (node == fixture)
				{
					if (ppF) ppF.m_next = fixture.m_next;
					else this.m_fixtureList = fixture.m_next;
					found = true;
					break;
				}
				ppF = node;
				node = node.m_next;
			}
			var edge = this.m_contactList;
			while (edge)
			{
				var c = edge.contact;
				edge = edge.next;
				var fixtureA = c.GetFixtureA();
				var fixtureB = c.GetFixtureB();
				if (fixture == fixtureA || fixture == fixtureB)
				{
					this.m_world.m_contactManager.Destroy(c);
				}
			}
			if (this.m_flags & b2Body.e_activeFlag)
			{
				var broadPhase = this.m_world.m_contactManager.m_broadPhase;
				fixture.DestroyProxy(broadPhase);
			}
			else
			{
			}
			fixture.Destroy();
			fixture.m_body = null;
			fixture.m_next = null;
			--this.m_fixtureCount;
			this.ResetMassData();
		}
		b2Body.prototype.SetPositionAndAngle = function (position, angle)
		{
			if (angle === undefined) angle = 0;
			var f;
			if (this.m_world.IsLocked() == true)
			{
				return;
			}
			this.m_xf.R.Set(angle);
			this.m_xf.position.SetV(position);
			var tMat = this.m_xf.R;
			var tVec = this.m_sweep.localCenter;
			this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			this.m_sweep.c.x += this.m_xf.position.x;
			this.m_sweep.c.y += this.m_xf.position.y;
			this.m_sweep.c0.SetV(this.m_sweep.c);
			this.m_sweep.a0 = this.m_sweep.a = angle;
			var broadPhase = this.m_world.m_contactManager.m_broadPhase;
			for (f = this.m_fixtureList;
			     f; f = f.m_next)
			{
				f.Synchronize(broadPhase, this.m_xf, this.m_xf);
			}
			this.m_world.m_contactManager.FindNewContacts();
		}
		b2Body.prototype.SetTransform = function (xf)
		{
			this.SetPositionAndAngle(xf.position, xf.GetAngle());
		}
		b2Body.prototype.GetTransform = function ()
		{
			return this.m_xf;
		}
		b2Body.prototype.GetPosition = function ()
		{
			return this.m_xf.position;
		}
		b2Body.prototype.SetPosition = function (position)
		{
			this.SetPositionAndAngle(position, this.GetAngle());
		}
		b2Body.prototype.GetAngle = function ()
		{
			return this.m_sweep.a;
		}
		b2Body.prototype.SetAngle = function (angle)
		{
			if (angle === undefined) angle = 0;
			this.SetPositionAndAngle(this.GetPosition(), angle);
		}
		b2Body.prototype.GetWorldCenter = function ()
		{
			return this.m_sweep.c;
		}
		b2Body.prototype.GetLocalCenter = function ()
		{
			return this.m_sweep.localCenter;
		}
		b2Body.prototype.SetLinearVelocity = function (v)
		{
			if (this.m_type == b2Body.b2_staticBody)
			{
				return;
			}
			this.m_linearVelocity.SetV(v);
		}
		b2Body.prototype.GetLinearVelocity = function ()
		{
			return this.m_linearVelocity;
		}
		b2Body.prototype.SetAngularVelocity = function (omega)
		{
			if (omega === undefined) omega = 0;
			if (this.m_type == b2Body.b2_staticBody)
			{
				return;
			}
			this.m_angularVelocity = omega;
		}
		b2Body.prototype.GetAngularVelocity = function ()
		{
			return this.m_angularVelocity;
		}
		b2Body.prototype.GetDefinition = function ()
		{
			var bd = new b2BodyDef();
			bd.type = this.GetType();
			bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
			bd.angle = this.GetAngle();
			bd.angularDamping = this.m_angularDamping;
			bd.angularVelocity = this.m_angularVelocity;
			bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
			bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
			bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
			bd.linearDamping = this.m_linearDamping;
			bd.linearVelocity.SetV(this.GetLinearVelocity());
			bd.position = this.GetPosition();
			bd.userData = this.GetUserData();
			return bd;
		}
		b2Body.prototype.ApplyForce = function (force, point)
		{
			if (this.m_type != b2Body.b2_dynamicBody)
			{
				return;
			}
			if (this.IsAwake() == false)
			{
				this.SetAwake(true);
			}
			this.m_force.x += force.x;
			this.m_force.y += force.y;
			// FRANCOIS
			// this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
		}
		b2Body.prototype.ResetForce = function ()
		{
			if (this.m_type != b2Body.b2_dynamicBody)
			{
				return;
			}
			if (this.IsAwake() == false)
			{
				this.SetAwake(true);
			}
			this.m_force.x = 0;
			this.m_force.y = 0;
			// FRANCOIS
			// this.m_torque = 0;
		}
		b2Body.prototype.ApplyTorque = function (torque)
		{
			if (torque === undefined) torque = 0;
			if (this.m_type != b2Body.b2_dynamicBody)
			{
				return;
			}
			if (this.IsAwake() == false)
			{
				this.SetAwake(true);
			}
			this.m_torque += torque;
		}
		b2Body.prototype.ResetTorque = function ()
		{
			if (this.m_type != b2Body.b2_dynamicBody)
			{
				return;
			}
			if (this.IsAwake() == false)
			{
				this.SetAwake(true);
			}
			this.m_torque = 0;
		}
		b2Body.prototype.ApplyImpulse = function (impulse, point)
		{
			if (this.m_type != b2Body.b2_dynamicBody)
			{
				return;
			}
			if (this.IsAwake() == false)
			{
				this.SetAwake(true);
			}
			this.m_linearVelocity.x += this.m_invMass * impulse.x;
			this.m_linearVelocity.y += this.m_invMass * impulse.y;
			this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
		}
		b2Body.prototype.Split = function (callback)
		{
			var linearVelocity = this.GetLinearVelocity().Copy();
			var angularVelocity = this.GetAngularVelocity();
			var center = this.GetWorldCenter();
			var body1 = this;
			var body2 = this.m_world.CreateBody(this.GetDefinition());
			var prev;
			for (var f = body1.m_fixtureList; f;)
			{
				if (callback(f))
				{
					var next = f.m_next;
					if (prev)
					{
						prev.m_next = next;
					}
					else
					{
						body1.m_fixtureList = next;
					}
					body1.m_fixtureCount--;
					f.m_next = body2.m_fixtureList;
					body2.m_fixtureList = f;
					body2.m_fixtureCount++;
					f.m_body = body2;
					f = next;
				}
				else
				{
					prev = f;
					f = f.m_next;
				}
			}
			body1.ResetMassData();
			body2.ResetMassData();
			var center1 = body1.GetWorldCenter();
			var center2 = body2.GetWorldCenter();
			var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
			var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
			body1.SetLinearVelocity(velocity1);
			body2.SetLinearVelocity(velocity2);
			body1.SetAngularVelocity(angularVelocity);
			body2.SetAngularVelocity(angularVelocity);
			body1.SynchronizeFixtures();
			body2.SynchronizeFixtures();
			return body2;
		}
		b2Body.prototype.Merge = function (other)
		{
			var f;
			for (f = other.m_fixtureList;
			     f;)
			{
				var next = f.m_next;
				other.m_fixtureCount--;
				f.m_next = this.m_fixtureList;
				this.m_fixtureList = f;
				this.m_fixtureCount++;
				f.m_body = body2;
				f = next;
			}
			body1.m_fixtureCount = 0;
			var body1 = this;
			var body2 = other;
			var center1 = body1.GetWorldCenter();
			var center2 = body2.GetWorldCenter();
			var velocity1 = body1.GetLinearVelocity().Copy();
			var velocity2 = body2.GetLinearVelocity().Copy();
			var angular1 = body1.GetAngularVelocity();
			var angular = body2.GetAngularVelocity();
			body1.ResetMassData();
			this.SynchronizeFixtures();
		}
		b2Body.prototype.GetMass = function ()
		{
			return this.m_mass;
		}
		b2Body.prototype.GetInertia = function ()
		{
			return this.m_I;
		}
		b2Body.prototype.GetMassData = function (data)
		{
			data.mass = this.m_mass;
			data.I = this.m_I;
			data.center.SetV(this.m_sweep.localCenter);
		}
		b2Body.prototype.SetMassData = function (massData)
		{
			b2Settings.b2Assert(this.m_world.IsLocked() == false);
			if (this.m_world.IsLocked() == true)
			{
				return;
			}
			if (this.m_type != b2Body.b2_dynamicBody)
			{
				return;
			}
			this.m_invMass = 0.0;
			this.m_I = 0.0;
			this.m_invI = 0.0;
			this.m_mass = massData.mass;
			if (this.m_mass <= 0.0)
			{
				this.m_mass = 1.0;
			}
			this.m_invMass = 1.0 / this.m_mass;
			if (massData.I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0)
			{
				this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
				this.m_invI = 1.0 / this.m_I;
			}
			var oldCenter = this.m_sweep.c.Copy();
			this.m_sweep.localCenter.SetV(massData.center);
			this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
			this.m_sweep.c.SetV(this.m_sweep.c0);
			this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
			this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
		}
		b2Body.prototype.ResetMassData = function ()
		{
			this.m_mass = 0.0;
			this.m_invMass = 0.0;
			this.m_I = 0.0;
			this.m_invI = 0.0;
			this.m_sweep.localCenter.SetZero();
			if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody)
			{
				return;
			}
			var center = b2Vec2.Make(0, 0);
			for (var f = this.m_fixtureList; f; f = f.m_next)
			{
				if (f.m_density == 0.0)
				{
					continue;
				}
				var massData = f.GetMassData();
				this.m_mass += massData.mass;
				center.x += massData.center.x * massData.mass;
				center.y += massData.center.y * massData.mass;
				this.m_I += massData.I;
			}
			if (this.m_mass > 0.0)
			{
				this.m_invMass = 1.0 / this.m_mass;
				center.x *= this.m_invMass;
				center.y *= this.m_invMass;
			}
			else
			{
				this.m_mass = 1.0;
				this.m_invMass = 1.0;
			}
			if (this.m_I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0)
			{
				this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
				this.m_I *= this.m_inertiaScale;
				b2Settings.b2Assert(this.m_I > 0);
				this.m_invI = 1.0 / this.m_I;
			}
			else
			{
				this.m_I = 0.0;
				this.m_invI = 0.0;
			}
			var oldCenter = this.m_sweep.c.Copy();
			this.m_sweep.localCenter.SetV(center);
			this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
			this.m_sweep.c.SetV(this.m_sweep.c0);
			this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
			this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
		}
		b2Body.prototype.GetWorldPoint = function (localPoint)
		{
			var A = this.m_xf.R;
			var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
			u.x += this.m_xf.position.x;
			u.y += this.m_xf.position.y;
			return u;
		}
		b2Body.prototype.GetWorldVector = function (localVector)
		{
			return b2Math.MulMV(this.m_xf.R, localVector);
		}
		b2Body.prototype.GetLocalPoint = function (worldPoint)
		{
			return b2Math.MulXT(this.m_xf, worldPoint);
		}
		b2Body.prototype.GetLocalVector = function (worldVector)
		{
			return b2Math.MulTMV(this.m_xf.R, worldVector);
		}
		b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint)
		{
			return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
		}
		b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint)
		{
			var A = this.m_xf.R;
			var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
			worldPoint.x += this.m_xf.position.x;
			worldPoint.y += this.m_xf.position.y;
			return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
		}
		b2Body.prototype.GetLinearDamping = function ()
		{
			return this.m_linearDamping;
		}
		b2Body.prototype.SetLinearDamping = function (linearDamping)
		{
			if (linearDamping === undefined) linearDamping = 0;
			this.m_linearDamping = linearDamping;
		}
		b2Body.prototype.GetAngularDamping = function ()
		{
			return this.m_angularDamping;
		}
		b2Body.prototype.SetAngularDamping = function (angularDamping)
		{
			if (angularDamping === undefined) angularDamping = 0;
			this.m_angularDamping = angularDamping;
		}
		b2Body.prototype.SetType = function (type)
		{
			if (type === undefined) type = 0;
			if (this.m_type == type)
			{
				return;
			}
			this.m_type = type;
			this.ResetMassData();
			if (this.m_type == b2Body.b2_staticBody)
			{
				this.m_linearVelocity.SetZero();
				this.m_angularVelocity = 0.0;
			}
			this.SetAwake(true);
			this.m_force.SetZero();
			this.m_torque = 0.0;
			for (var ce = this.m_contactList; ce; ce = ce.next)
			{
				ce.contact.FlagForFiltering();
			}
		}
		b2Body.prototype.GetType = function ()
		{
			return this.m_type;
		}
		b2Body.prototype.SetBullet = function (flag)
		{
			if (flag)
			{
				this.m_flags |= b2Body.e_bulletFlag;
			}
			else
			{
				this.m_flags &= ~b2Body.e_bulletFlag;
			}
		}
		b2Body.prototype.IsBullet = function ()
		{
			return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
		}
		b2Body.prototype.SetSleepingAllowed = function (flag)
		{
			if (flag)
			{
				this.m_flags |= b2Body.e_allowSleepFlag;
			}
			else
			{
				this.m_flags &= ~b2Body.e_allowSleepFlag;
				this.SetAwake(true);
			}
		}
		b2Body.prototype.SetAwake = function (flag)
		{
			if (flag)
			{
				this.m_flags |= b2Body.e_awakeFlag;
				this.m_sleepTime = 0.0;
			}
			else
			{
				this.m_flags &= ~b2Body.e_awakeFlag;
				this.m_sleepTime = 0.0;
				this.m_linearVelocity.SetZero();
				this.m_angularVelocity = 0.0;
				this.m_force.SetZero();
				this.m_torque = 0.0;
			}
		}
		b2Body.prototype.IsAwake = function ()
		{
			return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
		}
		b2Body.prototype.SetFixedRotation = function (fixed)
		{
			if (fixed)
			{
				this.m_flags |= b2Body.e_fixedRotationFlag;
			}
			else
			{
				this.m_flags &= ~b2Body.e_fixedRotationFlag;
			}
			this.ResetMassData();
		}
		b2Body.prototype.IsFixedRotation = function ()
		{
			return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
		}
		b2Body.prototype.SetActive = function (flag)
		{
			if (flag == this.IsActive())
			{
				return;
			}
			var broadPhase;
			var f;
			if (flag)
			{
				this.m_flags |= b2Body.e_activeFlag;
				broadPhase = this.m_world.m_contactManager.m_broadPhase;
				for (f = this.m_fixtureList;
				     f; f = f.m_next)
				{
					f.CreateProxy(broadPhase, this.m_xf);
				}
			}
			else
			{
				this.m_flags &= ~b2Body.e_activeFlag;
				broadPhase = this.m_world.m_contactManager.m_broadPhase;
				for (f = this.m_fixtureList;
				     f; f = f.m_next)
				{
					f.DestroyProxy(broadPhase);
				}
				var ce = this.m_contactList;
				while (ce)
				{
					var ce0 = ce;
					ce = ce.next;
					this.m_world.m_contactManager.Destroy(ce0.contact);
				}
				this.m_contactList = null;
			}
		}
		b2Body.prototype.IsActive = function ()
		{
			return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
		}
		b2Body.prototype.IsSleepingAllowed = function ()
		{
			return (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
		}
		b2Body.prototype.GetFixtureList = function ()
		{
			return this.m_fixtureList;
		}
		b2Body.prototype.GetJointList = function ()
		{
			return this.m_jointList;
		}
		b2Body.prototype.GetControllerList = function ()
		{
			return this.m_controllerList;
		}
		b2Body.prototype.GetContactList = function ()
		{
			return this.m_contactList;
		}
		b2Body.prototype.GetNext = function ()
		{
			return this.m_next;
		}
		b2Body.prototype.GetUserData = function ()
		{
			return this.m_userData;
		}
		b2Body.prototype.SetUserData = function (data)
		{
			this.m_userData = data;
		}
		b2Body.prototype.GetWorld = function ()
		{
			return this.m_world;
		}
		b2Body.prototype.b2Body = function (bd, world)
		{
			this.m_flags = 0;
			if (bd.bullet)
			{
				this.m_flags |= b2Body.e_bulletFlag;
			}
			if (bd.fixedRotation)
			{
				this.m_flags |= b2Body.e_fixedRotationFlag;
			}
			if (bd.allowSleep)
			{
				this.m_flags |= b2Body.e_allowSleepFlag;
			}
			if (bd.awake)
			{
				this.m_flags |= b2Body.e_awakeFlag;
			}
			if (bd.active)
			{
				this.m_flags |= b2Body.e_activeFlag;
			}
			this.m_world = world;
			this.m_xf.position.SetV(bd.position);
			this.m_xf.R.Set(bd.angle);
			this.m_sweep.localCenter.SetZero();
			this.m_sweep.t0 = 1.0;
			this.m_sweep.a0 = this.m_sweep.a = bd.angle;
			var tMat = this.m_xf.R;
			var tVec = this.m_sweep.localCenter;
			this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			this.m_sweep.c.x += this.m_xf.position.x;
			this.m_sweep.c.y += this.m_xf.position.y;
			this.m_sweep.c0.SetV(this.m_sweep.c);
			this.m_jointList = null;
			this.m_controllerList = null;
			this.m_contactList = null;
			this.m_controllerCount = 0;
			this.m_prev = null;
			this.m_next = null;
			this.m_linearVelocity.SetV(bd.linearVelocity);
			this.m_angularVelocity = bd.angularVelocity;
			this.m_linearDamping = bd.linearDamping;
			this.m_angularDamping = bd.angularDamping;
			this.m_gravityScale = bd.gravityScale;
			this.m_force.Set(0.0, 0.0);
			this.m_torque = 0.0;
			this.m_sleepTime = 0.0;
			this.m_type = bd.type;
			if (this.m_type == b2Body.b2_dynamicBody)
			{
				this.m_mass = 1.0;
				this.m_invMass = 1.0;
			}
			else
			{
				this.m_mass = 0.0;
				this.m_invMass = 0.0;
			}
			this.m_I = 0.0;
			this.m_invI = 0.0;
			this.m_inertiaScale = bd.inertiaScale;
			this.m_userData = bd.userData;
			this.m_fixtureList = null;
			this.m_fixtureCount = 0;
		}
		b2Body.prototype.SetGravityScale = function (scale)
		{
			this.m_gravityScale = scale;
		}
		b2Body.prototype.GetGravityScale = function ()
		{
			return this.m_gravityScale;
		}
		b2Body.prototype.SynchronizeFixtures = function ()
		{
			var xf1 = b2Body.s_xf1;
			xf1.R.Set(this.m_sweep.a0);
			var tMat = xf1.R;
			var tVec = this.m_sweep.localCenter;
			xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
			var f;
			var broadPhase = this.m_world.m_contactManager.m_broadPhase;
			for (f = this.m_fixtureList;
			     f; f = f.m_next)
			{
				f.Synchronize(broadPhase, xf1, this.m_xf);
			}
		}
		b2Body.prototype.SynchronizeTransform = function ()
		{
			this.m_xf.R.Set(this.m_sweep.a);
			var tMat = this.m_xf.R;
			var tVec = this.m_sweep.localCenter;
			this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
			this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
		}
		b2Body.prototype.ShouldCollide = function (other)
		{
			if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody)
			{
				return false;
			}
			for (var jn = this.m_jointList; jn; jn = jn.next)
			{
				if (jn.other == other) if (jn.joint.m_collideConnected == false)
				{
					return false;
				}
			}
			return true;
		}
		b2Body.prototype.Advance = function (t)
		{
			if (t === undefined) t = 0;
			this.m_sweep.Advance(t);
			this.m_sweep.c.SetV(this.m_sweep.c0);
			this.m_sweep.a = this.m_sweep.a0;
			this.SynchronizeTransform();
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Dynamics.b2Body.s_xf1 = new b2Transform();
			Box2D.Dynamics.b2Body.e_islandFlag = 0x0001;
			Box2D.Dynamics.b2Body.e_awakeFlag = 0x0002;
			Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x0004;
			Box2D.Dynamics.b2Body.e_bulletFlag = 0x0008;
			Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x0010;
			Box2D.Dynamics.b2Body.e_activeFlag = 0x0020;
			Box2D.Dynamics.b2Body.b2_staticBody = 0;
			Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
			Box2D.Dynamics.b2Body.b2_dynamicBody = 2;
		});
		b2BodyDef.b2BodyDef = function ()
		{
			this.position = new b2Vec2();
			this.linearVelocity = new b2Vec2();
		};
		b2BodyDef.prototype.b2BodyDef = function ()
		{
			this.userData = null;
			this.position.Set(0.0, 0.0);
			this.angle = 0.0;
			this.linearVelocity.Set(0, 0);
			this.angularVelocity = 0.0;
			this.linearDamping = 0.0;
			this.angularDamping = 0.0;
			this.allowSleep = true;
			this.awake = true;
			this.fixedRotation = false;
			this.bullet = false;
			this.type = b2Body.b2_staticBody;
			this.active = true;
			this.inertiaScale = 1.0;
		}
		b2ContactFilter.b2ContactFilter = function ()
		{
		};
		b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB)
		{
			var filter1 = fixtureA.GetFilterData();
			var filter2 = fixtureB.GetFilterData();
			if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0)
			{
				return filter1.groupIndex > 0;
			}
			var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
			return collide;
		}
		b2ContactFilter.prototype.RayCollide = function (userData, fixture)
		{
			if (!userData) return true;
			return this.ShouldCollide((userData instanceof b2Fixture ? userData : null), fixture);
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
		});
		b2ContactImpulse.b2ContactImpulse = function ()
		{
			this.normalImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
			this.tangentImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
		};
		b2ContactListener.b2ContactListener = function ()
		{
		};
		b2ContactListener.prototype.BeginContact = function (contact)
		{
		}
		b2ContactListener.prototype.EndContact = function (contact)
		{
		}
		b2ContactListener.prototype.PreSolve = function (contact, oldManifold)
		{
		}
		b2ContactListener.prototype.PostSolve = function (contact, impulse)
		{
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b2ContactListener();
		});
		b2ContactManager.b2ContactManager = function ()
		{
		};
		b2ContactManager.prototype.b2ContactManager = function ()
		{
			this.m_world = null;
			this.m_contactCount = 0;
			this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
			this.m_contactListener = b2ContactListener.b2_defaultListener;
			this.m_contactFactory = new b2ContactFactory(this.m_allocator);
			this.m_broadPhase = new b2DynamicTreeBroadPhase();
		}
		b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB)
		{
			var fixtureA = (proxyUserDataA instanceof b2Fixture ? proxyUserDataA : null);
			var fixtureB = (proxyUserDataB instanceof b2Fixture ? proxyUserDataB : null);
			var bodyA = fixtureA.GetBody();
			var bodyB = fixtureB.GetBody();
			if (bodyA == bodyB) return;
			var edge = bodyB.GetContactList();
			while (edge)
			{
				if (edge.other == bodyA)
				{
					var fA = edge.contact.GetFixtureA();
					var fB = edge.contact.GetFixtureB();
					if (fA == fixtureA && fB == fixtureB) return;
					if (fA == fixtureB && fB == fixtureA) return;
				}
				edge = edge.next;
			}
			if (bodyB.ShouldCollide(bodyA) == false)
			{
				return;
			}
			if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false)
			{
				return;
			}
			var c = this.m_contactFactory.Create(fixtureA, fixtureB);
			fixtureA = c.GetFixtureA();
			fixtureB = c.GetFixtureB();
			bodyA = fixtureA.m_body;
			bodyB = fixtureB.m_body;
			c.m_prev = null;
			c.m_next = this.m_world.m_contactList;
			if (this.m_world.m_contactList != null)
			{
				this.m_world.m_contactList.m_prev = c;
			}
			this.m_world.m_contactList = c;
			c.m_nodeA.contact = c;
			c.m_nodeA.other = bodyB;
			c.m_nodeA.prev = null;
			c.m_nodeA.next = bodyA.m_contactList;
			if (bodyA.m_contactList != null)
			{
				bodyA.m_contactList.prev = c.m_nodeA;
			}
			bodyA.m_contactList = c.m_nodeA;
			c.m_nodeB.contact = c;
			c.m_nodeB.other = bodyA;
			c.m_nodeB.prev = null;
			c.m_nodeB.next = bodyB.m_contactList;
			if (bodyB.m_contactList != null)
			{
				bodyB.m_contactList.prev = c.m_nodeB;
			}
			bodyB.m_contactList = c.m_nodeB;
			++this.m_world.m_contactCount;
			return;
		}
		b2ContactManager.prototype.FindNewContacts = function ()
		{
			this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair));
		}
		b2ContactManager.prototype.Destroy = function (c)
		{
			var fixtureA = c.GetFixtureA();
			var fixtureB = c.GetFixtureB();
			var bodyA = fixtureA.GetBody();
			var bodyB = fixtureB.GetBody();
			if (c.IsTouching())
			{
				this.m_contactListener.EndContact(c);
			}
			if (c.m_prev)
			{
				c.m_prev.m_next = c.m_next;
			}
			if (c.m_next)
			{
				c.m_next.m_prev = c.m_prev;
			}
			if (c == this.m_world.m_contactList)
			{
				this.m_world.m_contactList = c.m_next;
			}
			if (c.m_nodeA.prev)
			{
				c.m_nodeA.prev.next = c.m_nodeA.next;
			}
			if (c.m_nodeA.next)
			{
				c.m_nodeA.next.prev = c.m_nodeA.prev;
			}
			if (c.m_nodeA == bodyA.m_contactList)
			{
				bodyA.m_contactList = c.m_nodeA.next;
			}
			if (c.m_nodeB.prev)
			{
				c.m_nodeB.prev.next = c.m_nodeB.next;
			}
			if (c.m_nodeB.next)
			{
				c.m_nodeB.next.prev = c.m_nodeB.prev;
			}
			if (c.m_nodeB == bodyB.m_contactList)
			{
				bodyB.m_contactList = c.m_nodeB.next;
			}
			this.m_contactFactory.Destroy(c);
			--this.m_contactCount;
		}
		b2ContactManager.prototype.Collide = function ()
		{
			var c = this.m_world.m_contactList;
			while (c)
			{
				var fixtureA = c.GetFixtureA();
				var fixtureB = c.GetFixtureB();
				var bodyA = fixtureA.GetBody();
				var bodyB = fixtureB.GetBody();
				if (bodyA.IsAwake() == false && bodyB.IsAwake() == false)
				{
					c = c.GetNext();
					continue;
				}
				if (c.m_flags & b2Contact.e_filterFlag)
				{
					if (bodyB.ShouldCollide(bodyA) == false)
					{
						var cNuke = c;
						c = cNuke.GetNext();
						this.Destroy(cNuke);
						continue;
					}
					if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false)
					{
						cNuke = c;
						c = cNuke.GetNext();
						this.Destroy(cNuke);
						continue;
					}
					c.m_flags &= ~b2Contact.e_filterFlag;
				}
				var proxyA = fixtureA.m_proxy;
				var proxyB = fixtureB.m_proxy;
				var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
				if (overlap == false)
				{
					cNuke = c;
					c = cNuke.GetNext();
					this.Destroy(cNuke);
					continue;
				}
				c.Update(this.m_contactListener);
				c = c.GetNext();
			}
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Dynamics.b2ContactManager.s_evalCP = new b2ContactPoint();
		});
		b2DebugDraw.b2DebugDraw = function ()
		{
		};
		b2DebugDraw.prototype.b2DebugDraw = function ()
		{
		}
		b2DebugDraw.prototype.SetFlags = function (flags)
		{
			if (flags === undefined) flags = 0;
		}
		b2DebugDraw.prototype.GetFlags = function ()
		{
		}
		b2DebugDraw.prototype.AppendFlags = function (flags)
		{
			if (flags === undefined) flags = 0;
		}
		b2DebugDraw.prototype.ClearFlags = function (flags)
		{
			if (flags === undefined) flags = 0;
		}
		b2DebugDraw.prototype.SetSprite = function (sprite)
		{
		}
		b2DebugDraw.prototype.GetSprite = function ()
		{
		}
		b2DebugDraw.prototype.SetDrawScale = function (drawScale)
		{
			if (drawScale === undefined) drawScale = 0;
		}
		b2DebugDraw.prototype.GetDrawScale = function ()
		{
		}
		b2DebugDraw.prototype.SetLineThickness = function (lineThickness)
		{
			if (lineThickness === undefined) lineThickness = 0;
		}
		b2DebugDraw.prototype.GetLineThickness = function ()
		{
		}
		b2DebugDraw.prototype.SetAlpha = function (alpha)
		{
			if (alpha === undefined) alpha = 0;
		}
		b2DebugDraw.prototype.GetAlpha = function ()
		{
		}
		b2DebugDraw.prototype.SetFillAlpha = function (alpha)
		{
			if (alpha === undefined) alpha = 0;
		}
		b2DebugDraw.prototype.GetFillAlpha = function ()
		{
		}
		b2DebugDraw.prototype.SetXFormScale = function (xformScale)
		{
			if (xformScale === undefined) xformScale = 0;
		}
		b2DebugDraw.prototype.GetXFormScale = function ()
		{
		}
		b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color)
		{
			if (vertexCount === undefined) vertexCount = 0;
		}
		b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color)
		{
			if (vertexCount === undefined) vertexCount = 0;
		}
		b2DebugDraw.prototype.DrawCircle = function (center, radius, color)
		{
			if (radius === undefined) radius = 0;
		}
		b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color)
		{
			if (radius === undefined) radius = 0;
		}
		b2DebugDraw.prototype.DrawSegment = function (p1, p2, color)
		{
		}
		b2DebugDraw.prototype.DrawTransform = function (xf)
		{
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Dynamics.b2DebugDraw.e_shapeBit = 0x0001;
			Box2D.Dynamics.b2DebugDraw.e_jointBit = 0x0002;
			Box2D.Dynamics.b2DebugDraw.e_aabbBit = 0x0004;
			Box2D.Dynamics.b2DebugDraw.e_pairBit = 0x0008;
			Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 0x0010;
			Box2D.Dynamics.b2DebugDraw.e_controllerBit = 0x0020;
		});
		b2DestructionListener.b2DestructionListener = function ()
		{
		};
		b2DestructionListener.prototype.SayGoodbyeJoint = function (joint)
		{
		}
		b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture)
		{
		}
		b2FilterData.b2FilterData = function ()
		{
			this.categoryBits = 0x0001;
			this.maskBits = 0xFFFF;
			this.groupIndex = 0;
		};
		b2FilterData.prototype.Copy = function ()
		{
			var copy = new b2FilterData();
			copy.categoryBits = this.categoryBits;
			copy.maskBits = this.maskBits;
			copy.groupIndex = this.groupIndex;
			return copy;
		}
		b2Fixture.b2Fixture = function ()
		{
			this.m_filter = new b2FilterData();
		};
		b2Fixture.prototype.GetType = function ()
		{
			return this.m_shape.GetType();
		}
		b2Fixture.prototype.GetShape = function ()
		{
			return this.m_shape;
		}
		b2Fixture.prototype.SetSensor = function (sensor)
		{
			if (this.m_isSensor == sensor) return;
			this.m_isSensor = sensor;
			if (this.m_body == null) return;
			var edge = this.m_body.GetContactList();
			while (edge)
			{
				var contact = edge.contact;
				var fixtureA = contact.GetFixtureA();
				var fixtureB = contact.GetFixtureB();
				if (fixtureA == this || fixtureB == this) contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
				edge = edge.next;
			}
		}
		b2Fixture.prototype.IsSensor = function ()
		{
			return this.m_isSensor;
		}
		b2Fixture.prototype.SetFilterData = function (filter)
		{
			this.m_filter = filter.Copy();
			if (this.m_body) return;
			var edge = this.m_body.GetContactList();
			while (edge)
			{
				var contact = edge.contact;
				var fixtureA = contact.GetFixtureA();
				var fixtureB = contact.GetFixtureB();
				if (fixtureA == this || fixtureB == this) contact.FlagForFiltering();
				edge = edge.next;
			}
		}
		b2Fixture.prototype.GetFilterData = function ()
		{
			return this.m_filter.Copy();
		}
		b2Fixture.prototype.GetBody = function ()
		{
			return this.m_body;
		}
		b2Fixture.prototype.GetNext = function ()
		{
			return this.m_next;
		}
		b2Fixture.prototype.GetUserData = function ()
		{
			return this.m_userData;
		}
		b2Fixture.prototype.SetUserData = function (data)
		{
			this.m_userData = data;
		}
		b2Fixture.prototype.TestPoint = function (p)
		{
			return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
		}
		b2Fixture.prototype.RayCast = function (output, input)
		{
			return this.m_shape.RayCast(output, input, this.m_body.GetTransform());
		}
		b2Fixture.prototype.GetMassData = function (massData)
		{
			if (massData === undefined) massData = null;
			if (massData == null)
			{
				massData = new b2MassData();
			}
			this.m_shape.ComputeMass(massData, this.m_density);
			return massData;
		}
		b2Fixture.prototype.SetDensity = function (density)
		{
			if (density === undefined) density = 0;
			this.m_density = density;
		}
		b2Fixture.prototype.GetDensity = function ()
		{
			return this.m_density;
		}
		b2Fixture.prototype.GetFriction = function ()
		{
			return this.m_friction;
		}
		b2Fixture.prototype.SetFriction = function (friction)
		{
			if (friction === undefined) friction = 0;
			this.m_friction = friction;
		}
		b2Fixture.prototype.GetRestitution = function ()
		{
			return this.m_restitution;
		}
		b2Fixture.prototype.SetRestitution = function (restitution)
		{
			if (restitution === undefined) restitution = 0;
			this.m_restitution = restitution;
		}
		b2Fixture.prototype.GetAABB = function ()
		{
			return this.m_aabb;
		}
		b2Fixture.prototype.b2Fixture = function ()
		{
			this.m_aabb = new b2AABB();
			this.m_userData = null;
			this.m_body = null;
			this.m_next = null;
			this.m_shape = null;
			this.m_density = 0.0;
			this.m_friction = 0.0;
			this.m_restitution = 0.0;
		}
		b2Fixture.prototype.Create = function (body, xf, def)
		{
			this.m_userData = def.userData;
			this.m_friction = def.friction;
			this.m_restitution = def.restitution;
			this.m_body = body;
			this.m_next = null;
			this.m_filter = def.filter.Copy();
			this.m_isSensor = def.isSensor;
			this.m_shape = def.shape.Copy();
			this.m_density = def.density;
		}
		b2Fixture.prototype.Destroy = function ()
		{
			this.m_shape = null;
		}
		b2Fixture.prototype.CreateProxy = function (broadPhase, xf)
		{
			this.m_shape.ComputeAABB(this.m_aabb, xf);
			this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this);
		}
		b2Fixture.prototype.DestroyProxy = function (broadPhase)
		{
			if (this.m_proxy == null)
			{
				return;
			}
			broadPhase.DestroyProxy(this.m_proxy);
			this.m_proxy = null;
		}
		b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2)
		{
			if (!this.m_proxy) return;
			var aabb1 = new b2AABB();
			var aabb2 = new b2AABB();
			this.m_shape.ComputeAABB(aabb1, transform1);
			this.m_shape.ComputeAABB(aabb2, transform2);
			this.m_aabb.Combine(aabb1, aabb2);
			var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
			broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement);
		}
		b2FixtureDef.b2FixtureDef = function ()
		{
			this.filter = new b2FilterData();
		};
		b2FixtureDef.prototype.b2FixtureDef = function ()
		{
			this.shape = null;
			this.userData = null;
			this.friction = 0.2;
			this.restitution = 0.0;
			this.density = 0.0;
			this.filter.categoryBits = 0x0001;
			this.filter.maskBits = 0xFFFF;
			this.filter.groupIndex = 0;
			this.isSensor = false;
		}
		b2Island.b2Island = function ()
		{
		};
		b2Island.prototype.b2Island = function ()
		{
			this.m_bodies = new Vector();
			this.m_contacts = new Vector();
			this.m_joints = new Vector();
		}
		b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver)
		{
			if (bodyCapacity === undefined) bodyCapacity = 0;
			if (contactCapacity === undefined) contactCapacity = 0;
			if (jointCapacity === undefined) jointCapacity = 0;
			var i = 0;
			this.m_bodyCapacity = bodyCapacity;
			this.m_contactCapacity = contactCapacity;
			this.m_jointCapacity = jointCapacity;
			this.m_bodyCount = 0;
			this.m_contactCount = 0;
			this.m_jointCount = 0;
			this.m_allocator = allocator;
			this.m_listener = listener;
			this.m_contactSolver = contactSolver;
			for (i = this.m_bodies.length;
			     i < bodyCapacity; i++)
				this.m_bodies[i] = null;
			for (i = this.m_contacts.length;
			     i < contactCapacity; i++)
				this.m_contacts[i] = null;
			for (i = this.m_joints.length;
			     i < jointCapacity; i++)
				this.m_joints[i] = null;
		}
		b2Island.prototype.Clear = function ()
		{
			this.m_bodyCount = 0;
			this.m_contactCount = 0;
			this.m_jointCount = 0;
		}
		b2Island.prototype.Solve = function (step, gravity, allowSleep)
		{
			var i = 0;
			var j = 0;
			var b;
			var joint;
			for (i = 0;
			     i < this.m_bodyCount; ++i)
			{
				b = this.m_bodies[i];
				if (b.GetType() != b2Body.b2_dynamicBody) continue;
				b.m_linearVelocity.x += step.dt * (gravity.x * b.m_gravityScale + b.m_invMass * b.m_force.x);
				b.m_linearVelocity.y += step.dt * (gravity.y * b.m_gravityScale + b.m_invMass * b.m_force.y);
				b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
				b.m_linearVelocity.Multiply(b2Math.Clamp(1.0 - step.dt * b.m_linearDamping, 0.0, 1.0));
				b.m_angularVelocity *= b2Math.Clamp(1.0 - step.dt * b.m_angularDamping, 0.0, 1.0);
			}
			this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
			var contactSolver = this.m_contactSolver;
			contactSolver.InitVelocityConstraints(step);
			for (i = 0;
			     i < this.m_jointCount; ++i)
			{
				joint = this.m_joints[i];
				joint.InitVelocityConstraints(step);
			}
			for (i = 0;
			     i < step.velocityIterations; ++i)
			{
				for (j = 0;
				     j < this.m_jointCount; ++j)
				{
					joint = this.m_joints[j];
					joint.SolveVelocityConstraints(step);
				}
				contactSolver.SolveVelocityConstraints();
			}
			for (i = 0;
			     i < this.m_jointCount; ++i)
			{
				joint = this.m_joints[i];
				joint.FinalizeVelocityConstraints();
			}
			contactSolver.FinalizeVelocityConstraints();
			for (i = 0;
			     i < this.m_bodyCount; ++i)
			{
				b = this.m_bodies[i];
				if (b.GetType() == b2Body.b2_staticBody) continue;
				var translationX = step.dt * b.m_linearVelocity.x;
				var translationY = step.dt * b.m_linearVelocity.y;
				if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared)
				{
					b.m_linearVelocity.Normalize();
					b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
					b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt;
				}
				var rotation = step.dt * b.m_angularVelocity;
				if (rotation * rotation > b2Settings.b2_maxRotationSquared)
				{
					if (b.m_angularVelocity < 0.0)
					{
						b.m_angularVelocity = (-b2Settings.b2_maxRotation * step.inv_dt);
					}
					else
					{
						b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt;
					}
				}
				b.m_sweep.c0.SetV(b.m_sweep.c);
				b.m_sweep.a0 = b.m_sweep.a;
				b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
				b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
				b.m_sweep.a += step.dt * b.m_angularVelocity;
				b.SynchronizeTransform();
			}
			for (i = 0;
			     i < step.positionIterations; ++i)
			{
				var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
				var jointsOkay = true;
				for (j = 0;
				     j < this.m_jointCount; ++j)
				{
					joint = this.m_joints[j];
					var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
					jointsOkay = jointsOkay && jointOkay;
				}
				if (contactsOkay && jointsOkay)
				{
					break;
				}
			}
			this.Report(contactSolver.m_constraints);
			if (allowSleep)
			{
				var minSleepTime = Number.MAX_VALUE;
				var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
				var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
				for (i = 0;
				     i < this.m_bodyCount; ++i)
				{
					b = this.m_bodies[i];
					if (b.GetType() == b2Body.b2_staticBody)
					{
						continue;
					}
					if ((b.m_flags & b2Body.e_allowSleepFlag) == 0)
					{
						b.m_sleepTime = 0.0;
						minSleepTime = 0.0;
					}
					if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr)
					{
						b.m_sleepTime = 0.0;
						minSleepTime = 0.0;
					}
					else
					{
						b.m_sleepTime += step.dt;
						minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime);
					}
				}
				if (minSleepTime >= b2Settings.b2_timeToSleep)
				{
					for (i = 0;
					     i < this.m_bodyCount; ++i)
					{
						b = this.m_bodies[i];
						b.SetAwake(false);
					}
				}
			}
		}
		b2Island.prototype.SolveTOI = function (subStep)
		{
			var i = 0;
			var j = 0;
			this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
			var contactSolver = this.m_contactSolver;
			for (i = 0;
			     i < this.m_jointCount; ++i)
			{
				this.m_joints[i].InitVelocityConstraints(subStep);
			}
			for (i = 0;
			     i < subStep.velocityIterations; ++i)
			{
				contactSolver.SolveVelocityConstraints();
				for (j = 0;
				     j < this.m_jointCount; ++j)
				{
					this.m_joints[j].SolveVelocityConstraints(subStep);
				}
			}
			for (i = 0;
			     i < this.m_bodyCount; ++i)
			{
				var b = this.m_bodies[i];
				if (b.GetType() == b2Body.b2_staticBody) continue;
				var translationX = subStep.dt * b.m_linearVelocity.x;
				var translationY = subStep.dt * b.m_linearVelocity.y;
				if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared)
				{
					b.m_linearVelocity.Normalize();
					b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
					b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt;
				}
				var rotation = subStep.dt * b.m_angularVelocity;
				if (rotation * rotation > b2Settings.b2_maxRotationSquared)
				{
					if (b.m_angularVelocity < 0.0)
					{
						b.m_angularVelocity = (-b2Settings.b2_maxRotation * subStep.inv_dt);
					}
					else
					{
						b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt;
					}
				}
				b.m_sweep.c0.SetV(b.m_sweep.c);
				b.m_sweep.a0 = b.m_sweep.a;
				b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
				b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
				b.m_sweep.a += subStep.dt * b.m_angularVelocity;
				b.SynchronizeTransform();
			}
			var k_toiBaumgarte = 0.75;
			for (i = 0;
			     i < subStep.positionIterations; ++i)
			{
				var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
				var jointsOkay = true;
				for (j = 0;
				     j < this.m_jointCount; ++j)
				{
					var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
					jointsOkay = jointsOkay && jointOkay;
				}
				if (contactsOkay && jointsOkay)
				{
					break;
				}
			}
			this.Report(contactSolver.m_constraints);
		}
		b2Island.prototype.Report = function (constraints)
		{
			if (this.m_listener == null)
			{
				return;
			}
			for (var i = 0; i < this.m_contactCount; ++i)
			{
				var c = this.m_contacts[i];
				var cc = constraints[i];
				for (var j = 0; j < cc.pointCount; ++j)
				{
					b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
					b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse;
				}
				this.m_listener.PostSolve(c, b2Island.s_impulse);
			}
		}
		b2Island.prototype.AddBody = function (body)
		{
			body.m_islandIndex = this.m_bodyCount;
			this.m_bodies[this.m_bodyCount++] = body;
		}
		b2Island.prototype.AddContact = function (contact)
		{
			this.m_contacts[this.m_contactCount++] = contact;
		}
		b2Island.prototype.AddJoint = function (joint)
		{
			this.m_joints[this.m_jointCount++] = joint;
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Dynamics.b2Island.s_impulse = new b2ContactImpulse();
		});
		b2TimeStep.b2TimeStep = function ()
		{
		};
		b2TimeStep.prototype.Set = function (step)
		{
			this.dt = step.dt;
			this.inv_dt = step.inv_dt;
			this.positionIterations = step.positionIterations;
			this.velocityIterations = step.velocityIterations;
			this.warmStarting = step.warmStarting;
		}
		b2World.b2World = function ()
		{
			this.s_stack = new Vector();
			this.m_contactManager = new b2ContactManager();
			this.m_contactSolver = new b2ContactSolver();
			this.m_island = new b2Island();
		};
		b2World.prototype.b2World = function (gravity, doSleep)
		{
			this.m_destructionListener = null;
			this.m_debugDraw = null;
			this.m_bodyList = null;
			this.m_contactList = null;
			this.m_jointList = null;
			this.m_controllerList = null;
			this.m_bodyCount = 0;
			this.m_contactCount = 0;
			this.m_jointCount = 0;
			this.m_controllerCount = 0;
			b2World.m_warmStarting = true;
			b2World.m_continuousPhysics = true;
			this.m_allowSleep = doSleep;
			this.m_gravity = gravity;
			this.m_inv_dt0 = 0.0;
			this.m_contactManager.m_world = this;
			var bd = new b2BodyDef();
			this.m_groundBody = this.CreateBody(bd);
		}
		b2World.prototype.SetDestructionListener = function (listener)
		{
			this.m_destructionListener = listener;
		}
		b2World.prototype.SetContactFilter = function (filter)
		{
			this.m_contactManager.m_contactFilter = filter;
		}
		b2World.prototype.SetContactListener = function (listener)
		{
			this.m_contactManager.m_contactListener = listener;
		}
		b2World.prototype.SetDebugDraw = function (debugDraw)
		{
			this.m_debugDraw = debugDraw;
		}
		b2World.prototype.SetBroadPhase = function (broadPhase)
		{
			var oldBroadPhase = this.m_contactManager.m_broadPhase;
			this.m_contactManager.m_broadPhase = broadPhase;
			for (var b = this.m_bodyList; b; b = b.m_next)
			{
				for (var f = b.m_fixtureList; f; f = f.m_next)
				{
					f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
				}
			}
		}
		b2World.prototype.Validate = function ()
		{
			this.m_contactManager.m_broadPhase.Validate();
		}
		b2World.prototype.GetProxyCount = function ()
		{
			return this.m_contactManager.m_broadPhase.GetProxyCount();
		}
		b2World.prototype.CreateBody = function (def)
		{
			if (this.IsLocked() == true)
			{
				return null;
			}
			var b = new b2Body(def, this);
			b.m_prev = null;
			b.m_next = this.m_bodyList;
			if (this.m_bodyList)
			{
				this.m_bodyList.m_prev = b;
			}
			this.m_bodyList = b;
			++this.m_bodyCount;
			return b;
		}
		b2World.prototype.DestroyBody = function (b)
		{
			if (this.IsLocked() == true)
			{
				return;
			}
			var jn = b.m_jointList;
			while (jn)
			{
				var jn0 = jn;
				jn = jn.next;
				if (this.m_destructionListener)
				{
					this.m_destructionListener.SayGoodbyeJoint(jn0.joint);
				}
				this.DestroyJoint(jn0.joint);
			}
			var coe = b.m_controllerList;
			while (coe)
			{
				var coe0 = coe;
				coe = coe.nextController;
				coe0.controller.RemoveBody(b);
			}
			var ce = b.m_contactList;
			while (ce)
			{
				var ce0 = ce;
				ce = ce.next;
				this.m_contactManager.Destroy(ce0.contact);
			}
			b.m_contactList = null;
			var f = b.m_fixtureList;
			while (f)
			{
				var f0 = f;
				f = f.m_next;
				if (this.m_destructionListener)
				{
					this.m_destructionListener.SayGoodbyeFixture(f0);
				}
				f0.DestroyProxy(this.m_contactManager.m_broadPhase);
				f0.Destroy();
			}
			b.m_fixtureList = null;
			b.m_fixtureCount = 0;
			if (b.m_prev)
			{
				b.m_prev.m_next = b.m_next;
			}
			if (b.m_next)
			{
				b.m_next.m_prev = b.m_prev;
			}
			if (b == this.m_bodyList)
			{
				this.m_bodyList = b.m_next;
			}
			--this.m_bodyCount;
		}
		b2World.prototype.CreateJoint = function (def)
		{
			var j = b2Joint.Create(def, null);
			j.m_prev = null;
			j.m_next = this.m_jointList;
			if (this.m_jointList)
			{
				this.m_jointList.m_prev = j;
			}
			this.m_jointList = j;
			++this.m_jointCount;
			j.m_edgeA.joint = j;
			j.m_edgeA.other = j.m_bodyB;
			j.m_edgeA.prev = null;
			j.m_edgeA.next = j.m_bodyA.m_jointList;
			if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
			j.m_bodyA.m_jointList = j.m_edgeA;
			j.m_edgeB.joint = j;
			j.m_edgeB.other = j.m_bodyA;
			j.m_edgeB.prev = null;
			j.m_edgeB.next = j.m_bodyB.m_jointList;
			if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
			j.m_bodyB.m_jointList = j.m_edgeB;
			var bodyA = def.bodyA;
			var bodyB = def.bodyB;
			if (def.collideConnected == false)
			{
				var edge = bodyB.GetContactList();
				while (edge)
				{
					if (edge.other == bodyA)
					{
						edge.contact.FlagForFiltering();
					}
					edge = edge.next;
				}
			}
			return j;
		}
		b2World.prototype.DestroyJoint = function (j)
		{
			var collideConnected = j.m_collideConnected;
			if (j.m_prev)
			{
				j.m_prev.m_next = j.m_next;
			}
			if (j.m_next)
			{
				j.m_next.m_prev = j.m_prev;
			}
			if (j == this.m_jointList)
			{
				this.m_jointList = j.m_next;
			}
			var bodyA = j.m_bodyA;
			var bodyB = j.m_bodyB;
			bodyA.SetAwake(true);
			bodyB.SetAwake(true);
			if (j.m_edgeA.prev)
			{
				j.m_edgeA.prev.next = j.m_edgeA.next;
			}
			if (j.m_edgeA.next)
			{
				j.m_edgeA.next.prev = j.m_edgeA.prev;
			}
			if (j.m_edgeA == bodyA.m_jointList)
			{
				bodyA.m_jointList = j.m_edgeA.next;
			}
			j.m_edgeA.prev = null;
			j.m_edgeA.next = null;
			if (j.m_edgeB.prev)
			{
				j.m_edgeB.prev.next = j.m_edgeB.next;
			}
			if (j.m_edgeB.next)
			{
				j.m_edgeB.next.prev = j.m_edgeB.prev;
			}
			if (j.m_edgeB == bodyB.m_jointList)
			{
				bodyB.m_jointList = j.m_edgeB.next;
			}
			j.m_edgeB.prev = null;
			j.m_edgeB.next = null;
			b2Joint.Destroy(j, null);
			--this.m_jointCount;
			if (collideConnected == false)
			{
				var edge = bodyB.GetContactList();
				while (edge)
				{
					if (edge.other == bodyA)
					{
						edge.contact.FlagForFiltering();
					}
					edge = edge.next;
				}
			}
		}
		b2World.prototype.AddController = function (c)
		{
			c.m_next = this.m_controllerList;
			c.m_prev = null;
			this.m_controllerList = c;
			c.m_world = this;
			this.m_controllerCount++;
			return c;
		}
		b2World.prototype.RemoveController = function (c)
		{
			if (c.m_prev) c.m_prev.m_next = c.m_next;
			if (c.m_next) c.m_next.m_prev = c.m_prev;
			if (this.m_controllerList == c) this.m_controllerList = c.m_next;
			this.m_controllerCount--;
		}
		b2World.prototype.CreateController = function (controller)
		{
			if (controller.m_world != this) throw new Error("Controller can only be a member of one world");
			controller.m_next = this.m_controllerList;
			controller.m_prev = null;
			if (this.m_controllerList) this.m_controllerList.m_prev = controller;
			this.m_controllerList = controller;
			++this.m_controllerCount;
			controller.m_world = this;
			return controller;
		}
		b2World.prototype.DestroyController = function (controller)
		{
			controller.Clear();
			if (controller.m_next) controller.m_next.m_prev = controller.m_prev;
			if (controller.m_prev) controller.m_prev.m_next = controller.m_next;
			if (controller == this.m_controllerList) this.m_controllerList = controller.m_next;
			--this.m_controllerCount;
		}
		b2World.prototype.SetWarmStarting = function (flag)
		{
			b2World.m_warmStarting = flag;
		}
		b2World.prototype.SetContinuousPhysics = function (flag)
		{
			b2World.m_continuousPhysics = flag;
		}
		b2World.prototype.GetBodyCount = function ()
		{
			return this.m_bodyCount;
		}
		b2World.prototype.GetJointCount = function ()
		{
			return this.m_jointCount;
		}
		b2World.prototype.GetContactCount = function ()
		{
			return this.m_contactCount;
		}
		b2World.prototype.SetGravity = function (gravity)
		{
			this.m_gravity = gravity;
		}
		b2World.prototype.GetGravity = function ()
		{
			return this.m_gravity;
		}
		b2World.prototype.GetGroundBody = function ()
		{
			return this.m_groundBody;
		}
		b2World.prototype.Step = function (dt, velocityIterations, positionIterations)
		{
			if (dt === undefined) dt = 0;
			if (velocityIterations === undefined) velocityIterations = 0;
			if (positionIterations === undefined) positionIterations = 0;
			if (this.m_flags & b2World.e_newFixture)
			{
				this.m_contactManager.FindNewContacts();
				this.m_flags &= ~b2World.e_newFixture;
			}
			//    this.m_flags |= b2World.e_locked;
			var step = b2World.s_timestep2;
			step.dt = dt;
			step.velocityIterations = velocityIterations;
			step.positionIterations = positionIterations;
			if (dt > 0.0)
			{
				step.inv_dt = 1.0 / dt;
			}
			else
			{
				step.inv_dt = 0.0;
			}
			step.dtRatio = this.m_inv_dt0 * dt;
			step.warmStarting = b2World.m_warmStarting;
			this.m_contactManager.Collide();
			if (step.dt > 0.0)
			{
				this.Solve(step);
			}
			if (b2World.m_continuousPhysics && step.dt > 0.0)
			{
				this.SolveTOI(step);
			}
			if (step.dt > 0.0)
			{
				this.m_inv_dt0 = step.inv_dt;
			}
			this.m_flags &= ~b2World.e_locked;
		}
		b2World.prototype.ClearForces = function ()
		{
			for (var body = this.m_bodyList; body; body = body.m_next)
			{
				body.m_force.SetZero();
				body.m_torque = 0.0;
			}
		}
		b2World.prototype.DrawDebugData = function ()
		{
			if (this.m_debugDraw == null)
			{
				return;
			}
			this.m_debugDraw.m_sprite.graphics.clear();
			var flags = this.m_debugDraw.GetFlags();
			var i = 0;
			var b;
			var f;
			var s;
			var j;
			var bp;
			var invQ = new b2Vec2;
			var x1 = new b2Vec2;
			var x2 = new b2Vec2;
			var xf;
			var b1 = new b2AABB();
			var b2 = new b2AABB();
			var vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
			var color = new b2Color(0, 0, 0);
			if (flags & b2DebugDraw.e_shapeBit)
			{
				for (b = this.m_bodyList;
				     b; b = b.m_next)
				{
					xf = b.m_xf;
					for (f = b.GetFixtureList();
					     f; f = f.m_next)
					{
						s = f.GetShape();
						if (b.IsActive() == false)
						{
							color.Set(0.5, 0.5, 0.3);
							this.DrawShape(s, xf, color);
						}
						else if (b.GetType() == b2Body.b2_staticBody)
						{
							color.Set(0.5, 0.9, 0.5);
							this.DrawShape(s, xf, color);
						}
						else if (b.GetType() == b2Body.b2_kinematicBody)
						{
							color.Set(0.5, 0.5, 0.9);
							this.DrawShape(s, xf, color);
						}
						else if (b.IsAwake() == false)
						{
							color.Set(0.6, 0.6, 0.6);
							this.DrawShape(s, xf, color);
						}
						else
						{
							color.Set(0.9, 0.7, 0.7);
							this.DrawShape(s, xf, color);
						}
					}
				}
			}
			if (flags & b2DebugDraw.e_jointBit)
			{
				for (j = this.m_jointList;
				     j; j = j.m_next)
				{
					this.DrawJoint(j);
				}
			}
			if (flags & b2DebugDraw.e_controllerBit)
			{
				for (var c = this.m_controllerList; c; c = c.m_next)
				{
					c.Draw(this.m_debugDraw);
				}
			}
			if (flags & b2DebugDraw.e_pairBit)
			{
				color.Set(0.3, 0.9, 0.9);
				for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext())
				{
					var fixtureA = contact.GetFixtureA();
					var fixtureB = contact.GetFixtureB();
					var cA = fixtureA.GetAABB().GetCenter();
					var cB = fixtureB.GetAABB().GetCenter();
					this.m_debugDraw.DrawSegment(cA, cB, color);
				}
			}
			if (flags & b2DebugDraw.e_aabbBit)
			{
				bp = this.m_contactManager.m_broadPhase;
				vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
				for (b = this.m_bodyList;
				     b; b = b.GetNext())
				{
					if (b.IsActive() == false)
					{
						continue;
					}
					for (f = b.GetFixtureList();
					     f; f = f.GetNext())
					{
						var aabb = bp.GetFatAABB(f.m_proxy);
						vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
						vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
						vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
						vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
						this.m_debugDraw.DrawPolygon(vs, 4, color);
					}
				}
			}
			if (flags & b2DebugDraw.e_centerOfMassBit)
			{
				for (b = this.m_bodyList;
				     b; b = b.m_next)
				{
					xf = b2World.s_xf;
					xf.R = b.m_xf.R;
					xf.position = b.GetWorldCenter();
					this.m_debugDraw.DrawTransform(xf);
				}
			}
		}
		b2World.prototype.QueryAABB = function (callback, aabb)
		{
			var __this = this;
			var broadPhase = __this.m_contactManager.m_broadPhase;

			function WorldQueryWrapper(proxy)
			{
				return callback(broadPhase.GetUserData(proxy));
			};
			broadPhase.Query(WorldQueryWrapper, aabb);
		}
		b2World.prototype.QueryShape = function (callback, shape, transform)
		{
			var __this = this;
			if (transform === undefined) transform = null;
			if (transform == null)
			{
				transform = new b2Transform();
				transform.SetIdentity();
			}
			var broadPhase = __this.m_contactManager.m_broadPhase;

			function WorldQueryWrapper(proxy)
			{
				var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
				if (b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) return callback(fixture);
				return true;
			};
			var aabb = new b2AABB();
			shape.ComputeAABB(aabb, transform);
			broadPhase.Query(WorldQueryWrapper, aabb);
		}
		b2World.prototype.QueryPoint = function (callback, p)
		{
			var __this = this;
			var broadPhase = __this.m_contactManager.m_broadPhase;

			function WorldQueryWrapper(proxy)
			{
				var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
				if (fixture.TestPoint(p)) return callback(fixture);
				return true;
			};
			var aabb = new b2AABB();
			aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
			aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
			broadPhase.Query(WorldQueryWrapper, aabb);
		}
		b2World.prototype.RayCast = function (callback, point1, point2)
		{
			var __this = this;
			var broadPhase = __this.m_contactManager.m_broadPhase;
			var output = new b2RayCastOutput;

			function RayCastWrapper(input, proxy)
			{
				var userData = broadPhase.GetUserData(proxy);
				var fixture = (userData instanceof b2Fixture ? userData : null);
				var hit = fixture.RayCast(output, input);
				if (hit)
				{
					var fraction = output.fraction;
					var point = new b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y);
					return callback(fixture, point, output.normal, fraction);
				}
				return input.maxFraction;
			};
			var input = new b2RayCastInput(point1, point2);
			broadPhase.RayCast(RayCastWrapper, input);
		}
		b2World.prototype.RayCastOne = function (point1, point2)
		{
			var __this = this;
			var result;

			function RayCastOneWrapper(fixture, point, normal, fraction)
			{
				if (fraction === undefined) fraction = 0;
				result = fixture;
				return fraction;
			};
			__this.RayCast(RayCastOneWrapper, point1, point2);
			return result;
		}
		b2World.prototype.RayCastAll = function (point1, point2)
		{
			var __this = this;
			var result = new Vector();

			function RayCastAllWrapper(fixture, point, normal, fraction)
			{
				if (fraction === undefined) fraction = 0;
				result[result.length] = fixture;
				return 1;
			};
			__this.RayCast(RayCastAllWrapper, point1, point2);
			return result;
		}
		b2World.prototype.GetBodyList = function ()
		{
			return this.m_bodyList;
		}
		b2World.prototype.GetJointList = function ()
		{
			return this.m_jointList;
		}
		b2World.prototype.GetContactList = function ()
		{
			return this.m_contactList;
		}
		b2World.prototype.IsLocked = function ()
		{
			return (this.m_flags & b2World.e_locked) > 0;
		}
		b2World.prototype.Solve = function (step)
		{
			var b;
			for (var controller = this.m_controllerList; controller; controller = controller.m_next)
			{
				controller.Step(step);
			}
			var island = this.m_island;
			island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
			for (b = this.m_bodyList;
			     b; b = b.m_next)
			{
				b.m_flags &= ~b2Body.e_islandFlag;
			}
			for (var c = this.m_contactList; c; c = c.m_next)
			{
				c.m_flags &= ~b2Contact.e_islandFlag;
			}
			for (var j = this.m_jointList; j; j = j.m_next)
			{
				j.m_islandFlag = false;
			}
			var stackSize = parseInt(this.m_bodyCount);
			var stack = this.s_stack;
			for (var seed = this.m_bodyList; seed; seed = seed.m_next)
			{
				if (seed.m_flags & b2Body.e_islandFlag)
				{
					continue;
				}
				if (seed.IsAwake() == false || seed.IsActive() == false)
				{
					continue;
				}
				if (seed.GetType() == b2Body.b2_staticBody)
				{
					continue;
				}
				island.Clear();
				var stackCount = 0;
				stack[stackCount++] = seed;
				seed.m_flags |= b2Body.e_islandFlag;
				while (stackCount > 0)
				{
					b = stack[--stackCount];
					island.AddBody(b);
					if (b.IsAwake() == false)
					{
						b.SetAwake(true);
					}
					if (b.GetType() == b2Body.b2_staticBody)
					{
						continue;
					}
					var other;
					for (var ce = b.m_contactList; ce; ce = ce.next)
					{
						if (ce.contact.m_flags & b2Contact.e_islandFlag)
						{
							continue;
						}
						if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false)
						{
							continue;
						}
						island.AddContact(ce.contact);
						ce.contact.m_flags |= b2Contact.e_islandFlag;
						other = ce.other;
						if (other.m_flags & b2Body.e_islandFlag)
						{
							continue;
						}
						stack[stackCount++] = other;
						other.m_flags |= b2Body.e_islandFlag;
					}
					for (var jn = b.m_jointList; jn; jn = jn.next)
					{
						if (jn.joint.m_islandFlag == true)
						{
							continue;
						}
						other = jn.other;
						if (other.IsActive() == false)
						{
							continue;
						}
						island.AddJoint(jn.joint);
						jn.joint.m_islandFlag = true;
						if (other.m_flags & b2Body.e_islandFlag)
						{
							continue;
						}
						stack[stackCount++] = other;
						other.m_flags |= b2Body.e_islandFlag;
					}
				}
				island.Solve(step, this.m_gravity, this.m_allowSleep);
				for (var i = 0; i < island.m_bodyCount; ++i)
				{
					b = island.m_bodies[i];
					if (b.GetType() == b2Body.b2_staticBody)
					{
						b.m_flags &= ~b2Body.e_islandFlag;
					}
				}
			}
			for (i = 0;
			     i < stack.length; ++i)
			{
				if (!stack[i]) break;
				stack[i] = null;
			}
			for (b = this.m_bodyList;
			     b; b = b.m_next)
			{
				if (b.IsAwake() == false || b.IsActive() == false)
				{
					continue;
				}
				if (b.GetType() == b2Body.b2_staticBody)
				{
					continue;
				}
				b.SynchronizeFixtures();
			}
			this.m_contactManager.FindNewContacts();
		}
		b2World.prototype.SolveTOI = function (step)
		{
			var b;
			var fA;
			var fB;
			var bA;
			var bB;
			var cEdge;
			var j;
			var island = this.m_island;
			island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
			var queue = b2World.s_queue;
			for (b = this.m_bodyList;
			     b; b = b.m_next)
			{
				b.m_flags &= ~b2Body.e_islandFlag;
				b.m_sweep.t0 = 0.0;
			}
			var c;
			for (c = this.m_contactList;
			     c; c = c.m_next)
			{
				c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag);
			}
			for (j = this.m_jointList;
			     j; j = j.m_next)
			{
				j.m_islandFlag = false;
			}
			for (; ;)
			{
				var minContact = null;
				var minTOI = 1.0;
				for (c = this.m_contactList;
				     c; c = c.m_next)
				{
					if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false)
					{
						continue;
					}
					var toi = 1.0;
					if (c.m_flags & b2Contact.e_toiFlag)
					{
						toi = c.m_toi;
					}
					else
					{
						fA = c.m_fixtureA;
						fB = c.m_fixtureB;
						bA = fA.m_body;
						bB = fB.m_body;
						if ((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false))
						{
							continue;
						}
						var t0 = bA.m_sweep.t0;
						if (bA.m_sweep.t0 < bB.m_sweep.t0)
						{
							t0 = bB.m_sweep.t0;
							bA.m_sweep.Advance(t0);
						}
						else if (bB.m_sweep.t0 < bA.m_sweep.t0)
						{
							t0 = bA.m_sweep.t0;
							bB.m_sweep.Advance(t0);
						}
						toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
						b2Settings.b2Assert(0.0 <= toi && toi <= 1.0);
						if (toi > 0.0 && toi < 1.0)
						{
							toi = (1.0 - toi) * t0 + toi;
							if (toi > 1) toi = 1;
						}
						c.m_toi = toi;
						c.m_flags |= b2Contact.e_toiFlag;
					}
					if (Number.MIN_VALUE < toi && toi < minTOI)
					{
						minContact = c;
						minTOI = toi;
					}
				}
				if (minContact == null || 1.0 - 100.0 * Number.MIN_VALUE < minTOI)
				{
					break;
				}
				fA = minContact.m_fixtureA;
				fB = minContact.m_fixtureB;
				bA = fA.m_body;
				bB = fB.m_body;
				b2World.s_backupA.Set(bA.m_sweep);
				b2World.s_backupB.Set(bB.m_sweep);
				bA.Advance(minTOI);
				bB.Advance(minTOI);
				minContact.Update(this.m_contactManager.m_contactListener);
				minContact.m_flags &= ~b2Contact.e_toiFlag;
				if (minContact.IsSensor() == true || minContact.IsEnabled() == false)
				{
					bA.m_sweep.Set(b2World.s_backupA);
					bB.m_sweep.Set(b2World.s_backupB);
					bA.SynchronizeTransform();
					bB.SynchronizeTransform();
					continue;
				}
				if (minContact.IsTouching() == false)
				{
					continue;
				}
				var seed = bA;
				if (seed.GetType() != b2Body.b2_dynamicBody)
				{
					seed = bB;
				}
				island.Clear();
				var queueStart = 0;
				var queueSize = 0;
				queue[queueStart + queueSize++] = seed;
				seed.m_flags |= b2Body.e_islandFlag;
				while (queueSize > 0)
				{
					b = queue[queueStart++];
					--queueSize;
					island.AddBody(b);
					if (b.IsAwake() == false)
					{
						b.SetAwake(true);
					}
					if (b.GetType() != b2Body.b2_dynamicBody)
					{
						continue;
					}
					for (cEdge = b.m_contactList;
					     cEdge; cEdge = cEdge.next)
					{
						if (island.m_contactCount == island.m_contactCapacity)
						{
							break;
						}
						if (cEdge.contact.m_flags & b2Contact.e_islandFlag)
						{
							continue;
						}
						if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false)
						{
							continue;
						}
						island.AddContact(cEdge.contact);
						cEdge.contact.m_flags |= b2Contact.e_islandFlag;
						var other = cEdge.other;
						if (other.m_flags & b2Body.e_islandFlag)
						{
							continue;
						}
						if (other.GetType() != b2Body.b2_staticBody)
						{
							other.Advance(minTOI);
							other.SetAwake(true);
						}
						queue[queueStart + queueSize] = other;
						++queueSize;
						other.m_flags |= b2Body.e_islandFlag;
					}
					for (var jEdge = b.m_jointList; jEdge; jEdge = jEdge.next)
					{
						if (island.m_jointCount == island.m_jointCapacity) continue;
						if (jEdge.joint.m_islandFlag == true) continue;
						other = jEdge.other;
						if (other.IsActive() == false)
						{
							continue;
						}
						island.AddJoint(jEdge.joint);
						jEdge.joint.m_islandFlag = true;
						if (other.m_flags & b2Body.e_islandFlag) continue;
						if (other.GetType() != b2Body.b2_staticBody)
						{
							other.Advance(minTOI);
							other.SetAwake(true);
						}
						queue[queueStart + queueSize] = other;
						++queueSize;
						other.m_flags |= b2Body.e_islandFlag;
					}
				}
				var subStep = b2World.s_timestep;
				subStep.warmStarting = false;
				subStep.dt = (1.0 - minTOI) * step.dt;
				subStep.inv_dt = 1.0 / subStep.dt;
				subStep.dtRatio = 0.0;
				subStep.velocityIterations = step.velocityIterations;
				subStep.positionIterations = step.positionIterations;
				island.SolveTOI(subStep);
				var i = 0;
				for (i = 0;
				     i < island.m_bodyCount; ++i)
				{
					b = island.m_bodies[i];
					b.m_flags &= ~b2Body.e_islandFlag;
					if (b.IsAwake() == false)
					{
						continue;
					}
					if (b.GetType() != b2Body.b2_dynamicBody)
					{
						continue;
					}
					b.SynchronizeFixtures();
					for (cEdge = b.m_contactList;
					     cEdge; cEdge = cEdge.next)
					{
						cEdge.contact.m_flags &= ~b2Contact.e_toiFlag;
					}
				}
				for (i = 0;
				     i < island.m_contactCount; ++i)
				{
					c = island.m_contacts[i];
					c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag);
				}
				for (i = 0;
				     i < island.m_jointCount; ++i)
				{
					j = island.m_joints[i];
					j.m_islandFlag = false;
				}
				this.m_contactManager.FindNewContacts();
			}
		}
		b2World.prototype.DrawJoint = function (joint)
		{
			var b1 = joint.GetBodyA();
			var b2 = joint.GetBodyB();
			var xf1 = b1.m_xf;
			var xf2 = b2.m_xf;
			var x1 = xf1.position;
			var x2 = xf2.position;
			var p1 = joint.GetAnchorA();
			var p2 = joint.GetAnchorB();
			var color = b2World.s_jointColor;
			switch (joint.m_type)
			{
				case b2Joint.e_distanceJoint:
					this.m_debugDraw.DrawSegment(p1, p2, color);
					break;
				case b2Joint.e_pulleyJoint:
				{
					var pulley = ((joint instanceof b2PulleyJoint ? joint : null));
					var s1 = pulley.GetGroundAnchorA();
					var s2 = pulley.GetGroundAnchorB();
					this.m_debugDraw.DrawSegment(s1, p1, color);
					this.m_debugDraw.DrawSegment(s2, p2, color);
					this.m_debugDraw.DrawSegment(s1, s2, color);
				}
					break;
				case b2Joint.e_mouseJoint:
					this.m_debugDraw.DrawSegment(p1, p2, color);
					break;
				default:
					if (b1 != this.m_groundBody) this.m_debugDraw.DrawSegment(x1, p1, color);
					this.m_debugDraw.DrawSegment(p1, p2, color);
					if (b2 != this.m_groundBody) this.m_debugDraw.DrawSegment(x2, p2, color);
			}
		}
		b2World.prototype.DrawShape = function (shape, xf, color)
		{
			switch (shape.m_type)
			{
				case b2Shape.e_circleShape:
				{
					var circle = ((shape instanceof b2CircleShape ? shape : null));
					var center = b2Math.MulX(xf, circle.m_p);
					var radius = circle.m_radius;
					var axis = xf.R.col1;
					this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
				}
					break;
				case b2Shape.e_polygonShape:
				{
					var i = 0;
					var poly = ((shape instanceof b2PolygonShape ? shape : null));
					var vertexCount = parseInt(poly.GetVertexCount());
					var localVertices = poly.GetVertices();
					var vertices = new Vector(vertexCount);
					for (i = 0;
					     i < vertexCount; ++i)
					{
						vertices[i] = b2Math.MulX(xf, localVertices[i]);
					}
					this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
				}
					break;
				case b2Shape.e_edgeShape:
				{
					var edge = (shape instanceof b2EdgeShape ? shape : null);
					this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
				}
					break;
			}
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Dynamics.b2World.s_timestep2 = new b2TimeStep();
			Box2D.Dynamics.b2World.s_xf = new b2Transform();
			Box2D.Dynamics.b2World.s_backupA = new b2Sweep();
			Box2D.Dynamics.b2World.s_backupB = new b2Sweep();
			Box2D.Dynamics.b2World.s_timestep = new b2TimeStep();
			Box2D.Dynamics.b2World.s_queue = new Vector();
			Box2D.Dynamics.b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
			Box2D.Dynamics.b2World.e_newFixture = 0x0001;
			Box2D.Dynamics.b2World.e_locked = 0x0002;
		});
	})();
	(function ()
	{
		var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
			b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
			b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
			b2MassData = Box2D.Collision.Shapes.b2MassData,
			b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
			b2Shape = Box2D.Collision.Shapes.b2Shape,
			b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
			b2Contact = Box2D.Dynamics.Contacts.b2Contact,
			b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
			b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
			b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
			b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
			b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
			b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
			b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
			b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
			b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
			b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
			b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
			b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
			b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
			b2Body = Box2D.Dynamics.b2Body,
			b2BodyDef = Box2D.Dynamics.b2BodyDef,
			b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
			b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
			b2ContactListener = Box2D.Dynamics.b2ContactListener,
			b2ContactManager = Box2D.Dynamics.b2ContactManager,
			b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
			b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
			b2FilterData = Box2D.Dynamics.b2FilterData,
			b2Fixture = Box2D.Dynamics.b2Fixture,
			b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
			b2Island = Box2D.Dynamics.b2Island,
			b2TimeStep = Box2D.Dynamics.b2TimeStep,
			b2World = Box2D.Dynamics.b2World,
			b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3,
			b2AABB = Box2D.Collision.b2AABB,
			b2Bound = Box2D.Collision.b2Bound,
			b2BoundValues = Box2D.Collision.b2BoundValues,
			b2Collision = Box2D.Collision.b2Collision,
			b2ContactID = Box2D.Collision.b2ContactID,
			b2ContactPoint = Box2D.Collision.b2ContactPoint,
			b2Distance = Box2D.Collision.b2Distance,
			b2DistanceInput = Box2D.Collision.b2DistanceInput,
			b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
			b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
			b2DynamicTree = Box2D.Collision.b2DynamicTree,
			b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
			b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
			b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
			b2Manifold = Box2D.Collision.b2Manifold,
			b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
			b2Point = Box2D.Collision.b2Point,
			b2RayCastInput = Box2D.Collision.b2RayCastInput,
			b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
			b2Segment = Box2D.Collision.b2Segment,
			b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
			b2Simplex = Box2D.Collision.b2Simplex,
			b2SimplexCache = Box2D.Collision.b2SimplexCache,
			b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
			b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
			b2TOIInput = Box2D.Collision.b2TOIInput,
			b2WorldManifold = Box2D.Collision.b2WorldManifold,
			ClipVertex = Box2D.Collision.ClipVertex,
			Features = Box2D.Collision.Features,
			IBroadPhase = Box2D.Collision.IBroadPhase;

		Box2D.inherit(b2CircleContact, Box2D.Dynamics.Contacts.b2Contact);
		b2CircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
		b2CircleContact.b2CircleContact = function ()
		{
			Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
		};
		b2CircleContact.Create = function (allocator)
		{
			return new b2CircleContact();
		}
		b2CircleContact.Destroy = function (contact, allocator)
		{
		}
		b2CircleContact.prototype.Reset = function (fixtureA, fixtureB)
		{
			this.__super.Reset.call(this, fixtureA, fixtureB);
		}
		b2CircleContact.prototype.Evaluate = function ()
		{
			var bA = this.m_fixtureA.GetBody();
			var bB = this.m_fixtureB.GetBody();
			b2Collision.CollideCircles(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2CircleShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
		}
		b2Contact.b2Contact = function ()
		{
			this.m_nodeA = new b2ContactEdge();
			this.m_nodeB = new b2ContactEdge();
			this.m_manifold = new b2Manifold();
			this.m_oldManifold = new b2Manifold();
		};
		b2Contact.prototype.GetManifold = function ()
		{
			return this.m_manifold;
		}
		b2Contact.prototype.GetWorldManifold = function (worldManifold)
		{
			var bodyA = this.m_fixtureA.GetBody();
			var bodyB = this.m_fixtureB.GetBody();
			var shapeA = this.m_fixtureA.GetShape();
			var shapeB = this.m_fixtureB.GetShape();
			worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
		}
		b2Contact.prototype.IsTouching = function ()
		{
			return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
		}
		b2Contact.prototype.IsContinuous = function ()
		{
			return (this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag;
		}
		b2Contact.prototype.SetSensor = function (sensor)
		{
			if (sensor)
			{
				this.m_flags |= b2Contact.e_sensorFlag;
			}
			else
			{
				this.m_flags &= ~b2Contact.e_sensorFlag;
			}
		}
		b2Contact.prototype.IsSensor = function ()
		{
			return (this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag;
		}
		b2Contact.prototype.SetEnabled = function (flag)
		{
			if (flag)
			{
				this.m_flags |= b2Contact.e_enabledFlag;
			}
			else
			{
				this.m_flags &= ~b2Contact.e_enabledFlag;
			}
		}
		b2Contact.prototype.IsEnabled = function ()
		{
			return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
		}
		b2Contact.prototype.GetNext = function ()
		{
			return this.m_next;
		}
		b2Contact.prototype.GetFixtureA = function ()
		{
			return this.m_fixtureA;
		}
		b2Contact.prototype.GetFixtureB = function ()
		{
			return this.m_fixtureB;
		}
		b2Contact.prototype.FlagForFiltering = function ()
		{
			this.m_flags |= b2Contact.e_filterFlag;
		}
		b2Contact.prototype.b2Contact = function ()
		{
		}
		b2Contact.prototype.Reset = function (fixtureA, fixtureB)
		{
			if (fixtureA === undefined) fixtureA = null;
			if (fixtureB === undefined) fixtureB = null;
			this.m_flags = b2Contact.e_enabledFlag;
			if (!fixtureA || !fixtureB)
			{
				this.m_fixtureA = null;
				this.m_fixtureB = null;
				return;
			}
			if (fixtureA.IsSensor() || fixtureB.IsSensor())
			{
				this.m_flags |= b2Contact.e_sensorFlag;
			}
			var bodyA = fixtureA.GetBody();
			var bodyB = fixtureB.GetBody();
			if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet())
			{
				this.m_flags |= b2Contact.e_continuousFlag;
			}
			this.m_fixtureA = fixtureA;
			this.m_fixtureB = fixtureB;
			this.m_manifold.m_pointCount = 0;
			this.m_prev = null;
			this.m_next = null;
			this.m_nodeA.contact = null;
			this.m_nodeA.prev = null;
			this.m_nodeA.next = null;
			this.m_nodeA.other = null;
			this.m_nodeB.contact = null;
			this.m_nodeB.prev = null;
			this.m_nodeB.next = null;
			this.m_nodeB.other = null;
		}
		b2Contact.prototype.Update = function (listener)
		{
			var tManifold = this.m_oldManifold;
			this.m_oldManifold = this.m_manifold;
			this.m_manifold = tManifold;
			this.m_flags |= b2Contact.e_enabledFlag;
			var touching = false;
			var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
			var bodyA = this.m_fixtureA.m_body;
			var bodyB = this.m_fixtureB.m_body;
			var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
			if (this.m_flags & b2Contact.e_sensorFlag)
			{
				if (aabbOverlap)
				{
					var shapeA = this.m_fixtureA.GetShape();
					var shapeB = this.m_fixtureB.GetShape();
					var xfA = bodyA.GetTransform();
					var xfB = bodyB.GetTransform();
					touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB);
				}
				this.m_manifold.m_pointCount = 0;
			}
			else
			{
				if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet())
				{
					this.m_flags |= b2Contact.e_continuousFlag;
				}
				else
				{
					this.m_flags &= ~b2Contact.e_continuousFlag;
				}
				if (aabbOverlap)
				{
					this.Evaluate();
					touching = this.m_manifold.m_pointCount > 0;
					for (var i = 0; i < this.m_manifold.m_pointCount; ++i)
					{
						var mp2 = this.m_manifold.m_points[i];
						mp2.m_normalImpulse = 0.0;
						mp2.m_tangentImpulse = 0.0;
						var id2 = mp2.m_id;
						for (var j = 0; j < this.m_oldManifold.m_pointCount; ++j)
						{
							var mp1 = this.m_oldManifold.m_points[j];
							if (mp1.m_id.key == id2.key)
							{
								mp2.m_normalImpulse = mp1.m_normalImpulse;
								mp2.m_tangentImpulse = mp1.m_tangentImpulse;
								break;
							}
						}
					}
				}
				else
				{
					this.m_manifold.m_pointCount = 0;
				}
				if (touching != wasTouching)
				{
					bodyA.SetAwake(true);
					bodyB.SetAwake(true);
				}
			}
			if (touching)
			{
				this.m_flags |= b2Contact.e_touchingFlag;
			}
			else
			{
				this.m_flags &= ~b2Contact.e_touchingFlag;
			}
			if (wasTouching == false && touching == true)
			{
				listener.BeginContact(this);
			}
			if (wasTouching == true && touching == false)
			{
				listener.EndContact(this);
			}
			if ((this.m_flags & b2Contact.e_sensorFlag) == 0)
			{
				listener.PreSolve(this, this.m_oldManifold);
			}
		}
		b2Contact.prototype.Evaluate = function ()
		{
		}
		b2Contact.prototype.ComputeTOI = function (sweepA, sweepB)
		{
			b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
			b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
			b2Contact.s_input.sweepA = sweepA;
			b2Contact.s_input.sweepB = sweepB;
			b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
			return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input);
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 0x0001;
			Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 0x0002;
			Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 0x0004;
			Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 0x0008;
			Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 0x0010;
			Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 0x0020;
			Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 0x0040;
			Box2D.Dynamics.Contacts.b2Contact.s_input = new b2TOIInput();
		});
		b2ContactConstraint.b2ContactConstraint = function ()
		{
			this.localPlaneNormal = new b2Vec2();
			this.localPoint = new b2Vec2();
			this.normal = new b2Vec2();
			this.normalMass = new b2Mat22();
			this.K = new b2Mat22();
		};
		b2ContactConstraint.prototype.b2ContactConstraint = function ()
		{
			this.points = new Vector(b2Settings.b2_maxManifoldPoints);
			for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++)
			{
				this.points[i] = new b2ContactConstraintPoint();
			}
		}
		b2ContactConstraintPoint.b2ContactConstraintPoint = function ()
		{
			this.localPoint = new b2Vec2();
			this.rA = new b2Vec2();
			this.rB = new b2Vec2();
		};
		b2ContactEdge.b2ContactEdge = function ()
		{
		};
		b2ContactFactory.b2ContactFactory = function ()
		{
		};
		b2ContactFactory.prototype.b2ContactFactory = function (allocator)
		{
			this.m_allocator = allocator;
			this.InitializeRegisters();
		}
		b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2)
		{
			if (type1 === undefined) type1 = 0;
			if (type2 === undefined) type2 = 0;
			this.m_registers[type1][type2].createFcn = createFcn;
			this.m_registers[type1][type2].destroyFcn = destroyFcn;
			this.m_registers[type1][type2].primary = true;
			if (type1 != type2)
			{
				this.m_registers[type2][type1].createFcn = createFcn;
				this.m_registers[type2][type1].destroyFcn = destroyFcn;
				this.m_registers[type2][type1].primary = false;
			}
		}
		b2ContactFactory.prototype.InitializeRegisters = function ()
		{
			this.m_registers = new Vector(b2Shape.e_shapeTypeCount);
			for (var i = 0; i < b2Shape.e_shapeTypeCount; i++)
			{
				this.m_registers[i] = new Vector(b2Shape.e_shapeTypeCount);
				for (var j = 0; j < b2Shape.e_shapeTypeCount; j++)
				{
					this.m_registers[i][j] = new b2ContactRegister();
				}
			}
			this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
			this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
			this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
			this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
			this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape);
		}
		b2ContactFactory.prototype.Create = function (fixtureA, fixtureB)
		{
			var type1 = parseInt(fixtureA.GetType());
			var type2 = parseInt(fixtureB.GetType());
			var reg = this.m_registers[type1][type2];
			var c;
			if (reg.pool)
			{
				c = reg.pool;
				reg.pool = c.m_next;
				reg.poolCount--;
				c.Reset(fixtureA, fixtureB);
				return c;
			}
			var createFcn = reg.createFcn;
			if (createFcn != null)
			{
				if (reg.primary)
				{
					c = createFcn(this.m_allocator);
					c.Reset(fixtureA, fixtureB);
					return c;
				}
				else
				{
					c = createFcn(this.m_allocator);
					c.Reset(fixtureB, fixtureA);
					return c;
				}
			}
			else
			{
				return null;
			}
		}
		b2ContactFactory.prototype.Destroy = function (contact)
		{
			if (contact.m_manifold.m_pointCount > 0)
			{
				contact.m_fixtureA.m_body.SetAwake(true);
				contact.m_fixtureB.m_body.SetAwake(true);
			}
			var type1 = parseInt(contact.m_fixtureA.GetType());
			var type2 = parseInt(contact.m_fixtureB.GetType());
			var reg = this.m_registers[type1][type2];
			if (true)
			{
				reg.poolCount++;
				contact.m_next = reg.pool;
				reg.pool = contact;
			}
			var destroyFcn = reg.destroyFcn;
			destroyFcn(contact, this.m_allocator);
		}
		b2ContactRegister.b2ContactRegister = function ()
		{
		};
		b2ContactResult.b2ContactResult = function ()
		{
			this.position = new b2Vec2();
			this.normal = new b2Vec2();
			this.id = new b2ContactID();
		};
		b2ContactSolver.b2ContactSolver = function ()
		{
			this.m_step = new b2TimeStep();
			this.m_constraints = new Vector();
		};
		b2ContactSolver.prototype.b2ContactSolver = function ()
		{
		}
		b2ContactSolver.prototype.Initialize = function (step, contacts, contactCount, allocator)
		{
			if (contactCount === undefined) contactCount = 0;
			var contact;
			this.m_step.Set(step);
			this.m_allocator = allocator;
			var i = 0;
			var tVec;
			var tMat;
			this.m_constraintCount = contactCount;
			while (this.m_constraints.length < this.m_constraintCount)
			{
				this.m_constraints[this.m_constraints.length] = new b2ContactConstraint();
			}
			for (i = 0;
			     i < contactCount; ++i)
			{
				contact = contacts[i];
				var fixtureA = contact.m_fixtureA;
				var fixtureB = contact.m_fixtureB;
				var shapeA = fixtureA.m_shape;
				var shapeB = fixtureB.m_shape;
				var radiusA = shapeA.m_radius;
				var radiusB = shapeB.m_radius;
				var bodyA = fixtureA.m_body;
				var bodyB = fixtureB.m_body;
				var manifold = contact.GetManifold();
				var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
				var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
				var vAX = bodyA.m_linearVelocity.x;
				var vAY = bodyA.m_linearVelocity.y;
				var vBX = bodyB.m_linearVelocity.x;
				var vBY = bodyB.m_linearVelocity.y;
				var wA = bodyA.m_angularVelocity;
				var wB = bodyB.m_angularVelocity;
				b2Settings.b2Assert(manifold.m_pointCount > 0);
				b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
				var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
				var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
				var cc = this.m_constraints[i];
				cc.bodyA = bodyA;
				cc.bodyB = bodyB;
				cc.manifold = manifold;
				cc.normal.x = normalX;
				cc.normal.y = normalY;
				cc.pointCount = manifold.m_pointCount;
				cc.friction = friction;
				cc.restitution = restitution;
				cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
				cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
				cc.localPoint.x = manifold.m_localPoint.x;
				cc.localPoint.y = manifold.m_localPoint.y;
				cc.radius = radiusA + radiusB;
				cc.type = manifold.m_type;
				for (var k = 0; k < cc.pointCount; ++k)
				{
					var cp = manifold.m_points[k];
					var ccp = cc.points[k];
					ccp.normalImpulse = cp.m_normalImpulse;
					ccp.tangentImpulse = cp.m_tangentImpulse;
					ccp.localPoint.SetV(cp.m_localPoint);
					var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
					var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
					var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
					var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
					var rnA = rAX * normalY - rAY * normalX;
					var rnB = rBX * normalY - rBY * normalX;
					rnA *= rnA;
					rnB *= rnB;
					var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
					ccp.normalMass = 1.0 / kNormal;
					var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
					kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
					ccp.equalizedMass = 1.0 / kEqualized;
					var tangentX = normalY;
					var tangentY = (-normalX);
					var rtA = rAX * tangentY - rAY * tangentX;
					var rtB = rBX * tangentY - rBY * tangentX;
					rtA *= rtA;
					rtB *= rtB;
					var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
					ccp.tangentMass = 1.0 / kTangent;
					ccp.velocityBias = 0.0;
					var tX = vBX + ((-wB * rBY)) - vAX - ((-wA * rAY));
					var tY = vBY + (wB * rBX) - vAY - (wA * rAX);
					var vRel = cc.normal.x * tX + cc.normal.y * tY;
					if (vRel < (-b2Settings.b2_velocityThreshold))
					{
						ccp.velocityBias += (-cc.restitution * vRel);
					}
				}
				if (cc.pointCount == 2)
				{
					var ccp1 = cc.points[0];
					var ccp2 = cc.points[1];
					var invMassA = bodyA.m_invMass;
					var invIA = bodyA.m_invI;
					var invMassB = bodyB.m_invMass;
					var invIB = bodyB.m_invI;
					var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
					var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
					var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
					var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
					var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
					var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
					var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
					var k_maxConditionNumber = 100.0;
					if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12))
					{
						cc.K.col1.Set(k11, k12);
						cc.K.col2.Set(k12, k22);
						cc.K.GetInverse(cc.normalMass);
					}
					else
					{
						cc.pointCount = 1;
					}
				}
			}
		}
		b2ContactSolver.prototype.InitVelocityConstraints = function (step)
		{
			var tVec;
			var tVec2;
			var tMat;
			for (var i = 0; i < this.m_constraintCount; ++i)
			{
				var c = this.m_constraints[i];
				var bodyA = c.bodyA;
				var bodyB = c.bodyB;
				var invMassA = bodyA.m_invMass;
				var invIA = bodyA.m_invI;
				var invMassB = bodyB.m_invMass;
				var invIB = bodyB.m_invI;
				var normalX = c.normal.x;
				var normalY = c.normal.y;
				var tangentX = normalY;
				var tangentY = (-normalX);
				var tX = 0;
				var j = 0;
				var tCount = 0;
				if (step.warmStarting)
				{
					tCount = c.pointCount;
					for (j = 0;
					     j < tCount; ++j)
					{
						var ccp = c.points[j];
						ccp.normalImpulse *= step.dtRatio;
						ccp.tangentImpulse *= step.dtRatio;
						var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
						var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
						bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
						bodyA.m_linearVelocity.x -= invMassA * PX;
						bodyA.m_linearVelocity.y -= invMassA * PY;
						bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
						bodyB.m_linearVelocity.x += invMassB * PX;
						bodyB.m_linearVelocity.y += invMassB * PY;
					}
				}
				else
				{
					tCount = c.pointCount;
					for (j = 0;
					     j < tCount; ++j)
					{
						var ccp2 = c.points[j];
						ccp2.normalImpulse = 0.0;
						ccp2.tangentImpulse = 0.0;
					}
				}
			}
		}
		b2ContactSolver.prototype.SolveVelocityConstraints = function ()
		{
			var j = 0;
			var ccp;
			var rAX = 0;
			var rAY = 0;
			var rBX = 0;
			var rBY = 0;
			var dvX = 0;
			var dvY = 0;
			var vn = 0;
			var vt = 0;
			var lambda = 0;
			var maxFriction = 0;
			var newImpulse = 0;
			var PX = 0;
			var PY = 0;
			var dX = 0;
			var dY = 0;
			var P1X = 0;
			var P1Y = 0;
			var P2X = 0;
			var P2Y = 0;
			var tMat;
			var tVec;
			for (var i = 0; i < this.m_constraintCount; ++i)
			{
				var c = this.m_constraints[i];
				var bodyA = c.bodyA;
				var bodyB = c.bodyB;
				var wA = bodyA.m_angularVelocity;
				var wB = bodyB.m_angularVelocity;
				var vA = bodyA.m_linearVelocity;
				var vB = bodyB.m_linearVelocity;
				var invMassA = bodyA.m_invMass;
				var invIA = bodyA.m_invI;
				var invMassB = bodyB.m_invMass;
				var invIB = bodyB.m_invI;
				var normalX = c.normal.x;
				var normalY = c.normal.y;
				var tangentX = normalY;
				var tangentY = (-normalX);
				var friction = c.friction;
				var tX = 0;
				for (j = 0;
				     j < c.pointCount; j++)
				{
					ccp = c.points[j];
					dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
					dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
					vt = dvX * tangentX + dvY * tangentY;
					lambda = ccp.tangentMass * (-vt);
					maxFriction = friction * ccp.normalImpulse;
					newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, (-maxFriction), maxFriction);
					lambda = newImpulse - ccp.tangentImpulse;
					PX = lambda * tangentX;
					PY = lambda * tangentY;
					vA.x -= invMassA * PX;
					vA.y -= invMassA * PY;
					wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
					vB.x += invMassB * PX;
					vB.y += invMassB * PY;
					wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
					ccp.tangentImpulse = newImpulse;
				}
				var tCount = parseInt(c.pointCount);
				if (c.pointCount == 1)
				{
					ccp = c.points[0];
					dvX = vB.x + ((-wB * ccp.rB.y)) - vA.x - ((-wA * ccp.rA.y));
					dvY = vB.y + (wB * ccp.rB.x) - vA.y - (wA * ccp.rA.x);
					vn = dvX * normalX + dvY * normalY;
					lambda = (-ccp.normalMass * (vn - ccp.velocityBias));
					newImpulse = ccp.normalImpulse + lambda;
					newImpulse = newImpulse > 0 ? newImpulse : 0.0;
					lambda = newImpulse - ccp.normalImpulse;
					PX = lambda * normalX;
					PY = lambda * normalY;
					vA.x -= invMassA * PX;
					vA.y -= invMassA * PY;
					wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
					vB.x += invMassB * PX;
					vB.y += invMassB * PY;
					wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
					ccp.normalImpulse = newImpulse;
				}
				else
				{
					var cp1 = c.points[0];
					var cp2 = c.points[1];
					var aX = cp1.normalImpulse;
					var aY = cp2.normalImpulse;
					var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
					var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
					var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
					var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
					var vn1 = dv1X * normalX + dv1Y * normalY;
					var vn2 = dv2X * normalX + dv2Y * normalY;
					var bX = vn1 - cp1.velocityBias;
					var bY = vn2 - cp2.velocityBias;
					tMat = c.K;
					bX -= tMat.col1.x * aX + tMat.col2.x * aY;
					bY -= tMat.col1.y * aX + tMat.col2.y * aY;
					var k_errorTol = 0.001;
					for (; ;)
					{
						tMat = c.normalMass;
						var xX = (-(tMat.col1.x * bX + tMat.col2.x * bY));
						var xY = (-(tMat.col1.y * bX + tMat.col2.y * bY));
						if (xX >= 0.0 && xY >= 0.0)
						{
							dX = xX - aX;
							dY = xY - aY;
							P1X = dX * normalX;
							P1Y = dX * normalY;
							P2X = dY * normalX;
							P2Y = dY * normalY;
							vA.x -= invMassA * (P1X + P2X);
							vA.y -= invMassA * (P1Y + P2Y);
							wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
							vB.x += invMassB * (P1X + P2X);
							vB.y += invMassB * (P1Y + P2Y);
							wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
							cp1.normalImpulse = xX;
							cp2.normalImpulse = xY;
							break;
						}
						xX = (-cp1.normalMass * bX);
						xY = 0.0;
						vn1 = 0.0;
						vn2 = c.K.col1.y * xX + bY;
						if (xX >= 0.0 && vn2 >= 0.0)
						{
							dX = xX - aX;
							dY = xY - aY;
							P1X = dX * normalX;
							P1Y = dX * normalY;
							P2X = dY * normalX;
							P2Y = dY * normalY;
							vA.x -= invMassA * (P1X + P2X);
							vA.y -= invMassA * (P1Y + P2Y);
							wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
							vB.x += invMassB * (P1X + P2X);
							vB.y += invMassB * (P1Y + P2Y);
							wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
							cp1.normalImpulse = xX;
							cp2.normalImpulse = xY;
							break;
						}
						xX = 0.0;
						xY = (-cp2.normalMass * bY);
						vn1 = c.K.col2.x * xY + bX;
						vn2 = 0.0;
						if (xY >= 0.0 && vn1 >= 0.0)
						{
							dX = xX - aX;
							dY = xY - aY;
							P1X = dX * normalX;
							P1Y = dX * normalY;
							P2X = dY * normalX;
							P2Y = dY * normalY;
							vA.x -= invMassA * (P1X + P2X);
							vA.y -= invMassA * (P1Y + P2Y);
							wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
							vB.x += invMassB * (P1X + P2X);
							vB.y += invMassB * (P1Y + P2Y);
							wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
							cp1.normalImpulse = xX;
							cp2.normalImpulse = xY;
							break;
						}
						xX = 0.0;
						xY = 0.0;
						vn1 = bX;
						vn2 = bY;
						if (vn1 >= 0.0 && vn2 >= 0.0)
						{
							dX = xX - aX;
							dY = xY - aY;
							P1X = dX * normalX;
							P1Y = dX * normalY;
							P2X = dY * normalX;
							P2Y = dY * normalY;
							vA.x -= invMassA * (P1X + P2X);
							vA.y -= invMassA * (P1Y + P2Y);
							wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
							vB.x += invMassB * (P1X + P2X);
							vB.y += invMassB * (P1Y + P2Y);
							wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
							cp1.normalImpulse = xX;
							cp2.normalImpulse = xY;
							break;
						}
						break;
					}
				}
				bodyA.m_angularVelocity = wA;
				bodyB.m_angularVelocity = wB;
			}
		}
		b2ContactSolver.prototype.FinalizeVelocityConstraints = function ()
		{
			for (var i = 0; i < this.m_constraintCount; ++i)
			{
				var c = this.m_constraints[i];
				var m = c.manifold;
				for (var j = 0; j < c.pointCount; ++j)
				{
					var point1 = m.m_points[j];
					var point2 = c.points[j];
					point1.m_normalImpulse = point2.normalImpulse;
					point1.m_tangentImpulse = point2.tangentImpulse;
				}
			}
		}
		b2ContactSolver.prototype.SolvePositionConstraints = function (baumgarte)
		{
			if (baumgarte === undefined) baumgarte = 0;
			var minSeparation = 0.0;
			for (var i = 0; i < this.m_constraintCount; i++)
			{
				var c = this.m_constraints[i];
				var bodyA = c.bodyA;
				var bodyB = c.bodyB;
				var invMassA = bodyA.m_mass * bodyA.m_invMass;
				var invIA = bodyA.m_mass * bodyA.m_invI;
				var invMassB = bodyB.m_mass * bodyB.m_invMass;
				var invIB = bodyB.m_mass * bodyB.m_invI;
				b2ContactSolver.s_psm.Initialize(c);
				var normal = b2ContactSolver.s_psm.m_normal;
				for (var j = 0; j < c.pointCount; j++)
				{
					var ccp = c.points[j];
					var point = b2ContactSolver.s_psm.m_points[j];
					var separation = b2ContactSolver.s_psm.m_separations[j];
					var rAX = point.x - bodyA.m_sweep.c.x;
					var rAY = point.y - bodyA.m_sweep.c.y;
					var rBX = point.x - bodyB.m_sweep.c.x;
					var rBY = point.y - bodyB.m_sweep.c.y;
					minSeparation = minSeparation < separation ? minSeparation : separation;
					var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), (-b2Settings.b2_maxLinearCorrection), 0.0);
					var impulse = (-ccp.equalizedMass * C);
					var PX = impulse * normal.x;
					var PY = impulse * normal.y;
					bodyA.m_sweep.c.x -= invMassA * PX;
					bodyA.m_sweep.c.y -= invMassA * PY;
					bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
					bodyA.SynchronizeTransform();
					bodyB.m_sweep.c.x += invMassB * PX;
					bodyB.m_sweep.c.y += invMassB * PY;
					bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
					bodyB.SynchronizeTransform();
				}
			}
			return minSeparation > (-1.5 * b2Settings.b2_linearSlop);
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new b2WorldManifold();
			Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new b2PositionSolverManifold();
		});
		Box2D.inherit(b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
		b2EdgeAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
		b2EdgeAndCircleContact.b2EdgeAndCircleContact = function ()
		{
			Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
		};
		b2EdgeAndCircleContact.Create = function (allocator)
		{
			return new b2EdgeAndCircleContact();
		}
		b2EdgeAndCircleContact.Destroy = function (contact, allocator)
		{
		}
		b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, fixtureB)
		{
			this.__super.Reset.call(this, fixtureA, fixtureB);
		}
		b2EdgeAndCircleContact.prototype.Evaluate = function ()
		{
			var bA = this.m_fixtureA.GetBody();
			var bB = this.m_fixtureB.GetBody();
			this.b2CollideEdgeAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2EdgeShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
		}
		b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function (manifold, edge, xf1, circle, xf2)
		{
		}
		Box2D.inherit(b2NullContact, Box2D.Dynamics.Contacts.b2Contact);
		b2NullContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
		b2NullContact.b2NullContact = function ()
		{
			Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
		};
		b2NullContact.prototype.b2NullContact = function ()
		{
			this.__super.b2Contact.call(this);
		}
		b2NullContact.prototype.Evaluate = function ()
		{
		}
		Box2D.inherit(b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
		b2PolyAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
		b2PolyAndCircleContact.b2PolyAndCircleContact = function ()
		{
			Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
		};
		b2PolyAndCircleContact.Create = function (allocator)
		{
			return new b2PolyAndCircleContact();
		}
		b2PolyAndCircleContact.Destroy = function (contact, allocator)
		{
		}
		b2PolyAndCircleContact.prototype.Reset = function (fixtureA, fixtureB)
		{
			this.__super.Reset.call(this, fixtureA, fixtureB);
			b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
			b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
		}
		b2PolyAndCircleContact.prototype.Evaluate = function ()
		{
			var bA = this.m_fixtureA.m_body;
			var bB = this.m_fixtureB.m_body;
			b2Collision.CollidePolygonAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
		}
		Box2D.inherit(b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2Contact);
		b2PolyAndEdgeContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
		b2PolyAndEdgeContact.b2PolyAndEdgeContact = function ()
		{
			Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
		};
		b2PolyAndEdgeContact.Create = function (allocator)
		{
			return new b2PolyAndEdgeContact();
		}
		b2PolyAndEdgeContact.Destroy = function (contact, allocator)
		{
		}
		b2PolyAndEdgeContact.prototype.Reset = function (fixtureA, fixtureB)
		{
			this.__super.Reset.call(this, fixtureA, fixtureB);
			b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
			b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape);
		}
		b2PolyAndEdgeContact.prototype.Evaluate = function ()
		{
			var bA = this.m_fixtureA.GetBody();
			var bB = this.m_fixtureB.GetBody();
			this.b2CollidePolyAndEdge(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2EdgeShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
		}
		b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function (manifold, polygon, xf1, edge, xf2)
		{
		}
		Box2D.inherit(b2PolygonContact, Box2D.Dynamics.Contacts.b2Contact);
		b2PolygonContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
		b2PolygonContact.b2PolygonContact = function ()
		{
			Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
		};
		b2PolygonContact.Create = function (allocator)
		{
			return new b2PolygonContact();
		}
		b2PolygonContact.Destroy = function (contact, allocator)
		{
		}
		b2PolygonContact.prototype.Reset = function (fixtureA, fixtureB)
		{
			this.__super.Reset.call(this, fixtureA, fixtureB);
		}
		b2PolygonContact.prototype.Evaluate = function ()
		{
			var bA = this.m_fixtureA.GetBody();
			var bB = this.m_fixtureB.GetBody();
			b2Collision.CollidePolygons(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2PolygonShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
		}
		b2PositionSolverManifold.b2PositionSolverManifold = function ()
		{
		};
		b2PositionSolverManifold.prototype.b2PositionSolverManifold = function ()
		{
			this.m_normal = new b2Vec2();
			this.m_separations = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
			this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
			for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++)
			{
				this.m_points[i] = new b2Vec2();
			}
		}
		b2PositionSolverManifold.prototype.Initialize = function (cc)
		{
			b2Settings.b2Assert(cc.pointCount > 0);
			var i = 0;
			var clipPointX = 0;
			var clipPointY = 0;
			var tMat;
			var tVec;
			var planePointX = 0;
			var planePointY = 0;
			switch (cc.type)
			{
				case b2Manifold.e_circles:
				{
					tMat = cc.bodyA.m_xf.R;
					tVec = cc.localPoint;
					var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					tMat = cc.bodyB.m_xf.R;
					tVec = cc.points[0].localPoint;
					var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					var dX = pointBX - pointAX;
					var dY = pointBY - pointAY;
					var d2 = dX * dX + dY * dY;
					if (d2 > Number.MIN_VALUE * Number.MIN_VALUE)
					{
						var d = Math.sqrt(d2);
						this.m_normal.x = dX / d;
						this.m_normal.y = dY / d;
					}
					else
					{
						this.m_normal.x = 1.0;
						this.m_normal.y = 0.0;
					}
					this.m_points[0].x = 0.5 * (pointAX + pointBX);
					this.m_points[0].y = 0.5 * (pointAY + pointBY);
					this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
				}
					break;
				case b2Manifold.e_faceA:
				{
					tMat = cc.bodyA.m_xf.R;
					tVec = cc.localPlaneNormal;
					this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					tMat = cc.bodyA.m_xf.R;
					tVec = cc.localPoint;
					planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					tMat = cc.bodyB.m_xf.R;
					for (i = 0;
					     i < cc.pointCount; ++i)
					{
						tVec = cc.points[i].localPoint;
						clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
						clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
						this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
						this.m_points[i].x = clipPointX;
						this.m_points[i].y = clipPointY;
					}
				}
					break;
				case b2Manifold.e_faceB:
				{
					tMat = cc.bodyB.m_xf.R;
					tVec = cc.localPlaneNormal;
					this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
					this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
					tMat = cc.bodyB.m_xf.R;
					tVec = cc.localPoint;
					planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
					planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
					tMat = cc.bodyA.m_xf.R;
					for (i = 0;
					     i < cc.pointCount; ++i)
					{
						tVec = cc.points[i].localPoint;
						clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
						clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
						this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
						this.m_points[i].Set(clipPointX, clipPointY);
					}
					this.m_normal.x *= (-1);
					this.m_normal.y *= (-1);
				}
					break;
			}
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new b2Vec2();
			Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new b2Vec2();
		});
	})();
	(function ()
	{
		var b2Body = Box2D.Dynamics.b2Body,
			b2BodyDef = Box2D.Dynamics.b2BodyDef,
			b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
			b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
			b2ContactListener = Box2D.Dynamics.b2ContactListener,
			b2ContactManager = Box2D.Dynamics.b2ContactManager,
			b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
			b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
			b2FilterData = Box2D.Dynamics.b2FilterData,
			b2Fixture = Box2D.Dynamics.b2Fixture,
			b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
			b2Island = Box2D.Dynamics.b2Island,
			b2TimeStep = Box2D.Dynamics.b2TimeStep,
			b2World = Box2D.Dynamics.b2World,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3,
			b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
			b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
			b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
			b2MassData = Box2D.Collision.Shapes.b2MassData,
			b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
			b2Shape = Box2D.Collision.Shapes.b2Shape,
			b2BuoyancyController = Box2D.Dynamics.Controllers.b2BuoyancyController,
			b2ConstantAccelController = Box2D.Dynamics.Controllers.b2ConstantAccelController,
			b2ConstantForceController = Box2D.Dynamics.Controllers.b2ConstantForceController,
			b2Controller = Box2D.Dynamics.Controllers.b2Controller,
			b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
			b2GravityController = Box2D.Dynamics.Controllers.b2GravityController,
			b2TensorDampingController = Box2D.Dynamics.Controllers.b2TensorDampingController;

		Box2D.inherit(b2BuoyancyController, Box2D.Dynamics.Controllers.b2Controller);
		b2BuoyancyController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
		b2BuoyancyController.b2BuoyancyController = function ()
		{
			Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
			this.normal = new b2Vec2(0, (-1));
			this.offset = 0;
			this.density = 0;
			this.velocity = new b2Vec2(0, 0);
			this.linearDrag = 2;
			this.angularDrag = 1;
			this.useDensity = false;
			this.useWorldGravity = true;
			this.gravity = null;
		};
		b2BuoyancyController.prototype.Step = function (step)
		{
			if (!this.m_bodyList) return;
			if (this.useWorldGravity)
			{
				this.gravity = this.GetWorld().GetGravity().Copy();
			}
			for (var i = this.m_bodyList; i; i = i.nextBody)
			{
				var body = i.body;
				if (body.IsAwake() == false)
				{
					continue;
				}
				var areac = new b2Vec2();
				var massc = new b2Vec2();
				var area = 0.0;
				var mass = 0.0;
				for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext())
				{
					var sc = new b2Vec2();
					var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
					area += sarea;
					areac.x += sarea * sc.x;
					areac.y += sarea * sc.y;
					var shapeDensity = 0;
					if (this.useDensity)
					{
						shapeDensity = 1;
					}
					else
					{
						shapeDensity = 1;
					}
					mass += sarea * shapeDensity;
					massc.x += sarea * sc.x * shapeDensity;
					massc.y += sarea * sc.y * shapeDensity;
				}
				areac.x /= area;
				areac.y /= area;
				massc.x /= mass;
				massc.y /= mass;
				if (area < Number.MIN_VALUE) continue;
				var buoyancyForce = this.gravity.GetNegative();
				buoyancyForce.Multiply(this.density * area);
				body.ApplyForce(buoyancyForce, massc);
				var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
				dragForce.Subtract(this.velocity);
				dragForce.Multiply((-this.linearDrag * area));
				body.ApplyForce(dragForce, areac);
				body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));
			}
		}
		b2BuoyancyController.prototype.Draw = function (debugDraw)
		{
			var r = 1000;
			var p1 = new b2Vec2();
			var p2 = new b2Vec2();
			p1.x = this.normal.x * this.offset + this.normal.y * r;
			p1.y = this.normal.y * this.offset - this.normal.x * r;
			p2.x = this.normal.x * this.offset - this.normal.y * r;
			p2.y = this.normal.y * this.offset + this.normal.x * r;
			var color = new b2Color(0, 0, 1);
			debugDraw.DrawSegment(p1, p2, color);
		}
		Box2D.inherit(b2ConstantAccelController, Box2D.Dynamics.Controllers.b2Controller);
		b2ConstantAccelController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
		b2ConstantAccelController.b2ConstantAccelController = function ()
		{
			Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
			this.A = new b2Vec2(0, 0);
		};
		b2ConstantAccelController.prototype.Step = function (step)
		{
			var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
			for (var i = this.m_bodyList; i; i = i.nextBody)
			{
				var body = i.body;
				if (!body.IsAwake()) continue;
				body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y));
			}
		}
		Box2D.inherit(b2ConstantForceController, Box2D.Dynamics.Controllers.b2Controller);
		b2ConstantForceController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
		b2ConstantForceController.b2ConstantForceController = function ()
		{
			Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
			this.F = new b2Vec2(0, 0);
		};
		b2ConstantForceController.prototype.Step = function (step)
		{
			for (var i = this.m_bodyList; i; i = i.nextBody)
			{
				var body = i.body;
				if (!body.IsAwake()) continue;
				body.ApplyForce(this.F, body.GetWorldCenter());
			}
		}
		b2Controller.b2Controller = function ()
		{
		};
		b2Controller.prototype.Step = function (step)
		{
		}
		b2Controller.prototype.Draw = function (debugDraw)
		{
		}
		b2Controller.prototype.AddBody = function (body)
		{
			var edge = new b2ControllerEdge();
			edge.controller = this;
			edge.body = body;
			edge.nextBody = this.m_bodyList;
			edge.prevBody = null;
			this.m_bodyList = edge;
			if (edge.nextBody) edge.nextBody.prevBody = edge;
			this.m_bodyCount++;
			edge.nextController = body.m_controllerList;
			edge.prevController = null;
			body.m_controllerList = edge;
			if (edge.nextController) edge.nextController.prevController = edge;
			body.m_controllerCount++;
		}
		b2Controller.prototype.RemoveBody = function (body)
		{
			var edge = body.m_controllerList;
			while (edge && edge.controller != this)
				edge = edge.nextController;
			if (edge.prevBody) edge.prevBody.nextBody = edge.nextBody;
			if (edge.nextBody) edge.nextBody.prevBody = edge.prevBody;
			if (edge.nextController) edge.nextController.prevController = edge.prevController;
			if (edge.prevController) edge.prevController.nextController = edge.nextController;
			if (this.m_bodyList == edge) this.m_bodyList = edge.nextBody;
			if (body.m_controllerList == edge) body.m_controllerList = edge.nextController;
			body.m_controllerCount--;
			this.m_bodyCount--;
		}
		b2Controller.prototype.Clear = function ()
		{
			while (this.m_bodyList)
				this.RemoveBody(this.m_bodyList.body);
		}
		b2Controller.prototype.GetNext = function ()
		{
			return this.m_next;
		}
		b2Controller.prototype.GetWorld = function ()
		{
			return this.m_world;
		}
		b2Controller.prototype.GetBodyList = function ()
		{
			return this.m_bodyList;
		}
		b2ControllerEdge.b2ControllerEdge = function ()
		{
		};
		Box2D.inherit(b2GravityController, Box2D.Dynamics.Controllers.b2Controller);
		b2GravityController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
		b2GravityController.b2GravityController = function ()
		{
			Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
			this.G = 1;
			this.invSqr = true;
		};
		b2GravityController.prototype.Step = function (step)
		{
			var i = null;
			var body1 = null;
			var p1 = null;
			var mass1 = 0;
			var j = null;
			var body2 = null;
			var p2 = null;
			var dx = 0;
			var dy = 0;
			var r2 = 0;
			var f = null;
			if (this.invSqr)
			{
				for (i = this.m_bodyList;
				     i; i = i.nextBody)
				{
					body1 = i.body;
					p1 = body1.GetWorldCenter();
					mass1 = body1.GetMass();
					for (j = this.m_bodyList;
					     j != i; j = j.nextBody)
					{
						body2 = j.body;
						p2 = body2.GetWorldCenter();
						dx = p2.x - p1.x;
						dy = p2.y - p1.y;
						r2 = dx * dx + dy * dy;
						if (r2 < Number.MIN_VALUE) continue;
						f = new b2Vec2(dx, dy);
						f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
						if (body1.IsAwake()) body1.ApplyForce(f, p1);
						f.Multiply((-1));
						if (body2.IsAwake()) body2.ApplyForce(f, p2);
					}
				}
			}
			else
			{
				for (i = this.m_bodyList;
				     i; i = i.nextBody)
				{
					body1 = i.body;
					p1 = body1.GetWorldCenter();
					mass1 = body1.GetMass();
					for (j = this.m_bodyList;
					     j != i; j = j.nextBody)
					{
						body2 = j.body;
						p2 = body2.GetWorldCenter();
						dx = p2.x - p1.x;
						dy = p2.y - p1.y;
						r2 = dx * dx + dy * dy;
						if (r2 < Number.MIN_VALUE) continue;
						f = new b2Vec2(dx, dy);
						f.Multiply(this.G / r2 * mass1 * body2.GetMass());
						if (body1.IsAwake()) body1.ApplyForce(f, p1);
						f.Multiply((-1));
						if (body2.IsAwake()) body2.ApplyForce(f, p2);
					}
				}
			}
		}
		Box2D.inherit(b2TensorDampingController, Box2D.Dynamics.Controllers.b2Controller);
		b2TensorDampingController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
		b2TensorDampingController.b2TensorDampingController = function ()
		{
			Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
			this.T = new b2Mat22();
			this.maxTimestep = 0;
		};
		b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping)
		{
			if (xDamping === undefined) xDamping = 0;
			if (yDamping === undefined) yDamping = 0;
			this.T.col1.x = (-xDamping);
			this.T.col1.y = 0;
			this.T.col2.x = 0;
			this.T.col2.y = (-yDamping);
			if (xDamping > 0 || yDamping > 0)
			{
				this.maxTimestep = 1 / Math.max(xDamping, yDamping);
			}
			else
			{
				this.maxTimestep = 0;
			}
		}
		b2TensorDampingController.prototype.Step = function (step)
		{
			var timestep = step.dt;
			if (timestep <= Number.MIN_VALUE) return;
			if (timestep > this.maxTimestep && this.maxTimestep > 0) timestep = this.maxTimestep;
			for (var i = this.m_bodyList; i; i = i.nextBody)
			{
				var body = i.body;
				if (!body.IsAwake())
				{
					continue;
				}
				var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
				body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep));
			}
		}
	})();
	(function ()
	{
		var b2Color = Box2D.Common.b2Color,
			b2internal = Box2D.Common.b2internal,
			b2Settings = Box2D.Common.b2Settings,
			b2Mat22 = Box2D.Common.Math.b2Mat22,
			b2Mat33 = Box2D.Common.Math.b2Mat33,
			b2Math = Box2D.Common.Math.b2Math,
			b2Sweep = Box2D.Common.Math.b2Sweep,
			b2Transform = Box2D.Common.Math.b2Transform,
			b2Vec2 = Box2D.Common.Math.b2Vec2,
			b2Vec3 = Box2D.Common.Math.b2Vec3,
			b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
			b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
			b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
			b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
			b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
			b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
			b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
			b2Joint = Box2D.Dynamics.Joints.b2Joint,
			b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
			b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
			b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
			b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
			b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
			b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
			b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
			b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
			b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
			b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
			b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
			b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
			b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
			b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef,
			b2Body = Box2D.Dynamics.b2Body,
			b2BodyDef = Box2D.Dynamics.b2BodyDef,
			b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
			b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
			b2ContactListener = Box2D.Dynamics.b2ContactListener,
			b2ContactManager = Box2D.Dynamics.b2ContactManager,
			b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
			b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
			b2FilterData = Box2D.Dynamics.b2FilterData,
			b2Fixture = Box2D.Dynamics.b2Fixture,
			b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
			b2Island = Box2D.Dynamics.b2Island,
			b2TimeStep = Box2D.Dynamics.b2TimeStep,
			b2World = Box2D.Dynamics.b2World;

		Box2D.inherit(b2DistanceJoint, Box2D.Dynamics.Joints.b2Joint);
		b2DistanceJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2DistanceJoint.b2DistanceJoint = function ()
		{
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.m_localAnchor1 = new b2Vec2();
			this.m_localAnchor2 = new b2Vec2();
			this.m_u = new b2Vec2();
		};
		b2DistanceJoint.prototype.GetAnchorA = function ()
		{
			return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
		}
		b2DistanceJoint.prototype.GetAnchorB = function ()
		{
			return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
		}
		b2DistanceJoint.prototype.GetReactionForce = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
		}
		b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return 0.0;
		}
		b2DistanceJoint.prototype.GetLength = function ()
		{
			return this.m_length;
		}
		b2DistanceJoint.prototype.SetLength = function (length)
		{
			if (length === undefined) length = 0;
			this.m_length = length;
		}
		b2DistanceJoint.prototype.GetFrequency = function ()
		{
			return this.m_frequencyHz;
		}
		b2DistanceJoint.prototype.SetFrequency = function (hz)
		{
			if (hz === undefined) hz = 0;
			this.m_frequencyHz = hz;
		}
		b2DistanceJoint.prototype.GetDampingRatio = function ()
		{
			return this.m_dampingRatio;
		}
		b2DistanceJoint.prototype.SetDampingRatio = function (ratio)
		{
			if (ratio === undefined) ratio = 0;
			this.m_dampingRatio = ratio;
		}
		b2DistanceJoint.prototype.b2DistanceJoint = function (def)
		{
			this.__super.b2Joint.call(this, def);
			var tMat;
			var tX = 0;
			var tY = 0;
			this.m_localAnchor1.SetV(def.localAnchorA);
			this.m_localAnchor2.SetV(def.localAnchorB);
			this.m_length = def.length;
			this.m_frequencyHz = def.frequencyHz;
			this.m_dampingRatio = def.dampingRatio;
			this.m_impulse = 0.0;
			this.m_gamma = 0.0;
			this.m_bias = 0.0;
		}
		b2DistanceJoint.prototype.InitVelocityConstraints = function (step)
		{
			var tMat;
			var tX = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
			this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
			var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
			if (length > b2Settings.b2_linearSlop)
			{
				this.m_u.Multiply(1.0 / length);
			}
			else
			{
				this.m_u.SetZero();
			}
			var cr1u = (r1X * this.m_u.y - r1Y * this.m_u.x);
			var cr2u = (r2X * this.m_u.y - r2Y * this.m_u.x);
			var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
			this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
			if (this.m_frequencyHz > 0.0)
			{
				var C = length - this.m_length;
				var omega = 2.0 * Math.PI * this.m_frequencyHz;
				var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;
				var k = this.m_mass * omega * omega;
				this.m_gamma = step.dt * (d + step.dt * k);
				this.m_gamma = this.m_gamma != 0.0 ? 1 / this.m_gamma : 0.0;
				this.m_bias = C * step.dt * k * this.m_gamma;
				this.m_mass = invMass + this.m_gamma;
				this.m_mass = this.m_mass != 0.0 ? 1.0 / this.m_mass : 0.0;
			}
			if (step.warmStarting)
			{
				this.m_impulse *= step.dtRatio;
				var PX = this.m_impulse * this.m_u.x;
				var PY = this.m_impulse * this.m_u.y;
				bA.m_linearVelocity.x -= bA.m_invMass * PX;
				bA.m_linearVelocity.y -= bA.m_invMass * PY;
				bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
				bB.m_linearVelocity.x += bB.m_invMass * PX;
				bB.m_linearVelocity.y += bB.m_invMass * PY;
				bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
			}
			else
			{
				this.m_impulse = 0.0;
			}
		}
		b2DistanceJoint.prototype.SolveVelocityConstraints = function (step)
		{
			var tMat;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
			var v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
			var v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
			var v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
			var Cdot = (this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y));
			var impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));
			this.m_impulse += impulse;
			var PX = impulse * this.m_u.x;
			var PY = impulse * this.m_u.y;
			bA.m_linearVelocity.x -= bA.m_invMass * PX;
			bA.m_linearVelocity.y -= bA.m_invMass * PY;
			bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
			bB.m_linearVelocity.x += bB.m_invMass * PX;
			bB.m_linearVelocity.y += bB.m_invMass * PY;
			bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
		}
		b2DistanceJoint.prototype.SolvePositionConstraints = function (baumgarte)
		{
			if (baumgarte === undefined) baumgarte = 0;
			var tMat;
			if (this.m_frequencyHz > 0.0)
			{
				return true;
			}
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
			var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
			var length = Math.sqrt(dX * dX + dY * dY);
			dX /= length;
			dY /= length;
			var C = length - this.m_length;
			C = b2Math.Clamp(C, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
			var impulse = (-this.m_mass * C);
			this.m_u.Set(dX, dY);
			var PX = impulse * this.m_u.x;
			var PY = impulse * this.m_u.y;
			bA.m_sweep.c.x -= bA.m_invMass * PX;
			bA.m_sweep.c.y -= bA.m_invMass * PY;
			bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
			bB.m_sweep.c.x += bB.m_invMass * PX;
			bB.m_sweep.c.y += bB.m_invMass * PY;
			bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
			bA.SynchronizeTransform();
			bB.SynchronizeTransform();
			return b2Math.Abs(C) < b2Settings.b2_linearSlop;
		}
		Box2D.inherit(b2DistanceJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2DistanceJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2DistanceJointDef.b2DistanceJointDef = function ()
		{
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.localAnchorA = new b2Vec2();
			this.localAnchorB = new b2Vec2();
		};
		b2DistanceJointDef.prototype.b2DistanceJointDef = function ()
		{
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_distanceJoint;
			this.length = 1.0;
			this.frequencyHz = 0.0;
			this.dampingRatio = 0.0;
		}
		b2DistanceJointDef.prototype.Initialize = function (bA, bB, anchorA, anchorB)
		{
			this.bodyA = bA;
			this.bodyB = bB;
			this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
			this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
			var dX = anchorB.x - anchorA.x;
			var dY = anchorB.y - anchorA.y;
			this.length = Math.sqrt(dX * dX + dY * dY);
			this.frequencyHz = 0.0;
			this.dampingRatio = 0.0;
		}
		Box2D.inherit(b2FrictionJoint, Box2D.Dynamics.Joints.b2Joint);
		b2FrictionJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2FrictionJoint.b2FrictionJoint = function ()
		{
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.m_localAnchorA = new b2Vec2();
			this.m_localAnchorB = new b2Vec2();
			this.m_linearMass = new b2Mat22();
			this.m_linearImpulse = new b2Vec2();
		};
		b2FrictionJoint.prototype.GetAnchorA = function ()
		{
			return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
		}
		b2FrictionJoint.prototype.GetAnchorB = function ()
		{
			return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
		}
		b2FrictionJoint.prototype.GetReactionForce = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
		}
		b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return inv_dt * this.m_angularImpulse;
		}
		b2FrictionJoint.prototype.SetMaxForce = function (force)
		{
			if (force === undefined) force = 0;
			this.m_maxForce = force;
		}
		b2FrictionJoint.prototype.GetMaxForce = function ()
		{
			return this.m_maxForce;
		}
		b2FrictionJoint.prototype.SetMaxTorque = function (torque)
		{
			if (torque === undefined) torque = 0;
			this.m_maxTorque = torque;
		}
		b2FrictionJoint.prototype.GetMaxTorque = function ()
		{
			return this.m_maxTorque;
		}
		b2FrictionJoint.prototype.b2FrictionJoint = function (def)
		{
			this.__super.b2Joint.call(this, def);
			this.m_localAnchorA.SetV(def.localAnchorA);
			this.m_localAnchorB.SetV(def.localAnchorB);
			this.m_linearMass.SetZero();
			this.m_angularMass = 0.0;
			this.m_linearImpulse.SetZero();
			this.m_angularImpulse = 0.0;
			this.m_maxForce = def.maxForce;
			this.m_maxTorque = def.maxTorque;
		}
		b2FrictionJoint.prototype.InitVelocityConstraints = function (step)
		{
			var tMat;
			var tX = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			tMat = bA.m_xf.R;
			var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
			var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
			rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
			rAX = tX;
			tMat = bB.m_xf.R;
			var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
			var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
			rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
			rBX = tX;
			var mA = bA.m_invMass;
			var mB = bB.m_invMass;
			var iA = bA.m_invI;
			var iB = bB.m_invI;
			var K = new b2Mat22();
			K.col1.x = mA + mB;
			K.col2.x = 0.0;
			K.col1.y = 0.0;
			K.col2.y = mA + mB;
			K.col1.x += iA * rAY * rAY;
			K.col2.x += (-iA * rAX * rAY);
			K.col1.y += (-iA * rAX * rAY);
			K.col2.y += iA * rAX * rAX;
			K.col1.x += iB * rBY * rBY;
			K.col2.x += (-iB * rBX * rBY);
			K.col1.y += (-iB * rBX * rBY);
			K.col2.y += iB * rBX * rBX;
			K.GetInverse(this.m_linearMass);
			this.m_angularMass = iA + iB;
			if (this.m_angularMass > 0.0)
			{
				this.m_angularMass = 1.0 / this.m_angularMass;
			}
			if (step.warmStarting)
			{
				this.m_linearImpulse.x *= step.dtRatio;
				this.m_linearImpulse.y *= step.dtRatio;
				this.m_angularImpulse *= step.dtRatio;
				var P = this.m_linearImpulse;
				bA.m_linearVelocity.x -= mA * P.x;
				bA.m_linearVelocity.y -= mA * P.y;
				bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
				bB.m_linearVelocity.x += mB * P.x;
				bB.m_linearVelocity.y += mB * P.y;
				bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse);
			}
			else
			{
				this.m_linearImpulse.SetZero();
				this.m_angularImpulse = 0.0;
			}
		}
		b2FrictionJoint.prototype.SolveVelocityConstraints = function (step)
		{
			var tMat;
			var tX = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var vA = bA.m_linearVelocity;
			var wA = bA.m_angularVelocity;
			var vB = bB.m_linearVelocity;
			var wB = bB.m_angularVelocity;
			var mA = bA.m_invMass;
			var mB = bB.m_invMass;
			var iA = bA.m_invI;
			var iB = bB.m_invI;
			tMat = bA.m_xf.R;
			var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
			var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
			rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
			rAX = tX;
			tMat = bB.m_xf.R;
			var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
			var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
			rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
			rBX = tX;
			var maxImpulse = 0;
			{
				var Cdot = wB - wA;
				var impulse = (-this.m_angularMass * Cdot);
				var oldImpulse = this.m_angularImpulse;
				maxImpulse = step.dt * this.m_maxTorque;
				this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);
				impulse = this.m_angularImpulse - oldImpulse;
				wA -= iA * impulse;
				wB += iB * impulse;
			}
			{
				var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
				var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
				var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2((-CdotX), (-CdotY)));
				var oldImpulseV = this.m_linearImpulse.Copy();
				this.m_linearImpulse.Add(impulseV);
				maxImpulse = step.dt * this.m_maxForce;
				if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse)
				{
					this.m_linearImpulse.Normalize();
					this.m_linearImpulse.Multiply(maxImpulse);
				}
				impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
				vA.x -= mA * impulseV.x;
				vA.y -= mA * impulseV.y;
				wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
				vB.x += mB * impulseV.x;
				vB.y += mB * impulseV.y;
				wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
			}
			bA.m_angularVelocity = wA;
			bB.m_angularVelocity = wB;
		}
		b2FrictionJoint.prototype.SolvePositionConstraints = function (baumgarte)
		{
			if (baumgarte === undefined) baumgarte = 0;
			return true;
		}
		Box2D.inherit(b2FrictionJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2FrictionJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2FrictionJointDef.b2FrictionJointDef = function ()
		{
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.localAnchorA = new b2Vec2();
			this.localAnchorB = new b2Vec2();
		};
		b2FrictionJointDef.prototype.b2FrictionJointDef = function ()
		{
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_frictionJoint;
			this.maxForce = 0.0;
			this.maxTorque = 0.0;
		}
		b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor)
		{
			this.bodyA = bA;
			this.bodyB = bB;
			this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
			this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
		}
		Box2D.inherit(b2GearJoint, Box2D.Dynamics.Joints.b2Joint);
		b2GearJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2GearJoint.b2GearJoint = function ()
		{
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.m_groundAnchor1 = new b2Vec2();
			this.m_groundAnchor2 = new b2Vec2();
			this.m_localAnchor1 = new b2Vec2();
			this.m_localAnchor2 = new b2Vec2();
			this.m_J = new b2Jacobian();
		};
		b2GearJoint.prototype.GetAnchorA = function ()
		{
			return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
		}
		b2GearJoint.prototype.GetAnchorB = function ()
		{
			return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
		}
		b2GearJoint.prototype.GetReactionForce = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y);
		}
		b2GearJoint.prototype.GetReactionTorque = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			var tMat = this.m_bodyB.m_xf.R;
			var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
			var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
			var tX = tMat.col1.x * rX + tMat.col2.x * rY;
			rY = tMat.col1.y * rX + tMat.col2.y * rY;
			rX = tX;
			var PX = this.m_impulse * this.m_J.linearB.x;
			var PY = this.m_impulse * this.m_J.linearB.y;
			return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX);
		}
		b2GearJoint.prototype.GetRatio = function ()
		{
			return this.m_ratio;
		}
		b2GearJoint.prototype.SetRatio = function (ratio)
		{
			if (ratio === undefined) ratio = 0;
			this.m_ratio = ratio;
		}
		b2GearJoint.prototype.b2GearJoint = function (def)
		{
			this.__super.b2Joint.call(this, def);
			var type1 = parseInt(def.joint1.m_type);
			var type2 = parseInt(def.joint2.m_type);
			this.m_revolute1 = null;
			this.m_prismatic1 = null;
			this.m_revolute2 = null;
			this.m_prismatic2 = null;
			var coordinate1 = 0;
			var coordinate2 = 0;
			this.m_ground1 = def.joint1.GetBodyA();
			this.m_bodyA = def.joint1.GetBodyB();
			if (type1 == b2Joint.e_revoluteJoint)
			{
				this.m_revolute1 = (def.joint1 instanceof b2RevoluteJoint ? def.joint1 : null);
				this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
				this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
				coordinate1 = this.m_revolute1.GetJointAngle();
			}
			else
			{
				this.m_prismatic1 = (def.joint1 instanceof b2PrismaticJoint ? def.joint1 : null);
				this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
				this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
				coordinate1 = this.m_prismatic1.GetJointTranslation();
			}
			this.m_ground2 = def.joint2.GetBodyA();
			this.m_bodyB = def.joint2.GetBodyB();
			if (type2 == b2Joint.e_revoluteJoint)
			{
				this.m_revolute2 = (def.joint2 instanceof b2RevoluteJoint ? def.joint2 : null);
				this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
				this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
				coordinate2 = this.m_revolute2.GetJointAngle();
			}
			else
			{
				this.m_prismatic2 = (def.joint2 instanceof b2PrismaticJoint ? def.joint2 : null);
				this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
				this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
				coordinate2 = this.m_prismatic2.GetJointTranslation();
			}
			this.m_ratio = def.ratio;
			this.m_constant = coordinate1 + this.m_ratio * coordinate2;
			this.m_impulse = 0.0;
		}
		b2GearJoint.prototype.InitVelocityConstraints = function (step)
		{
			var g1 = this.m_ground1;
			var g2 = this.m_ground2;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var ugX = 0;
			var ugY = 0;
			var rX = 0;
			var rY = 0;
			var tMat;
			var tVec;
			var crug = 0;
			var tX = 0;
			var K = 0.0;
			this.m_J.SetZero();
			if (this.m_revolute1)
			{
				this.m_J.angularA = (-1.0);
				K += bA.m_invI;
			}
			else
			{
				tMat = g1.m_xf.R;
				tVec = this.m_prismatic1.m_localXAxis1;
				ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
				ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
				tMat = bA.m_xf.R;
				rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
				rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
				tX = tMat.col1.x * rX + tMat.col2.x * rY;
				rY = tMat.col1.y * rX + tMat.col2.y * rY;
				rX = tX;
				crug = rX * ugY - rY * ugX;
				this.m_J.linearA.Set((-ugX), (-ugY));
				this.m_J.angularA = (-crug);
				K += bA.m_invMass + bA.m_invI * crug * crug;
			}
			if (this.m_revolute2)
			{
				this.m_J.angularB = (-this.m_ratio);
				K += this.m_ratio * this.m_ratio * bB.m_invI;
			}
			else
			{
				tMat = g2.m_xf.R;
				tVec = this.m_prismatic2.m_localXAxis1;
				ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
				ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
				tMat = bB.m_xf.R;
				rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
				rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
				tX = tMat.col1.x * rX + tMat.col2.x * rY;
				rY = tMat.col1.y * rX + tMat.col2.y * rY;
				rX = tX;
				crug = rX * ugY - rY * ugX;
				this.m_J.linearB.Set((-this.m_ratio * ugX), (-this.m_ratio * ugY));
				this.m_J.angularB = (-this.m_ratio * crug);
				K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug);
			}
			this.m_mass = K > 0.0 ? 1.0 / K : 0.0;
			if (step.warmStarting)
			{
				bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
				bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
				bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
				bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
				bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
				bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB;
			}
			else
			{
				this.m_impulse = 0.0;
			}
		}
		b2GearJoint.prototype.SolveVelocityConstraints = function (step)
		{
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
			var impulse = (-this.m_mass * Cdot);
			this.m_impulse += impulse;
			bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
			bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
			bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
			bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
			bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
			bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB;
		}
		b2GearJoint.prototype.SolvePositionConstraints = function (baumgarte)
		{
			if (baumgarte === undefined) baumgarte = 0;
			var linearError = 0.0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var coordinate1 = 0;
			var coordinate2 = 0;
			if (this.m_revolute1)
			{
				coordinate1 = this.m_revolute1.GetJointAngle();
			}
			else
			{
				coordinate1 = this.m_prismatic1.GetJointTranslation();
			}
			if (this.m_revolute2)
			{
				coordinate2 = this.m_revolute2.GetJointAngle();
			}
			else
			{
				coordinate2 = this.m_prismatic2.GetJointTranslation();
			}
			var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
			var impulse = (-this.m_mass * C);
			bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
			bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
			bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
			bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
			bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
			bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
			bA.SynchronizeTransform();
			bB.SynchronizeTransform();
			return linearError < b2Settings.b2_linearSlop;
		}
		Box2D.inherit(b2GearJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2GearJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2GearJointDef.b2GearJointDef = function ()
		{
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
		};
		b2GearJointDef.prototype.b2GearJointDef = function ()
		{
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_gearJoint;
			this.joint1 = null;
			this.joint2 = null;
			this.ratio = 1.0;
		}
		b2Jacobian.b2Jacobian = function ()
		{
			this.linearA = new b2Vec2();
			this.linearB = new b2Vec2();
		};
		b2Jacobian.prototype.SetZero = function ()
		{
			this.linearA.SetZero();
			this.angularA = 0.0;
			this.linearB.SetZero();
			this.angularB = 0.0;
		}
		b2Jacobian.prototype.Set = function (x1, a1, x2, a2)
		{
			if (a1 === undefined) a1 = 0;
			if (a2 === undefined) a2 = 0;
			this.linearA.SetV(x1);
			this.angularA = a1;
			this.linearB.SetV(x2);
			this.angularB = a2;
		}
		b2Jacobian.prototype.Compute = function (x1, a1, x2, a2)
		{
			if (a1 === undefined) a1 = 0;
			if (a2 === undefined) a2 = 0;
			return (this.linearA.x * x1.x + this.linearA.y * x1.y) + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2;
		}
		b2Joint.b2Joint = function ()
		{
			this.m_edgeA = new b2JointEdge();
			this.m_edgeB = new b2JointEdge();
			this.m_localCenterA = new b2Vec2();
			this.m_localCenterB = new b2Vec2();
		};
		b2Joint.prototype.GetType = function ()
		{
			return this.m_type;
		}
		b2Joint.prototype.GetAnchorA = function ()
		{
			return null;
		}
		b2Joint.prototype.GetAnchorB = function ()
		{
			return null;
		}
		b2Joint.prototype.GetReactionForce = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return null;
		}
		b2Joint.prototype.GetReactionTorque = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return 0.0;
		}
		b2Joint.prototype.GetBodyA = function ()
		{
			return this.m_bodyA;
		}
		b2Joint.prototype.GetBodyB = function ()
		{
			return this.m_bodyB;
		}
		b2Joint.prototype.GetNext = function ()
		{
			return this.m_next;
		}
		b2Joint.prototype.GetUserData = function ()
		{
			return this.m_userData;
		}
		b2Joint.prototype.SetUserData = function (data)
		{
			this.m_userData = data;
		}
		b2Joint.prototype.IsActive = function ()
		{
			return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
		}
		b2Joint.Create = function (def, allocator)
		{
			var joint = null;
			switch (def.type)
			{
				case b2Joint.e_distanceJoint:
				{
					joint = new b2DistanceJoint((def instanceof b2DistanceJointDef ? def : null));
				}
					break;
				case b2Joint.e_mouseJoint:
				{
					joint = new b2MouseJoint((def instanceof b2MouseJointDef ? def : null));
				}
					break;
				case b2Joint.e_prismaticJoint:
				{
					joint = new b2PrismaticJoint((def instanceof b2PrismaticJointDef ? def : null));
				}
					break;
				case b2Joint.e_revoluteJoint:
				{
					joint = new b2RevoluteJoint((def instanceof b2RevoluteJointDef ? def : null));
				}
					break;
				case b2Joint.e_pulleyJoint:
				{
					joint = new b2PulleyJoint((def instanceof b2PulleyJointDef ? def : null));
				}
					break;
				case b2Joint.e_gearJoint:
				{
					joint = new b2GearJoint((def instanceof b2GearJointDef ? def : null));
				}
					break;
				case b2Joint.e_lineJoint:
				{
					joint = new b2LineJoint((def instanceof b2LineJointDef ? def : null));
				}
					break;
				case b2Joint.e_weldJoint:
				{
					joint = new b2WeldJoint((def instanceof b2WeldJointDef ? def : null));
				}
					break;
				case b2Joint.e_frictionJoint:
				{
					joint = new b2FrictionJoint((def instanceof b2FrictionJointDef ? def : null));
				}
					break;
				default:
					break;
			}
			return joint;
		}
		b2Joint.Destroy = function (joint, allocator)
		{
		}
		b2Joint.prototype.b2Joint = function (def)
		{
			b2Settings.b2Assert(def.bodyA != def.bodyB);
			this.m_type = def.type;
			this.m_prev = null;
			this.m_next = null;
			this.m_bodyA = def.bodyA;
			this.m_bodyB = def.bodyB;
			this.m_collideConnected = def.collideConnected;
			this.m_islandFlag = false;
			this.m_userData = def.userData;
		}
		b2Joint.prototype.InitVelocityConstraints = function (step)
		{
		}
		b2Joint.prototype.SolveVelocityConstraints = function (step)
		{
		}
		b2Joint.prototype.FinalizeVelocityConstraints = function ()
		{
		}
		b2Joint.prototype.SolvePositionConstraints = function (baumgarte)
		{
			if (baumgarte === undefined) baumgarte = 0;
			return false;
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;
			Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;
			Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
			Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
			Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
			Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
			Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
			Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
			Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
			Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
			Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
			Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;
			Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;
			Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;
		});
		b2JointDef.b2JointDef = function ()
		{
		};
		b2JointDef.prototype.b2JointDef = function ()
		{
			this.type = b2Joint.e_unknownJoint;
			this.userData = null;
			this.bodyA = null;
			this.bodyB = null;
			this.collideConnected = false;
		}
		b2JointEdge.b2JointEdge = function ()
		{
		};
		Box2D.inherit(b2LineJoint, Box2D.Dynamics.Joints.b2Joint);
		b2LineJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2LineJoint.b2LineJoint = function ()
		{
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.m_localAnchor1 = new b2Vec2();
			this.m_localAnchor2 = new b2Vec2();
			this.m_localXAxis1 = new b2Vec2();
			this.m_localYAxis1 = new b2Vec2();
			this.m_axis = new b2Vec2();
			this.m_perp = new b2Vec2();
			this.m_K = new b2Mat22();
			this.m_impulse = new b2Vec2();
		};
		b2LineJoint.prototype.GetAnchorA = function ()
		{
			return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
		}
		b2LineJoint.prototype.GetAnchorB = function ()
		{
			return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
		}
		b2LineJoint.prototype.GetReactionForce = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
		}
		b2LineJoint.prototype.GetReactionTorque = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return inv_dt * this.m_impulse.y;
		}
		b2LineJoint.prototype.GetJointTranslation = function ()
		{
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			var p1 = bA.GetWorldPoint(this.m_localAnchor1);
			var p2 = bB.GetWorldPoint(this.m_localAnchor2);
			var dX = p2.x - p1.x;
			var dY = p2.y - p1.y;
			var axis = bA.GetWorldVector(this.m_localXAxis1);
			var translation = axis.x * dX + axis.y * dY;
			return translation;
		}
		b2LineJoint.prototype.GetJointSpeed = function ()
		{
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var p1X = bA.m_sweep.c.x + r1X;
			var p1Y = bA.m_sweep.c.y + r1Y;
			var p2X = bB.m_sweep.c.x + r2X;
			var p2Y = bB.m_sweep.c.y + r2Y;
			var dX = p2X - p1X;
			var dY = p2Y - p1Y;
			var axis = bA.GetWorldVector(this.m_localXAxis1);
			var v1 = bA.m_linearVelocity;
			var v2 = bB.m_linearVelocity;
			var w1 = bA.m_angularVelocity;
			var w2 = bB.m_angularVelocity;
			var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
			return speed;
		}
		b2LineJoint.prototype.IsLimitEnabled = function ()
		{
			return this.m_enableLimit;
		}
		b2LineJoint.prototype.EnableLimit = function (flag)
		{
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_enableLimit = flag;
		}
		b2LineJoint.prototype.GetLowerLimit = function ()
		{
			return this.m_lowerTranslation;
		}
		b2LineJoint.prototype.GetUpperLimit = function ()
		{
			return this.m_upperTranslation;
		}
		b2LineJoint.prototype.SetLimits = function (lower, upper)
		{
			if (lower === undefined) lower = 0;
			if (upper === undefined) upper = 0;
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_lowerTranslation = lower;
			this.m_upperTranslation = upper;
		}
		b2LineJoint.prototype.IsMotorEnabled = function ()
		{
			return this.m_enableMotor;
		}
		b2LineJoint.prototype.EnableMotor = function (flag)
		{
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_enableMotor = flag;
		}
		b2LineJoint.prototype.SetMotorSpeed = function (speed)
		{
			if (speed === undefined) speed = 0;
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_motorSpeed = speed;
		}
		b2LineJoint.prototype.GetMotorSpeed = function ()
		{
			return this.m_motorSpeed;
		}
		b2LineJoint.prototype.SetMaxMotorForce = function (force)
		{
			if (force === undefined) force = 0;
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_maxMotorForce = force;
		}
		b2LineJoint.prototype.GetMaxMotorForce = function ()
		{
			return this.m_maxMotorForce;
		}
		b2LineJoint.prototype.GetMotorForce = function ()
		{
			return this.m_motorImpulse;
		}
		b2LineJoint.prototype.b2LineJoint = function (def)
		{
			this.__super.b2Joint.call(this, def);
			var tMat;
			var tX = 0;
			var tY = 0;
			this.m_localAnchor1.SetV(def.localAnchorA);
			this.m_localAnchor2.SetV(def.localAnchorB);
			this.m_localXAxis1.SetV(def.localAxisA);
			this.m_localYAxis1.x = (-this.m_localXAxis1.y);
			this.m_localYAxis1.y = this.m_localXAxis1.x;
			this.m_impulse.SetZero();
			this.m_motorMass = 0.0;
			this.m_motorImpulse = 0.0;
			this.m_lowerTranslation = def.lowerTranslation;
			this.m_upperTranslation = def.upperTranslation;
			this.m_maxMotorForce = def.maxMotorForce;
			this.m_motorSpeed = def.motorSpeed;
			this.m_enableLimit = def.enableLimit;
			this.m_enableMotor = def.enableMotor;
			this.m_limitState = b2Joint.e_inactiveLimit;
			this.m_axis.SetZero();
			this.m_perp.SetZero();
		}
		b2LineJoint.prototype.InitVelocityConstraints = function (step)
		{
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			var tX = 0;
			this.m_localCenterA.SetV(bA.GetLocalCenter());
			this.m_localCenterB.SetV(bB.GetLocalCenter());
			var xf1 = bA.GetTransform();
			var xf2 = bB.GetTransform();
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
			var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
			tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
			var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
			var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
			this.m_invMassA = bA.m_invMass;
			this.m_invMassB = bB.m_invMass;
			this.m_invIA = bA.m_invI;
			this.m_invIB = bB.m_invI;
			{
				this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
				this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
				this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
				this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
				this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1.0 / this.m_motorMass : 0.0;
			}
			{
				this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
				this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
				this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
				var m1 = this.m_invMassA;
				var m2 = this.m_invMassB;
				var i1 = this.m_invIA;
				var i2 = this.m_invIB;
				this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
				this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
				this.m_K.col2.x = this.m_K.col1.y;
				this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
			}
			if (this.m_enableLimit)
			{
				var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
				if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop)
				{
					this.m_limitState = b2Joint.e_equalLimits;
				}
				else if (jointTransition <= this.m_lowerTranslation)
				{
					if (this.m_limitState != b2Joint.e_atLowerLimit)
					{
						this.m_limitState = b2Joint.e_atLowerLimit;
						this.m_impulse.y = 0.0;
					}
				}
				else if (jointTransition >= this.m_upperTranslation)
				{
					if (this.m_limitState != b2Joint.e_atUpperLimit)
					{
						this.m_limitState = b2Joint.e_atUpperLimit;
						this.m_impulse.y = 0.0;
					}
				}
				else
				{
					this.m_limitState = b2Joint.e_inactiveLimit;
					this.m_impulse.y = 0.0;
				}
			}
			else
			{
				this.m_limitState = b2Joint.e_inactiveLimit;
			}
			if (this.m_enableMotor == false)
			{
				this.m_motorImpulse = 0.0;
			}
			if (step.warmStarting)
			{
				this.m_impulse.x *= step.dtRatio;
				this.m_impulse.y *= step.dtRatio;
				this.m_motorImpulse *= step.dtRatio;
				var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
				var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
				var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
				var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
				bA.m_linearVelocity.x -= this.m_invMassA * PX;
				bA.m_linearVelocity.y -= this.m_invMassA * PY;
				bA.m_angularVelocity -= this.m_invIA * L1;
				bB.m_linearVelocity.x += this.m_invMassB * PX;
				bB.m_linearVelocity.y += this.m_invMassB * PY;
				bB.m_angularVelocity += this.m_invIB * L2;
			}
			else
			{
				this.m_impulse.SetZero();
				this.m_motorImpulse = 0.0;
			}
		}
		b2LineJoint.prototype.SolveVelocityConstraints = function (step)
		{
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var v1 = bA.m_linearVelocity;
			var w1 = bA.m_angularVelocity;
			var v2 = bB.m_linearVelocity;
			var w2 = bB.m_angularVelocity;
			var PX = 0;
			var PY = 0;
			var L1 = 0;
			var L2 = 0;
			if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits)
			{
				var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
				var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
				var oldImpulse = this.m_motorImpulse;
				var maxImpulse = step.dt * this.m_maxMotorForce;
				this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
				impulse = this.m_motorImpulse - oldImpulse;
				PX = impulse * this.m_axis.x;
				PY = impulse * this.m_axis.y;
				L1 = impulse * this.m_a1;
				L2 = impulse * this.m_a2;
				v1.x -= this.m_invMassA * PX;
				v1.y -= this.m_invMassA * PY;
				w1 -= this.m_invIA * L1;
				v2.x += this.m_invMassB * PX;
				v2.y += this.m_invMassB * PY;
				w2 += this.m_invIB * L2;
			}
			var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
			if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit)
			{
				var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
				var f1 = this.m_impulse.Copy();
				var df = this.m_K.Solve(new b2Vec2(), (-Cdot1), (-Cdot2));
				this.m_impulse.Add(df);
				if (this.m_limitState == b2Joint.e_atLowerLimit)
				{
					this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0.0);
				}
				else if (this.m_limitState == b2Joint.e_atUpperLimit)
				{
					this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0.0);
				}
				var b = (-Cdot1) - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
				var f2r = 0;
				if (this.m_K.col1.x != 0.0)
				{
					f2r = b / this.m_K.col1.x + f1.x;
				}
				else
				{
					f2r = f1.x;
				}
				this.m_impulse.x = f2r;
				df.x = this.m_impulse.x - f1.x;
				df.y = this.m_impulse.y - f1.y;
				PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
				PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
				L1 = df.x * this.m_s1 + df.y * this.m_a1;
				L2 = df.x * this.m_s2 + df.y * this.m_a2;
				v1.x -= this.m_invMassA * PX;
				v1.y -= this.m_invMassA * PY;
				w1 -= this.m_invIA * L1;
				v2.x += this.m_invMassB * PX;
				v2.y += this.m_invMassB * PY;
				w2 += this.m_invIB * L2;
			}
			else
			{
				var df2 = 0;
				if (this.m_K.col1.x != 0.0)
				{
					df2 = ((-Cdot1)) / this.m_K.col1.x;
				}
				else
				{
					df2 = 0.0;
				}
				this.m_impulse.x += df2;
				PX = df2 * this.m_perp.x;
				PY = df2 * this.m_perp.y;
				L1 = df2 * this.m_s1;
				L2 = df2 * this.m_s2;
				v1.x -= this.m_invMassA * PX;
				v1.y -= this.m_invMassA * PY;
				w1 -= this.m_invIA * L1;
				v2.x += this.m_invMassB * PX;
				v2.y += this.m_invMassB * PY;
				w2 += this.m_invIB * L2;
			}
			bA.m_linearVelocity.SetV(v1);
			bA.m_angularVelocity = w1;
			bB.m_linearVelocity.SetV(v2);
			bB.m_angularVelocity = w2;
		}
		b2LineJoint.prototype.SolvePositionConstraints = function (baumgarte)
		{
			if (baumgarte === undefined) baumgarte = 0;
			var limitC = 0;
			var oldLimitImpulse = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var c1 = bA.m_sweep.c;
			var a1 = bA.m_sweep.a;
			var c2 = bB.m_sweep.c;
			var a2 = bB.m_sweep.a;
			var tMat;
			var tX = 0;
			var m1 = 0;
			var m2 = 0;
			var i1 = 0;
			var i2 = 0;
			var linearError = 0.0;
			var angularError = 0.0;
			var active = false;
			var C2 = 0.0;
			var R1 = b2Mat22.FromAngle(a1);
			var R2 = b2Mat22.FromAngle(a2);
			tMat = R1;
			var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
			var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
			tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = R2;
			var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
			var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var dX = c2.x + r2X - c1.x - r1X;
			var dY = c2.y + r2Y - c1.y - r1Y;
			if (this.m_enableLimit)
			{
				this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
				this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
				this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
				var translation = this.m_axis.x * dX + this.m_axis.y * dY;
				if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop)
				{
					C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
					linearError = b2Math.Abs(translation);
					active = true;
				}
				else if (translation <= this.m_lowerTranslation)
				{
					C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
					linearError = this.m_lowerTranslation - translation;
					active = true;
				}
				else if (translation >= this.m_upperTranslation)
				{
					C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
					linearError = translation - this.m_upperTranslation;
					active = true;
				}
			}
			this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
			this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
			this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
			var impulse = new b2Vec2();
			var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
			linearError = b2Math.Max(linearError, b2Math.Abs(C1));
			angularError = 0.0;
			if (active)
			{
				m1 = this.m_invMassA;
				m2 = this.m_invMassB;
				i1 = this.m_invIA;
				i2 = this.m_invIB;
				this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
				this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
				this.m_K.col2.x = this.m_K.col1.y;
				this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
				this.m_K.Solve(impulse, (-C1), (-C2));
			}
			else
			{
				m1 = this.m_invMassA;
				m2 = this.m_invMassB;
				i1 = this.m_invIA;
				i2 = this.m_invIB;
				var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
				var impulse1 = 0;
				if (k11 != 0.0)
				{
					impulse1 = ((-C1)) / k11;
				}
				else
				{
					impulse1 = 0.0;
				}
				impulse.x = impulse1;
				impulse.y = 0.0;
			}
			var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
			var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
			var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
			var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
			c1.x -= this.m_invMassA * PX;
			c1.y -= this.m_invMassA * PY;
			a1 -= this.m_invIA * L1;
			c2.x += this.m_invMassB * PX;
			c2.y += this.m_invMassB * PY;
			a2 += this.m_invIB * L2;
			bA.m_sweep.a = a1;
			bB.m_sweep.a = a2;
			bA.SynchronizeTransform();
			bB.SynchronizeTransform();
			return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
		}
		Box2D.inherit(b2LineJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2LineJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2LineJointDef.b2LineJointDef = function ()
		{
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.localAnchorA = new b2Vec2();
			this.localAnchorB = new b2Vec2();
			this.localAxisA = new b2Vec2();
		};
		b2LineJointDef.prototype.b2LineJointDef = function ()
		{
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_lineJoint;
			this.localAxisA.Set(1.0, 0.0);
			this.enableLimit = false;
			this.lowerTranslation = 0.0;
			this.upperTranslation = 0.0;
			this.enableMotor = false;
			this.maxMotorForce = 0.0;
			this.motorSpeed = 0.0;
		}
		b2LineJointDef.prototype.Initialize = function (bA, bB, anchor, axis)
		{
			this.bodyA = bA;
			this.bodyB = bB;
			this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
			this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
			this.localAxisA = this.bodyA.GetLocalVector(axis);
		}
		Box2D.inherit(b2MouseJoint, Box2D.Dynamics.Joints.b2Joint);
		b2MouseJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2MouseJoint.b2MouseJoint = function ()
		{
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.K = new b2Mat22();
			this.K1 = new b2Mat22();
			this.K2 = new b2Mat22();
			this.m_localAnchor = new b2Vec2();
			this.m_target = new b2Vec2();
			this.m_impulse = new b2Vec2();
			this.m_mass = new b2Mat22();
			this.m_C = new b2Vec2();
		};
		b2MouseJoint.prototype.GetAnchorA = function ()
		{
			return this.m_target;
		}
		b2MouseJoint.prototype.GetAnchorB = function ()
		{
			return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
		}
		b2MouseJoint.prototype.GetReactionForce = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
		}
		b2MouseJoint.prototype.GetReactionTorque = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return 0.0;
		}
		b2MouseJoint.prototype.GetTarget = function ()
		{
			return this.m_target;
		}
		b2MouseJoint.prototype.SetTarget = function (target)
		{
			if (this.m_bodyB.IsAwake() == false)
			{
				this.m_bodyB.SetAwake(true);
			}
			this.m_target = target;
		}
		b2MouseJoint.prototype.GetMaxForce = function ()
		{
			return this.m_maxForce;
		}
		b2MouseJoint.prototype.SetMaxForce = function (maxForce)
		{
			if (maxForce === undefined) maxForce = 0;
			this.m_maxForce = maxForce;
		}
		b2MouseJoint.prototype.GetFrequency = function ()
		{
			return this.m_frequencyHz;
		}
		b2MouseJoint.prototype.SetFrequency = function (hz)
		{
			if (hz === undefined) hz = 0;
			this.m_frequencyHz = hz;
		}
		b2MouseJoint.prototype.GetDampingRatio = function ()
		{
			return this.m_dampingRatio;
		}
		b2MouseJoint.prototype.SetDampingRatio = function (ratio)
		{
			if (ratio === undefined) ratio = 0;
			this.m_dampingRatio = ratio;
		}
		b2MouseJoint.prototype.b2MouseJoint = function (def)
		{
			this.__super.b2Joint.call(this, def);
			this.m_target.SetV(def.target);
			var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
			var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
			var tMat = this.m_bodyB.m_xf.R;
			this.m_localAnchor.x = (tX * tMat.col1.x + tY * tMat.col1.y);
			this.m_localAnchor.y = (tX * tMat.col2.x + tY * tMat.col2.y);
			this.m_maxForce = def.maxForce;
			this.m_impulse.SetZero();
			this.m_frequencyHz = def.frequencyHz;
			this.m_dampingRatio = def.dampingRatio;
			this.m_beta = 0.0;
			this.m_gamma = 0.0;
		}
		b2MouseJoint.prototype.InitVelocityConstraints = function (step)
		{
			var b = this.m_bodyB;
			var mass = b.GetMass();
			var omega = 2.0 * Math.PI * this.m_frequencyHz;
			var d = 2.0 * mass * this.m_dampingRatio * omega;
			var k = mass * omega * omega;
			this.m_gamma = step.dt * (d + step.dt * k);
			this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0.0;
			this.m_beta = step.dt * k * this.m_gamma;
			var tMat;
			tMat = b.m_xf.R;
			var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
			var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
			var tX = (tMat.col1.x * rX + tMat.col2.x * rY);
			rY = (tMat.col1.y * rX + tMat.col2.y * rY);
			rX = tX;
			var invMass = b.m_invMass;
			var invI = b.m_invI;
			this.K1.col1.x = invMass;
			this.K1.col2.x = 0.0;
			this.K1.col1.y = 0.0;
			this.K1.col2.y = invMass;
			this.K2.col1.x = invI * rY * rY;
			this.K2.col2.x = (-invI * rX * rY);
			this.K2.col1.y = (-invI * rX * rY);
			this.K2.col2.y = invI * rX * rX;
			this.K.SetM(this.K1);
			this.K.AddM(this.K2);
			this.K.col1.x += this.m_gamma;
			this.K.col2.y += this.m_gamma;
			this.K.GetInverse(this.m_mass);
			this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
			this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
			b.m_angularVelocity *= 0.98;
			this.m_impulse.x *= step.dtRatio;
			this.m_impulse.y *= step.dtRatio;
			b.m_linearVelocity.x += invMass * this.m_impulse.x;
			b.m_linearVelocity.y += invMass * this.m_impulse.y;
			b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x);
		}
		b2MouseJoint.prototype.SolveVelocityConstraints = function (step)
		{
			var b = this.m_bodyB;
			var tMat;
			var tX = 0;
			var tY = 0;
			tMat = b.m_xf.R;
			var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
			var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rX + tMat.col2.x * rY);
			rY = (tMat.col1.y * rX + tMat.col2.y * rY);
			rX = tX;
			var CdotX = b.m_linearVelocity.x + ((-b.m_angularVelocity * rY));
			var CdotY = b.m_linearVelocity.y + (b.m_angularVelocity * rX);
			tMat = this.m_mass;
			tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
			tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
			var impulseX = (-(tMat.col1.x * tX + tMat.col2.x * tY));
			var impulseY = (-(tMat.col1.y * tX + tMat.col2.y * tY));
			var oldImpulseX = this.m_impulse.x;
			var oldImpulseY = this.m_impulse.y;
			this.m_impulse.x += impulseX;
			this.m_impulse.y += impulseY;
			var maxImpulse = step.dt * this.m_maxForce;
			if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse)
			{
				this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
			}
			impulseX = this.m_impulse.x - oldImpulseX;
			impulseY = this.m_impulse.y - oldImpulseY;
			b.m_linearVelocity.x += b.m_invMass * impulseX;
			b.m_linearVelocity.y += b.m_invMass * impulseY;
			b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX);
		}
		b2MouseJoint.prototype.SolvePositionConstraints = function (baumgarte)
		{
			if (baumgarte === undefined) baumgarte = 0;
			return true;
		}
		Box2D.inherit(b2MouseJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2MouseJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2MouseJointDef.b2MouseJointDef = function ()
		{
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.target = new b2Vec2();
		};
		b2MouseJointDef.prototype.b2MouseJointDef = function ()
		{
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_mouseJoint;
			this.maxForce = 0.0;
			this.frequencyHz = 5.0;
			this.dampingRatio = 0.7;
		}
		Box2D.inherit(b2PrismaticJoint, Box2D.Dynamics.Joints.b2Joint);
		b2PrismaticJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2PrismaticJoint.b2PrismaticJoint = function ()
		{
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.m_localAnchor1 = new b2Vec2();
			this.m_localAnchor2 = new b2Vec2();
			this.m_localXAxis1 = new b2Vec2();
			this.m_localYAxis1 = new b2Vec2();
			this.m_axis = new b2Vec2();
			this.m_perp = new b2Vec2();
			this.m_K = new b2Mat33();
			this.m_impulse = new b2Vec3();
		};
		b2PrismaticJoint.prototype.GetAnchorA = function ()
		{
			return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
		}
		b2PrismaticJoint.prototype.GetAnchorB = function ()
		{
			return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
		}
		b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
		}
		b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return inv_dt * this.m_impulse.y;
		}
		b2PrismaticJoint.prototype.GetJointTranslation = function ()
		{
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			var p1 = bA.GetWorldPoint(this.m_localAnchor1);
			var p2 = bB.GetWorldPoint(this.m_localAnchor2);
			var dX = p2.x - p1.x;
			var dY = p2.y - p1.y;
			var axis = bA.GetWorldVector(this.m_localXAxis1);
			var translation = axis.x * dX + axis.y * dY;
			return translation;
		}
		b2PrismaticJoint.prototype.GetJointSpeed = function ()
		{
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var p1X = bA.m_sweep.c.x + r1X;
			var p1Y = bA.m_sweep.c.y + r1Y;
			var p2X = bB.m_sweep.c.x + r2X;
			var p2Y = bB.m_sweep.c.y + r2Y;
			var dX = p2X - p1X;
			var dY = p2Y - p1Y;
			var axis = bA.GetWorldVector(this.m_localXAxis1);
			var v1 = bA.m_linearVelocity;
			var v2 = bB.m_linearVelocity;
			var w1 = bA.m_angularVelocity;
			var w2 = bB.m_angularVelocity;
			var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
			return speed;
		}
		b2PrismaticJoint.prototype.IsLimitEnabled = function ()
		{
			return this.m_enableLimit;
		}
		b2PrismaticJoint.prototype.EnableLimit = function (flag)
		{
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_enableLimit = flag;
		}
		b2PrismaticJoint.prototype.GetLowerLimit = function ()
		{
			return this.m_lowerTranslation;
		}
		b2PrismaticJoint.prototype.GetUpperLimit = function ()
		{
			return this.m_upperTranslation;
		}
		b2PrismaticJoint.prototype.SetLimits = function (lower, upper)
		{
			if (lower === undefined) lower = 0;
			if (upper === undefined) upper = 0;
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_lowerTranslation = lower;
			this.m_upperTranslation = upper;
		}
		b2PrismaticJoint.prototype.IsMotorEnabled = function ()
		{
			return this.m_enableMotor;
		}
		b2PrismaticJoint.prototype.EnableMotor = function (flag)
		{
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_enableMotor = flag;
		}
		b2PrismaticJoint.prototype.SetMotorSpeed = function (speed)
		{
			if (speed === undefined) speed = 0;
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_motorSpeed = speed;
		}
		b2PrismaticJoint.prototype.GetMotorSpeed = function ()
		{
			return this.m_motorSpeed;
		}
		b2PrismaticJoint.prototype.SetMaxMotorForce = function (force)
		{
			if (force === undefined) force = 0;
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_maxMotorForce = force;
		}
		b2PrismaticJoint.prototype.GetMotorForce = function ()
		{
			return this.m_motorImpulse;
		}
		b2PrismaticJoint.prototype.b2PrismaticJoint = function (def)
		{
			this.__super.b2Joint.call(this, def);
			var tMat;
			var tX = 0;
			var tY = 0;
			this.m_localAnchor1.SetV(def.localAnchorA);
			this.m_localAnchor2.SetV(def.localAnchorB);
			this.m_localXAxis1.SetV(def.localAxisA);
			this.m_localYAxis1.x = (-this.m_localXAxis1.y);
			this.m_localYAxis1.y = this.m_localXAxis1.x;
			this.m_refAngle = def.referenceAngle;
			this.m_impulse.SetZero();
			this.m_motorMass = 0.0;
			this.m_motorImpulse = 0.0;
			this.m_lowerTranslation = def.lowerTranslation;
			this.m_upperTranslation = def.upperTranslation;
			this.m_maxMotorForce = def.maxMotorForce;
			this.m_motorSpeed = def.motorSpeed;
			this.m_enableLimit = def.enableLimit;
			this.m_enableMotor = def.enableMotor;
			this.m_limitState = b2Joint.e_inactiveLimit;
			this.m_axis.SetZero();
			this.m_perp.SetZero();
		}
		b2PrismaticJoint.prototype.InitVelocityConstraints = function (step)
		{
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			var tX = 0;
			this.m_localCenterA.SetV(bA.GetLocalCenter());
			this.m_localCenterB.SetV(bB.GetLocalCenter());
			var xf1 = bA.GetTransform();
			var xf2 = bB.GetTransform();
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
			var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
			tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
			var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
			var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
			this.m_invMassA = bA.m_invMass;
			this.m_invMassB = bB.m_invMass;
			this.m_invIA = bA.m_invI;
			this.m_invIB = bB.m_invI;
			{
				this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
				this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
				this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
				this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
				if (this.m_motorMass > Number.MIN_VALUE) this.m_motorMass = 1.0 / this.m_motorMass;
			}
			{
				this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
				this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
				this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
				var m1 = this.m_invMassA;
				var m2 = this.m_invMassB;
				var i1 = this.m_invIA;
				var i2 = this.m_invIB;
				this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
				this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
				this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
				this.m_K.col2.x = this.m_K.col1.y;
				this.m_K.col2.y = i1 + i2;
				this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
				this.m_K.col3.x = this.m_K.col1.z;
				this.m_K.col3.y = this.m_K.col2.z;
				this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
			}
			if (this.m_enableLimit)
			{
				var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
				if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop)
				{
					this.m_limitState = b2Joint.e_equalLimits;
				}
				else if (jointTransition <= this.m_lowerTranslation)
				{
					if (this.m_limitState != b2Joint.e_atLowerLimit)
					{
						this.m_limitState = b2Joint.e_atLowerLimit;
						this.m_impulse.z = 0.0;
					}
				}
				else if (jointTransition >= this.m_upperTranslation)
				{
					if (this.m_limitState != b2Joint.e_atUpperLimit)
					{
						this.m_limitState = b2Joint.e_atUpperLimit;
						this.m_impulse.z = 0.0;
					}
				}
				else
				{
					this.m_limitState = b2Joint.e_inactiveLimit;
					this.m_impulse.z = 0.0;
				}
			}
			else
			{
				this.m_limitState = b2Joint.e_inactiveLimit;
			}
			if (this.m_enableMotor == false)
			{
				this.m_motorImpulse = 0.0;
			}
			if (step.warmStarting)
			{
				this.m_impulse.x *= step.dtRatio;
				this.m_impulse.y *= step.dtRatio;
				this.m_motorImpulse *= step.dtRatio;
				var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
				var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
				var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
				var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
				bA.m_linearVelocity.x -= this.m_invMassA * PX;
				bA.m_linearVelocity.y -= this.m_invMassA * PY;
				bA.m_angularVelocity -= this.m_invIA * L1;
				bB.m_linearVelocity.x += this.m_invMassB * PX;
				bB.m_linearVelocity.y += this.m_invMassB * PY;
				bB.m_angularVelocity += this.m_invIB * L2;
			}
			else
			{
				this.m_impulse.SetZero();
				this.m_motorImpulse = 0.0;
			}
		}
		b2PrismaticJoint.prototype.SolveVelocityConstraints = function (step)
		{
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var v1 = bA.m_linearVelocity;
			var w1 = bA.m_angularVelocity;
			var v2 = bB.m_linearVelocity;
			var w2 = bB.m_angularVelocity;
			var PX = 0;
			var PY = 0;
			var L1 = 0;
			var L2 = 0;
			if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits)
			{
				var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
				var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
				var oldImpulse = this.m_motorImpulse;
				var maxImpulse = step.dt * this.m_maxMotorForce;
				this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
				impulse = this.m_motorImpulse - oldImpulse;
				PX = impulse * this.m_axis.x;
				PY = impulse * this.m_axis.y;
				L1 = impulse * this.m_a1;
				L2 = impulse * this.m_a2;
				v1.x -= this.m_invMassA * PX;
				v1.y -= this.m_invMassA * PY;
				w1 -= this.m_invIA * L1;
				v2.x += this.m_invMassB * PX;
				v2.y += this.m_invMassB * PY;
				w2 += this.m_invIB * L2;
			}
			var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
			var Cdot1Y = w2 - w1;
			if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit)
			{
				var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
				var f1 = this.m_impulse.Copy();
				var df = this.m_K.Solve33(new b2Vec3(), (-Cdot1X), (-Cdot1Y), (-Cdot2));
				this.m_impulse.Add(df);
				if (this.m_limitState == b2Joint.e_atLowerLimit)
				{
					this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0.0);
				}
				else if (this.m_limitState == b2Joint.e_atUpperLimit)
				{
					this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0.0);
				}
				var bX = (-Cdot1X) - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
				var bY = (-Cdot1Y) - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
				var f2r = this.m_K.Solve22(new b2Vec2(), bX, bY);
				f2r.x += f1.x;
				f2r.y += f1.y;
				this.m_impulse.x = f2r.x;
				this.m_impulse.y = f2r.y;
				df.x = this.m_impulse.x - f1.x;
				df.y = this.m_impulse.y - f1.y;
				df.z = this.m_impulse.z - f1.z;
				PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
				PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
				L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
				L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
				v1.x -= this.m_invMassA * PX;
				v1.y -= this.m_invMassA * PY;
				w1 -= this.m_invIA * L1;
				v2.x += this.m_invMassB * PX;
				v2.y += this.m_invMassB * PY;
				w2 += this.m_invIB * L2;
			}
			else
			{
				var df2 = this.m_K.Solve22(new b2Vec2(), (-Cdot1X), (-Cdot1Y));
				this.m_impulse.x += df2.x;
				this.m_impulse.y += df2.y;
				PX = df2.x * this.m_perp.x;
				PY = df2.x * this.m_perp.y;
				L1 = df2.x * this.m_s1 + df2.y;
				L2 = df2.x * this.m_s2 + df2.y;
				v1.x -= this.m_invMassA * PX;
				v1.y -= this.m_invMassA * PY;
				w1 -= this.m_invIA * L1;
				v2.x += this.m_invMassB * PX;
				v2.y += this.m_invMassB * PY;
				w2 += this.m_invIB * L2;
			}
			bA.m_linearVelocity.SetV(v1);
			bA.m_angularVelocity = w1;
			bB.m_linearVelocity.SetV(v2);
			bB.m_angularVelocity = w2;
		}
		b2PrismaticJoint.prototype.SolvePositionConstraints = function (baumgarte)
		{
			if (baumgarte === undefined) baumgarte = 0;
			var limitC = 0;
			var oldLimitImpulse = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var c1 = bA.m_sweep.c;
			var a1 = bA.m_sweep.a;
			var c2 = bB.m_sweep.c;
			var a2 = bB.m_sweep.a;
			var tMat;
			var tX = 0;
			var m1 = 0;
			var m2 = 0;
			var i1 = 0;
			var i2 = 0;
			var linearError = 0.0;
			var angularError = 0.0;
			var active = false;
			var C2 = 0.0;
			var R1 = b2Mat22.FromAngle(a1);
			var R2 = b2Mat22.FromAngle(a2);
			tMat = R1;
			var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
			var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
			tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = R2;
			var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
			var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var dX = c2.x + r2X - c1.x - r1X;
			var dY = c2.y + r2Y - c1.y - r1Y;
			if (this.m_enableLimit)
			{
				this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
				this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
				this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
				var translation = this.m_axis.x * dX + this.m_axis.y * dY;
				if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop)
				{
					C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
					linearError = b2Math.Abs(translation);
					active = true;
				}
				else if (translation <= this.m_lowerTranslation)
				{
					C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
					linearError = this.m_lowerTranslation - translation;
					active = true;
				}
				else if (translation >= this.m_upperTranslation)
				{
					C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
					linearError = translation - this.m_upperTranslation;
					active = true;
				}
			}
			this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
			this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
			this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
			var impulse = new b2Vec3();
			var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
			var C1Y = a2 - a1 - this.m_refAngle;
			linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
			angularError = b2Math.Abs(C1Y);
			if (active)
			{
				m1 = this.m_invMassA;
				m2 = this.m_invMassB;
				i1 = this.m_invIA;
				i2 = this.m_invIB;
				this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
				this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
				this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
				this.m_K.col2.x = this.m_K.col1.y;
				this.m_K.col2.y = i1 + i2;
				this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
				this.m_K.col3.x = this.m_K.col1.z;
				this.m_K.col3.y = this.m_K.col2.z;
				this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
				this.m_K.Solve33(impulse, (-C1X), (-C1Y), (-C2));
			}
			else
			{
				m1 = this.m_invMassA;
				m2 = this.m_invMassB;
				i1 = this.m_invIA;
				i2 = this.m_invIB;
				var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
				var k12 = i1 * this.m_s1 + i2 * this.m_s2;
				var k22 = i1 + i2;
				this.m_K.col1.Set(k11, k12, 0.0);
				this.m_K.col2.Set(k12, k22, 0.0);
				var impulse1 = this.m_K.Solve22(new b2Vec2(), (-C1X), (-C1Y));
				impulse.x = impulse1.x;
				impulse.y = impulse1.y;
				impulse.z = 0.0;
			}
			var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
			var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
			var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
			var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
			c1.x -= this.m_invMassA * PX;
			c1.y -= this.m_invMassA * PY;
			a1 -= this.m_invIA * L1;
			c2.x += this.m_invMassB * PX;
			c2.y += this.m_invMassB * PY;
			a2 += this.m_invIB * L2;
			bA.m_sweep.a = a1;
			bB.m_sweep.a = a2;
			bA.SynchronizeTransform();
			bB.SynchronizeTransform();
			return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
		}
		Box2D.inherit(b2PrismaticJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2PrismaticJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2PrismaticJointDef.b2PrismaticJointDef = function ()
		{
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.localAnchorA = new b2Vec2();
			this.localAnchorB = new b2Vec2();
			this.localAxisA = new b2Vec2();
		};
		b2PrismaticJointDef.prototype.b2PrismaticJointDef = function ()
		{
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_prismaticJoint;
			this.localAxisA.Set(1.0, 0.0);
			this.referenceAngle = 0.0;
			this.enableLimit = false;
			this.lowerTranslation = 0.0;
			this.upperTranslation = 0.0;
			this.enableMotor = false;
			this.maxMotorForce = 0.0;
			this.motorSpeed = 0.0;
		}
		b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis)
		{
			this.bodyA = bA;
			this.bodyB = bB;
			this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
			this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
			this.localAxisA = this.bodyA.GetLocalVector(axis);
			this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
		}
		Box2D.inherit(b2PulleyJoint, Box2D.Dynamics.Joints.b2Joint);
		b2PulleyJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2PulleyJoint.b2PulleyJoint = function ()
		{
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.m_groundAnchor1 = new b2Vec2();
			this.m_groundAnchor2 = new b2Vec2();
			this.m_localAnchor1 = new b2Vec2();
			this.m_localAnchor2 = new b2Vec2();
			this.m_u1 = new b2Vec2();
			this.m_u2 = new b2Vec2();
		};
		b2PulleyJoint.prototype.GetAnchorA = function ()
		{
			return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
		}
		b2PulleyJoint.prototype.GetAnchorB = function ()
		{
			return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
		}
		b2PulleyJoint.prototype.GetReactionForce = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y);
		}
		b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return 0.0;
		}
		b2PulleyJoint.prototype.GetGroundAnchorA = function ()
		{
			var a = this.m_ground.m_xf.position.Copy();
			a.Add(this.m_groundAnchor1);
			return a;
		}
		b2PulleyJoint.prototype.GetGroundAnchorB = function ()
		{
			var a = this.m_ground.m_xf.position.Copy();
			a.Add(this.m_groundAnchor2);
			return a;
		}
		b2PulleyJoint.prototype.GetLength1 = function ()
		{
			var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
			var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
			var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
			var dX = p.x - sX;
			var dY = p.y - sY;
			return Math.sqrt(dX * dX + dY * dY);
		}
		b2PulleyJoint.prototype.GetLength2 = function ()
		{
			var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
			var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
			var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
			var dX = p.x - sX;
			var dY = p.y - sY;
			return Math.sqrt(dX * dX + dY * dY);
		}
		b2PulleyJoint.prototype.GetRatio = function ()
		{
			return this.m_ratio;
		}
		b2PulleyJoint.prototype.b2PulleyJoint = function (def)
		{
			this.__super.b2Joint.call(this, def);
			var tMat;
			var tX = 0;
			var tY = 0;
			this.m_ground = this.m_bodyA.m_world.m_groundBody;
			this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
			this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
			this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
			this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
			this.m_localAnchor1.SetV(def.localAnchorA);
			this.m_localAnchor2.SetV(def.localAnchorB);
			this.m_ratio = def.ratio;
			this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
			this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
			this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
			this.m_impulse = 0.0;
			this.m_limitImpulse1 = 0.0;
			this.m_limitImpulse2 = 0.0;
		}
		b2PulleyJoint.prototype.InitVelocityConstraints = function (step)
		{
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var p1X = bA.m_sweep.c.x + r1X;
			var p1Y = bA.m_sweep.c.y + r1Y;
			var p2X = bB.m_sweep.c.x + r2X;
			var p2Y = bB.m_sweep.c.y + r2Y;
			var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
			var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
			var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
			var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
			this.m_u1.Set(p1X - s1X, p1Y - s1Y);
			this.m_u2.Set(p2X - s2X, p2Y - s2Y);
			var length1 = this.m_u1.Length();
			var length2 = this.m_u2.Length();
			if (length1 > b2Settings.b2_linearSlop)
			{
				this.m_u1.Multiply(1.0 / length1);
			}
			else
			{
				this.m_u1.SetZero();
			}
			if (length2 > b2Settings.b2_linearSlop)
			{
				this.m_u2.Multiply(1.0 / length2);
			}
			else
			{
				this.m_u2.SetZero();
			}
			var C = this.m_constant - length1 - this.m_ratio * length2;
			if (C > 0.0)
			{
				this.m_state = b2Joint.e_inactiveLimit;
				this.m_impulse = 0.0;
			}
			else
			{
				this.m_state = b2Joint.e_atUpperLimit;
			}
			if (length1 < this.m_maxLength1)
			{
				this.m_limitState1 = b2Joint.e_inactiveLimit;
				this.m_limitImpulse1 = 0.0;
			}
			else
			{
				this.m_limitState1 = b2Joint.e_atUpperLimit;
			}
			if (length2 < this.m_maxLength2)
			{
				this.m_limitState2 = b2Joint.e_inactiveLimit;
				this.m_limitImpulse2 = 0.0;
			}
			else
			{
				this.m_limitState2 = b2Joint.e_atUpperLimit;
			}
			var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
			var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
			this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
			this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
			this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
			this.m_limitMass1 = 1.0 / this.m_limitMass1;
			this.m_limitMass2 = 1.0 / this.m_limitMass2;
			this.m_pulleyMass = 1.0 / this.m_pulleyMass;
			if (step.warmStarting)
			{
				this.m_impulse *= step.dtRatio;
				this.m_limitImpulse1 *= step.dtRatio;
				this.m_limitImpulse2 *= step.dtRatio;
				var P1X = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.x;
				var P1Y = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.y;
				var P2X = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.x;
				var P2Y = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.y;
				bA.m_linearVelocity.x += bA.m_invMass * P1X;
				bA.m_linearVelocity.y += bA.m_invMass * P1Y;
				bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
				bB.m_linearVelocity.x += bB.m_invMass * P2X;
				bB.m_linearVelocity.y += bB.m_invMass * P2Y;
				bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
			}
			else
			{
				this.m_impulse = 0.0;
				this.m_limitImpulse1 = 0.0;
				this.m_limitImpulse2 = 0.0;
			}
		}
		b2PulleyJoint.prototype.SolveVelocityConstraints = function (step)
		{
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var v1X = 0;
			var v1Y = 0;
			var v2X = 0;
			var v2Y = 0;
			var P1X = 0;
			var P1Y = 0;
			var P2X = 0;
			var P2Y = 0;
			var Cdot = 0;
			var impulse = 0;
			var oldImpulse = 0;
			if (this.m_state == b2Joint.e_atUpperLimit)
			{
				v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
				v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
				v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
				v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
				Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y)) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
				impulse = this.m_pulleyMass * ((-Cdot));
				oldImpulse = this.m_impulse;
				this.m_impulse = b2Math.Max(0.0, this.m_impulse + impulse);
				impulse = this.m_impulse - oldImpulse;
				P1X = (-impulse * this.m_u1.x);
				P1Y = (-impulse * this.m_u1.y);
				P2X = (-this.m_ratio * impulse * this.m_u2.x);
				P2Y = (-this.m_ratio * impulse * this.m_u2.y);
				bA.m_linearVelocity.x += bA.m_invMass * P1X;
				bA.m_linearVelocity.y += bA.m_invMass * P1Y;
				bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
				bB.m_linearVelocity.x += bB.m_invMass * P2X;
				bB.m_linearVelocity.y += bB.m_invMass * P2Y;
				bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
			}
			if (this.m_limitState1 == b2Joint.e_atUpperLimit)
			{
				v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
				v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
				Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y));
				impulse = (-this.m_limitMass1 * Cdot);
				oldImpulse = this.m_limitImpulse1;
				this.m_limitImpulse1 = b2Math.Max(0.0, this.m_limitImpulse1 + impulse);
				impulse = this.m_limitImpulse1 - oldImpulse;
				P1X = (-impulse * this.m_u1.x);
				P1Y = (-impulse * this.m_u1.y);
				bA.m_linearVelocity.x += bA.m_invMass * P1X;
				bA.m_linearVelocity.y += bA.m_invMass * P1Y;
				bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
			}
			if (this.m_limitState2 == b2Joint.e_atUpperLimit)
			{
				v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
				v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
				Cdot = (-(this.m_u2.x * v2X + this.m_u2.y * v2Y));
				impulse = (-this.m_limitMass2 * Cdot);
				oldImpulse = this.m_limitImpulse2;
				this.m_limitImpulse2 = b2Math.Max(0.0, this.m_limitImpulse2 + impulse);
				impulse = this.m_limitImpulse2 - oldImpulse;
				P2X = (-impulse * this.m_u2.x);
				P2Y = (-impulse * this.m_u2.y);
				bB.m_linearVelocity.x += bB.m_invMass * P2X;
				bB.m_linearVelocity.y += bB.m_invMass * P2Y;
				bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
			}
		}
		b2PulleyJoint.prototype.SolvePositionConstraints = function (baumgarte)
		{
			if (baumgarte === undefined) baumgarte = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
			var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
			var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
			var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
			var r1X = 0;
			var r1Y = 0;
			var r2X = 0;
			var r2Y = 0;
			var p1X = 0;
			var p1Y = 0;
			var p2X = 0;
			var p2Y = 0;
			var length1 = 0;
			var length2 = 0;
			var C = 0;
			var impulse = 0;
			var oldImpulse = 0;
			var oldLimitPositionImpulse = 0;
			var tX = 0;
			var linearError = 0.0;
			if (this.m_state == b2Joint.e_atUpperLimit)
			{
				tMat = bA.m_xf.R;
				r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
				r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
				r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
				r1X = tX;
				tMat = bB.m_xf.R;
				r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
				r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
				r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
				r2X = tX;
				p1X = bA.m_sweep.c.x + r1X;
				p1Y = bA.m_sweep.c.y + r1Y;
				p2X = bB.m_sweep.c.x + r2X;
				p2Y = bB.m_sweep.c.y + r2Y;
				this.m_u1.Set(p1X - s1X, p1Y - s1Y);
				this.m_u2.Set(p2X - s2X, p2Y - s2Y);
				length1 = this.m_u1.Length();
				length2 = this.m_u2.Length();
				if (length1 > b2Settings.b2_linearSlop)
				{
					this.m_u1.Multiply(1.0 / length1);
				}
				else
				{
					this.m_u1.SetZero();
				}
				if (length2 > b2Settings.b2_linearSlop)
				{
					this.m_u2.Multiply(1.0 / length2);
				}
				else
				{
					this.m_u2.SetZero();
				}
				C = this.m_constant - length1 - this.m_ratio * length2;
				linearError = b2Math.Max(linearError, (-C));
				C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
				impulse = (-this.m_pulleyMass * C);
				p1X = (-impulse * this.m_u1.x);
				p1Y = (-impulse * this.m_u1.y);
				p2X = (-this.m_ratio * impulse * this.m_u2.x);
				p2Y = (-this.m_ratio * impulse * this.m_u2.y);
				bA.m_sweep.c.x += bA.m_invMass * p1X;
				bA.m_sweep.c.y += bA.m_invMass * p1Y;
				bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
				bB.m_sweep.c.x += bB.m_invMass * p2X;
				bB.m_sweep.c.y += bB.m_invMass * p2Y;
				bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
				bA.SynchronizeTransform();
				bB.SynchronizeTransform();
			}
			if (this.m_limitState1 == b2Joint.e_atUpperLimit)
			{
				tMat = bA.m_xf.R;
				r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
				r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
				r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
				r1X = tX;
				p1X = bA.m_sweep.c.x + r1X;
				p1Y = bA.m_sweep.c.y + r1Y;
				this.m_u1.Set(p1X - s1X, p1Y - s1Y);
				length1 = this.m_u1.Length();
				if (length1 > b2Settings.b2_linearSlop)
				{
					this.m_u1.x *= 1.0 / length1;
					this.m_u1.y *= 1.0 / length1;
				}
				else
				{
					this.m_u1.SetZero();
				}
				C = this.m_maxLength1 - length1;
				linearError = b2Math.Max(linearError, (-C));
				C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
				impulse = (-this.m_limitMass1 * C);
				p1X = (-impulse * this.m_u1.x);
				p1Y = (-impulse * this.m_u1.y);
				bA.m_sweep.c.x += bA.m_invMass * p1X;
				bA.m_sweep.c.y += bA.m_invMass * p1Y;
				bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
				bA.SynchronizeTransform();
			}
			if (this.m_limitState2 == b2Joint.e_atUpperLimit)
			{
				tMat = bB.m_xf.R;
				r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
				r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
				r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
				r2X = tX;
				p2X = bB.m_sweep.c.x + r2X;
				p2Y = bB.m_sweep.c.y + r2Y;
				this.m_u2.Set(p2X - s2X, p2Y - s2Y);
				length2 = this.m_u2.Length();
				if (length2 > b2Settings.b2_linearSlop)
				{
					this.m_u2.x *= 1.0 / length2;
					this.m_u2.y *= 1.0 / length2;
				}
				else
				{
					this.m_u2.SetZero();
				}
				C = this.m_maxLength2 - length2;
				linearError = b2Math.Max(linearError, (-C));
				C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
				impulse = (-this.m_limitMass2 * C);
				p2X = (-impulse * this.m_u2.x);
				p2Y = (-impulse * this.m_u2.y);
				bB.m_sweep.c.x += bB.m_invMass * p2X;
				bB.m_sweep.c.y += bB.m_invMass * p2Y;
				bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
				bB.SynchronizeTransform();
			}
			return linearError < b2Settings.b2_linearSlop;
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2.0;
		});
		Box2D.inherit(b2PulleyJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2PulleyJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2PulleyJointDef.b2PulleyJointDef = function ()
		{
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.groundAnchorA = new b2Vec2();
			this.groundAnchorB = new b2Vec2();
			this.localAnchorA = new b2Vec2();
			this.localAnchorB = new b2Vec2();
		};
		b2PulleyJointDef.prototype.b2PulleyJointDef = function ()
		{
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_pulleyJoint;
			this.groundAnchorA.Set((-1.0), 1.0);
			this.groundAnchorB.Set(1.0, 1.0);
			this.localAnchorA.Set((-1.0), 0.0);
			this.localAnchorB.Set(1.0, 0.0);
			this.lengthA = 0.0;
			this.maxLengthA = 0.0;
			this.lengthB = 0.0;
			this.maxLengthB = 0.0;
			this.ratio = 1.0;
			this.collideConnected = true;
		}
		b2PulleyJointDef.prototype.Initialize = function (bA, bB, gaA, gaB, anchorA, anchorB, r)
		{
			if (r === undefined) r = 0;
			this.bodyA = bA;
			this.bodyB = bB;
			this.groundAnchorA.SetV(gaA);
			this.groundAnchorB.SetV(gaB);
			this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
			this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
			var d1X = anchorA.x - gaA.x;
			var d1Y = anchorA.y - gaA.y;
			this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
			var d2X = anchorB.x - gaB.x;
			var d2Y = anchorB.y - gaB.y;
			this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
			this.ratio = r;
			var C = this.lengthA + this.ratio * this.lengthB;
			this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
			this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio;
		}
		Box2D.inherit(b2RevoluteJoint, Box2D.Dynamics.Joints.b2Joint);
		b2RevoluteJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2RevoluteJoint.b2RevoluteJoint = function ()
		{
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.K = new b2Mat22();
			this.K1 = new b2Mat22();
			this.K2 = new b2Mat22();
			this.K3 = new b2Mat22();
			this.impulse3 = new b2Vec3();
			this.impulse2 = new b2Vec2();
			this.reduced = new b2Vec2();
			this.m_localAnchor1 = new b2Vec2();
			this.m_localAnchor2 = new b2Vec2();
			this.m_impulse = new b2Vec3();
			this.m_mass = new b2Mat33();
		};
		b2RevoluteJoint.prototype.GetAnchorA = function ()
		{
			return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
		}
		b2RevoluteJoint.prototype.GetAnchorB = function ()
		{
			return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
		}
		b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
		}
		b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return inv_dt * this.m_impulse.z;
		}
		b2RevoluteJoint.prototype.GetJointAngle = function ()
		{
			return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
		}
		b2RevoluteJoint.prototype.GetJointSpeed = function ()
		{
			return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
		}
		b2RevoluteJoint.prototype.IsLimitEnabled = function ()
		{
			return this.m_enableLimit;
		}
		b2RevoluteJoint.prototype.EnableLimit = function (flag)
		{
			this.m_enableLimit = flag;
		}
		b2RevoluteJoint.prototype.GetLowerLimit = function ()
		{
			return this.m_lowerAngle;
		}
		b2RevoluteJoint.prototype.GetUpperLimit = function ()
		{
			return this.m_upperAngle;
		}
		b2RevoluteJoint.prototype.SetLimits = function (lower, upper)
		{
			if (lower === undefined) lower = 0;
			if (upper === undefined) upper = 0;
			this.m_lowerAngle = lower;
			this.m_upperAngle = upper;
		}
		b2RevoluteJoint.prototype.IsMotorEnabled = function ()
		{
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			return this.m_enableMotor;
		}
		b2RevoluteJoint.prototype.EnableMotor = function (flag)
		{
			this.m_enableMotor = flag;
		}
		b2RevoluteJoint.prototype.SetMotorSpeed = function (speed)
		{
			if (speed === undefined) speed = 0;
			this.m_bodyA.SetAwake(true);
			this.m_bodyB.SetAwake(true);
			this.m_motorSpeed = speed;
		}
		b2RevoluteJoint.prototype.GetMotorSpeed = function ()
		{
			return this.m_motorSpeed;
		}
		b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque)
		{
			if (torque === undefined) torque = 0;
			this.m_maxMotorTorque = torque;
		}
		b2RevoluteJoint.prototype.GetMotorTorque = function ()
		{
			return this.m_maxMotorTorque;
		}
		b2RevoluteJoint.prototype.b2RevoluteJoint = function (def)
		{
			this.__super.b2Joint.call(this, def);
			this.m_localAnchor1.SetV(def.localAnchorA);
			this.m_localAnchor2.SetV(def.localAnchorB);
			this.m_referenceAngle = def.referenceAngle;
			this.m_impulse.SetZero();
			this.m_motorImpulse = 0.0;
			this.m_lowerAngle = def.lowerAngle;
			this.m_upperAngle = def.upperAngle;
			this.m_maxMotorTorque = def.maxMotorTorque;
			this.m_motorSpeed = def.motorSpeed;
			this.m_enableLimit = def.enableLimit;
			this.m_enableMotor = def.enableMotor;
			this.m_limitState = b2Joint.e_inactiveLimit;
		}
		b2RevoluteJoint.prototype.InitVelocityConstraints = function (step)
		{
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			var tX = 0;
			if (this.m_enableMotor || this.m_enableLimit)
			{
			}
			tMat = bA.m_xf.R;
			var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
			var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
			r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
			r1X = tX;
			tMat = bB.m_xf.R;
			var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
			var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
			r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
			r2X = tX;
			var m1 = bA.m_invMass;
			var m2 = bB.m_invMass;
			var i1 = bA.m_invI;
			var i2 = bB.m_invI;
			this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
			this.m_mass.col2.x = (-r1Y * r1X * i1) - r2Y * r2X * i2;
			this.m_mass.col3.x = (-r1Y * i1) - r2Y * i2;
			this.m_mass.col1.y = this.m_mass.col2.x;
			this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
			this.m_mass.col3.y = r1X * i1 + r2X * i2;
			this.m_mass.col1.z = this.m_mass.col3.x;
			this.m_mass.col2.z = this.m_mass.col3.y;
			this.m_mass.col3.z = i1 + i2;
			this.m_motorMass = 1.0 / (i1 + i2);
			if (this.m_enableMotor == false)
			{
				this.m_motorImpulse = 0.0;
			}
			if (this.m_enableLimit)
			{
				var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
				if (b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop)
				{
					this.m_limitState = b2Joint.e_equalLimits;
				}
				else if (jointAngle <= this.m_lowerAngle)
				{
					if (this.m_limitState != b2Joint.e_atLowerLimit)
					{
						this.m_impulse.z = 0.0;
					}
					this.m_limitState = b2Joint.e_atLowerLimit;
				}
				else if (jointAngle >= this.m_upperAngle)
				{
					if (this.m_limitState != b2Joint.e_atUpperLimit)
					{
						this.m_impulse.z = 0.0;
					}
					this.m_limitState = b2Joint.e_atUpperLimit;
				}
				else
				{
					this.m_limitState = b2Joint.e_inactiveLimit;
					this.m_impulse.z = 0.0;
				}
			}
			else
			{
				this.m_limitState = b2Joint.e_inactiveLimit;
			}
			if (step.warmStarting)
			{
				this.m_impulse.x *= step.dtRatio;
				this.m_impulse.y *= step.dtRatio;
				this.m_motorImpulse *= step.dtRatio;
				var PX = this.m_impulse.x;
				var PY = this.m_impulse.y;
				bA.m_linearVelocity.x -= m1 * PX;
				bA.m_linearVelocity.y -= m1 * PY;
				bA.m_angularVelocity -= i1 * ((r1X * PY - r1Y * PX) + this.m_motorImpulse + this.m_impulse.z);
				bB.m_linearVelocity.x += m2 * PX;
				bB.m_linearVelocity.y += m2 * PY;
				bB.m_angularVelocity += i2 * ((r2X * PY - r2Y * PX) + this.m_motorImpulse + this.m_impulse.z);
			}
			else
			{
				this.m_impulse.SetZero();
				this.m_motorImpulse = 0.0;
			}
		}
		b2RevoluteJoint.prototype.SolveVelocityConstraints = function (step)
		{
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var tMat;
			var tX = 0;
			var newImpulse = 0;
			var r1X = 0;
			var r1Y = 0;
			var r2X = 0;
			var r2Y = 0;
			var v1 = bA.m_linearVelocity;
			var w1 = bA.m_angularVelocity;
			var v2 = bB.m_linearVelocity;
			var w2 = bB.m_angularVelocity;
			var m1 = bA.m_invMass;
			var m2 = bB.m_invMass;
			var i1 = bA.m_invI;
			var i2 = bB.m_invI;
			if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits)
			{
				var Cdot = w2 - w1 - this.m_motorSpeed;
				var impulse = this.m_motorMass * ((-Cdot));
				var oldImpulse = this.m_motorImpulse;
				var maxImpulse = step.dt * this.m_maxMotorTorque;
				this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
				impulse = this.m_motorImpulse - oldImpulse;
				w1 -= i1 * impulse;
				w2 += i2 * impulse;
			}
			if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit)
			{
				tMat = bA.m_xf.R;
				r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
				r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
				r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
				r1X = tX;
				tMat = bB.m_xf.R;
				r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
				r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
				r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
				r2X = tX;
				var Cdot1X = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
				var Cdot1Y = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
				var Cdot2 = w2 - w1;
				this.m_mass.Solve33(this.impulse3, (-Cdot1X), (-Cdot1Y), (-Cdot2));
				if (this.m_limitState == b2Joint.e_equalLimits)
				{
					this.m_impulse.Add(this.impulse3);
				}
				else if (this.m_limitState == b2Joint.e_atLowerLimit)
				{
					newImpulse = this.m_impulse.z + this.impulse3.z;
					if (newImpulse < 0.0)
					{
						this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
						this.impulse3.x = this.reduced.x;
						this.impulse3.y = this.reduced.y;
						this.impulse3.z = (-this.m_impulse.z);
						this.m_impulse.x += this.reduced.x;
						this.m_impulse.y += this.reduced.y;
						this.m_impulse.z = 0.0;
					}
				}
				else if (this.m_limitState == b2Joint.e_atUpperLimit)
				{
					newImpulse = this.m_impulse.z + this.impulse3.z;
					if (newImpulse > 0.0)
					{
						this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
						this.impulse3.x = this.reduced.x;
						this.impulse3.y = this.reduced.y;
						this.impulse3.z = (-this.m_impulse.z);
						this.m_impulse.x += this.reduced.x;
						this.m_impulse.y += this.reduced.y;
						this.m_impulse.z = 0.0;
					}
				}
				v1.x -= m1 * this.impulse3.x;
				v1.y -= m1 * this.impulse3.y;
				w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
				v2.x += m2 * this.impulse3.x;
				v2.y += m2 * this.impulse3.y;
				w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z);
			}
			else
			{
				tMat = bA.m_xf.R;
				r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
				r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
				r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
				r1X = tX;
				tMat = bB.m_xf.R;
				r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
				r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
				r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
				r2X = tX;
				var CdotX = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
				var CdotY = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
				this.m_mass.Solve22(this.impulse2, (-CdotX), (-CdotY));
				this.m_impulse.x += this.impulse2.x;
				this.m_impulse.y += this.impulse2.y;
				v1.x -= m1 * this.impulse2.x;
				v1.y -= m1 * this.impulse2.y;
				w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
				v2.x += m2 * this.impulse2.x;
				v2.y += m2 * this.impulse2.y;
				w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x);
			}
			bA.m_linearVelocity.SetV(v1);
			bA.m_angularVelocity = w1;
			bB.m_linearVelocity.SetV(v2);
			bB.m_angularVelocity = w2;
		}
		b2RevoluteJoint.prototype.SolvePositionConstraints = function (baumgarte)
		{
			if (baumgarte === undefined) baumgarte = 0;
			var oldLimitImpulse = 0;
			var C = 0;
			var tMat;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var angularError = 0.0;
			var positionError = 0.0;
			var tX = 0;
			var impulseX = 0;
			var impulseY = 0;
			if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit)
			{
				var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
				var limitImpulse = 0.0;
				if (this.m_limitState == b2Joint.e_equalLimits)
				{
					C = b2Math.Clamp(angle - this.m_lowerAngle, (-b2Settings.b2_maxAngularCorrection), b2Settings.b2_maxAngularCorrection);
					limitImpulse = (-this.m_motorMass * C);
					angularError = b2Math.Abs(C);
				}
				else if (this.m_limitState == b2Joint.e_atLowerLimit)
				{
					C = angle - this.m_lowerAngle;
					angularError = (-C);
					C = b2Math.Clamp(C + b2Settings.b2_angularSlop, (-b2Settings.b2_maxAngularCorrection), 0.0);
					limitImpulse = (-this.m_motorMass * C);
				}
				else if (this.m_limitState == b2Joint.e_atUpperLimit)
				{
					C = angle - this.m_upperAngle;
					angularError = C;
					C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection);
					limitImpulse = (-this.m_motorMass * C);
				}
				bA.m_sweep.a -= bA.m_invI * limitImpulse;
				bB.m_sweep.a += bB.m_invI * limitImpulse;
				bA.SynchronizeTransform();
				bB.SynchronizeTransform();
			}
			{
				tMat = bA.m_xf.R;
				var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
				var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
				r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
				r1X = tX;
				tMat = bB.m_xf.R;
				var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
				var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
				tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
				r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
				r2X = tX;
				var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
				var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
				var CLengthSquared = CX * CX + CY * CY;
				var CLength = Math.sqrt(CLengthSquared);
				positionError = CLength;
				var invMass1 = bA.m_invMass;
				var invMass2 = bB.m_invMass;
				var invI1 = bA.m_invI;
				var invI2 = bB.m_invI;
				var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
				if (CLengthSquared > k_allowedStretch * k_allowedStretch)
				{
					var uX = CX / CLength;
					var uY = CY / CLength;
					var k = invMass1 + invMass2;
					var m = 1.0 / k;
					impulseX = m * ((-CX));
					impulseY = m * ((-CY));
					var k_beta = 0.5;
					bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
					bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
					bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
					bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
					CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
					CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
				}
				this.K1.col1.x = invMass1 + invMass2;
				this.K1.col2.x = 0.0;
				this.K1.col1.y = 0.0;
				this.K1.col2.y = invMass1 + invMass2;
				this.K2.col1.x = invI1 * r1Y * r1Y;
				this.K2.col2.x = (-invI1 * r1X * r1Y);
				this.K2.col1.y = (-invI1 * r1X * r1Y);
				this.K2.col2.y = invI1 * r1X * r1X;
				this.K3.col1.x = invI2 * r2Y * r2Y;
				this.K3.col2.x = (-invI2 * r2X * r2Y);
				this.K3.col1.y = (-invI2 * r2X * r2Y);
				this.K3.col2.y = invI2 * r2X * r2X;
				this.K.SetM(this.K1);
				this.K.AddM(this.K2);
				this.K.AddM(this.K3);
				this.K.Solve(b2RevoluteJoint.tImpulse, (-CX), (-CY));
				impulseX = b2RevoluteJoint.tImpulse.x;
				impulseY = b2RevoluteJoint.tImpulse.y;
				bA.m_sweep.c.x -= bA.m_invMass * impulseX;
				bA.m_sweep.c.y -= bA.m_invMass * impulseY;
				bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
				bB.m_sweep.c.x += bB.m_invMass * impulseX;
				bB.m_sweep.c.y += bB.m_invMass * impulseY;
				bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
				bA.SynchronizeTransform();
				bB.SynchronizeTransform();
			}
			return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
		}
		Box2D.postDefs.push(function ()
		{
			Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new b2Vec2();
		});
		Box2D.inherit(b2RevoluteJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2RevoluteJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2RevoluteJointDef.b2RevoluteJointDef = function ()
		{
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.localAnchorA = new b2Vec2();
			this.localAnchorB = new b2Vec2();
		};
		b2RevoluteJointDef.prototype.b2RevoluteJointDef = function ()
		{
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_revoluteJoint;
			this.localAnchorA.Set(0.0, 0.0);
			this.localAnchorB.Set(0.0, 0.0);
			this.referenceAngle = 0.0;
			this.lowerAngle = 0.0;
			this.upperAngle = 0.0;
			this.maxMotorTorque = 0.0;
			this.motorSpeed = 0.0;
			this.enableLimit = false;
			this.enableMotor = false;
		}
		b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor)
		{
			this.bodyA = bA;
			this.bodyB = bB;
			this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
			this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
			this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
		}
		Box2D.inherit(b2WeldJoint, Box2D.Dynamics.Joints.b2Joint);
		b2WeldJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
		b2WeldJoint.b2WeldJoint = function ()
		{
			Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
			this.m_localAnchorA = new b2Vec2();
			this.m_localAnchorB = new b2Vec2();
			this.m_impulse = new b2Vec3();
			this.m_mass = new b2Mat33();
		};
		b2WeldJoint.prototype.GetAnchorA = function ()
		{
			return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
		}
		b2WeldJoint.prototype.GetAnchorB = function ()
		{
			return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
		}
		b2WeldJoint.prototype.GetReactionForce = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
		}
		b2WeldJoint.prototype.GetReactionTorque = function (inv_dt)
		{
			if (inv_dt === undefined) inv_dt = 0;
			return inv_dt * this.m_impulse.z;
		}
		b2WeldJoint.prototype.b2WeldJoint = function (def)
		{
			this.__super.b2Joint.call(this, def);
			this.m_localAnchorA.SetV(def.localAnchorA);
			this.m_localAnchorB.SetV(def.localAnchorB);
			this.m_referenceAngle = def.referenceAngle;
			this.m_impulse.SetZero();
			this.m_mass = new b2Mat33();
		}
		b2WeldJoint.prototype.InitVelocityConstraints = function (step)
		{
			var tMat;
			var tX = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			tMat = bA.m_xf.R;
			var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
			var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
			rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
			rAX = tX;
			tMat = bB.m_xf.R;
			var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
			var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
			rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
			rBX = tX;
			var mA = bA.m_invMass;
			var mB = bB.m_invMass;
			var iA = bA.m_invI;
			var iB = bB.m_invI;
			this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
			this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
			this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
			this.m_mass.col1.y = this.m_mass.col2.x;
			this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
			this.m_mass.col3.y = rAX * iA + rBX * iB;
			this.m_mass.col1.z = this.m_mass.col3.x;
			this.m_mass.col2.z = this.m_mass.col3.y;
			this.m_mass.col3.z = iA + iB;
			if (step.warmStarting)
			{
				this.m_impulse.x *= step.dtRatio;
				this.m_impulse.y *= step.dtRatio;
				this.m_impulse.z *= step.dtRatio;
				bA.m_linearVelocity.x -= mA * this.m_impulse.x;
				bA.m_linearVelocity.y -= mA * this.m_impulse.y;
				bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
				bB.m_linearVelocity.x += mB * this.m_impulse.x;
				bB.m_linearVelocity.y += mB * this.m_impulse.y;
				bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z);
			}
			else
			{
				this.m_impulse.SetZero();
			}
		}
		b2WeldJoint.prototype.SolveVelocityConstraints = function (step)
		{
			var tMat;
			var tX = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			var vA = bA.m_linearVelocity;
			var wA = bA.m_angularVelocity;
			var vB = bB.m_linearVelocity;
			var wB = bB.m_angularVelocity;
			var mA = bA.m_invMass;
			var mB = bB.m_invMass;
			var iA = bA.m_invI;
			var iB = bB.m_invI;
			tMat = bA.m_xf.R;
			var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
			var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
			rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
			rAX = tX;
			tMat = bB.m_xf.R;
			var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
			var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
			rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
			rBX = tX;
			var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
			var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
			var Cdot2 = wB - wA;
			var impulse = new b2Vec3();
			this.m_mass.Solve33(impulse, (-Cdot1X), (-Cdot1Y), (-Cdot2));
			this.m_impulse.Add(impulse);
			vA.x -= mA * impulse.x;
			vA.y -= mA * impulse.y;
			wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
			vB.x += mB * impulse.x;
			vB.y += mB * impulse.y;
			wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
			bA.m_angularVelocity = wA;
			bB.m_angularVelocity = wB;
		}
		b2WeldJoint.prototype.SolvePositionConstraints = function (baumgarte)
		{
			if (baumgarte === undefined) baumgarte = 0;
			var tMat;
			var tX = 0;
			var bA = this.m_bodyA;
			var bB = this.m_bodyB;
			tMat = bA.m_xf.R;
			var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
			var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
			rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
			rAX = tX;
			tMat = bB.m_xf.R;
			var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
			var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
			tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
			rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
			rBX = tX;
			var mA = bA.m_invMass;
			var mB = bB.m_invMass;
			var iA = bA.m_invI;
			var iB = bB.m_invI;
			var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
			var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
			var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
			var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
			var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
			var angularError = b2Math.Abs(C2);
			if (positionError > k_allowedStretch)
			{
				iA *= 1.0;
				iB *= 1.0;
			}
			this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
			this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
			this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
			this.m_mass.col1.y = this.m_mass.col2.x;
			this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
			this.m_mass.col3.y = rAX * iA + rBX * iB;
			this.m_mass.col1.z = this.m_mass.col3.x;
			this.m_mass.col2.z = this.m_mass.col3.y;
			this.m_mass.col3.z = iA + iB;
			var impulse = new b2Vec3();
			this.m_mass.Solve33(impulse, (-C1X), (-C1Y), (-C2));
			bA.m_sweep.c.x -= mA * impulse.x;
			bA.m_sweep.c.y -= mA * impulse.y;
			bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
			bB.m_sweep.c.x += mB * impulse.x;
			bB.m_sweep.c.y += mB * impulse.y;
			bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
			bA.SynchronizeTransform();
			bB.SynchronizeTransform();
			return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
		}
		Box2D.inherit(b2WeldJointDef, Box2D.Dynamics.Joints.b2JointDef);
		b2WeldJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
		b2WeldJointDef.b2WeldJointDef = function ()
		{
			Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
			this.localAnchorA = new b2Vec2();
			this.localAnchorB = new b2Vec2();
		};
		b2WeldJointDef.prototype.b2WeldJointDef = function ()
		{
			this.__super.b2JointDef.call(this);
			this.type = b2Joint.e_weldJoint;
			this.referenceAngle = 0.0;
		}
		b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor)
		{
			this.bodyA = bA;
			this.bodyB = bB;
			this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
			this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
			this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
		}
	})();
	(function ()
	{
		var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
		b2DebugDraw.b2DebugDraw = function ()
		{
			this.m_drawScale = 1.0;
			this.m_lineThickness = 1.0;
			this.m_alpha = 1.0;
			this.m_fillAlpha = 1.0;
			this.m_xformScale = 1.0;
			var __this = this;
			//#WORKAROUND
			this.m_sprite = {
				graphics: {
					clear: function ()
					{
						__this.m_ctx.clearRect(0, 0, __this.m_ctx.canvas.width, __this.m_ctx.canvas.height)
					}
				}
			};
		};
		b2DebugDraw.prototype._color = function (color, alpha)
		{
			return "rgba(" + ((color & 0xFF0000) >> 16) + "," + ((color & 0xFF00) >> 8) + "," + (color & 0xFF) + "," + alpha + ")";
		};
		b2DebugDraw.prototype.b2DebugDraw = function ()
		{
			this.m_drawFlags = 0;
		};
		b2DebugDraw.prototype.SetFlags = function (flags)
		{
			if (flags === undefined) flags = 0;
			this.m_drawFlags = flags;
		};
		b2DebugDraw.prototype.GetFlags = function ()
		{
			return this.m_drawFlags;
		};
		b2DebugDraw.prototype.AppendFlags = function (flags)
		{
			if (flags === undefined) flags = 0;
			this.m_drawFlags |= flags;
		};
		b2DebugDraw.prototype.ClearFlags = function (flags)
		{
			if (flags === undefined) flags = 0;
			this.m_drawFlags &= ~flags;
		};
		b2DebugDraw.prototype.SetSprite = function (sprite)
		{
			this.m_ctx = sprite;
		};
		b2DebugDraw.prototype.GetSprite = function ()
		{
			return this.m_ctx;
		};
		b2DebugDraw.prototype.SetDrawScale = function (drawScale)
		{
			if (drawScale === undefined) drawScale = 0;
			this.m_drawScale = drawScale;
		};
		b2DebugDraw.prototype.GetDrawScale = function ()
		{
			return this.m_drawScale;
		};
		b2DebugDraw.prototype.SetLineThickness = function (lineThickness)
		{
			if (lineThickness === undefined) lineThickness = 0;
			this.m_lineThickness = lineThickness;
			this.m_ctx.strokeWidth = lineThickness;
		};
		b2DebugDraw.prototype.GetLineThickness = function ()
		{
			return this.m_lineThickness;
		};
		b2DebugDraw.prototype.SetAlpha = function (alpha)
		{
			if (alpha === undefined) alpha = 0;
			this.m_alpha = alpha;
		};
		b2DebugDraw.prototype.GetAlpha = function ()
		{
			return this.m_alpha;
		};
		b2DebugDraw.prototype.SetFillAlpha = function (alpha)
		{
			if (alpha === undefined) alpha = 0;
			this.m_fillAlpha = alpha;
		};
		b2DebugDraw.prototype.GetFillAlpha = function ()
		{
			return this.m_fillAlpha;
		};
		b2DebugDraw.prototype.SetXFormScale = function (xformScale)
		{
			if (xformScale === undefined) xformScale = 0;
			this.m_xformScale = xformScale;
		};
		b2DebugDraw.prototype.GetXFormScale = function ()
		{
			return this.m_xformScale;
		};
		b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color)
		{
			if (!vertexCount) return;
			var s = this.m_ctx;
			var drawScale = this.m_drawScale;
			s.beginPath();
			s.strokeStyle = this._color(color.color, this.m_alpha);
			s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
			for (var i = 1; i < vertexCount; i++)
			{
				s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
			}
			s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
			s.closePath();
			s.stroke();
		};
		b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color)
		{
			if (!vertexCount) return;
			var s = this.m_ctx;
			var drawScale = this.m_drawScale;
			s.beginPath();
			s.strokeStyle = this._color(color.color, this.m_alpha);
			s.fillStyle = this._color(color.color, this.m_fillAlpha);
			s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
			for (var i = 1; i < vertexCount; i++)
			{
				s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
			}
			s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
			s.closePath();
			s.fill();
			s.stroke();
		};
		b2DebugDraw.prototype.DrawCircle = function (center, radius, color)
		{
			if (!radius) return;
			var s = this.m_ctx;
			var drawScale = this.m_drawScale;
			s.beginPath();
			s.strokeStyle = this._color(color.color, this.m_alpha);
			s.arc(center.x * drawScale, center.y * drawScale, radius * drawScale, 0, Math.PI * 2, true);
			s.closePath();
			s.stroke();
		};
		b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color)
		{
			if (!radius) return;
			var s = this.m_ctx,
				drawScale = this.m_drawScale,
				cx = center.x * drawScale,
				cy = center.y * drawScale;
			s.moveTo(0, 0);
			s.beginPath();
			s.strokeStyle = this._color(color.color, this.m_alpha);
			s.fillStyle = this._color(color.color, this.m_fillAlpha);
			s.arc(cx, cy, radius * drawScale, 0, Math.PI * 2, true);
			s.moveTo(cx, cy);
			s.lineTo((center.x + axis.x * radius) * drawScale, (center.y + axis.y * radius) * drawScale);
			s.closePath();
			s.fill();
			s.stroke();
		};
		b2DebugDraw.prototype.DrawSegment = function (p1, p2, color)
		{
			var s = this.m_ctx,
				drawScale = this.m_drawScale;
			s.strokeStyle = this._color(color.color, this.m_alpha);
			s.beginPath();
			s.moveTo(p1.x * drawScale, p1.y * drawScale);
			s.lineTo(p2.x * drawScale, p2.y * drawScale);
			s.closePath();
			s.stroke();
		};
		b2DebugDraw.prototype.DrawTransform = function (xf)
		{
			var s = this.m_ctx,
				drawScale = this.m_drawScale;
			s.beginPath();
			s.strokeStyle = this._color(0xff0000, this.m_alpha);
			s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
			s.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col1.y) * drawScale);

			s.strokeStyle = this._color(0xff00, this.m_alpha);
			s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
			s.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col2.y) * drawScale);
			s.closePath();
			s.stroke();
		};
	})(); //post-definitions
	var i;
	for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();
	delete Box2D.postDefs;	/* Get object (James) */
	/* Copyright (c) 1996-2012 Clickteam
	 *
	 * This source code is part of the HTML5 exporter for Clickteam Multimedia Fusion 2.
	 *
	 * Permission is hereby granted to any person obtaining a legal copy
	 * of Clickteam Multimedia Fusion 2 to use or modify this source code for
	 * debugging, optimizing, or customizing applications created with
	 * Clickteam Multimedia Fusion 2.
	 * Any other use of this source code is prohibited.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 */
	// Removed user-agent, charset and Content-length, declared unsafe in new Chrome browser, 12/05/2016

	CRunGet.GETCP_FROMWEBPAGE = 0x0000;
	CRunGet.GETCP_FROMAPP     = 0x0001;
	CRunGet.GETCP_UTF8        = 0x0002;
	CRunGet.GETFLAG_MASK = 0x0003;

	this.Get = CRunGet;

	function CRunGet()
	{
		this.postData = {};
		this.response = '';
		this.respStatus = 0;
		this.pending = false;

		this.useragent = '';
		this.headers = '';
		this.user = '';
		this.password = '';
		this.timeout = 0;
		this.flag = -1;
		this.completeEvent = -1;
		this.charset = '';
	}

	CRunGet.prototype = CServices.extend(new CRunExtension(),
		{
			getNumberOfConditions: function ()
			{
				return 3;
			},

			createRunObject: function (file, cob, version)
			{
				try {
					this.flag = file.readAInt();
				}
				catch (err) {
					this.flag = 0;
				}

			},

			allowCrossDomain: function(request, url) {
				request.setRequestHeader("Access-Control-Allow-Origin", "*");
				request.setRequestHeader("Access-Control-Allow-Headers", "origin, content-type, accept");
				request.setRequestHeader("Access-Control-Allow-Credentials", "true");
				request.setRequestHeader("Access-Control-Allow-Methods", "GET,PUT,POST,DELETE,ORIGIN");
				request.setRequestHeader("Access-Control-Max-Age", "846000");
			},
			
			action: function (num, act)
			{
				switch (num)
				{
					case 0: /* Request URL */

						if (this.pending)
							return;

						var url = act.getParamExpString(this.rh, 0);
						request = new XMLHttpRequest();

						var that = this;

						var data = '';

						for (var key in this.postData)
						{
							if (data.length)
								data += '&';

							data += key + '=' + encodeURI(this.postData[key]);
						}

						this.postData = {};

						if (data.length)
						{
							if ("withCredentials" in request) {
								// request for Chrome/Firefox/Opera/Safari.
								request.open("POST", url, true);
							} else if (typeof XDomainRequest != "undefined") {
								// XDomainRequest for IE.
								request = new XDomainRequest();
								request.open("POST", url);
							} else {
								// CORS not supported.
								alert('CORS not supported');
								break;
							}
							// this must be filled according your setting in server
							this.fillheaders(request);
							//this.allowCrossDomain(request);
							
							request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');

							request.onreadystatechange = function ()
							{
								/*
								0: request not initialized 
								1: server connection established
								2: request received 
								3: processing request 
								4: request finished and response is ready 
								*/

								if (request.readyState == 4) {

									that.pending = false;
									that.respStatus = request.status != 0 ? request.status : 522;	// No server connection
									that.response = request.status !== 200 ? '' : request.responseText;

									that.completeEvent = that.ho.getEventCount();
									if (request.status !== 408 && that.respStatus !== 522 ) {
										that.ho.generateEvent(0, 0);
									}
									else {
										that.ho.pushEvent(2, 0);
									}
								}
							}

							request.ontimeout = function () {
								that.respStatus = 408;
								that.completeEvent = that.ho.getEventCount();
								that.ho.generateEvent(2,  0);
							}

							request.onerror = function () {
								that.response = '';
								that.respStatus = request.status != 0 ? request.status : 522;
								that.completeEvent = that.ho.getEventCount();
								if(that.respStatus !== 522 && that.respStatus !== 408)
									that.ho.pushEvent(2,  0);
							}
						
							request.send(data);
						}
						else
						{
							if (url.indexOf("forceLoad") > 0)
								url += ((/\?/).test(url) ? "&" : "?") + (new Date()).getTime();

							if ("withCredentials" in request) {
								// request for Chrome/Firefox/Opera/Safari.
								request.open("GET", url, true);
							 } else if (typeof XDomainRequest != "undefined") {
								// XDomainRequest for IE.
								request = new XDomainRequest();
								request.open("GET", url);
							 } else {
								// CORS not supported.
								alert('CORS not supported');
								break;
							 }
							// this must be filled according your setting in server
							this.fillheaders(request);
							//this.allowCrossDomain(request);
							 
							request.onreadystatechange = function ()
							{
								/*
								0: request not initialized 
								1: server connection established
								2: request received 
								3: processing request 
								4: request finished and response is ready 
								*/

								if (request.readyState == 4) {

									that.pending = false;
									that.respStatus = request.status != 0 ? request.status : 522;	// No server connection
									that.response = request.status !== 200 ? '' : request.responseText;

									that.completeEvent = that.ho.getEventCount();
									if (request.status !== 408 && that.respStatus !== 522 ) {
										that.ho.generateEvent(0, 0);
									}
									else {
										that.ho.pushEvent(2, 0);
									}
								}
							}

							request.ontimeout = function () {
								that.respStatus = 408;
								that.completeEvent = that.ho.getEventCount();
								that.ho.generateEvent(2,  0);
							}

							request.onerror = function () {
								that.response = '';
								that.respStatus = request.status != 0 ? request.status : 522;
								that.completeEvent = that.ho.getEventCount();
								if(that.respStatus !== 522 && that.respStatus !== 408)
									that.ho.pushEvent(2,  0);
							}

							
						
							request.send(null);
						}

						this.pending = true;

						break;

					case 1: /* Add POST data */

						var key = act.getParamExpString(this.rh, 0),
							value = act.getParamExpString(this.rh, 1);

						this.postData[key] = value;

						break;
				    case 2: /* Add Custom Header */

				        this.headers = act.getParamExpString(this.rh, 0);

				        break;
				    case 3: /* Set User */

				        this.user = act.getParamExpString(this.rh, 0);

				        break;
				    case 4: /* Set Password */

				        this.password = act.getParamExpString(this.rh, 0);

				        break;
				    case 5: /* Set Timeout */

				        this.timeout = act.getParamExpression(this.rh, 0);

				        break;
				    case 6: /* Set User-Agent */

				        this.useragent = act.getParamExpString(this.rh, 0);

				        break;
				}
				;
			},

			condition: function (num, cnd)
			{
				switch (num)
				{
					case 0: /* On request complete */

						return (this.ho.hoFlags & CObject.HOF_TRUEEVENT) != 0 ||
							(this.ho.getEventCount() == this.completeEvent);

					case 1: /* Request pending? */

					    return this.pending;

				    case 2: /* On request timeout */

				        return (this.ho.hoFlags & CObject.HOF_TRUEEVENT) != 0 ||
							(this.ho.getEventCount() == this.completeEvent);
				}
				;

				return false;
			},

			expression: function (num)
			{
				switch (num)
				{
					case 0: /* Response$ */
						return this.response;

					case 1: /* URLEncode$ */
					    return encodeURI('' + this.ho.getExpParam());

				    case 2: /* ResponseStatus$ */
				        return this.respStatus;
				}
				;
			},

			fillheaders: function (request) {

			    if (this.headers) {
			        var lines = this.headers.split("[\\r\\n]+");
			        for (i = 0; i < lines.length; i++) {
			            var fields = lines[i].split(":");
			            request.setRequestHeader(fields[0], fields[1]);
			        }

			    }

			    if (this.user && this.password) {
			        request.setRequestHeader("Authorization", "Basic " +this.user + ":" + this.password);
			    }

			    if (this.timeout > 0) {
			    request.timeout = this.timeout * 1000;
			    }

			    var charset = "iso-8559-1";

			    if(this.flag == CRunGet.GETCP_FROMWEBPAGE)
			    {
			        var line = request.getResponseHeader("Content-Type");
			        if (line) {
			            var fields = line.split(";");
			            if (fields && fields[0].indexOf("charset") >= 0) {
			                var field = fields[0].split("=");
			                charset = field[1];
			            }
			        }
			    }
			    else if(this.flag == CRunGet.GETCP_FROMAPP)
			    {
			        charset = ReverseCharset(this.ho.hoAdRunHeader.rhApp.codePage);
			    }
			    else if(this.flag == CRunGet.GETCP_UTF8)
			    {
			        charset = "utf-8";
			    }

		        return;
			},

			encode_utf8:function (s) {
	            return unescape(encodeURIComponent(s));
	        },

	        decode_utf8:function (s) {
	            return decodeURIComponent(escape(s));
	        },

	        ReverseCharSet: function (uCodePage) {
	            var sCharSet;

	            if (uCodePage == 28591) {
	                sCharSet = "iso-8859-1";       // iso-8859-1 translation
	            }
	            else if (uCodePage == 28592) {
	                sCharSet = "iso-8859-2";       // iso-8859-2 translation
	            }
	            else if (uCodePage == 28593) {
	                sCharSet = "iso-8859-3";       // iso-8859-3 translation
	            }
	            else if (uCodePage == 28594) {
	                sCharSet = "iso-8859-4";       // iso-8859-4 translation
	            }
	            else if (uCodePage == 28595) {
	                sCharSet = "iso-8859-5";       // iso-8859-5 translation
	            }
	            else if (uCodePage == 28596) {
	                sCharSet = "iso-8859-6";       // iso-8859-6 translation
	            }
	            else if (uCodePage == 28597) {
	                sCharSet = "iso-8859-7";       // iso-8859-7 translation
	            }
	            else if (uCodePage == 28598) {
	                sCharSet = "iso-8859-8";       // iso-8859-8 translation
	            }
	            else if (uCodePage == 1251) {
	                sCharSet = "windows-1251";       // windows-1251 translation
	            }
	            else if (uCodePage == 1252) {
	                sCharSet = "windows-1252";       // windows-1252 translation
	            }
	            else if (uCodePage == 1253) {
	                sCharSet = "windows-1253";       // windows-1253 translation
	            }
	            else if (uCodePage == 1254) {
	                sCharSet = "windows-1254";       // windows-1254 translation
	            }
	            else if (uCodePage == 1255) {
	                sCharSet = "windows-1255";       // windows-1255 translation
	            }
	            else if (uCodePage == 20936) {
	                sCharSet = "gb2312";       // gbk2312 translation
	            }
	            else if (uCodePage == 936) {
	                sCharSet = "gbk";       // gbk translation
	            }
	            else if (uCodePage == 950) {
	                sCharSet = "big5";       // big5 translation
	            }
	            else if (uCodePage == 20866) {
	                sCharSet = "koi8-r";	// koi8-r translation
	            }
	            else if (uCodePage == 51932) {
	                sCharSet = "euc-jp";       // euc-jp translation
	            }
	            else if (uCodePage == 51949) {
	                sCharSet = "euc-kr";       // euc-kr translation
	            }
	            else if (uCodePage == 51936) {
	                sCharSet = "euc-cn";       // euc-cn translation
	            }
	            else if (uCodePage == 50222) {
	                sCharSet = "iso-2022-jp";       // iso-2022-jp translation
	            }
	            else if (uCodePage == 50225) {
	                sCharSet = "iso-2022-kr";       // iso-2022-kr translation
	            }
	            else if (uCodePage == 65001) {
	                sCharSet = "utf-8";       // UTF-8 translation
	            }
	            else if (uCodePage == 0) {
	                sCharSet = "utf-8";       // UTF-8 translation, language neutral
	            }
	            else {
	                sCharSet = null;       // No Page
	            }
	            return sCharSet;
	        }
		});


	Runtime(__can, __path); 
})